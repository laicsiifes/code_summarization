code	desc
@ override public int run command ( boolean merge error into output , string ... commands ) throws io , interrupted exception { return run command ( merge error into output , new array list < string > ( arrays . as list ( commands ) ) ) ; }	runs a command on the command line synchronously .
private int find plv ( int m id ) { timestamp price date = null ; string date str = env . get context ( env . get ctx ( ) , p , str ) ; if ( date str != null && date str . length ( ) > num ) price date = env . get context as date ( env . get ctx ( ) , p , str ) ; else { date str = env . get context ( env . get ctx ( ) , p , str ) ; if ( date str != null && date str . length ( ) > num ) price date = env . get context as date ( env . get ctx ( ) , p , str ) ; } if ( price date == null ) price date = new timestamp ( system . current time millis ( ) ) ; log . config ( str + m id + str + price date ) ; int ret value = num ; string sql = str + str + str + str + str + str ; try { prepared statement pstmt = db . prepare statement ( sql , null ) ; pstmt . set int ( num , m id ) ; result set rs = pstmt . execute query ( ) ; while ( rs . next ( ) && ret value == num ) { timestamp pl date = rs . get timestamp ( num ) ; if ( ! price date . before ( pl date ) ) ret value = rs . get int ( num ) ; } rs . close ( ) ; pstmt . close ( ) ; } catch ( sql e ) { log . log ( level . severe , sql , e ) ; } env . set context ( env . get ctx ( ) , p , str , ret value ) ; return ret value ; }	find price list version and update context.
public static boolean memory is low ( ) { return available memory ( ) * num < runtime . total memory ( ) * num ; }	returns true if less then 5 % of the available memory is free .
public string describe attributes ( ) { string builder sb = new string builder ( ) ; sb . append ( str ) ; boolean first = bool ; for ( object key : attributes . key set ( ) ) { if ( first ) { first = bool ; } else { sb . append ( str ) ; } sb . append ( key ) ; sb . append ( str ) ; sb . append ( attributes . get ( key ) ) ; } sb . append ( str ) ; return sb . to string ( ) ; }	returns a string representation of the object ' s current attributes.
public static byte [ ] next bytes ( byte [ ] buffer ) { s random . next bytes ( buffer ) ; return buffer ; }	fill the given buffer with random bytes .
public void remove all from damaged ( final collection < unit > damaged units ) { for ( final unit u : damaged units ) { while ( m damaged . contains ( u ) ) { m damaged . remove ( u ) ; } } }	can have multiple of the same unit , to show multiple hits to that unit .
private i [ ] compute children ( array list names without extension ) { int size = names without extension . size ( ) ; if ( size == num ) return no elements ; i [ ] children = new i [ size ] ; for ( int i = num ; i < size ; i ++ ) { string name without extension = ( string ) names without extension . get ( i ) ; children [ i ] = new class file ( this , manager , name without extension ) ; } return children ; }	compute the children of this package fragment.
public object [ ] to array ( ) { object [ ] result = new object [ size ] ; system . arraycopy ( element data , num , result , num , size ) ; return result ; }	returns an array containing all of the elements in this list in the correct order .
@ override protected void on delete complete ( int token , object cookie , int result ) { if ( token == m delete token ) { synchronized ( s deleting threads lock ) { s deleting threads = bool ; if ( deletedebug ) { log . v ( tag , str + s deleting threads ) ; } s deleting threads lock . notify all ( ) ; } unread badge service . update ( m context ) ; notification manager . create ( m context ) ; } }	always call this super method from your overridden ondeletecomplete function .
private static i create new launch configuration ( i project ) throws core exception , operation canceled exception { string initial name = calculate launch config name ( project ) ; i launch config = gwt super dev mode code server launch util . create launch config ( initial name , project ) ; return launch config ; }	create a new launch configuration .
protected long parse date ( ) throws io { if ( utc calendar == null ) utc calendar = calendar . get instance ( time zone . get time zone ( str ) ) ; return parse date ( utc calendar ) ; }	parses a date value from the stream .
@ override public request < list < builder status > > builds ( project reference project reference ) { list < dummy builder status > current = current builder statuses . get ( project reference . name ( ) ) ; list < builder status > update = new array list < > ( ) ; if ( current != null ) { for ( dummy builder status dummy builder status : current ) { update . add ( dummy builder status ) ; } } return new dummy request < > ( update ) ; }	gets the project builds for the given project.
public string lookahead ( ) { if ( buf != null ) { return new string ( buf , buf pos , buf . length - buf pos ) ; } else { return text . substring ( pos . get index ( ) ) ; } }	returns a string containing the remainder of the characters to be returned by this iterator , without any option processing.
protected int entity index ( entity entity ) { return arrays . binary search ( entities , entity ) ; }	check whether the device contains the specified entity.
public void run test ( ) throws throwable { document doc ; node list element list ; node name node ; character data child ; doc = ( document ) load ( str , bool ) ; element list = doc . get elements by tag name ( str ) ; name node = element list . item ( num ) ; child = ( character data ) name node . get first child ( ) ; { boolean success = bool ; try { child . insert data ( - num , str ) ; } catch ( dom ex ) { success = ( ex . code == dom . index size err ) ; } assert true ( str , success ) ; } }	runs the test case .
public abstract boolean is loggable ( level level ) ;	" logger like " api to be used by rmi implementation.
public string replace tokens ( string query string , string replacement , string ... non replacement token prefixes ) { matcher matcher = token pattern . matcher ( query string ) ; string buffer buf = new string buffer ( ) ; while ( matcher . find ( ) ) { string orig token = matcher . group ( num ) ; if ( orig token != null ) { matcher . append replacement ( buf , str ) ; if ( token starts with prefix ( orig token , non replacement token prefixes ) ) { buf . append ( str + orig token + str ) ; } else { buf . append ( replacement ) ; } } } matcher . append tail ( buf ) ; return buf . to string ( ) ; }	replaces a query string with tokens of format $ { token - name } with the specified replacement string for all tokens .
public boolean is plural ( ) { return type string . contains ( suffix plural ) ; }	determine if the expression is in plural form .
public void insert ( force item item ) { try { insert ( item , root , x min , y min , x max , y max ) ; } catch ( stack overflow error e ) { e . print stack trace ( ) ; } }	inserts an item into the quadtree .
private void handle hovering ( int x , int y ) { handle cell hover ( x , y ) ; if ( column headers visible ) { handle hover on column header ( x , y ) ; } }	handles the assignment of the correct values to the hover * field variables that let the painting code now what to paint as hovered .
public static void draw circled text ( d g , font font , string text , int x , int y ) { d g2 = ( d ) g . create ( ) ; g2 . set font ( font ) ; font metrics fm = g2 . get font metrics ( ) ; int padding = num ; d bounds = fm . get string bounds ( text , g2 ) ; double th = bounds . get height ( ) ; double tw = bounds . get width ( ) ; float radius = ( float ) ( math . max ( th , tw ) / num + padding ) ; d . float circle = new d . float ( x - radius , y - radius , num * radius + num , num * radius + num ) ; g2 . fill ( circle ) ; g2 . set color ( color . black ) ; g2 . draw string ( text , ( int ) ( x - tw / num ) , ( y + fm . get ascent ( ) / num ) ) ; if ( debug ) { g2 . set color ( color . red ) ; g2 . draw line ( x - num , y , x + num , y ) ; g2 . draw line ( x , y - num , x , y + num ) ; } g2 . dispose ( ) ; }	utility function to draw a circle text centered at coordinates ( x , y ).
private void register end ( final string prefix singular , final string prefix plural , final string end string ) { prefix end list . add ( new prefix entry ( end string , prefix singular , prefix plural ) ) ; register prefix ( prefix singular , prefix plural ) ; }	define the singular and plural prefix strings for an item name to be matched at the end , for example " bottle of.
public void add observer ( observer observer ) { observers . add ( observer ) ; }	sets the observer , which will observe the iterator returned in the next call to iterator ( ) method.
public string to string ( ) { return str + subject public key info . to string ( ) + str + subject + str + str + str + attribute set . to string ( ) + str ; }	provides a short description of this request .
public system properties table model ( ) { column names = new string [ num ] ; column names [ num ] = res . get string ( str ) ; column names [ num ] = res . get string ( str ) ; data = new object [ num ] [ num ] ; }	construct a new systempropertiestablemodel .
public boolean cancel job ( long id , boolean is persistent ) { job holder holder ; synchronized ( get next job lock ) { if ( job consumer executor . is running ( id , is persistent ) ) return bool ; if ( is persistent ) { synchronized ( persistent job queue ) { holder = persistent job queue . find job by id ( id ) ; if ( holder == null ) return bool ; persistent job queue . remove ( holder ) ; } } else { synchronized ( non persistent job queue ) { holder = non persistent job queue . find job by id ( id ) ; if ( holder == null ) return bool ; non persistent job queue . remove ( holder ) ; } } } base job base job = holder . get base job ( ) ; if ( dependency injector != null ) { dependency injector . inject ( base job ) ; } base job . on cancel ( ) ; return bool ; }	cancels job which is waiting to be run .
public static boolean is simple match pattern ( string str ) { return str . index of ( str ) != - num ; }	is the str a simple match pattern .
public string read script ( string fname ) throws io { string builder sb = new string builder ( ) ; buffered reader in = null ; try { if ( fname . starts with ( str ) || fname . starts with ( str ) ) { file system fs = file system . get ( configuration manager . get cached job conf ( ) ) ; path script path = new path ( fname ) ; in = new buffered reader ( new input stream reader ( fs . open ( script path ) ) ) ; } else { in = new buffered reader ( new file reader ( fname ) ) ; } string tmp = null ; while ( ( tmp = in . read line ( ) ) != null ) { sb . append ( tmp ) ; sb . append ( str ) ; } } finally { io . close silently ( in ) ; } return sb . to string ( ) ; }	read a dml or pydml file as a string .
public static binary field accessor create ( field field , int id ) { binary write mode mode = binary utils . mode ( field . get type ( ) ) ; switch ( mode ) { case p byte : return new byte primitive accessor ( field , id ) ; case p boolean : return new boolean primitive accessor ( field , id ) ; case p short : return new short primitive accessor ( field , id ) ; case p char : return new char primitive accessor ( field , id ) ; case p int : return new int primitive accessor ( field , id ) ; case p long : return new long primitive accessor ( field , id ) ; case p float : return new float primitive accessor ( field , id ) ; case p double : return new double primitive accessor ( field , id ) ; case byte : case boolean : case short : case char : case int : case long : case float : case double : case decimal : case string : case uuid : case date : case timestamp : case byte arr : case short arr : case int arr : case long arr : case float arr : case double arr : case char arr : case boolean arr : case decimal arr : case string arr : case uuid arr : case date arr : case timestamp arr : case enum arr : case object arr : case binary obj : case binary : return new default final class accessor ( field , id , mode , bool ) ; default : return new default final class accessor ( field , id , mode , ! u . is final ( field . get type ( ) ) ) ; } }	create accessor for the field .
private string result ( url conn , boolean input ) throws io { string buffer sb = new string buffer ( ) ; if ( input ) { input stream is = conn . get input stream ( ) ; buffered reader reader = new buffered reader ( new input stream reader ( is , str ) ) ; string line = null ; while ( ( line = reader . read line ( ) ) != null ) { sb . append ( line ) ; } reader . close ( ) ; is . close ( ) ; } map < string , object > result = new hash map < string , object > ( ) ; result . put ( str , conn . get response code ( ) ) ; result . put ( str , conn . get response message ( ) ) ; result . put ( str , conn . get content type ( ) ) ; result . put ( str , sb ) ; string output = string . value of ( conn . get response code ( ) ) ; set output response code ( output ) ; gson gson = new gson ( ) ; string json = gson . to json ( result ) ; logger . info ( str + json ) ; return json ; }	report the result in json way.
public boolean is banned method ( string sig ) { return banned methods . contains ( sig ) ; }	used by the specification create to check if a method is legal to put in the spec.
private void attach plot ( svg newplot ) { this . plot = newplot ; if ( newplot == null ) { super . set svg ( null ) ; return ; } newplot . synchronize with ( synchronizer ) ; super . set svg ( newplot . get document ( ) ) ; super . set disable interactions ( newplot . get disable interactions ( ) ) ; }	attach to a new plot , and display .
public e take ( ) throws interrupted exception { final reentrant lock lock = this . lock ; lock . lock interruptibly ( ) ; try { for ( ; ; ) { e first = q . peek ( ) ; if ( first == null ) available . await ( ) ; else { long delay = first . get delay ( nanoseconds ) ; if ( delay <= num ) return q . poll ( ) ; first = null ; if ( leader != null ) available . await ( ) ; else { thread this thread = thread . current thread ( ) ; leader = this thread ; try { available . await nanos ( delay ) ; } finally { if ( leader == this thread ) leader = null ; } } } } } finally { if ( leader == null && q . peek ( ) != null ) available . signal ( ) ; lock . unlock ( ) ; } }	retrieves and removes the head of this queue , waiting if necessary until an element with an expired delay is available on this queue .
public void shutdown ( ) throws exception { try { if ( solr client != null ) solr client . close ( ) ; list < callable < jetty solr runner > > shutdowns = new array list < > ( jettys . size ( ) ) ; for ( final jetty solr runner jetty : jettys ) { shutdowns . add ( null ) ; } jettys . clear ( ) ; collection < future < jetty solr runner > > futures = executor . invoke all ( shutdowns ) ; exception shutdown error = check for exceptions ( str , futures ) ; if ( shutdown error != null ) { throw shutdown error ; } } finally { executor . shutdown ( ) ; executor . await termination ( num , time unit . seconds ) ; try { if ( ! external zk server ) { zk server . shutdown ( ) ; } } finally { system . clear property ( str ) ; } } }	shut down the cluster , including all solr nodes and zookeeper.
private static control create request control ( final class clazz , final class [ ] param types , final object [ ] params ) { constructor constructor = class utils . get constructor if available ( clazz , param types ) ; if ( constructor == null ) { ldap exception utils . generate error exception ( ldap error codes . err 10005 control contructor not found , new string [ ] { clazz . to string ( ) , string utils . array to comma delimited string ( param types ) } , logger ) ; } control result = null ; try { result = ( control ) constructor . new instance ( params ) ; } catch ( exception e ) { ldap exception utils . generate error exception ( ldap error codes . err 10006 control instance failed , new string [ ] { clazz . to string ( ) , string utils . array to comma delimited string ( param types ) , string utils . array to comma delimited string ( params ) } , logger , e ) ; } return result ; }	permite crear una instancia de la clase pasada como parametro .
private static boolean is in corner target zone ( float x , float y , float handle x , float handle y , float target radius ) { return math . abs ( x - handle x ) <= target radius && math . abs ( y - handle y ) <= target radius ; }	determines if the specified coordinate is in the target touch zone for a corner handle .
public boolean is new state ( ) { return file name . equals ( str ) ; }	tells whether this session is in a new state or not.
public boolean offer ( e e ) { final reentrant lock lock = this . lock ; lock . lock ( ) ; try { q . offer ( e ) ; if ( q . peek ( ) == e ) { leader = null ; available . signal ( ) ; } return bool ; } finally { lock . unlock ( ) ; } }	inserts the specified element into this delay queue .
public void update league history ( ) { collections . sort ( team list , new team comp poll ( ) ) ; string [ ] year top10 = new string [ num ] ; team tt ; for ( int i = num ; i < num ; ++ i ) { tt = team list . get ( i ) ; year top10 [ i ] = tt . abbr + str + tt . wins + str + tt . losses + str ; } league history . add ( year top10 ) ; }	at the end of the year , record the top 10 teams for the league ' s history .
public suffix file filter ( string [ ] suffixes , io case sensitivity ) { if ( suffixes == null ) { throw new illegal argument exception ( str ) ; } this . suffixes = new string [ suffixes . length ] ; system . arraycopy ( suffixes , num , this . suffixes , num , suffixes . length ) ; this . case sensitivity = case sensitivity == null ? io . sensitive : case sensitivity ; }	constructs a new suffix file filter for an array of suffixs specifying case - sensitivity.
private void update font ( ) { string font name = font list . get value ( ) ; integer font size = fallback font size ; try { font size = integer . parse int ( font size list . get value ( ) ) ; } catch ( number format exception ex ) { } font = new font ( font name , font . plain , font size ) ; preview . set font ( font ) ; }	creates a new font based on the current settings and also updates the preview.
public static properties read property file from file system ( final file property file location ) throws configuration exception { final properties file properties = new properties ( ) ; try { final input stream input stream = new file input stream ( property file location ) ; file properties . load ( input stream ) ; input stream . close ( ) ; } catch ( io e ) { throw new configuration exception ( str , e ) ; } return file properties ; }	reads a property file into a properties object .
public void test ( ) { assert equals ( str , curve , ecps . get curve ( ) ) ; }	test for getcurve ( ) method.
@ override public void close ( ) throws io { f input stream . close ( ) ; }	close the stream . once a stream has been closed , further read ( ) , ready ( ) , mark ( ) , or reset ( ) invocations will throw an ioexception . closing a previously - closed stream , however , has no effect .
public static void sleep ( ) { try { thread . sleep ( test settings . response wait ) ; } catch ( interrupted exception e ) { } }	current thread sleeps for a predefined amount of time.
public void add ( uri uri , http cookie cookie ) { if ( cookie == null ) { throw new null pointer exception ( str ) ; } lock . lock ( ) ; try { cookie jar . remove ( cookie ) ; if ( cookie . get max age ( ) != num ) { cookie jar . add ( cookie ) ; if ( cookie . get domain ( ) != null ) { add index ( domain index , cookie . get domain ( ) , cookie ) ; } if ( uri != null ) { add index ( uri index , get effective uri ( uri ) , cookie ) ; } } } finally { lock . unlock ( ) ; } }	add one cookie into cookie store .
public void delete ( random access file raf , random access file temp raf ) throws io , cannot write exception { flac tag empty tag = new flac tag ( null , new array list < metadata block data picture > ( ) ) ; raf . seek ( num ) ; temp raf . seek ( num ) ; write ( empty tag , raf , temp raf ) ; }	delete tag from file.
void show ( rectangle bounds ) { if ( ! is created ( ) ) { return ; } if ( log . is loggable ( platform logger . level . finer ) ) { log . finer ( str + get window ( ) + str + bounds ) ; } x . awt lock ( ) ; try { reshape ( bounds . x , bounds . y , bounds . width , bounds . height ) ; x set visible ( bool ) ; to front ( ) ; select item ( get first selectable item ( ) , bool ) ; } finally { x . awt unlock ( ) ; } }	init window if it ' s not inited yet and show it at specified coordinates.
void downcase ( final string buffer text , final int leng ) { for ( int i = num ; i < leng ; i ++ ) { if ( character . is upper case ( text . char at ( i ) ) ) { text . set char at ( i , character . to lower case ( text . char at ( i ) ) ) ; } } }	lowercase the characters up to the given length.
public int index of key ( object key ) { return key == null ? index of null ( ) : index of ( key , key . hash code ( ) ) ; }	returns the index of a key in the set .
public void release external resources ( ) { if ( ! is closed . get ( ) ) { logger . info ( str ) ; actor config . shut down actor system force ( ) ; http client store . shutdown ( ) ; tcp ssh ping resource store . shutdown ( ) ; task manager . clean wait task queue ( ) ; task manager . clean inprogress job map ( ) ; is closed . set ( bool ) ; logger . info ( str + str + str ) ; } else { logger . debug ( str ) ; } }	releases the external resources that this object depends on.
@ override public enumeration < option > list options ( ) { vector < option > new vector = new vector < option > ( num ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str + str + str , str , num , str ) ) ; new vector . add element ( new option ( str + str + str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; return new vector . elements ( ) ; }	returns an enumeration describing the available options .
public static bytes to name canonicalizer create root ( ) { long now = system . current time millis ( ) ; int seed = ( ( ( int ) now ) + ( ( int ) now > > > num ) ) | num ; return create root ( seed ) ; }	factory method to call to create a symbol table instance with a randomized seed value .
public void fill field values ( list < synapse update rule > rule list ) { hebbian rule synapse ref = ( hebbian rule ) rule list . get ( num ) ; if ( ! network utils . is consistent ( rule list , hebbian rule . class , str ) ) { tf learning rate . set text ( simbrain constants . null string ) ; } else { tf learning rate . set text ( double . to string ( synapse ref . get learning rate ( ) ) ) ; } }	populate fields with current data .
public static int count argument placeholders ( final string message pattern ) { if ( message pattern == null ) { return num ; } final int delim = message pattern . index of ( delim start ) ; if ( delim == - num ) { return num ; } int result = num ; boolean is escaped = bool ; for ( int i = num ; i < message pattern . length ( ) ; i ++ ) { final char cur char = message pattern . char at ( i ) ; if ( cur char == escape char ) { is escaped = ! is escaped ; } else if ( cur char == delim start ) { if ( ! is escaped && i < message pattern . length ( ) - num && message pattern . char at ( i + num ) == delim stop ) { result ++ ; i ++ ; } is escaped = bool ; } else { is escaped = bool ; } } return result ; }	counts the number of unescaped placeholders in the given messagepattern .
protected abstract boolean is end of chunk ( char curr prefix , string curr label , char next prefix , string next label ) ;	determines whether the current outcome represents the end of a chunk.
public void clear ( ) { set . clear ( ) ; fire contents changed ( this , num , num ) ; }	clears this list model .
static string to string ( @ not null final bytes buffer , long position , long len ) throws buffer underflow exception { final long pos = buffer . read position ( ) ; final long limit = buffer . read limit ( ) ; buffer . read position remaining ( position , len ) ; try { final string builder builder = new string builder ( ) ; while ( buffer . read remaining ( ) > num ) { builder . append ( ( char ) buffer . read byte ( ) ) ; } return builder . to string ( ) ; } finally { buffer . read limit ( limit ) ; buffer . read position ( pos ) ; } }	the buffer is not modified by this call.
void collect unresponsive members ( set s ) { if ( still waiting ( ) ) { internal distributed member [ ] member list = get members ( ) ; synchronized ( member list ) { for ( int i = num ; i < member list . length ; i ++ ) { internal distributed member m = member list [ i ] ; if ( m != null ) { s . add ( m ) ; } } } } }	adds any unresponsive members to s.
private void init from auth header ( string auth header ) { this . auth header = auth header ; if ( auth header == null ) throw new null pointer exception ( str ) ; matcher auth matcher = scheme pattern . matcher ( auth header ) ; if ( ! auth matcher . matches ( ) ) { throw new illegal state exception ( str + auth header ) ; } scheme = auth matcher . group ( num ) ; if ( auth matcher . group count ( ) > num ) { matcher param matcher = param pattern . matcher ( auth matcher . group ( num ) ) ; while ( param matcher . find ( ) ) { string value = param matcher . group ( num ) ; if ( value == null ) { value = param matcher . group ( num ) ; } parameters . put ( param matcher . group ( num ) , value ) ; } } }	initializes internal state from the contents of a www - authenticate header .
public string to string ( ) { string s = str ; hex dump encoder encoder = new hex dump encoder ( ) ; s += encoder . encode buffer ( octet string ) ; s += str ; return ( s ) ; }	returns a printable representation of the keyusage .
public static void add startup listener ( start up listener s ) { s startup listeners . add ( s ) ; }	add a listener to be notified when startup is complete.
public void test write2 ( ) throws exception { byte [ ] data = new byte [ ] { - num , - num , - num , - num , - num , num , num , num , num , num } ; test output stream tos = new test output stream ( ) ; cipher output stream cos = new cipher output stream ( tos , new null cipher ( ) ) ; cos . write ( data ) ; cos . flush ( ) ; byte [ ] result = tos . to byte array ( ) ; if ( ! arrays . equals ( result , data ) ) { fail ( str ) ; } try { cos . write ( null ) ; fail ( str ) ; } catch ( null pointer exception e ) { } }	write ( byte [ ] b ) method testing.
@ visible for testing static boolean should open after download ( download info download info ) { string type = download info . get mime type ( ) ; return download info . has user gesture ( ) && ! is attachment ( download info . get content disposition ( ) ) && mime types to open . contains ( type ) ; }	determines if the download should be immediately opened after downloading .
@ transactional public void save ( final list < work flow matrix > actual work flow matrix details , final string [ ] departments ) { for ( final string dept : departments ) { for ( final work flow matrix work flow matrix : actual work flow matrix details ) { final work flow matrix wf obj = work flow matrix . clone ( ) ; if ( dept . equals ( default ) ) { wf obj . set department ( str ) ; } else { wf obj . set department ( dept ) ; } workflow matrix repository . save ( wf obj ) ; } } }	this method saves the workflow matrix details for every department selected.
public void write ( string file ) throws exception { write ( new file ( file ) ) ; }	writes the current dom document into the given file .
private static boolean fields equal ( object a , object b ) { return a == b || ( a != null && a . equals ( b ) ) ; }	checks to see if two objects are equal either as nulls or through their comparator.
public static string quote if needed ( string s , string delim ) { if ( s == null ) return null ; if ( s . length ( ) == num ) return str ; for ( int i = num ; i < s . length ( ) ; i ++ ) { char c = s . char at ( i ) ; if ( c == str || c == str || c == str || character . is whitespace ( c ) || delim . index of ( c ) >= num ) { string buffer b = new string buffer ( s . length ( ) + num ) ; quote ( b , s ) ; return b . to string ( ) ; } } return s ; }	quote a string . the string is quoted only if quoting is required due to embedded delimiters , quote characters or the empty string .
public static void report ( ) { if ( license . is developer ( ) ) { for ( final object obj : spies ) { diagnostic . developer log ( obj . to string ( ) ) ; } } }	generate a report to the log from all the current spies .
@ deprecated public void write ( byte b [ ] , int off , int len ) { if ( len < num ) throw new array index out of bounds exception ( len ) ; for ( int i = num ; i < len ; ++ i ) write ( b [ off + i ] ) ; }	write a subarray of bytes.
public final void test next bytesbyte array03 ( ) throws no such algorithm exception , no such provider exception { secure random sr1 ; secure random sr2 ; byte [ ] my bytes1 ; byte [ ] my bytes2 ; for ( int i = num ; i < length / num ; i += incr ) { sr1 = secure random . get instance ( algorithm , provider ) ; sr2 = secure random . get instance ( algorithm , provider ) ; boolean flag = bool ; my bytes1 = new byte [ i ] ; my bytes2 = new byte [ i ] ; sr1 . next bytes ( my bytes1 ) ; sr2 . next bytes ( my bytes2 ) ; for ( int j = num ; j < i ; j ++ ) { flag &= my bytes1 [ j ] == my bytes2 [ j ] ; } sr1 . next bytes ( my bytes1 ) ; sr2 . next bytes ( my bytes2 ) ; for ( int j = num ; j < i ; j ++ ) { flag &= my bytes1 [ j ] == my bytes2 [ j ] ; } if ( flag ) { fail ( str + i ) ; } } }	test against the " void nextbytes ( byte [ ] ) " method ; it checks out that different securerandom objects being supplied with seed by themselves return different sequencies of bytes as results of their " nextbytes ( byte [ ] ) " methods.
public cursor query ( sq db , string [ ] projection in , string selection , string [ ] selection args , string group by , string having , string sort order , string limit ) { if ( m tables == null ) { return null ; } if ( m strict && selection != null && selection . length ( ) > num ) { string sql for validation = build query ( projection in , str + selection + str , group by , having , sort order , limit ) ; validate sql ( db , sql for validation ) ; } string sql = build query ( projection in , selection , group by , having , sort order , limit ) ; return db . raw query with factory ( m factory , sql , selection args , sq . find edit table ( m tables ) ) ; }	perform a query by combining all current settings and the information passed into this method .
public boolean is paused ( ) { return bool ; }	whether or not the game is paused .
public builder trust certificates ( key store trust store ) throws general security exception { ssl ssl context = ssl utils . get tls ssl context ( ) ; ssl utils . init ssl context ( ssl context , trust store , ssl utils . get pkix trust manager factory ( ) ) ; return set ssl socket factory ( ssl context . get socket factory ( ) ) ; }	sets the ssl socket factory based on a root certificate trust store .
public void reject re invite ( int code ) { if ( s logger . is activated ( ) ) { s logger . debug ( str ) ; } synchronized ( m wait user answer ) { m re invite status = invitation status . invitation rejected ; m wait user answer . notify all ( ) ; } }	reject the session invitation.
public static point parse point ( string str , spatial context ctx ) throws invalid shape exception { try { double x , y ; str = str . trim ( ) ; int comma idx = str . index of ( str ) ; if ( comma idx == - num ) { int space idx = str . index of ( str ) ; if ( space idx == - num ) throw new invalid shape exception ( str + str ) ; int middle end idx = find index not space ( str , space idx + num , + num ) ; x = double . parse double ( str . substring ( num , space idx ) ) ; y = double . parse double ( str . substring ( middle end idx ) ) ; } else { int middle start idx = find index not space ( str , comma idx - num , - num ) ; int middle end idx = find index not space ( str , comma idx + num , + num ) ; y = double . parse double ( str . substring ( num , middle start idx + num ) ) ; x = double . parse double ( str . substring ( middle end idx ) ) ; } x = ctx . norm x ( x ) ; y = ctx . norm y ( y ) ; return ctx . make point ( x , y ) ; } catch ( invalid shape exception e ) { throw e ; } catch ( exception e ) { throw new invalid shape exception ( e . to string ( ) , e ) ; } }	parses either " lat , lon " ( spaces optional on either comma side ) or " x y " style formats.
public boolean is prune ( ) { return prune ; }	returns the value of the prune attribute .
public void enqueue normal ( string method name , int count ) { deque < invocation handler > handlers = get handlers ( method name ) ; for ( int i = num ; i < count ; i ++ ) { handlers . add ( delegate handler ) ; } }	enqueues the specified number of normal operations.
@ suppress warnings ( str ) @ override protected object read post process ( object o ) throws exception { enumeration < object > enm ; vector < vector < ? > > deserialized ; object key ; deserialized = ( vector < vector < ? > > ) super . read post process ( o ) ; rebuild bean connections ( deserialized , regular connection ) ; enm = m . keys ( ) ; while ( enm . has more elements ( ) ) { key = enm . next element ( ) ; if ( ! ( key instanceof meta bean ) ) { continue ; } rebuild bean connections ( deserialized , key ) ; } if ( get data type ( ) == datatype usercomponents ) { remove user tool bar beans ( deserialized ) ; } return deserialized ; }	additional post - processing can happen in derived classes after reading from xml.
public static boolean can see ( i game , entity ae , targetable target ) { return can see ( game , ae , target , bool , null , null ) ; }	checks to see if the target is visible to the unit , always considering sensors .
@ override void to xml ( string builder xml , int level ) { indent ( xml , level ) ; xml . append ( str ) ; for ( int i = num ; i < bytes . length ; i ++ ) { byte b = bytes [ i ] ; if ( b < num ) xml . append ( str ) ; xml . append ( integer . to hex string ( b ) ) ; } xml . append ( str ) ; }	there is no xml representation specified for uids.
public final int read line ( char [ ] buf , int length , boolean is chop ) throws io { byte [ ] read buffer = read buffer ; int offset = num ; while ( bool ) { int read offset = read offset ; int sublen = math . min ( length , read length - read offset ) ; for ( ; sublen > num ; sublen -- ) { int ch = read buffer [ read offset ++ ] & num ; if ( ch != str ) { } else if ( is chop ) { read offset = read offset ; if ( offset > num && buf [ offset - num ] == str ) return offset - num ; else return offset ; } else { buf [ offset ++ ] = ( char ) ch ; read offset = read offset ; return offset + num ; } buf [ offset ++ ] = ( char ) ch ; } read offset = read offset ; if ( read offset <= read length ) { if ( ! read buffer ( ) ) { return offset ; } } if ( length <= offset ) return length + num ; } }	reads a line into the character buffer.
public static void goto offset ( final c model , final i offset , final boolean focus memory window ) { model . set active memory address ( offset , focus memory window ) ; }	sets the caret of a hex control to a given offset .
public list < abstract condition > to conditions list ( ) { list < abstract condition > list = new array list < > ( ) ; for ( node < abstract condition > node : to list ( ) ) { list . add ( node . get data ( ) ) ; } return list ; }	get all conditions as a plain list .
protected void init batch buffer ( ) { try { if ( ! is incremental ( ) ) { m = m . get data set ( ) ; } else { m = null ; } } catch ( exception e ) { e . print stack trace ( ) ; } }	initializes the batch buffer if necessary , i.
public bigdata sail repository connection cxn ( ) { return tl tx . get ( ) ; }	direct access to the unisolated connection.
public static int hash object ( object o ) { return o == null ? num : o . hash code ( ) ; }	null - safe hash code method for objects.
public synchronized void check access ( license checker callback callback ) { if ( m policy . allow access ( ) ) { log . i ( tag , str ) ; callback . allow ( policy . licensed ) ; } else { license validator validator = new license validator ( m policy , new null device limiter ( ) , callback , generate nonce ( ) , m package name , m version code ) ; if ( m service == null ) { log . i ( tag , str ) ; try { boolean bind result = m context . bind service ( new intent ( str ) , this , context . bind auto create ) ; if ( bind result ) { m pending checks . offer ( validator ) ; } else { log . e ( tag , str ) ; handle service connection error ( validator ) ; } } catch ( exception e ) { callback . application error ( license checker callback . error missing permission ) ; } } else { m pending checks . offer ( validator ) ; run checks ( ) ; } } }	checks if the user should have access to the app.
public area ( final rp zone , int x , int y , int width , int height ) { this . zone = zone ; final d myshape = new d . double ( ) ; myshape . set rect ( x , y , width , height ) ; this . shape = myshape ; }	creates a new area .
private byte next tc ( ) throws io { if ( has pushback tc ) { has pushback tc = bool ; } else { pushback tc = input . read byte ( ) ; } return pushback tc ; }	return the next token code ( tc ) from the receiver , which indicates what kind of object follows.
private void newline ( ) { print ( str ) ; }	put the line separator string onto the print stream .
public static string digest string ( string pass , string algorithm ) throws no such algorithm exception { message digest md ; byte array output stream bos ; try { md = message digest . get instance ( algorithm ) ; byte [ ] digest = md . digest ( pass . get bytes ( str ) ) ; bos = new byte array output stream ( ) ; output stream encoded stream = mime utility . encode ( bos , str ) ; encoded stream . write ( digest ) ; return bos . to string ( str ) ; } catch ( io ioe ) { throw new runtime exception ( str + ioe ) ; } catch ( messaging exception me ) { throw new runtime exception ( str + me ) ; } }	calculate digest of given string using given algorithm.
public static boolean is directory ( string path ) { file f = new file ( path ) ; return f . is directory ( ) ; }	checks if the given path is a directory.
private void put with validation ( string key , object value ) throws uri { if ( parameter map . contains key ( key ) ) { throw new uri ( string . format ( locale . us , str , key ) ) ; } else { parameter map . put ( key , value ) ; } }	put the value against the key in the map checking for duplication.
static void transform kill slot ( final rp object ) { final rp kills = keyed slot util . get keyed slot object ( object , str ) ; if ( kills != null ) { final rp new kills = new rp ( ) ; for ( final string attr : kills ) { if ( ! attr . equals ( str ) ) { string new attr = attr ; string value = kills . get ( attr ) ; if ( attr . index of ( str ) < num ) { new attr = update item name ( new attr ) ; new attr = value + str + new attr ; value = str ; } new kills . put ( new attr , value ) ; } } final rp slot = object . get slot ( str ) ; slot . remove ( kills . get id ( ) ) ; slot . add ( new kills ) ; } }	transform kill slot content to the new kill recording system .
public static char sequence trim trailing whitespace ( char sequence source ) { if ( source == null ) return str ; int i = source . length ( ) ; while ( -- i >= num && character . is whitespace ( source . char at ( i ) ) ) { } return source . sub sequence ( num , i + num ) ; }	trims trailing whitespace . removes any of these characters : 0009 , horizontal tabulation 000a , line feed 000b , vertical tabulation 000c , form feed 000d , carriage return 001c , file separator 001d , group separator 001e , record separator 001f , unit separator.
private static void write string vector to file ( vector input vec , string file name ) throws string vector to file exception { try { buffered writer file w = new buffered writer ( new file writer ( file name ) ) ; int line num = num ; while ( line num < input vec . size ( ) ) { file w . write ( ( string ) input vec . element at ( line num ) ) ; file w . new line ( ) ; line num = line num + num ; } ; file w . close ( ) ; } catch ( exception e ) { throw new string vector to file exception ( str + file name ) ; } ; }	methods for reading and writing files.
public boolean before ( string user defined value ) throws illegal argument exception { try { return value . before ( get date ( user defined value ) ) ; } catch ( data type validation exception e ) { throw new illegal argument exception ( e . get message ( ) ) ; } }	indicates whether or not provided value is before .
public void close ( ) { if ( null != input stream reader ) { carbon util . close streams ( input stream reader ) ; } }	below method will be used to clear all the stream.
public static double exponent ( object left , object right ) throws page exception { return strict math . pow ( caster . to double value ( left ) , caster . to double value ( right ) ) ; }	calculate the exponent of the left value.
public synchronized void add action listener ( action listener action listener ) { if ( action listeners == null ) action listeners = new array list < action listener > ( ) ; action listeners . add ( action listener ) ; if ( fired ) { action listener . action performed ( new action event ( this , action event . action performed , str ) ) ; } }	adds a listener that will be notified upon completion of all of the running threads.
public string write data file ( ) throws data file exception { byte array output stream bos = new byte array output stream ( ) ; write data file ( bos ) ; string out string = bos . to string ( ) ; try { if ( bos != null ) bos . close ( ) ; } catch ( io e ) { debug . log warning ( e , module ) ; } return out string ; }	returns the records in this datafile object as a plain text data file content.
public static color determine background color ( final i start instruction , final string tracked register , final c result ) { preconditions . check not null ( start instruction , str ) ; preconditions . check not null ( tracked register , str ) ; preconditions . check not null ( result , str ) ; if ( result . get instruction ( ) == start instruction ) { return color . decode ( str ) ; } else if ( result . undefines all ( ) ) { return color . decode ( str ) ; } else if ( result . clears tracked register ( tracked register ) ) { return color . decode ( str ) ; } else if ( result . undefines some ( ) ) { return color . decode ( str ) ; } else if ( result . defines ( ) ) { return color . decode ( str ) ; } else if ( result . updates ( ) ) { return color . decode ( str ) ; } else if ( result . uses ( ) ) { return color . decode ( str ) ; } else { return color . white ; } }	determines the background color to be used in the table and in the graph to highlight a given instruction result .
public void remove on central position changed listener ( on central position changed listener listener ) { m on central position changed listeners . remove ( listener ) ; }	removes a listener that would be called when the central item of the list changes .
public void add pickup rs ( ) { int old = pickup rs ; pickup rs ++ ; set dirty and fire property change ( str , integer . to string ( old ) , integer . to string ( pickup rs ) ) ; }	increments the number of cars and or engines that will be picked up by a train at this location .
public double convert ( ) { return double . long bits to double ( ints2long ( high , low ) ) ; }	converts the internal representation ( two ints ) to a double .
public void warn ( x xctxt , string msg , object args [ ] ) throws javax . xml . transform . transformer exception { string formatted msg = xsl . create warning ( msg , args ) ; error listener err handler = xctxt . get error listener ( ) ; err handler . warning ( new transformer exception ( formatted msg , ( sax ) xctxt . get sax ( ) ) ) ; }	warn the user of a problem .
public void clear archive directory ( ) { file directory = new file ( get archive directory ( ) ) ; if ( directory . exists ( ) && directory . is directory ( ) ) { string [ ] listing = directory . list ( ) ; for ( string a listing : listing ) { file file = new file ( get archive directory ( ) , a listing ) ; file . delete ( ) ; } } if ( ! directory . exists ( ) ) { directory . mkdirs ( ) ; } }	clears the archive directory .
public void test divide remainder is zero ( ) { string a = str ; int a scale = - num ; string b = str ; int b scale = num ; string c = str ; int res scale = - num ; big decimal a number = new big decimal ( new big integer ( a ) , a scale ) ; big decimal b number = new big decimal ( new big integer ( b ) , b scale ) ; big decimal result = a number . divide ( b number , res scale , big decimal . round ceiling ) ; assert equals ( str , c , result . to string ( ) ) ; assert equals ( str , res scale , result . scale ( ) ) ; }	divide : remainder is zero.
public static boolean nonempty query result ( result set r ) { logger . trace ( str ) ; boolean non empty = bool ; if ( r == null ) { return bool ; } try { if ( r . get row ( ) != num ) { non empty = bool ; } else { logger . trace ( str ) ; non empty = r . first ( ) ; r . before first ( ) ; } } catch ( throwable t ) { surface throwable ( str , t ) ; } return non empty ; }	since the resultset class mysteriously lacks a " size ( ) " method , and since simply iterating thru what might be a large resultset could be a costly exercise , we play the following games.
private string create full message text ( string sender name , string receiver name , string text ) { if ( sender name . equals ( receiver name ) ) { return str + text ; } else { return sender name + str + text ; } }	creates the full message based on the text provided by the player.
public void validate ( ) throws ignite checked exception { for ( cache plugin provider provider : providers list ) provider . validate ( ) ; }	validates cache plugin configurations.
protected boolean one same network ( mac address m1 , mac address m2 ) { string net1 = mac to guid . get ( m1 ) ; string net2 = mac to guid . get ( m2 ) ; if ( net1 == null ) return bool ; if ( net2 == null ) return bool ; return net1 . equals ( net2 ) ; }	checks to see if two mac addresses are on the same network .
public static object [ ] polar2 cartesian array ( double r , double alpha ) { double x = r . double value ( ) * math . cos ( alpha . double value ( ) ) ; double y = r . double value ( ) * math . sin ( alpha . double value ( ) ) ; return new object [ ] { new double ( x ) , new double ( y ) } ; }	convert polar coordinates to cartesian coordinates.
protected void single ensemble ( final double [ ] ensemble , final number vector vec ) { double [ ] buf = new double [ num ] ; for ( int i = num ; i < ensemble . length ; i ++ ) { buf [ num ] = vec . double value ( i ) ; ensemble [ i ] = voting . combine ( buf , num ) ; if ( double . is na n ( ensemble [ i ] ) ) { log . warning ( str + format util . format ( buf ) + str + voting . to string ( ) ) ; } } apply scaling ( ensemble , scaling ) ; }	build a single - element " ensemble " .
@ override public boolean is ( ) { for ( int index = num ; index < lines size ( ) ; ++ index ) { pla line int curr line = tline get ( index ) ; if ( ! curr line . is orthogonal ( ) ) return bool ; if ( ! corner is bounded ( index ) ) return bool ; } return bool ; }	checks if this simplex can be converted into an intbox.
public void add item at index ( t item , int index ) { if ( index <= items . size ( ) ) { items . add ( index , item ) ; fire data changed event ( data changed listener . added , index ) ; } }	adding an item to list at given index.
public static matched values request control new control ( final boolean is critical , final string ... filters ) { reject . if false ( filters . length > num , str ) ; final list < filter > parsed filters = new array list < > ( filters . length ) ; for ( final string filter : filters ) { parsed filters . add ( validate filter ( filter . value of ( filter ) ) ) ; } return new matched values request control ( is critical , collections . unmodifiable list ( parsed filters ) ) ; }	creates a new matched values request control with the provided criticality and list of filters .
private void update ip ( map < string , object > key map , storage port port , cim ip point instance , string port instance id ) throws io { if ( null != port ) { update ip ( get cim ( ip point instance , i ) , port ) ; db client . persist object ( port ) ; } }	update end point details.
public void replace ( string param , string value ) { int [ ] range ; while ( ( range = find template ( param ) ) != null ) buff . replace ( range [ num ] , range [ num ] , value ) ; }	substitute the specified text for the parameter.
private json writer open ( json scope empty , string open bracket ) throws io { before value ( bool ) ; stack . add ( empty ) ; out . write ( open bracket ) ; return this ; }	enters a new scope by appending any necessary whitespace and the given bracket .
public static boolean is composition playlist ( resource byte range provider resource byte range provider ) throws io { try ( input stream input stream = resource byte range provider . get byte range as stream ( num , resource byte range provider . get resource size ( ) - num ) ) { document builder factory document builder factory = document builder factory . new instance ( ) ; document builder factory . set namespace aware ( bool ) ; document builder document builder = document builder factory . new document builder ( ) ; document document = document builder . parse ( input stream ) ; node list node list = null ; for ( string cpl namespace uri : supported cpl ur ) { node list = document . get elements by tag name ns ( cpl namespace uri , str ) ; if ( node list != null && node list . get length ( ) == num ) { return bool ; } } } catch ( parser configuration exception | sax e ) { return bool ; } return bool ; }	a method that confirms if the inputstream corresponds to a composition document instance .
public xml ( final string namespace , final string schema ) throws xml { try { jaxb jc = jaxb . new instance ( namespace ) ; marshaller = jc . create marshaller ( ) ; marshaller . set schema ( xml . create schema ( schema ) ) ; unmarshaller = jc . create unmarshaller ( ) ; unmarshaller . set schema ( xml . create schema ( schema ) ) ; } catch ( jaxb e ) { throw new xml ( str + namespace , e ) ; } }	creates the xmlparser with the namespace and schema file for validation .
public void warn ( string msg , object args [ ] ) throws org . xml . sax . sax { string formatted msg = xsl . create warning ( msg , args ) ; sax locator = get locator ( ) ; error listener handler = m stylesheet processor . get error listener ( ) ; try { if ( null != handler ) handler . warning ( new transformer exception ( formatted msg , locator ) ) ; } catch ( transformer exception te ) { throw new org . xml . sax . sax ( te ) ; } }	warn the user of an problem .
public shape triangle up ( float x , float y , float height ) { m path . reset ( ) ; m path . move to ( x , y + height ) ; m path . line to ( x + height / num , y ) ; m path . line to ( x + height , ( y + height ) ) ; m path . close path ( ) ; return m path ; }	returns a up - pointing triangle of the given dimenisions .
public double min data dl ( int index , double exp fp , boolean check err ) { double [ ] ruleset stat = new double [ num ] ; for ( int j = num ; j < m . size ( ) ; j ++ ) { ruleset stat [ num ] += m . get ( j ) [ num ] ; ruleset stat [ num ] += m . get ( j ) [ num ] ; ruleset stat [ num ] += m . get ( j ) [ num ] ; if ( j == m . size ( ) - num ) { ruleset stat [ num ] = m . get ( j ) [ num ] ; ruleset stat [ num ] = m . get ( j ) [ num ] ; ruleset stat [ num ] = m . get ( j ) [ num ] ; } } double potential = num ; for ( int k = index + num ; k < m . size ( ) ; k ++ ) { double [ ] rule stat = get simple stats ( k ) ; double if deleted = potential ( k , exp fp , ruleset stat , rule stat , check err ) ; if ( ! double . is na n ( if deleted ) ) { potential += if deleted ; } } double data dl = data dl ( exp fp , ruleset stat [ num ] , ruleset stat [ num ] , ruleset stat [ num ] , ruleset stat [ num ] ) ; return ( data dl - potential ) ; }	compute the minimal data description length of the ruleset if the rule in the given position is not deleted . < br > the min_data_dl_if_n_deleted = data_dl_if_n_deleted - potential.
public static void write integer collection ( @ nonnull nbt data , @ nonnull collection < integer > coll ) { data . set integer ( str , coll . size ( ) ) ; final int [ ] ary = new int [ coll . size ( ) ] ; int i = num ; for ( integer num : coll ) { ary [ i ] = num ; i ++ ; } data . set tag ( str , new nbt ( ary ) ) ; }	writes the given collection to the nbttagcompound as an intarray.
@ suppress warnings ( str ) public void query for dump ( string cf name , string file name , string [ ] ids ) throws exception { final class clazz = get class from cf ( cf name ) ; if ( clazz == null ) { return ; } init dump xml file ( cf name ) ; for ( string id : ids ) { query and print record ( uri . create ( id ) , clazz , db cli operation . dump ) ; } write to xml file ( file name ) ; }	query and dump into xml for a particular id in a columnfamily.
private ascii funcs ( ) { }	utility class not to be instantiated .
public dialogue importer import dialogue ( string dialogue file ) { list < dialogue state > turns = xml . extract dialogue ( dialogue file ) ; dialogue importer importer = new dialogue importer ( this , turns ) ; importer . start ( ) ; return importer ; }	imports the dialogue specified in the provided file .
public static string transform filename ( string file name ) { if ( ! file name . ends with ( str ) ) { file name = file name + str ; } return file name ; }	transform a user - entered filename into a proper filename , by adding the ".
public void hide validation messages ( ) { for ( validation error message invalid field : validation messages ) { view view = parent view . find view with tag ( invalid field . get payment product field id ( ) ) ; validation message renderer . remove validation message ( ( view group ) view . get parent ( ) , invalid field . get payment product field id ( ) ) ; } validation messages . clear ( ) ; field ids of error messages showing . clear ( ) ; }	hides all visible validationmessages.
private synchronized void remove loader ( class loader loader ) { int i ; for ( i = loaders . size ( ) - num ; i >= num ; i -- ) { weak reference < class loader > ref = loaders . get ( i ) ; class loader ref loader = ref . get ( ) ; if ( ref loader == null ) loaders . remove ( i ) ; else if ( ref loader == loader ) loaders . remove ( i ) ; } }	removes the specified loader .
public static double parse string ( string value ) { return double . parse double ( value ) ; }	parse string value returning a double .
private void write post content ( url connection , string post content ) throws exception { connection . set request method ( str ) ; connection . add request property ( str , str ) ; connection . set do output ( bool ) ; connection . set do input ( bool ) ; connection . set allow user interaction ( bool ) ; data output stream dstream = null ; try { connection . connect ( ) ; dstream = new data output stream ( connection . get output stream ( ) ) ; dstream . write bytes ( post content ) ; dstream . flush ( ) ; } finally { if ( dstream != null ) { try { dstream . close ( ) ; } catch ( exception ex ) { log . error ( str + str + ex , str ) ; } } } }	send a post request with content to the specified connection.
public void add ( wf node ) { m nodes . add ( node ) ; }	add component and add mouse listener.
@ override public int clamp view position vertical ( view child , int top , int dy ) { int top bound = num ; int bottom bound = num ; switch ( dragger view . get drag position ( ) ) { case top : if ( top > num ) { top bound = dragger view . get padding top ( ) ; bottom bound = ( int ) dragger listener . drag vertical drag range ( ) ; } break ; case bottom : if ( top < num ) { top bound = ( int ) - dragger listener . drag vertical drag range ( ) ; bottom bound = dragger view . get padding top ( ) ; } break ; default : break ; } return math . min ( math . max ( top , top bound ) , bottom bound ) ; }	return the value of slide based on top and height of the element.
@ get @ produces ( { media type . application xml , media type . application json } ) @ path ( str ) @ deprecated public host list list hosts ( @ path param ( str ) uri id ) throws database exception { get tenant by id ( id , bool ) ; verify authorized in tenant org ( id , get user from context ( ) ) ; host list list = new host list ( ) ; list . set hosts ( map ( resource type enum . host , list children ( id , host . class , str , str ) ) ) ; return list ; }	lists the id and name for all the hosts that belong to the given tenant organization.
private void process director stats ( map < string , metric header info > metric header info map , map < string , double > max values , map < string , string > last sample ) { metric header info header info = metric header info map . get ( header key director busy ) ; if ( header info != null ) { string director busy string = last sample . get ( header key director busy ) ; if ( director busy string != null ) { double percent busy = double . value of ( director busy string ) ; double iops = ( max values . contains key ( header key director fe ops ) ) ? max values . get ( header key director fe ops ) : double . value of ( last sample . get ( header key director fe ops ) ) ; string last sample time = last sample . get ( header key time utc ) ; port metrics processor . process fe ( percent busy , iops . long value ( ) , header info . director , last sample time , bool ) ; } } }	process the director metrics found in metricheaderinfomap.
public d transform ( d p ) { if ( p == null ) return null ; return transform . transform ( p , null ) ; }	applies the transform to the supplied point .
static public void assert equals ( string message , string expected , string actual ) { if ( expected == null && actual == null ) return ; if ( expected != null && expected . equals ( actual ) ) return ; throw new comparison failure ( message , expected , actual ) ; }	asserts that two strings are equal .
private void correct changed ( ) { clock . set correct hardware ( correct check box . is selected ( ) , bool ) ; changed = bool ; }	method to handle correct check box change.
private void write of ( datapath id dpid , list < of > messages ) { iof ofswitch = switch service . get switch ( dpid ) ; if ( ofswitch != null ) { if ( log . is debug enabled ( ) ) { log . debug ( str , messages . size ( ) , dpid ) ; } ofswitch . write ( messages ) ; } }	writes a list of ofmessages to a switch.
public void add container request ( map < streaming container agent . container start request , mutable pair < integer , container request > > requested resources , int loop counter , list < container request > container requests , streaming container agent . container start request csr , container request cr ) { mutable pair < integer , container request > pair = new mutable pair < integer , container request > ( loop counter , cr ) ; requested resources . put ( csr , pair ) ; container requests . add ( cr ) ; }	add container request to list of issued requests to yarn along with current loop counter.
public void wait for channel state ( distributed member member , map channel state ) throws interrupted exception { if ( thread . interrupted ( ) ) throw new interrupted exception ( ) ; tcp tc = this . conduit ; if ( tc != null ) { tc . wait for thread owned ordered connection state ( member , channel state ) ; } }	wait for the given connections to process the number of messages associated with the connection in the given map.
private boolean is same circle of trust ( base config type config , string realm , string entity id ) { boolean is trusted = bool ; if ( config != null ) { map attr = idff . get attributes ( config ) ; list cot list = ( list ) attr . get ( idffcot . cot list ) ; if ( ( cot list != null ) && ! cot list . is empty ( ) ) { for ( iterator iter = cot list . iterator ( ) ; iter . has next ( ) ; ) { string cot name = ( string ) iter . next ( ) ; if ( cot manager . is in circle of trust ( realm , cot name , cot . idff , entity id ) ) { is trusted = bool ; } } } } return is trusted ; }	checks if the remote entity identifier is in the entity config ' s circle of trust .
public rule grounding ( ) { groundings = new hash set < assignment > ( ) ; groundings . add ( new assignment ( ) ) ; }	constructs an empty set of groundings.
public void remove index keyspace ( final string index ) throws io { try { query processor . process ( string . format ( str , index ) , consistency level . local one ) ; } catch ( throwable e ) { throw new io ( e . get message ( ) , e ) ; } }	don ' t use queryprocessor.
public static string unhtml angle brackets ( string str ) { str = str . replace all ( str , str ) ; str = str . replace all ( str , str ) ; return str ; }	replace & amp ; lt ; & amp ; gt ; entities with & lt ; & gt ; characters .
public long next ( long from time ) { if ( get current count ( ) == num || from time == num || from time == start date . get time ( ) ) { return first ( ) ; } if ( debug . verbose on ( ) ) { debug . log verbose ( str + ( r date list == null ? num : r date list . size ( ) ) , module ) ; debug . log verbose ( str + ( r rules list == null ? num : r rules list . size ( ) ) , module ) ; } if ( r date list == null && r rules list == null ) { return num ; } long next rule time = from time ; boolean has next = bool ; iterator < recurrence rule > rules iterator = get recurrence rule iterator ( ) ; while ( rules iterator . has next ( ) ) { recurrence rule rule = rules iterator . next ( ) ; while ( has next ) { next rule time = get next time ( rule , next rule time ) ; if ( next rule time == num || is valid ( next rule time ) ) { has next = bool ; } } } return next rule time ; }	returns the next recurrence from the specified time .
public t extract latest attempted ( ) { array list < t > updates = new array list < > ( inflight attempted . size ( ) + num ) ; synchronized ( attempted lock ) { updates . add ( finished attempted ) ; updates . add all ( inflight attempted . values ( ) ) ; } return aggregation . extract ( aggregation . combine ( updates ) ) ; }	extract the latest values from all attempted and in - progress bundles .
public set < json user > load known users ( ) throws interrupted exception , execution exception , remote exception , operation application exception { set < json user > users = get users from db ( ) ; if ( users . is empty ( ) ) { log . i ( str ) ; users = sync known users ( ) ; } log . i ( string . format ( str , users . size ( ) ) ) ; return users ; }	loads the known users from local store . if there is no user in db or the application can ' t retrieve from there , then it fetches the users from server.
public void start ( ) { event log thread . start ( ) ; logger . info ( str + event log thread . get name ( ) + str + event log thread . get id ( ) + str ) ; }	starts the event log thread .
private static string htmlencode ( string str ) { if ( str == null ) { return str ; } else { string builder buf = new string builder ( ) ; for ( char ch : str . to char array ( ) ) { switch ( ch ) { case str : buf . append ( str ) ; break ; case str : buf . append ( str ) ; break ; case str : buf . append ( str ) ; break ; default : buf . append ( ch ) ; break ; } } return buf . to string ( ) ; } }	escapes all ' < ' , ' > ' and ' & ' characters in a string .
public static void begin ( servlet request request , servlet response response , string service name , string object id ) throws servlet exception { service context context = ( service context ) local context . get ( ) ; if ( context == null ) { context = new service context ( ) ; local context . set ( context ) ; } context . request = request ; context . response = response ; context . service name = service name ; context . object id = object id ; context . count ++ ; }	sets the request object prior to calling the service ' s method .
public final buffered image load stored image ( string current image ) { if ( current image == null ) { return null ; } current image = remove illegal file name characters ( current image ) ; final string flag = image type . get ( current image ) ; buffered image image = null ; if ( flag == null ) { return null ; } else if ( flag . equals ( str ) ) { image = load stored image ( current image , str ) ; } else if ( flag . equals ( str ) ) { image = load stored jpeg ( current image ) ; } else if ( flag . equals ( str ) ) { image = load stored image ( current image , str ) ; } else if ( flag . equals ( str ) ) { image = load stored image ( current image , str ) ; } return image ; }	load a image when required and remove from store.
public boolean can use cached project data ( ) { if ( ! my gradle plugin version . equals ( gradle plugin recommended version ) ) { return bool ; } for ( map . entry < string , byte [ ] > entry : my file checksums . entry set ( ) ) { file file = new file ( entry . get key ( ) ) ; if ( ! file . is absolute ( ) ) { file = new file ( my root dir path , file . get path ( ) ) ; } try { if ( ! arrays . equals ( entry . get value ( ) , create checksum ( file ) ) ) { return bool ; } } catch ( io e ) { return bool ; } } return bool ; }	verifies that whether the persisted external project data can be used to create the project or not.
protected void wait for image ( image image ) { int id = ++ next tracker id ; tracker . add image ( image , id ) ; try { tracker . wait for id ( id , num ) ; } catch ( interrupted exception e ) { e . print stack trace ( ) ; } tracker . remove image ( image , id ) ; }	wait for an image to load .
@ override public object [ ] to array ( ) { return new array ( new object [ size ( ) ] ) ; }	returns all the elements in an array.
@ request mapping ( value = str ) public void slo error ( locale locale , @ path variable ( value = str ) string tenant , http servlet response response ) throws io { logger . info ( str + locale . to string ( ) + str + tenant ) ; slo default tenant binding error ( locale , response ) ; }	handle request sent with a wrong binding.
public static double cdf ( double x , double lambda ) { return num - math . exp ( - lambda * x ) ; }	cumulative density function of the exponential distribution.
public void test add math context diff scale pos neg ( ) { string a = str ; int a scale = num ; string b = str ; int b scale = - num ; string c = str ; int c scale = - num ; big decimal a number = new big decimal ( new big integer ( a ) , a scale ) ; big decimal b number = new big decimal ( new big integer ( b ) , b scale ) ; math context mc = new math context ( num , rounding mode . ceiling ) ; big decimal result = a number . add ( b number , mc ) ; assert equals ( str , c , c . to string ( ) ) ; assert equals ( str , c scale , result . scale ( ) ) ; }	add two numbers of different scales using mathcontext ; the first is positive.
private boolean is derived by restriction ( string ancestor ns , string ancestor name , xs type ) { xs old type = null ; while ( type != null && type != old type ) { if ( ( ancestor name . equals ( type . get name ( ) ) ) && ( ( ancestor ns != null && ancestor ns . equals ( type . get namespace ( ) ) ) || ( type . get namespace ( ) == null && ancestor ns == null ) ) ) { return bool ; } old type = type ; type = type . get base type ( ) ; } return bool ; }	dom level 3 checks if a type is derived from another by restriction.
public static void on operator error ( bi function < ? super throwable , object , ? extends throwable > f ) { log . info ( str ) ; on operator error hook = objects . require non null ( f , str ) ; }	override global operator error mapping which by default add as suppressed exception either data driven exception or error driven exception .
public boolean show join part and quit ( ) { return preferences . get boolean ( resources . get string ( r . string . key show joinpartquit ) , boolean . parse boolean ( resources . get string ( r . string . default show joinpartquit ) ) ) ; }	should join , part and quit messages be displayed ?.
public void reset ( ) { last mtd = null ; map . clear ( ) ; load cnt . set ( num ) ; put cnt . set ( num ) ; put all cnt . set ( num ) ; ts = system . current time millis ( ) ; txs . clear ( ) ; }	resets the store to initial state .
public static configuration load ( input stream stream ) throws io { try { properties properties = new properties ( ) ; properties . load ( stream ) ; return from ( properties ) ; } finally { stream . close ( ) ; } }	obtain a configuration instance by loading the properties from the supplied stream .
private static string encode base64 ( final byte d [ ] , final int len ) throws illegal argument exception { int off = num ; final string buffer rs = new string buffer ( ) ; int c1 , c2 ; if ( len <= num || len > d . length ) { throw new illegal argument exception ( str ) ; } while ( off < len ) { c1 = d [ off ++ ] & num ; rs . append ( base64 code [ c1 > > num & num ] ) ; c1 = ( c1 & num ) << num ; if ( off >= len ) { rs . append ( base64 code [ c1 & num ] ) ; break ; } c2 = d [ off ++ ] & num ; c1 |= c2 > > num & num ; rs . append ( base64 code [ c1 & num ] ) ; c1 = ( c2 & num ) << num ; if ( off >= len ) { rs . append ( base64 code [ c1 & num ] ) ; break ; } c2 = d [ off ++ ] & num ; c1 |= c2 > > num & num ; rs . append ( base64 code [ c1 & num ] ) ; rs . append ( base64 code [ c2 & num ] ) ; } return rs . to string ( ) ; }	encode a byte array using bcrypt ' s slightly - modified base64 encoding scheme.
protected byte read byte protected ( data input stream istream ) throws java . io . io { while ( bool ) { int nchars ; nchars = istream . read ( rcv buffer , num , num ) ; if ( nchars > num ) { return rcv buffer [ num ] ; } } }	read a single byte , protecting against various timeouts , etc.
public static pc runner serializable instance ( ) { return pc runner . serializable instance ( ) ; }	generates a simple exemplar of this class to test serialization .
public void draw figure ( d g ) { affine transform saved transform = null ; if ( get ( transform ) != null ) { saved transform = g . get transform ( ) ; g . transform ( get ( transform ) ) ; } paint paint = svg . get fill paint ( this ) ; if ( paint != null ) { g . set paint ( paint ) ; draw fill ( g ) ; } paint = svg . get stroke paint ( this ) ; if ( paint != null && get ( stroke width ) > num ) { g . set paint ( paint ) ; g . set stroke ( svg . get stroke ( this ) ) ; draw stroke ( g ) ; } if ( get ( transform ) != null ) { g . set transform ( saved transform ) ; } }	this method is invoked before the rendered image of the figure is composited .
public static string decode attribute code ( string attribute code ) { return attribute code . starts with ( str ) ? attribute code . substring ( num ) : attribute code ; }	remove dynamic attribute marker ( + ) from attribute code ( if exists ).
public boolean to boolean ( element el , string attribute name ) { return caster . to boolean value ( el . get attribute ( attribute name ) , bool ) ; }	reads a xml element attribute ans cast it to a boolean value.
void save to stream ( data output stream out ) throws io { out . write utf ( m url ) ; out . write utf ( m name ) ; out . write utf ( m value ) ; out . write utf ( m domain ) ; out . write utf ( m path ) ; out . write long ( m creation ) ; out . write long ( m expiration ) ; out . write long ( m last access ) ; out . write boolean ( m secure ) ; out . write boolean ( m http only ) ; out . write boolean ( m first party only ) ; out . write int ( m priority ) ; }	serializes for saving to disk.
public boolean delete ( file f ) { if ( f . is directory ( ) ) { for ( file child : f . list files ( ) ) { if ( ! delete ( child ) ) { return ( bool ) ; } } } boolean result = f . delete ( ) ; media scanner connection . scan file ( this , new string [ ] { f . get absolute path ( ) } , null , null ) ; return ( result ) ; }	recursively deletes a directory and its contents .
public static void replace http header map node specific ( map < string , string > http header map , map < string , string > request parameters ) { boolean need to replace var in http header = bool ; for ( string parameter : request parameters . key set ( ) ) { if ( parameter . contains ( pc constants . node request prefix replace var ) ) { need to replace var in http header = bool ; break ; } } if ( ! need to replace var in http header ) { logger . debug ( str ) ; return ; } for ( entry < string , string > entry : http header map . entry set ( ) ) { string key = entry . get key ( ) ; string value original = entry . get value ( ) ; string value updated = node req response . replace str by map ( request parameters , value original ) ; http header map . put ( key , value updated ) ; } }	! ! ! ! assumption : all var exists in http header must of type : apivarreplace_name_prefix_http_header 20140310 this may be costly ( o ( n ^ 2 ) ) of the updated related # of headers ; # of parameters in the requests.
private void map put ( map map , string name , object preference ) throws io { is empty = bool ; if ( ( name . length ( ) == num ) || ( name == null ) ) { throw new io ( str + str ) ; } if ( map . put ( name , preference ) != null ) { throw new io ( str + name ) ; } }	insert a preference expression and value into a given map .
public builder with tags ( map < string , string > tags ) { this . tags = collections . unmodifiable map ( tags ) ; return this ; }	add these tags to all metrics .
public static script create multi sig input script ( list < transaction signature > signatures ) { list < byte [ ] > sigs = new array list < byte [ ] > ( signatures . size ( ) ) ; for ( transaction signature signature : signatures ) sigs . add ( signature . encode to bitcoin ( ) ) ; return create multi sig input script bytes ( sigs ) ; }	create a program that satisfies an op_checkmultisig program .
@ override public object [ ] to array ( ) { final array list < object > out = new array list < object > ( ) ; final iterator < igpo > gpos = iterator ( ) ; while ( gpos . has next ( ) ) { out . add ( gpos . next ( ) ) ; } return out . to array ( ) ; }	eagerly streams materialized objects into an array.
public static angle rhumb azimuth ( lat lon p1 , lat lon p2 ) { if ( p1 == null || p2 == null ) { throw new illegal argument exception ( str ) ; } double lat1 = p1 . get latitude ( ) . radians ; double lon1 = p1 . get longitude ( ) . radians ; double lat2 = p2 . get latitude ( ) . radians ; double lon2 = p2 . get longitude ( ) . radians ; if ( lat1 == lat2 && lon1 == lon2 ) return angle . zero ; double d lon = lon2 - lon1 ; double d phi = math . log ( math . tan ( lat2 / num + math . pi / num ) / math . tan ( lat1 / num + math . pi / num ) ) ; if ( math . abs ( d lon ) > math . pi ) { d lon = d lon > num ? - ( num * math . pi - d lon ) : ( num * math . pi + d lon ) ; } double azimuth radians = math . atan2 ( d lon , d phi ) ; return double . is na n ( azimuth radians ) ? angle . zero : angle . from radians ( azimuth radians ) ; }	computes the azimuth angle ( clockwise from north ) of a rhumb line ( a line of constant heading ) between two locations .
public void take column family snapshot ( string keyspace name , string column family name , string tag ) throws io { if ( keyspace name == null ) throw new io ( str ) ; if ( operation mode == mode . joining ) throw new io ( str ) ; if ( column family name == null ) throw new io ( str ) ; if ( column family name . contains ( str ) ) throw new illegal argument exception ( str ) ; if ( tag == null || tag . equals ( str ) ) throw new io ( str ) ; keyspace keyspace = get valid keyspace ( keyspace name ) ; column family store column family store = keyspace . get column family store ( column family name ) ; if ( column family store . snapshot exists ( tag ) ) throw new io ( str + tag + str ) ; column family store . snapshot ( tag ) ; }	takes the snapshot of a specific column family.
@ override public enumeration < option > list options ( ) { vector < option > new vector = new vector < option > ( num ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; return new vector . elements ( ) ; }	returns an enumeration describing the available options.
private void dialog changed ( ) { string file name = get filename ( ) ; string set = get setname ( ) ; if ( ( null == file name ) || ( file name . length ( ) < num ) ) { update status ( str ) ; return ; } if ( ( null == set ) || ( set . length ( ) < num ) ) { update status ( str ) ; return ; } update status ( null ) ; }	check data entered . file name and set name must be specified .
@ suppress warnings ( str ) private void apply to group and sub groups ( final as b context , final query root query root , final query hint scope scope , final graph pattern group < i > group , final string name , final string value ) { for ( i child : group ) { apply query hint ( context , query root , scope , ( ast ) child , name , value ) ; if ( child instanceof graph pattern group < ? > ) { apply to group and sub groups ( context , query root , scope , ( graph pattern group < i > ) child , name , value ) ; } } apply query hint ( context , query root , scope , ( ast ) group , name , value ) ; }	apply the query hint to the group and , recursively , to any sub - groups .
public static int read int ( final json json object , final string key , final boolean required , final boolean not null ) throws json { if ( required ) { return json object . get int ( key ) ; } if ( not null && json object . is null ( key ) ) { throw new json ( string . format ( locale . us , null value format object , key ) ) ; } int value = num ; if ( ! json object . is null ( key ) ) { value = json object . get int ( key ) ; } return value ; }	reads the int value from the json object for specified tag .
public xy ( ) { this ( time zone . get default ( ) , locale . get default ( ) ) ; }	creates a new dataset .
public void remove tmp store ( imx store ) { if ( null != store ) { m tmp stores . remove ( store ) ; } }	remove the dedicated store from the tmp stores list .
public static list < annotation dto > transform to dto ( list < annotation > annotations ) { if ( annotations == null ) { throw new web application exception ( str , status . internal server error ) ; } list < annotation dto > result = new array list < > ( ) ; for ( annotation annotation : annotations ) { result . add ( transform to dto ( annotation ) ) ; } return result ; }	converts list of alert entity objects to list of alertdto objects .
protected void enable buttons ( ) { m m id = - num ; m = null ; m = null ; int row = m table . get selected row ( ) ; boolean enabled = row != - num ; if ( enabled ) { integer id = m table . get selected row key ( ) ; if ( id != null ) { m m id = id . int value ( ) ; m = ( string ) m table . get value at ( row , num ) ; m = ( big decimal ) m table . get value at ( row , num ) ; } } f ok . set enabled ( enabled ) ; log . fine ( str + m m id + str + m + str + m ) ; }	enable / set buttons and set id.
public void start ( ) { managed ports . add ( create port ( ) ) ; fix names ( ) ; ports . add observer ( observer , bool ) ; }	creates an initial port and starts to listen .
public hessian debug output stream ( output stream os , print writer dbg ) { os = os ; state = new hessian debug state ( dbg ) ; }	creates an uninitialized hessian input stream .
public configurator from file ( file file ) { if ( ! file . exists ( ) ) { throw new file not found exception ( file . get absolute path ( ) + str ) ; } return new configurator ( file . get absolute path ( ) , bool ) ; }	use a file as the pdf source.
public synchronized void insert text ( string inputtype , string outputtype , string locale , string voice , string outputparams , string style , string effects , string inputtext , string outputtext ) throws sql { if ( inputtype == null || outputtype == null || locale == null || voice == null || inputtext == null || outputtext == null ) { throw new null pointer exception ( str ) ; } if ( lookup text ( inputtype , outputtype , locale , voice , outputparams , style , effects , inputtext ) != null ) { return ; } string query = str + inputtype + str + outputtype + str + locale + str + voice + str + outputparams + str + style + str + effects + str ; prepared statement st = connection . prepare statement ( query ) ; st . set string ( num , inputtext ) ; st . set string ( num , outputtext ) ; st . execute update ( ) ; st . close ( ) ; }	insert a record of a mary request producing data of type text into the cache.
public boolean is empty ( ) { return bool ; }	methods that need to be implemented from generaltaskrunnable .
public static boolean is numeric or punctuation or symbols ( string token ) { int len = token . length ( ) ; for ( int i = num ; i < len ; ++ i ) { char c = token . char at ( i ) ; if ( ! ( character . is digit ( c ) || characters . is punctuation ( c ) || characters . is symbol ( c ) ) ) { return bool ; } } return bool ; }	returns true if a string consists entirely of numbers , punctuation , and / or symbols .
@ deprecated public dc ( string s ) { set binary ( bool ) ; set retries ( n retries ) ; set timeout ( dc ) ; my message = new string builder ( s ) ; n data chars = my message . length ( ) ; data chars = new int [ n data chars ] ; }	create a dccppmessage from a string containing bytes . since dccppmessages are text , there is no hex - to - byte conversion.
@ override public void start ( ) throws baleen exception { }	will not start controllers .
public object instance ( object name object name , string class name ) { if ( object name . is pattern ( ) ) { final illegal argument exception iae = new illegal argument exception ( str + object name . to string ( ) ) ; throw new runtime operations exception ( iae ) ; } this . name = object name ; this . class name = class name ; }	allows an object instance to be created given an object name and the full class name , including the package name .
public static void flush el ( writer w ) { try { if ( w != null ) w . flush ( ) ; } catch ( exception e ) { } }	flush outputstream without a exception.
public dimension maximum layout size ( container target ) { dimension size ; synchronized ( this ) { check container ( target ) ; check requests ( ) ; size = new dimension ( x total . maximum , y total . maximum ) ; } insets insets = target . get insets ( ) ; size . width = ( int ) math . min ( ( long ) size . width + ( long ) insets . left + ( long ) insets . right , integer . max value ) ; size . height = ( int ) math . min ( ( long ) size . height + ( long ) insets . top + ( long ) insets . bottom , integer . max value ) ; return size ; }	returns the maximum dimensions the target container can use to lay out the components it contains .
private void add group text ( form entry caption [ ] groups ) { string builder s = new string builder ( str ) ; string t = str ; int i ; for ( form entry caption g : groups ) { i = g . get multiplicity ( ) + num ; t = g . get long text ( ) ; if ( t != null ) { s . append ( t ) ; if ( g . repeats ( ) && i > num ) { s . append ( str + i + str ) ; } s . append ( str ) ; } } if ( s . length ( ) > num ) { text view tv = new text view ( get context ( ) ) ; tv . set text ( s . substring ( num , s . length ( ) - num ) ) ; int question fontsize = collect . get question fontsize ( ) ; tv . set text size ( typed value . complex unit dip , question fontsize - num ) ; tv . set padding ( num , num , num , num ) ; m view . add view ( tv , m layout ) ; } }	/ / * add a textview containing the hierarchy of groups to which the question belongs . / /.
public static number plus ( number left , character right ) { return number number plus . plus ( left , integer . value of ( right ) ) ; }	add a number and a character.
public void add flag ( id optionid ) { parameters . add ( new parameter pair ( optionid , flag . set ) ) ; }	add a flag to the parameter list.
public static byte buffer to buffer ( string spaced hex ) { return byte buffer . wrap ( to byte array ( spaced hex ) ) ; }	convert the spaced hex form of a string into a bytebuffer .
protected void print ( char v ) throws io { os . write ( v ) ; }	prints a char to the stream .
public static boolean is right turn ( point p1 , point p2 , point p3 ) { if ( p1 . equals ( p2 ) || p2 . equals ( p3 ) ) { return bool ; } double val = ( p2 . x * p3 . y + p1 . x * p2 . y + p3 . x * p1 . y ) - ( p2 . x * p1 . y + p3 . x * p2 . y + p1 . x * p3 . y ) ; return val > num ; }	returns true , if the three given points make a right turn .
private string convert less than one thousand ( int number ) { string so far ; if ( number % num < num ) { so far = num names [ number % num ] ; number /= num ; } else { so far = num names [ number % num ] ; number /= num ; string s = double . to string ( number ) ; if ( s . ends with ( str ) && ! so far . equals ( str ) ) so far = str + so far . trim ( ) ; else if ( so far . equals ( str ) ) so far = tens names [ number % num ] + str + so far ; else so far = tens names [ number % num ] + str + so far ; number /= num ; } if ( number == num ) return tens names [ number % num ] + so far ; if ( number > num ) so far = str + so far ; if ( number == num && ! so far . equals ( str ) ) number = num ; so far = str + so far ; return num names [ number ] + str + so far ; }	convert less than one thousand.
public boolean is refresh token expired ( ) { return refresh token expires at . before ( new date ( ) ) ; }	checks if the time the refresh access token will be valid are over.
public string to string ( ) { if ( m == null ) { return str ; } string result = str + get classifier spec ( ) + str + get filter spec ( ) + str + m . to string ( ) + str + m . to string ( ) ; return result ; }	output a representation of this classifier.
@ bean public spring process engine configuration activiti process engine configuration ( async executor activiti async executor ) { spring process engine configuration configuration = new spring process engine configuration ( ) ; configuration . set data source ( herd data source ) ; configuration . set transaction manager ( herd transaction manager ) ; configuration . set database schema update ( get activiti db schema update param bean name ( ) ) ; configuration . set async executor activate ( bool ) ; configuration . set async executor enabled ( bool ) ; configuration . set async executor ( activiti async executor ) ; configuration . set beans ( new hash map < > ( ) ) ; configuration . set delegate interceptor ( herd delegate interceptor ) ; configuration . set command invoker ( herd command invoker ) ; init scripting engines ( configuration ) ; configuration . set mail server default from ( configuration helper . get property ( configuration value . activiti default mail from ) ) ; list < process engine configurator > herd configurators = new array list < > ( ) ; herd configurators . add ( herd process engine configurator ) ; configuration . set configurators ( herd configurators ) ; return configuration ; }	gets the activiti process engine configuration .
protected < t > void run tasks concurrent ( final list < abstract task < t > > tasks ) throws interrupted exception { assert resource manager . overflow tasks concurrent >= num ; try { final list < future < t > > futures = resource manager . get concurrency manager ( ) . invoke all ( tasks , resource manager . overflow timeout , time unit . milliseconds ) ; final iterator < abstract task < t > > titr = tasks . iterator ( ) ; for ( future < ? extends object > f : futures ) { final abstract task < t > task = titr . next ( ) ; get future for task ( f , task , num , time unit . nanoseconds ) ; } } finally { } }	runs the overflow tasks in parallel , cancelling any tasks which have not completed if we run out of time.
public void init components ( ) { set title ( bundle . get message ( str ) ) ; container content pane = get content pane ( ) ; content pane . set layout ( new box layout ( content pane , box layout . y axis ) ) ; content pane . add ( init address panel ( ) ) ; content pane . add ( init notes panel ( ) ) ; content pane . add ( init button panel ( ) ) ; pack ( ) ; }	initialize the config window.
private static double v ( jni env , int obj jref , int method id , address arg address ) throws exception { if ( trace jni ) vm . sys write ( str ) ; runtime entrypoints . check jni gc ( ) ; try { object obj = env . get jni ( obj jref ) ; object return obj = jni . invoke with var arg ( obj , method id , arg address , type reference . double , bool ) ; return reflection . unwrap double ( return obj ) ; } catch ( throwable unexpected ) { if ( trace jni ) unexpected . print stack trace ( system . err ) ; env . record exception ( unexpected ) ; return num ; } }	calldoublemethodv : invoke a virtual method that returns a double value.
private final int trade bonus ( position pos ) { final int w m = pos . w mtrl ; final int b m = pos . b mtrl ; final int w pawn = pos . w mtrl pawns ; final int b pawn = pos . b mtrl pawns ; final int delta score = w m - b m ; int p bonus = num ; p bonus += interpolate ( ( delta score > num ) ? w pawn : b pawn , num , - num * delta score / num , num * p v , num ) ; p bonus += interpolate ( ( delta score > num ) ? b m : w m , num , num * delta score / num , q v + num * r v + num * b v + num * n v , num ) ; return p bonus ; }	implement the " when ahead trade pieces , when behind trade pawns " rule .
private list < vcenter > filter vcenters by tenant ( list < vcenter > vcenters , uri tenant id ) { list < vcenter > tenant vcenter list = new array list < vcenter > ( ) ; iterator < vcenter > vcenter it = vcenters . iterator ( ) ; while ( vcenter it . has next ( ) ) { vcenter vcenter = vcenter it . next ( ) ; if ( vcenter == null ) { continue ; } set < uri > tenant uris = permissions helper . get usage ur ( vcenter . get acls ( ) ) ; if ( collection utils . is empty ( tenant uris ) ) { continue ; } if ( ! null column value getter . is null uri ( tenant id ) && ! tenant uris . contains ( tenant id ) ) { continue ; } iterator < uri > tenant uri it = tenant uris . iterator ( ) ; while ( tenant uri it . has next ( ) ) { if ( verify authorized in tenant org ( tenant uri it . next ( ) ) ) { tenant vcenter list . add ( vcenter ) ; } } } return tenant vcenter list ; }	filters the vcenters by the tenant.
public void update visiblity value ( int reference index ) { m cached visible area = m layout tab . compute visible area ( ) ; m cached index distance = math . abs ( m index - reference index ) ; m order sorting value = compute order sorting value ( m cached index distance , m cache stack visibility ) ; m visiblity sorting value = compute visibility sorting value ( m cached visible area , m order sorting value , m cache stack visibility ) ; }	updates the cached visible area value to be used to sort tabs by visibility .
public boolean contains ( event point ep ) { return events . contains ( ep ) ; }	determine whether event point already exists within the queue .
public facebook exception ( string format , object ... args ) { this ( string . format ( format , args ) ) ; }	constructs a new facebookexception .
private boolean is nanpa number with national prefix ( ) { return ( current metadata . get country code ( ) == num ) && ( national number . char at ( num ) == str ) && ( national number . char at ( num ) != str ) && ( national number . char at ( num ) != str ) ; }	returns true if the current country is a nanpa country and the national number begins with the national prefix .
public static void zip files ( file zip , file ... files ) throws io { try ( buffered output stream buffered out = new buffered output stream ( new file output stream ( zip ) ) ) { zip files ( buffered out , files ) ; } }	create an output zip stream and add each file to that stream.
protected void process client pom ( ) throws io { file pom = new file ( project root , client pom ) ; string pom content = read file content ( pom ) ; string dep string = gen start + string . format ( str , maven group id , maven artifact id ) + gen end ; if ( ! pom content . contains ( dep end tag ) ) { throw new io ( string . format ( str , client pom , dep end tag ) ) ; } pom content = pom content . replace ( dep end tag , dep string + dep end tag ) ; write file content ( pom content , pom ) ; }	insert dependency at the end of " dependencies " section .
public void put ( uri uri , byte [ ] bimg , buffered image img ) { synchronized ( bytemap ) { while ( bytesize > num * num * num ) { uri olduri = bytemap access queue . remove first ( ) ; byte [ ] oldbimg = bytemap . remove ( olduri ) ; bytesize -= oldbimg . length ; log ( str ) ; } bytemap . put ( uri , bimg ) ; bytesize += bimg . length ; bytemap access queue . add last ( uri ) ; } add to image cache ( uri , img ) ; }	put a tile image into the cache.
public static attrib key for attribute ( namespaces in scope , el key el , string qname ) { namespaces ns ; string local name ; int colon = qname . index of ( str ) ; if ( colon < num ) { ns = el . ns ; local name = qname ; } else { ns = in scope . for attr name ( el . ns , qname ) ; if ( ns == null ) { return null ; } ns = in scope . for uri ( ns . uri ) ; local name = qname . substring ( colon + num ) ; } return new attrib key ( el , ns , local name ) ; }	looks up an attribute key by qualified name .
public void remove map events listener ( map events listener listener ) { if ( map events listeners != null ) { map events listeners . remove ( listener ) ; } }	removes map event listener from the map .
@ request mapping ( value = { str , str } , method = request method . get ) @ response body public rest wrapper list using key ( @ path variable ( str ) string config group , @ path variable ( str ) string key , principal principal ) { rest wrapper rest wrapper = null ; get general config get general config = new get general config ( ) ; general config general config = get general config . by conig group and key ( config group , key ) ; if ( general config . get required ( ) == num ) { rest wrapper = new rest wrapper ( str , rest wrapper . error ) ; } else { rest wrapper = new rest wrapper ( general config , rest wrapper . ok ) ; logger . info ( str + config group + str + key + str + principal . get name ( ) ) ; } return rest wrapper ; }	this method calls proc getgenconfigproperty and fetches a record from generalconfig table corresponding to config group and key passed .
private color state list apply text appearance ( paint p , int res id ) { text view tv = new text view ( m context ) ; if ( s . is api 23 ( ) ) { tv . set text appearance ( res id ) ; } else { tv . set text appearance ( m context , res id ) ; } p . set typeface ( tv . get typeface ( ) ) ; p . set text size ( tv . get text size ( ) ) ; final color state list text color = tv . get text colors ( ) ; if ( text color != null ) { final int enabled color = text color . get color for state ( enabled state set , num ) ; p . set color ( enabled color ) ; } return text color ; }	applies the specified text appearance resource to a paint , returning the text color if one is set in the text appearance .
public void remove discovery listener ( discovery listener l ) { synchronized ( registrars ) { if ( terminated ) { throw new illegal state exception ( str ) ; } listeners . remove ( l ) ; } }	indicate that a listener is no longer interested in receiving discoveryevent notifications .
public static void copy file ( file in , file out ) throws io { file input stream fis = new file input stream ( in ) ; file output stream fos = new file output stream ( out ) ; try { copy stream ( fis , fos ) ; } finally { fis . close ( ) ; fos . close ( ) ; } }	copy a file from one place to another.
private int x to screen coords ( int map coord ) { return ( int ) ( map coord * map . get scale ( ) - map . get scroll x ( ) ) ; }	transforms coordinate in map coordinate system to screen coordinate system.
public alias filter ( map < string , object > filter ) { if ( filter == null || filter . is empty ( ) ) { this . filter = null ; return this ; } try { x builder = x . content builder ( x . json ) ; builder . map ( filter ) ; this . filter = builder . string ( ) ; return this ; } catch ( io e ) { throw new elasticsearch generation exception ( str + filter + str , e ) ; } }	associates a filter to the alias.
public void connect to bean context ( bean context in bc ) throws property veto exception { if ( in bc != null ) { in bc . add bean context membership listener ( this ) ; bean context child support . set bean context ( in bc ) ; } }	layer method to just connect to the beancontext , without grabbing the iterator as in setbeancontext ( ).
public static id create cert id ( big integer subject serial number , x509 certificate issuer ) throws exception { return new id ( create digest calculator ( sh id ) , new x509 certificate holder ( issuer . get encoded ( ) ) , subject serial number ) ; }	creates a new certificate id instance ( using sha - 1 digest calculator ) for the specified subject certificate serial number and issuer certificate .
public static final string convert to text ( final string input , final boolean is xml ) { final string buffer output data ; if ( is xml ) { final byte [ ] raw data = string utils . to bytes ( input ) ; final int length = raw data . length ; int ptr = num ; boolean in token = bool ; for ( int i = num ; i < length ; i ++ ) { if ( raw data [ i ] == str ) { in token = bool ; if ( raw data [ i + num ] == str && raw data [ i + num ] == str && raw data [ i + num ] == str && raw data [ i + num ] == str && raw data [ i + num ] == str ) { raw data [ ptr ] = str ; ptr ++ ; } } else if ( raw data [ i ] == str ) { in token = bool ; } else if ( ! in token ) { raw data [ ptr ] = raw data [ i ] ; ptr ++ ; } } final byte [ ] cleaned string = new byte [ ptr ] ; system . arraycopy ( raw data , num , cleaned string , num , ptr ) ; output data = new string buffer ( new string ( cleaned string ) ) ; } else { output data = new string buffer ( input ) ; } return output data . to string ( ) ; }	strip out xml tags and put in a tab ( do not use on chinese text ).
private int parse key ( final byte [ ] b , final int off ) throws parse exception { final int bytes to parse len = b . length - off ; if ( bytes to parse len >= encrypted key len ) { encrypted key = arrays . copy of range ( b , off , off + encrypted key len ) ; return encrypted key len ; } else { throw new parse exception ( str ) ; } }	parse the key in the provided bytes.
public static reply processor21 send ( set recipients , dm dm , int pr id , int bucket id , bucket profile bp , boolean require ack ) { if ( recipients . is empty ( ) ) { return null ; } reply processor21 rp = null ; int proc id = num ; if ( require ack ) { rp = new reply processor21 ( dm , recipients ) ; proc id = rp . get processor id ( ) ; } bucket profile update message m = new bucket profile update message ( recipients , pr id , proc id , bucket id , bp ) ; dm . put outgoing ( m ) ; return rp ; }	send a profile update to a set of members .
static boolean is caller sensitive ( member name mem ) { if ( ! mem . is invocable ( ) ) return bool ; return mem . is caller sensitive ( ) || can be called virtual ( mem ) ; }	is this method a caller - sensitive method ? i.
public void stop search ( ) { m matched node . clear ( ) ; m query text . set length ( num ) ; m search overlay . hide ( ) ; m active = bool ; }	stop the current search.
boolean persist managed schema ( boolean create only ) { if ( loader instanceof zk solr resource loader ) { return persist managed schema to zoo keeper ( create only ) ; } file managed schema file = new file ( loader . get config dir ( ) , managed schema resource name ) ; output stream writer writer = null ; try { file parent dir = managed schema file . get parent file ( ) ; if ( ! parent dir . is directory ( ) ) { if ( ! parent dir . mkdirs ( ) ) { final string msg = str + parent dir . get absolute path ( ) ; log . error ( msg ) ; throw new solr exception ( error code . server error , msg ) ; } } final file output stream out = new file output stream ( managed schema file ) ; writer = new output stream writer ( out , standard charsets . utf 8 ) ; persist ( writer ) ; log . info ( str + managed schema file . get path ( ) ) ; } catch ( io e ) { final string msg = str + managed schema file ; log . error ( msg , e ) ; throw new solr exception ( error code . server error , msg , e ) ; } finally { io . close quietly ( writer ) ; try { file utils . sync ( managed schema file ) ; } catch ( io e ) { final string msg = str + managed schema file ; log . error ( msg , e ) ; } } return bool ; }	persist the schema to local storage or to zookeeper.
public static string make xml safe ( string text ) { if ( string util . is null or empty ( text ) ) return str ; text = text . replace ( esc ampersand , str ) ; text = text . replace ( str , esc quote ) ; text = text . replace ( str , esc ampersand ) ; text = text . replace ( str , esc apostrophe ) ; text = text . replace ( str , esc less than ) ; text = text . replace ( str , esc greater than ) ; text = text . replace ( str , str ) ; return text ; }	takes in a string , and replaces all xml special characters with the approprate escape strings .
final public mutable string to upper case ( ) { int n = length ( ) ; final char [ ] a = array ; while ( n -- != num ) a [ n ] = character . to upper case ( a [ n ] ) ; changed ( ) ; return this ; }	converts all of the characters in this mutable string to upper case using the rules of the default locale .
@ override public void handle mouse pressed ( chart canvas canvas , mouse event e ) { this . mouse pressed point = new d . double ( e . get x ( ) , e . get y ( ) ) ; }	handles a mouse pressed event by recording the location of the mouse pointer ( so that later we can check that the click isn ' t part of a drag ) .
public static path create temp file ( string prefix , string suffix ) throws io { path temp dir path = paths . get ( system properties . get temp files path ( ) ) ; return create temp file ( temp dir path , prefix , suffix ) ; }	creates a temporary file on disk ( location specified by systemproperties.
public static short [ ] initialize sub state array ( list < tree < string > > train trees , list < tree < string > > validation trees , numberer tag numberer , short n sub states ) { short [ ] n sub = new short [ num ] ; n sub [ num ] = num ; n sub [ num ] = n sub states ; state set tree list train state set trees = new state set tree list ( train trees , n sub , bool , tag numberer ) ; @ suppress warnings ( str ) state set tree list validation state set trees = new state set tree list ( validation trees , n sub , bool , tag numberer ) ; state set tree list . initialize tag numberer ( train trees , tag numberer ) ; state set tree list . initialize tag numberer ( validation trees , tag numberer ) ; short num states = ( short ) tag numberer . total ( ) ; short [ ] n sub state array = new short [ num states ] ; arrays . fill ( n sub state array , n sub states ) ; n sub state array [ num ] = num ; return n sub state array ; }	convert a single tree [ string ] to tree [ stateset ].
public void add property change listener ( property change listener listener ) { property change support . add property change listener ( listener ) ; }	add a propertychangelistener to the listener list .
public plugin description file ( final string plugin name , final string plugin version , final string main class ) { name = plugin name . replace ( str , str ) ; version = plugin version ; main = main class ; }	creates a new plugindescriptionfile with the given detailed.
public void fill ( d g , shape s ) { rectangle bounds = s . get bounds ( ) ; int width = bounds . width ; int height = bounds . height ; buffered image bimage = effect . create buffered image ( width , height , bool ) ; d gbi = bimage . create graphics ( ) ; gbi . set color ( color . black ) ; gbi . fill ( s ) ; g . draw image ( apply effect ( bimage , null , width , height ) , num , num , null ) ; }	paint the effect based around a solid shape in the graphics supplied .
public void silent clear ( ) { m selected widgets . clear ( ) ; m modified widgets . clear ( ) ; }	clear the selection without warning listeners.
public static boolean is array ( element array e ) { string name = array e . get tag name ( ) ; if ( name . equals ( str ) || name . equals ( str ) || name . equals ( str ) || name . equals ( str ) || name . equals ( str ) || is sparse array ( array e ) ) { return bool ; } return bool ; }	utility method to check if an xml element is an array .
public void add notification listener ( object name name , notification listener listener , notification filter filter , object handback ) throws instance not found exception { mbs interceptor . add notification listener ( clone object name ( name ) , listener , filter , handback ) ; }	adds a listener to a registered mbean .
static long read var long ( input stream in ) throws io { long x = in . read ( ) ; if ( x < num ) { throw new eof ( ) ; } x = ( byte ) x ; if ( x >= num ) { return x ; } x &= num ; for ( int s = num ; s < num ; s += num ) { long b = in . read ( ) ; if ( b < num ) { throw new eof ( ) ; } b = ( byte ) b ; x |= ( b & num ) << s ; if ( b >= num ) { break ; } } return x ; }	read a variable size long value .
public static builder create builder ( abstract managed object definition < ? , ? > d , string property name ) { return new builder ( d , property name ) ; }	create a aci property definition builder .
public void filter ( file input file , print writer o ) throws io { buffered writer bw = new buffered writer ( o ) ; string buffer sb = ( string buffer ) file map . get ( input file . to string ( ) ) ; if ( sb == null ) { sb = load file ( input file ) ; } filter ( sb , bw ) ; bw . flush ( ) ; }	filters data from file .
public int update ( string sql , statement visitor visitor ) throws sql { connection connection = null ; prepared statement stmt = null ; try { connection = source . get connection ( ) ; stmt = connection . prepare statement ( sql ) ; visitor . visit ( stmt ) ; return stmt . execute update ( ) ; } finally { sql . close quietly ( stmt ) ; sql . close quietly ( connection ) ; } }	perform sql update statement.
public void stop ( ) { logger . info ( str ) ; if ( thrift server != null ) thrift server . stop ( ) ; if ( native server != null ) native server . stop ( ) ; if ( fb . is windows ( ) ) system . exit ( num ) ; if ( jmx server != null ) { try { jmx server . stop ( ) ; } catch ( io e ) { logger . error ( str , e ) ; } } }	stop the daemon , ideally in an idempotent manner . hook for jsvc / procrun.
private void compile method ( hot spot resolved java method method , int counter ) { try { long start = system . current time millis ( ) ; long allocated at start = mem use tracker impl . get current thread allocated bytes ( ) ; int entry bci = jvmci . invocation entry bci ; hot spot compilation request request = new hot spot compilation request ( method , entry bci , num ) ; boolean use profiling info = bool ; boolean install as default = bool ; compilation task task = new compilation task ( jvmci runtime , compiler , request , use profiling info , install as default ) ; task . run compilation ( ) ; hot spot installed code installed code = task . get installed code ( ) ; if ( installed code != null ) { installed code . invalidate ( ) ; } memory used . get and add ( mem use tracker impl . get current thread allocated bytes ( ) - allocated at start ) ; compile time . get and add ( system . current time millis ( ) - start ) ; compiled methods counter . increment and get ( ) ; } catch ( throwable t ) { println ( str , counter , method . format ( str ) ) ; print stack trace ( t ) ; } }	compiles a method and gathers some statistics .
private static void do copy directory ( file src dir , file dest dir , file filter filter , boolean preserve file date , list < string > exclusion list ) throws io { file [ ] src files = filter == null ? src dir . list files ( ) : src dir . list files ( filter ) ; if ( src files == null ) { throw new io ( str + src dir ) ; } if ( dest dir . exists ( ) ) { if ( dest dir . is directory ( ) == bool ) { throw new io ( str + dest dir + str ) ; } } else { if ( ! dest dir . mkdirs ( ) && ! dest dir . is directory ( ) ) { throw new io ( str + dest dir + str ) ; } } if ( dest dir . can write ( ) == bool ) { throw new io ( str + dest dir + str ) ; } for ( file src file : src files ) { file dst file = new file ( dest dir , src file . get name ( ) ) ; if ( exclusion list == null || ! exclusion list . contains ( src file . get canonical path ( ) ) ) { if ( src file . is directory ( ) ) { do copy directory ( src file , dst file , filter , preserve file date , exclusion list ) ; } else { do copy file ( src file , dst file , preserve file date ) ; } } } if ( preserve file date ) { dest dir . set last modified ( src dir . last modified ( ) ) ; } }	internal copy directory method .
public int process byte ( byte in , byte [ ] out , int out off ) throws data length exception , illegal state exception { int result len = num ; if ( buf off == buf . length ) { result len = cipher . process block ( buf , num , out , out off ) ; system . arraycopy ( buf , block size , buf , num , block size ) ; buf off = block size ; } buf [ buf off ++ ] = in ; return result len ; }	process a single byte , producing an output block if necessary .
public esri shape export ( esri graphic list list , dbf table model dbf , string path to file ) { set graphic list ( list ) ; set master dbf ( dbf ) ; file path = path to file ; debug = logger . is loggable ( level . fine ) ; }	create an esrishapeexport object .
void save offset in external store ( string topic , int partition , long offset ) { try { file writer writer = new file writer ( storage name ( topic , partition ) , bool ) ; buffered writer buffered writer = new buffered writer ( writer ) ; buffered writer . write ( offset + str ) ; buffered writer . flush ( ) ; buffered writer . close ( ) ; } catch ( exception e ) { e . print stack trace ( ) ; throw new runtime exception ( e ) ; } }	overwrite the offset for the topic in an external storage .
private centroid cluster model assine points ( centroid cluster model model ) { double [ ] values = new double [ attributes . size ( ) ] ; int i = num ; for ( example example : example set ) { double [ ] example values = get as double array ( example , attributes , values ) ; double nearest distance = measure . calculate distance ( model . get centroid coordinates ( num ) , example values ) ; int nearest index = num ; int id = num ; for ( centroid cr : model . get centroids ( ) ) { double distance = measure . calculate distance ( cr . get centroid ( ) , example values ) ; if ( distance < nearest distance ) { nearest distance = distance ; nearest index = id ; } id ++ ; } centroid assignments [ i ] = nearest index ; i ++ ; } model . set cluster assignments ( centroid assignments , example set ) ; return model ; }	assign the points to cluster.
public static string format quantity ( big decimal quantity ) { if ( quantity == null ) return str ; else return quantity decimal format . format ( quantity ) ; }	formats an bigdecimal representing a quantity into a string.
public void import pkc ( burp certificate certificate , string filename ) { set status ( str ) ; file input stream fis ; file file = new file ( filename ) ; private key private key ; try { fis = new file input stream ( file ) ; data input stream dis = new data input stream ( fis ) ; byte [ ] key bytes = new byte [ ( int ) file . length ( ) ] ; dis . read fully ( key bytes ) ; dis . close ( ) ; pkc key spec = new pkc ( key bytes ) ; key factory key factory = key factory . get instance ( str ) ; private key = key factory . generate private ( key spec ) ; certificate . set private key ( private key ) ; set certificate tree ( ) ; set status ( str ) ; } catch ( io | no such algorithm exception | invalid key spec exception e ) { set status ( str + e . get message ( ) + str ) ; e . print stack trace ( ) ; } catch ( exception e ) { set status ( str + e . get message ( ) + str ) ; } }	import a private key in pkcs8 format in der format .
public collection < object > undo ( ) { hash set < object > modified objects = null ; boolean done = bool ; while ( ( index of next add > num ) && ! done ) { list < mx undoable edit > edits = history . get ( -- index of next add ) ; for ( int i = edits . size ( ) - num ; i >= num ; i -- ) { mx undoable edit edit = edits . get ( i ) ; edit . undo ( ) ; modified objects = edit . get affected objects ( ) ; if ( edit . is significant ( ) ) { fire event ( new mx event object ( mx event . undo , str , edit ) ) ; done = bool ; } } } return modified objects ; }	undoes the last change .
public x ( string parse string , x formula ) { this ( parse string , formula , bool ) ; }	create a new texparser.
public static < t > tree node < t > copy ( tree def < t > tree def , t root ) { return copy ( tree def , root , function . identity ( ) ) ; }	creates a hierarchy of treenodes that copies the structure and content of the given tree .
protected void draw with offset ( float zone , int points right , int points left , float fixed points , canvas canvas , paint paint ) { int position = get position for zone ( zone ) ; int first position = ( int ) ( position - points left - fixed points ) ; int last position = ( int ) ( position + points right + fixed points ) ; if ( last position > points number - num && last position != points number ) { int offset = last position - points number - num ; float [ ] points f = get array float ( points . sub list ( num , offset ) ) ; last position = points number - num ; canvas . draw points ( points f , paint ) ; } if ( first position < num ) { int offset = math . abs ( first position ) ; float [ ] points f = get array float ( points . sub list ( ( points number - num ) - offset , points number - num ) ) ; canvas . draw points ( points f , paint ) ; first position = num ; } float [ ] points f = get array float ( points . sub list ( first position , last position ) ) ; canvas . draw points ( points f , paint ) ; }	paint a line with a offset for right and left.
static string calculate nth percentile ( list < string > values , int n ) { string [ ] values arr = new string [ values . size ( ) ] ; values arr = values . to array ( values arr ) ; arrays . sort ( values arr ) ; int ordinal rank = ( int ) math . ceil ( n * values . size ( ) / num ) ; return values arr [ ordinal rank - num ] ; }	calculates nth percentile of a set of values using the nearest neighbor method .
private void bounds changed ( ) { if ( run later pending ) return ; run later pending = bool ; platform . run later ( null ) ; }	remembers the window bounds when the window is not iconified , maximized or in fullscreen .
public void clear ( ) { synchronized ( lock ) { file [ ] files = cache path . list files ( ) ; if ( files == null ) { return ; } for ( file file : files ) { remove file ( file ) ; } pending tasks . clear ( ) ; } }	gets rid of all pending commands .
@ nullable protected abstract url resolve test data ( string name ) ;	resolves a test data name relative to the root of all test data , returning a url to represent it .
public static boolean is full accessible field ( j field , j clazz ) { return field . is public ( ) || has get and set methods ( field , clazz ) ; }	verify if the given field is fully accessible .
public byte [ ] convert ( byte [ ] in buffer , int size ) { byte [ ] result = null ; if ( in buffer != null ) { drm converted status converted status = null ; try { if ( size != in buffer . length ) { byte [ ] buf = new byte [ size ] ; system . arraycopy ( in buffer , num , buf , num , size ) ; converted status = m drm client . convert data ( m convert session id , buf ) ; } else { converted status = m drm client . convert data ( m convert session id , in buffer ) ; } if ( converted status != null && converted status . status code == drm converted status . status ok && converted status . converted data != null ) { result = converted status . converted data ; } } catch ( illegal argument exception e ) { log . w ( tag , str + m convert session id , e ) ; } catch ( illegal state exception e ) { log . w ( tag , str + m convert session id , e ) ; } } else { throw new illegal argument exception ( str ) ; } return result ; }	convert a buffer of data to protected format .
public void simulate method ( soot method method , reference variable this var , reference variable return var , reference variable params [ ] ) { string sub signature = method . get sub signature ( ) ; if ( sub signature . equals ( str ) ) { java lang exec internal ( method , this var , return var , params ) ; return ; } else { default method ( method , this var , return var , params ) ; return ; } }	implements the abstract method simulatemethod.
@ deprecated private static void make js ( appendable writer , map < string , object > context , model form model form , string hidden form name ) throws io { list < model form field > row submit fields = model form . get multi submit fields ( ) ; if ( row submit fields != null ) { writer . append ( str ) ; writer . append ( str ) ; writer . append ( str + hidden form name + str ) ; writer . append ( str ) ; for ( model form field row submit field : row submit fields ) { writer . append ( str + row submit field . get current container id ( context ) + str ) ; writer . append ( str ) ; writer . append ( str ) ; make hidden fields for hidden form ( writer ) ; writer . append ( str ) ; writer . append ( str ) ; } writer . append ( str ) ; writer . append ( str ) ; writer . append ( str ) ; writer . append ( str ) ; writer . append ( str ) ; } }	scipio : creates js script to populate the target hidden form with the corresponding fields of the row that triggered the submission ( only when use - submit - row is false ).
private url create search url ( url url ) throws url { if ( url == null ) { return url ; } string protocol = url . get protocol ( ) ; if ( is directory ( url ) || protocol . equals ( str ) ) { return url ; } if ( factory == null ) { return new url ( str , str , - num , url . to string ( ) + str ) ; } return new url ( str , str , - num , url . to string ( ) + str , factory . create url ( str ) ) ; }	returns an url that will be checked if it contains the class or resource.
public final void tracked action ( core controller ) throws interrupted exception { long time = system . current time millis ( ) ; statistics . use now ( ) ; action ( controller ) ; time = system . current time millis ( ) - time ; statistics . update average execution time ( time ) ; }	perform the action and track the statistics related to this action .
private boolean translate ready ops ( int ops , int initial ops , selection key impl sk ) { int int ops = sk . nio interest ops ( ) ; int old ops = sk . nio ready ops ( ) ; int new ops = initial ops ; if ( ( ops & net . pollnval ) != num ) { return bool ; } if ( ( ops & ( net . pollerr | net . pollhup ) ) != num ) { new ops = int ops ; sk . nio ready ops ( new ops ) ; return ( new ops & ~ old ops ) != num ; } if ( ( ( ops & net . pollin ) != num ) && ( ( int ops & selection key . op read ) != num ) ) new ops |= selection key . op read ; if ( ( ( ops & net . pollout ) != num ) && ( ( int ops & selection key . op write ) != num ) ) new ops |= selection key . op write ; sk . nio ready ops ( new ops ) ; return ( new ops & ~ old ops ) != num ; }	translates native poll revent ops into a ready operation ops.
public executor env ( map < string , string > env ) { this . env = env ; return this ; }	sets the environment variables for the child process .
public static key pair create ec ( string name ) throws io { try { ec ec spec = new ec ( name ) ; key pair generator key gen = key pair generator . get instance ( str ) ; key gen . initialize ( ec spec , new secure random ( ) ) ; return key gen . generate key pair ( ) ; } catch ( no such algorithm exception | invalid algorithm parameter exception ex ) { throw new io ( ex ) ; } }	creates a random ecc key pair with the given curve name .
public void init ( boolean encrypting , cipher parameters params ) throws illegal argument exception { this . encrypting = encrypting ; if ( params instanceof iv ) { iv iv param = ( iv ) params ; byte [ ] iv = iv param . get iv ( ) ; if ( iv . length < iv . length ) { system . arraycopy ( iv , num , iv , iv . length - iv . length , iv . length ) ; for ( int i = num ; i < iv . length - iv . length ; i ++ ) { iv [ i ] = num ; } } else { system . arraycopy ( iv , num , iv , num , iv . length ) ; } reset ( ) ; if ( iv param . get parameters ( ) != null ) { cipher . init ( bool , iv param . get parameters ( ) ) ; } } else { reset ( ) ; if ( params != null ) { cipher . init ( bool , params ) ; } } }	initialise the cipher and , possibly , the initialisation vector ( iv ).
public static document load document ( input stream stream ) throws exception { document builder factory factory = document builder factory . new instance ( ) ; document builder builder = factory . new document builder ( ) ; return builder . parse ( stream ) ; }	loads a xml document from a stream and returns the corresponding dom document .
private int handle single nal unit packet ( buffer input , buffer output ) { byte [ ] buffer data = ( byte [ ] ) input . get data ( ) ; int buffer data length = buffer data . length ; byte [ ] data = new byte [ buffer data length ] ; system . arraycopy ( buffer data , num , data , num , buffer data length ) ; output . set data ( data ) ; output . set length ( data . length ) ; output . set offset ( num ) ; output . set time stamp ( input . get time stamp ( ) ) ; output . set sequence number ( input . get sequence number ( ) ) ; output . set video orientation ( input . get video orientation ( ) ) ; output . set format ( input . get format ( ) ) ; output . set flags ( input . get flags ( ) ) ; return buffer processed ok ; }	handle single nal unit packet.
public static < t > list < t > as list ( t ... values ) { if ( values == null ) { return new array list < t > ( num ) ; } else { return new array list < t > ( arrays . as list ( values ) ) ; } }	collects the passed in objects into a list .
void message received ( byte buffer buf ) throws ignite checked exception , ssl { if ( buf . limit ( ) > in net buf . remaining ( ) ) { in net buf = expand buffer ( in net buf , in net buf . capacity ( ) + buf . limit ( ) * num ) ; app buf = expand buffer ( app buf , in net buf . capacity ( ) * num ) ; if ( log . is debug enabled ( ) ) log . debug ( str + in net buf . capacity ( ) + str + app buf . capacity ( ) + str + ses + str ) ; } in net buf . put ( buf ) ; if ( ! handshake finished ) handshake ( ) ; else unwrap data ( ) ; if ( is inbound done ( ) ) { int new position = buf . position ( ) - in net buf . position ( ) ; if ( new position >= num ) { buf . position ( new position ) ; if ( buf . has remaining ( ) ) u . warn ( log , str + ses ) ; } in net buf . clear ( ) ; } }	called by ssl filter when new message was received .
public final object copy ( ) { dynamic int array copy = new dynamic int array ( m . length ) ; copy . m = m ; copy . m = m ; copy . m = m ; system . arraycopy ( m , num , copy . m , num , m ) ; return copy ; }	produces a copy of this vector .
public static int delete old sms ( ) { long olderthan = system . current time millis ( ) - old sms threshold ; return database . delete ( database open helper . sms table name , str + olderthan , null ) ; }	deletes sms from the database that are older then 5 days.
private static string encode metric filters ( string metric string , map < string , string > mapper ) { string final string = metric string ; int counter = num ; int start index = num ; int end index = num ; for ( int i = num ; i < metric string . length ( ) ; i ++ ) { char current char = metric string . char at ( i ) ; start index = ( current char == str && counter == num ) ? i : start index ; counter = ( current char == str ) ? counter + num : counter ; if ( current char == str ) { end index = i ; counter = counter - num ; } if ( counter == num && start index != num ) { string filter string = metric string . substring ( start index , end index + num ) ; final string = final string . replace ( filter string , str + start index ) ; mapper . put ( str + start index , filter string ) ; start index = num ; } } return final string ; }	returns modified metrics string.
private void finalize additions ( boolean add home screen shortcuts ) { finalize work folder ( ) ; if ( add home screen shortcuts && ! m homescreen apps . is empty ( ) ) { sort list ( m homescreen apps ) ; m model . add and bind added workspace items ( m context , m homescreen apps ) ; } }	adds and binds all shortcuts marked for addition .
private void stop checking status ( ) { executor . shutdown now ( ) ; executor = executors . new single thread executor ( ) ; future = null ; }	re - sets the executor and indicates the system is no longer checking the status of the transactions.
public void update notification ( int notification id ) { try { notification dao . open ( ) ; notification dao . update notification ( notification id , notification . status . dismissed ) ; } finally { notification dao . close ( ) ; } }	this method is used to update the notification which is stored in the embedded db .
public static element add child element ns ( element element , string child element name , string child element value , document document , string name space url ) { element new element = document . create element ns ( name space url , child element name ) ; new element . append child ( document . create text node ( child element value ) ) ; element . append child ( new element ) ; return element ; }	creates a child element with the given namespace supportive name and appends it to the element child node list.
public void add column listener ( column listener listener ) { m listeners . add ( listener ) ; }	adds a listener to be notified when this column changes.
public void load dataset ( url url , iri context , parser config config ) throws repository exception { try { long since = last modified . get ( url ) ; url url con = url . open connection ( ) ; if ( since != null ) { url con . set if modified since ( since ) ; } if ( since == null || since < url con . get last modified ( ) ) { load ( url , url con , context , config ) ; } } catch ( rdf e ) { throw new repository exception ( e ) ; } catch ( io e ) { throw new repository exception ( e ) ; } }	inspects if the dataset at the supplied url location has been modified since the last load into this repository and if so loads it into the supplied context .
protected int read ( input stream input stream , byte [ ] buffer , char [ ] divider ) throws io { int index = num ; int divider index = num ; do { byte read byte = ( byte ) ( num & input stream . read ( ) ) ; if ( read byte == - num ) { return index ; } if ( read byte == divider [ divider index ] ) { divider index ++ ; } if ( divider index == divider . length ) { index -= divider index - num ; for ( int i = index ; i < index + divider index ; i ++ ) { if ( i >= buffer . length ) { break ; } buffer [ i ] = num ; } return index ; } buffer [ index ] = read byte ; index ++ ; } while ( index < buffer . length ) ; return index ; }	reads bytes from a given file reader until either a specified character sequence is read , the buffer is completely filled or the end of file is reached .
public void test node document fragment normalize1 ( ) throws throwable { document doc ; document fragment doc fragment ; string node value ; text txt node ; node retval ; doc = ( document ) load ( str , builder ) ; doc fragment = doc . create document fragment ( ) ; txt node = doc . create text node ( str ) ; retval = doc fragment . append child ( txt node ) ; txt node = doc . create text node ( str ) ; retval = doc fragment . append child ( txt node ) ; doc fragment . normalize ( ) ; txt node = ( text ) doc fragment . get first child ( ) ; node value = txt node . get node value ( ) ; assert equals ( str , str , node value ) ; retval = txt node . get next sibling ( ) ; assert null ( str , retval ) ; }	runs the test case .
private void collect times ( tree tree , node ref node , set < node ref > exclude nodes below , intervals intervals ) { intervals . add coalescent event ( tree . get node height ( node ) ) ; for ( int i = num ; i < tree . get child count ( node ) ; i ++ ) { node ref child = tree . get child ( node , i ) ; boolean include = bool ; if ( exclude nodes below != null && exclude nodes below . contains ( child ) ) { include = bool ; } if ( ! include || tree . is external ( child ) ) { intervals . add sample event ( tree . get node height ( child ) ) ; } else { collect times ( tree , child , exclude nodes below , intervals ) ; } } }	extract coalescent times and tip information into arraylist times from tree .
public string body ( final string text , final string mime type , charset charset ) throws unsupported encoding exception { super ( mime type ) ; if ( text == null ) { throw new illegal argument exception ( str ) ; } if ( charset == null ) { charset = charset . for name ( http . utf 8 ) ; } this . content = text . get bytes ( charset . name ( ) ) ; this . charset = charset ; }	create a stringbody from the specified text , mime type and character set .
public void make immutable ( ) { mutable = bool ; if ( authn context class ref != null ) { authn context class ref = collections . unmodifiable list ( authn context class ref ) ; } if ( authn context decl ref != null ) { authn context decl ref = collections . unmodifiable list ( authn context decl ref ) ; } return ; }	makes the obejct immutable.
protected abstract int read skip data ( int level , index input skip stream ) throws io ;	subclasses must implement the actual skip data encoding in this method .
protected tams message poll message ( ) { if ( disable poll ) { return null ; } if ( ! poll queue . is empty ( ) ) { poll message pm = poll queue . peek ( ) ; if ( pm != null ) { tm = pm . get message ( ) ; return pm . get message ( ) ; } } return null ; }	check tams mc for status updates.
public path bin ( ) { return root . resolve ( str ) ; }	gets the bin directory .
public static void safe copy ( final reader reader , final writer writer ) throws io { try { io . copy ( reader , writer ) ; } finally { io . close quietly ( reader ) ; io . close quietly ( writer ) ; } }	copy and close the reader and writer streams .
public static < t extends bean > t load ( bson query , t t ) { string collection = get collection ( t . get class ( ) ) ; if ( collection != null ) { try { return load ( query , null , t ) ; } catch ( exception e ) { if ( log . is error enabled ( ) ) log . error ( e . get message ( ) , e ) ; } } return null ; }	load the data full into the t .
private print element create image element ( m item ) { object obj = m data . get node ( new integer ( item . get ad id ( ) ) ) ; if ( obj == null ) return null ; else if ( obj instanceof print data element ) ; else { log . log ( level . severe , str + obj . get class ( ) ) ; return null ; } print data element data = ( print data element ) obj ; if ( data . is null ( ) && item . is suppress null ( ) ) return null ; string url = data . get value display ( m format . get language ( ) ) ; if ( ( url == null || url . length ( ) == num ) ) { if ( item . is suppress null ( ) ) return null ; else return null ; } image element element = null ; if ( data . get display type ( ) == display type . image ) { element = image element . get ( data , url ) ; } else { element = image element . get ( url ) ; } return element ; }	create image element from item.
public void reset charges ( ) { pending charges . remove all elements ( ) ; }	resets the pending charges list .
static repaint manager current manager ( app context app context ) { repaint manager rm = ( repaint manager ) app context . get ( repaint manager key ) ; if ( rm == null ) { rm = new repaint manager ( buffer strategy type ) ; app context . put ( repaint manager key , rm ) ; } return rm ; }	returns the repaintmanager for the specified appcontext.
public int decrement ( ) { lock . lock ( ) ; int new value = -- value ; lock . unlock ( ) ; return new value ; }	decrements the counter by 1 .
private void add point ( point p ) { coordinate coord = p . get coordinate ( ) ; insert point ( arg index , coord , location . interior ) ; }	add a point to the graph .
public boolean is connectable ( ) { for ( device service service : services . values ( ) ) { if ( service . is connectable ( ) ) return bool ; } return bool ; }	whether the device has any deviceservices that require an active connection ( websocket , http registration , etc ).
private static void skip array ( byte buffer buf ) { int length = buf . get short ( ) & num ; for ( int i = num ; i < length ; i ++ ) skip member value ( buf ) ; }	skips the array value at the current position in the specified byte buffer.
public static byte [ ] hash ( byte [ ] input ) { if ( input != null ) { final message digest digest ; try { digest = message digest . get instance ( str ) ; byte [ ] hashed bytes = input ; digest . update ( hashed bytes , num , hashed bytes . length ) ; return hashed bytes ; } catch ( no such algorithm exception e ) { log . e ( tag , str + input + str + e . get message ( ) , e ) ; } } else { log . w ( tag , str ) ; } return null ; }	created sha256 of input.
private void reopen ( ) { timeline animation = new timeline ( new key frame ( duration . seconds ( num ) , new key value ( inputs . pref height property ( ) , inputs . get max height ( ) ) ) ) ; animation . play ( ) ; }	makes an animation to make the input vbox slide open over . 1 seconds.
private byte [ ] copy array ( byte [ ] buffer , int length ) { byte [ ] result = new byte [ length ] ; system . arraycopy ( buffer , num , result , num , math . min ( buffer . length , length ) ) ; return result ; }	implement java . util . arrays . copyof ( ) for jdk 1 . 5 .
public static map < string , object > test soap ( dispatch context dctx , map < string , ? > context ) { delegator delegator = dctx . get delegator ( ) ; map < string , object > response = service util . return success ( ) ; list < generic value > testing nodes = new linked list < generic value > ( ) ; for ( int i = num ; i < num ; i ++ ) { generic value testing node = delegator . make value ( str ) ; testing node . put ( str , str + i ) ; testing node . put ( str , str + i ) ; testing node . put ( str , util date time . now timestamp ( ) ) ; testing nodes . add ( testing node ) ; } response . put ( str , testing nodes ) ; return response ; }	generic test soap service.
public xml dom ( input stream is ) throws sax { document builder factory factory = document builder factory . new instance ( ) ; document builder builder ; try { builder = factory . new document builder ( ) ; document doc = builder . parse ( is ) ; this . root = ( element ) doc . get document element ( ) ; } catch ( parser configuration exception e ) { } catch ( io e ) { throw new sax ( e ) ; } }	instantiates a new xml dom .
public void remove key listener ( global key listener listener ) { listeners . remove ( listener ) ; }	removes a global key listener.
public set search3 ( string token id , string start dn , string filter , int num of entries , int time limit , boolean sort results , boolean ascending order , set excludes ) throws sms , sso , remote exception { initialize ( ) ; if ( debug . message enabled ( ) ) { debug . message ( str + start dn + str + filter + str + excludes ) ; } iterator i = sms . search ( get token ( token id ) , start dn , filter , num of entries , time limit , sort results , ascending order , excludes ) ; set < string > result = new hash set < string > ( ) ; while ( i . has next ( ) ) { sms e = ( sms ) i . next ( ) ; try { result . add ( e . to json ( ) ) ; } catch ( json ex ) { debug . error ( str + start dn + str + filter + str + excludes , ex ) ; } } return result ; }	searches the data store for objects that match the filter with an exclude set.
public boolean remove entry ( int x index , int data set index ) { if ( data set index >= m data sets . size ( ) ) return bool ; t data set = m data sets . get ( data set index ) ; entry e = data set . get entry for x ( x index ) ; if ( e == null || e . get x ( ) != x index ) return bool ; return remove entry ( e , data set index ) ; }	removes the entry object at the given xindex from the dataset at the specified index.
void close stream ( closeable closeable ) { try { if ( closeable != null ) { closeable . close ( ) ; } } catch ( io ex ) { utils . log issue ( str , ex ) ; } }	attempt to close given fileinputstream.
public void test from date ( ) throws exception { time zone . set default ( time zone . get time zone ( str ) ) ; final calendar date = calendar . get instance ( ) ; date . set time ( new date ( num ) ) ; assert . assert equals ( str , calendar serializer . serialize ( date ) ) ; final calendar date no millis = calendar . get instance ( ) ; date no millis . set time ( new date ( num ) ) ; assert . assert equals ( str , calendar serializer . serialize ( date no millis ) ) ; }	make sure that dates with and without millis can be converted properly into strings.
@ override public boolean e is set ( int feature id ) { switch ( feature id ) { case eip package . metadata key : return key edefault == null ? key != null : ! key edefault . equals ( key ) ; case eip package . metadata values : return values != null && ! values . is empty ( ) ; } return super . e is set ( feature id ) ; }	< ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
@ override public boolean is modified ( ) { if ( is digest modified ) { if ( log . is loggable ( level . fine ) ) log . fine ( source . get native path ( ) + str ) ; return bool ; } long source last modified = source . get last modified ( ) ; long source length = source . length ( ) ; if ( ! require source && source last modified == num ) { return bool ; } else if ( source length != length ) { if ( log . is loggable ( level . fine ) ) { log . fine ( source . get native path ( ) + str + length + str + source length + str ) ; } return bool ; } else if ( source last modified != last modified ) { if ( log . is loggable ( level . fine ) ) log . fine ( source . get native path ( ) + str ) ; return bool ; } else return bool ; }	if the source modified date changes at all , treat it as a modification.
public byte [ ] to byte array ( ) { int total len = past len + curr block ptr ; if ( total len == num ) { return no bytes ; } byte [ ] result = new byte [ total len ] ; int offset = num ; for ( byte [ ] block : past blocks ) { int len = block . length ; system . arraycopy ( block , num , result , offset , len ) ; offset += len ; } system . arraycopy ( curr block , num , result , offset , curr block ptr ) ; offset += curr block ptr ; if ( offset != total len ) { throw new runtime exception ( str + total len + str + offset + str ) ; } if ( ! past blocks . is empty ( ) ) { reset ( ) ; } return result ; }	method called when results are finalized and we can get the full aggregated result buffer to return to the caller.
public static < m extends message > string write json stream ( immutable list < m > messages ) { byte array output stream result stream = new byte array output stream ( ) ; message writer < m > writer = message writer . create ( output . for stream ( new print stream ( result stream ) ) ) ; writer . write all ( messages ) ; return result stream . to string ( ) ; }	returns the string representation of the stream of supplied messages.
public org . smpte ra . schemas . st2067 2 2016 . content maturity rating type build content maturity rating type ( string agency , string rating , org . smpte ra . schemas . st2067 2 2016 . content maturity rating type . audience audience ) throws uri { org . smpte ra . schemas . st2067 2 2016 . content maturity rating type content maturity rating type = new org . smpte ra . schemas . st2067 2 2016 . content maturity rating type ( ) ; if ( ! agency . matches ( str ) == bool ) { throw new uri ( str , str ) ; } content maturity rating type . set agency ( agency ) ; content maturity rating type . set rating ( rating ) ; content maturity rating type . set audience ( audience ) ; return content maturity rating type ; }	a method to construct a contentmaturityratingtype conforming to the 2016 schema.
protected as ( as v ) { for ( int i = num ; i != v . size ( ) ; i ++ ) { seq . add element ( v . get ( i ) ) ; } }	create a sequence containing a vector of objects .
private final double read datum ( final data input in , final column type column type ) throws io { switch ( column type ) { case double : return in . read double ( ) ; case integer : int i value = in . read int ( ) ; if ( i value == integer . min value + num ) { boolean is missing = in . read boolean ( ) ; if ( is missing ) { return double . n ; } else { return i value ; } } else { return i value ; } case nominal byte : byte b value = in . read byte ( ) ; if ( b value == - num ) { return double . n ; } else { return b value ; } case nominal integer : i value = in . read int ( ) ; if ( i value == - num ) { return double . n ; } else { return i value ; } case nominal short : short s value = in . read short ( ) ; if ( s value == - num ) { return double . n ; } else { return s value ; } default : throw new runtime exception ( str + column type ) ; } }	reads a single datum in non - sparse representation of the given type and returns it as a double .
protected void close transport layer ( ) throws io { super . close ( ) ; if ( input != null ) { input . close ( ) ; output . close ( ) ; } }	closes the transport data streams .
public double op ( final double x ) { final double sn = math . sin ( this . asr * ( - x + num ) * num ) ; return math . exp ( ( sn * hk - hs ) / ( num - sn * sn ) ) ; }	computes equation 3 , see references.
public void listen ( stanza listener stanza listener , stanza filter stanza filter ) { connection . add async stanza listener ( stanza listener , stanza filter ) ; logger . info ( str ) ; }	begin listening for incoming messages .
public static void add input mode ( string name , hashtable values , boolean first upcase ) { init input modes ( ) ; input modes . put ( name , values ) ; if ( first upcase ) { first uppercase input mode . add element ( name ) ; } }	adds a new inputmode hashtable with the given name and set of values.
@ override public void add env var updated listener ( env var update interface listener ) { if ( ! listener list . contains ( listener ) ) { listener list . add ( listener ) ; } }	adds the env var updated listener .
private void init ( configuration exp ) throws io { is initialized = bool ; }	private initializer method that sets up the generic resources .
public list < local variable > visible variables ( ) throws absent information exception { validate stack frame ( ) ; create visible variables ( ) ; list < local variable > map as list = new array list < local variable > ( visible variables . values ( ) ) ; collections . sort ( map as list ) ; return map as list ; }	return the list of visible variable in the frame.
public static void start services ( service host host , class ... services ) throws instantiation exception , illegal access exception { check argument ( services != null , str ) ; for ( class service : services ) { start service ( host , service ) ; } }	starts the list of services on the host .
private applied migration create applied migration ( int version , string description ) { return new applied migration ( version , version , migration version . from version ( integer . to string ( version ) ) , description , migration type . cql , str , null , new date ( ) , str , num , bool ) ; }	creates a new applied migration with this version .
template entry next entry ( ) { if ( ! has next ( ) ) { throw new no such element exception ( ) ; } final template entry entry = next entry ; next entry = null ; return entry ; }	returns the next generated entry .
private void create record holder queue ( file [ ] list files ) { this . record holder heap = new priority queue < sort temp file chunk holder > ( list files . length ) ; }	this method will be used to create the heap which will be used to hold the chunk of data.
public static double correlation ( double [ ] x , double [ ] y ) { if ( x . length == y . length ) { double mx = math utils . mean ( x ) ; double my = math utils . mean ( y ) ; double sx = math . sqrt ( math utils . variance ( x ) ) ; double sy = math . sqrt ( math utils . variance ( y ) ) ; int n = x . length ; double nval = num ; for ( int i = num ; i < n ; i ++ ) { nval += ( x [ i ] - mx ) * ( y [ i ] - my ) ; } double r = nval / ( ( n - num ) * sx * sy ) ; return r ; } else throw new illegal argument exception ( str ) ; }	sample correlation coefficient ref : http : / / en.
public static int write message fully ( message msg , output stream out , byte buffer buf , message writer writer ) throws io { assert msg != null ; assert out != null ; assert buf != null ; assert buf . has array ( ) ; if ( writer != null ) writer . set current write class ( msg . get class ( ) ) ; boolean finished = bool ; int cnt = num ; while ( ! finished ) { finished = msg . write to ( buf , writer ) ; out . write ( buf . array ( ) , num , buf . position ( ) ) ; cnt += buf . position ( ) ; buf . clear ( ) ; } return cnt ; }	fully writes communication message to provided stream .
protected final void drag exit ( final int x , final int y ) { drag source event event = new drag source event ( get drag source context ( ) , x , y ) ; event dispatcher dispatcher = new event dispatcher ( dispatch exit , event ) ; sun toolkit . invoke later on app context ( sun toolkit . target to app context ( get component ( ) ) , dispatcher ) ; start secondary event loop ( ) ; }	upcall from native code.
public static string generate random string ( int count ) { random random = new random ( ) ; string buffer buffer = new string buffer ( ) ; while ( count -- != num ) { char ch = ( char ) ( random . next int ( num ) + num ) ; buffer . append ( ch ) ; } return buffer . to string ( ) ; }	generate a random string.
public void decrement ( ) { int counter val = counter . decrement and get ( ) ; if ( counter val == num ) { if ( null != resource callback ) { resource callback . on transition to idle ( ) ; } became idle at = system clock . uptime millis ( ) ; } if ( debug counting ) { if ( counter val == num ) { log . i ( tag , str + resource name + str + ( became idle at - became busy at ) + str ) ; } else { log . i ( tag , str + resource name + str + counter val ) ; } } if ( counter val < num ) { throw new illegal argument exception ( str ) ; } }	decrements the count of in - flight transactions to the resource being monitored.
public void remove testing callback ( one sheeld testing callback testing callback ) { if ( testing callback != null && testing callbacks . contains ( testing callback ) ) testing callbacks . remove ( testing callback ) ; }	remove a testing callback .
public boolean should data be routed ( simple router context context , data meta data data meta data , node node , boolean initial load , boolean initial load select used , trigger router trigger router ) { i router = get data router ( data meta data . get router ( ) ) ; set < node > one node set = new hash set < node > ( num ) ; one node set . add ( node ) ; collection < string > node ids = router . route to nodes ( context , data meta data , one node set , initial load , initial load select used , trigger router ) ; return node ids != null && node ids . contains ( node . get node id ( ) ) ; }	for use in data load events.
@ override public object put ( object key , object value ) { entry tab [ ] = table ; int hash = num ; int index = num ; if ( key != null ) { hash = system . identity hash code ( key ) ; index = ( hash & num ) % tab . length ; for ( entry e = tab [ index ] ; e != null ; e = e . next ) { if ( ( e . hash == hash ) && key == e . key ) { object old = e . value ; e . value = value ; return old ; } } } else { for ( entry e = tab [ num ] ; e != null ; e = e . next ) { if ( e . key == null ) { object old = e . value ; e . value = value ; return old ; } } } mod count ++ ; if ( count >= threshold ) { rehash ( ) ; tab = table ; index = ( hash & num ) % tab . length ; } entry e = new entry ( hash , key , value , tab [ index ] ) ; tab [ index ] = e ; count ++ ; return null ; }	associates the specified value with the specified key in this map.
public static string back quote chars ( string string , char [ ] find , string [ ] replace ) { int index ; string builder new str ; int i ; if ( string == null ) return string ; for ( i = num ; i < find . length ; i ++ ) { if ( string . index of ( find [ i ] ) != - num ) { new str = new string builder ( ) ; while ( ( index = string . index of ( find [ i ] ) ) != - num ) { if ( index > num ) new str . append ( string . substring ( num , index ) ) ; new str . append ( replace [ i ] ) ; if ( ( index + num ) < string . length ( ) ) string = string . substring ( index + num ) ; else string = str ; } new str . append ( string ) ; string = new str . to string ( ) ; } } return string ; }	converts specified characters into the string equivalents .
public void test bit length negative2 ( ) { byte a bytes [ ] = { - num , num , num , - num , - num , num , num , num , num , - num , num , num } ; int a sign = - num ; big integer a number = new big integer ( a sign , a bytes ) ; assert equals ( num , a number . bit length ( ) ) ; }	bitlength ( ) of a negative number with the leftmost bit set.
public void add language ( execution language language ) { languages . add ( num , language ) ; }	registers a new executionlanguage to the registry .
private static boolean member equals ( final class < ? > type , final object o1 , final object o2 ) { if ( o1 == o2 ) { return bool ; } if ( o1 == null || o2 == null ) { return bool ; } if ( type . is array ( ) ) { return array member equals ( type . get component type ( ) , o1 , o2 ) ; } if ( type . is annotation ( ) ) { return equals ( ( annotation ) o1 , ( annotation ) o2 ) ; } return o1 . equals ( o2 ) ; }	helper method for checking whether two objects of the given type are equal.
public encoding ( string name ) { this . name = name ; }	constructs a new encoding .
public string write long to string ( ) { string builder builder = new string builder ( ) ; for ( int i = num ; i < ( bit set . get bits ( ) . length ) ; ++ i ) { builder . append ( long . to string ( bit set . get bits ( ) [ i ] ) + str ) ; } return builder . to string ( ) ; }	writes vector to a string of the form 010 etc.
@ override public void committed ( long committed window id ) throws io { log . debug ( str , committed window id ) ; for ( long current window : saved windows . key set ( ) ) { if ( current window <= largest window added to transfer queue ) { continue ; } if ( current window <= committed window id ) { log . debug ( str , current window ) ; largest window added to transfer queue = current window ; windows to transfer . add ( current window ) ; } else { break ; } } }	transfers the data which has been committed till windowid to data files .
public void delete ( random access file raf , random access file temp raf ) throws cannot read exception , cannot write exception , io { raf . seek ( num ) ; temp raf . seek ( num ) ; delete tag ( raf , temp raf ) ; }	delete the tag ( if any ) present in the given randomaccessfile , and do not close it at the end .
void on deferred end drag ( drag view drag view ) { drag view . remove ( ) ; if ( m drag object . defer drag view cleanup post animation ) { for ( drag listener listener : new array list < > ( m listeners ) ) { listener . on drag end ( ) ; } } }	this only gets called as a result of drag view cleanup being deferred in enddrag ( ) ;.
private byte [ ] page to byte array ( p page ) { try { if ( page == null ) { byte array output stream baos = new byte array output stream ( ) ; object output stream oos = new object output stream ( baos ) ; oos . write int ( empty page ) ; oos . close ( ) ; baos . close ( ) ; byte [ ] array = baos . to byte array ( ) ; byte [ ] result = new byte [ page size ] ; system . arraycopy ( array , num , result , num , array . length ) ; return result ; } else { byte array output stream baos = new byte array output stream ( ) ; object output stream oos = new object output stream ( baos ) ; oos . write int ( filled page ) ; page . write external ( oos ) ; oos . close ( ) ; baos . close ( ) ; byte [ ] array = baos . to byte array ( ) ; if ( array . length > this . page size ) { throw new illegal argument exception ( str + page + str + str + array . length + str + page size ) ; } else if ( array . length == this . page size ) { return array ; } else { byte [ ] result = new byte [ page size ] ; system . arraycopy ( array , num , result , num , array . length ) ; return result ; } } } catch ( io e ) { throw new runtime exception ( str , e ) ; } }	serializes an object into a byte array .
void present decor animations ( int position , float offset ) { int anim map size = m decor animations . size ( ) ; for ( int i = num ; i < anim map size ; i ++ ) { decor decor = m decor animations . key at ( i ) ; array list < animation > animations = m decor animations . get ( decor ) ; int anim list size = animations . size ( ) ; for ( int j = num ; j < anim list size ; j ++ ) { animation animation = animations . get ( j ) ; if ( animation == null ) { continue ; } if ( ! animation . should animate ( position ) ) { if ( m previous position < position && animation . page end < position ) { animation . animate ( decor . content view , num , num , position ) ; } else if ( m previous position > position && animation . page start > position ) { animation . animate ( decor . content view , num , num , position ) ; } continue ; } animation . animate ( decor . content view , offset , num , position ) ; } } m previous position = position ; }	run the animations based on the decor animations saved within the presenter and the offset of the scrolling .
public static boolean deltree ( file directory ) { if ( directory == null || ! directory . exists ( ) ) { return bool ; } boolean result = bool ; if ( directory . is file ( ) ) { result = directory . delete ( ) ; } else { file [ ] list = directory . list files ( ) ; for ( int i = list . length ; i -- > num ; ) { if ( ! deltree ( list [ i ] ) ) { result = bool ; } } if ( ! directory . delete ( ) ) { result = bool ; } } return result ; }	deletes the given file and everything under it .
public void invalidate ( long new file size ) { if ( new file size < file size ) { file size = new file size ; counters . clear ( ) ; block size = calc block size ( file size ) ; } else if ( new file size > file size ) compact ( new file size ) ; }	check if counters and blocksize should be adjusted according to file size .
public void add case ( switch case switch case ) { assert not null ( switch case ) ; if ( cases == null ) { cases = new array list < switch case > ( ) ; } cases . add ( switch case ) ; switch case . set parent ( this ) ; }	adds a switch case statement to the end of the list .
public void test atomic append full block ( ) throws io { final string id = str ; final int version = num ; random r = new random ( ) ; final byte [ ] expected = new byte [ block size ] ; r . next bytes ( expected ) ; final long block0 = repo . append block ( id , version , expected , num , expected . length ) ; assert equals ( str , num , block0 ) ; assert equals ( str , num , repo . get block count ( id , version ) ) ; assert equals ( str , expected , repo . read block ( id , version , block0 ) ) ; assert equals ( str , expected , read ( repo . input stream ( id , version ) ) ) ; }	atomic append of a full block .
public static int hash ( byte [ ] data , int offset , int length , int seed ) { return hash ( byte buffer . wrap ( data , offset , length ) , seed ) ; }	hashes bytes in part of an array .
public static boolean is file exist ( string file path , file type file type ) throws io { file path = file path . replace ( str , str ) ; switch ( file type ) { case hdfs : case viewfs : path path = new path ( file path ) ; file system fs = path . get file system ( configuration ) ; return fs . exists ( path ) ; case local : default : file default file = new file ( file path ) ; return default file . exists ( ) ; } }	this method checks the given path exists or not and also is it file or not if the performfilecheck is true.
private void check qop support ( byte [ ] qop in challenge , byte [ ] ciphers in challenge ) throws io { string qop options ; if ( qop in challenge == null ) { qop options = str ; } else { qop options = new string ( qop in challenge , encoding ) ; } string [ ] server qop tokens = new string [ num ] ; byte [ ] server qop = parse qop ( qop options , server qop tokens , bool ) ; byte server all qop = combine masks ( server qop ) ; switch ( find preferred mask ( server all qop , qop ) ) { case num : throw new sasl exception ( str + str ) ; case no protection : negotiated qop = str ; break ; case integrity only protection : negotiated qop = str ; integrity = bool ; raw send size = send max buf size - num ; break ; case privacy protection : negotiated qop = str ; privacy = integrity = bool ; raw send size = send max buf size - num ; check strength support ( ciphers in challenge ) ; break ; } if ( logger . is loggable ( level . fine ) ) { logger . log ( level . fine , str , new integer ( raw send size ) ) ; } }	parses the ' qop ' directive.
public void close ( boolean p close underlying ) throws io { if ( closed ) { return ; } if ( p close underlying ) { closed = bool ; input . close ( ) ; } else { for ( ; ; ) { int av = available ( ) ; if ( av == num ) { av = make available ( ) ; if ( av == num ) { break ; } } long skip = skip ( av ) ; if ( skip != av ) { if ( log . is debug enabled ( ) ) { log . debug ( skip + str ) ; } } } } closed = bool ; }	closes the input stream .
protected void add new event ( object event key , t event ) { if ( unwritten events == null ) { unwritten events = maps . new hash map ( ) ; } list < t > list events = unwritten events . get ( event key ) ; if ( list events == null ) { unwritten events . put ( event key , lists . new array list ( event ) ) ; } else { list events . add ( event ) ; } }	add the given event into the unwritternevents map.
public static locale locale from string ( final string locale as string ) { if ( string utils . is blank ( locale as string ) ) { final list < api parameter error > data validation errors = new array list < > ( ) ; final api parameter error error = api parameter error . parameter error ( str , str , str ) ; data validation errors . add ( error ) ; throw new platform api data validation exception ( str , str , data validation errors ) ; } string language code = str ; string country code = str ; string variant code = str ; final string [ ] locale parts = locale as string . split ( str ) ; if ( locale parts != null && locale parts . length == num ) { language code = locale parts [ num ] ; } if ( locale parts != null && locale parts . length == num ) { language code = locale parts [ num ] ; country code = locale parts [ num ] ; } if ( locale parts != null && locale parts . length == num ) { language code = locale parts [ num ] ; country code = locale parts [ num ] ; variant code = locale parts [ num ] ; } return locale from ( language code , country code , variant code ) ; }	todo : vishwas move all locale related code to a separate utils class.
protected object decode response ( input stream input stream , string content type ) throws io { object value ; if ( content type . starts with ( json mime type ) ) { json decoder = new json ( ) ; value = decoder . read value ( input stream ) ; } else if ( content type . starts with ( text mime type prefix ) ) { text decoder decoder = new text decoder ( ) ; value = decoder . read value ( input stream ) ; } else { value = null ; } return value ; }	decodes a response value .
public static void load module ( final j tree , final i module ) { preconditions . check not null ( tree , str ) ; preconditions . check not null ( module , str ) ; load module threaded ( swing utilities . get window ancestor ( tree ) , module , tree ) ; }	loads a module while showing a progress dialog .
public boolean evaluate ( feature class info fci , int row ) { boolean ret = bool ; string buffer reasoning = null ; if ( logger . is loggable ( level . fine ) ) { reasoning = new string buffer ( ) ; } if ( exp != null ) { ret = exp . evaluate ( fci , row , reasoning ) ; } if ( reasoning != null ) { reasoning . append ( str ) ; logger . fine ( reasoning . to string ( ) ) ; } return ret ; }	does the feature in row of fci pass the conditions of this expression .
public void add functional instrumentation ( special instrumentation point functional instrumentation ) { if ( null == functional instrumentations ) { functional instrumentations = new hash set < special instrumentation point > ( num ) ; } functional instrumentations . add ( functional instrumentation ) ; }	adds functional instrumentation point .
public final list < integer > execute int list query ( string sql ) throws ade exception { return special sql queries . execute int list query ( sql , m connection ) ; }	executes a query that is expected to returned a column of integers .
@ api operation ( value = str ) @ request mapping ( value = str , method = request method . post ) @ response status ( http status . no content ) @ response body public final void post uninstall ( ) { uninstall impl ( get symmetric engine ( ) ) ; }	uninstalls all symmetricds objects from the given node ( database ) for the single engine on the node.
public boolean one outgoing transition leaves composite with exit actions ( state state ) { set < state > source parent states = new hash set < state > ( get parent states ( state ) ) ; for ( transition transition : state . get outgoing transitions ( ) ) { set < state > target parent states = get parent states ( transition . get target ( ) ) ; set < state > crossed states = new hash set < state > ( source parent states ) ; crossed states . remove all ( target parent states ) ; for ( state crossed composite state : crossed states ) { if ( has exit action ( crossed composite state ) ) return bool ; } } return bool ; }	checks if at least one of the outgoing transitions of the specified state leaves a parent composite of this state which has exit actions .
@ override public int read ( ) throws io { int x = in . read ( ) ; if ( x != - num ) { check . update ( x ) ; } return x ; }	reads one byte of data from the underlying input stream and updates the checksum with the byte data .
public static boolean remove table ( table t ) { try { table list . remove ( t ) ; } catch ( exception e ) { return bool ; } return bool ; }	remove the a table .
public plot add ( string label , population population , int x , int y ) { list < number > xs = new array list < number > ( ) ; list < number > ys = new array list < number > ( ) ; for ( solution solution : population ) { if ( ! solution . violates constraints ( ) ) { xs . add ( solution . get objective ( x ) ) ; ys . add ( solution . get objective ( y ) ) ; } } scatter ( label , xs , ys ) ; set labels if blank ( str + ( x + num ) , str + ( y + num ) ) ; return this ; }	displays the solutions in the given population in a 2d scatter plot.
private void initialize neighborhoods ( ) { list < individual > sorted population = new array list < individual > ( population ) ; for ( individual individual : population ) { collections . sort ( sorted population , new weight sorter ( individual ) ) ; for ( int i = num ; i < neighborhood size ; i ++ ) { individual . add neighbor ( sorted population . get ( i ) ) ; } } }	constructs the neighborhoods for all individuals in the population based on the distances between weights .
public void print ( boolean x ) { out . print ( x ) ; out . flush ( ) ; }	prints a boolean to this output stream and flushes this output stream .
public final boolean remove element ( int s ) { for ( int i = num ; i < m first free ; i ++ ) { if ( m map [ i ] == s ) { if ( ( i + num ) < m first free ) system . arraycopy ( m map , i + num , m map , i - num , m first free - i ) ; else m map [ i ] = java . lang . integer . min value ; m first free -- ; return bool ; } } return bool ; }	removes the first occurrence of the argument from this vector.
public vn restore lun group snap ( string snap id , vn restore param ) throws vn { string builder url builder = new string builder ( url instance ) ; url builder . append ( snap id ) ; url builder . append ( url restore ) ; url = url builder . to string ( ) ; return post request async ( restore param ) ; }	restore lun group snapshot.
public haskell catalog ( ) { this ( haskell catalog . xml path ) ; }	constructs a haskell catalog using the default file location .
public class factory ( file dir , class loader parent ) { super ( parent ) ; this . output = dir ; dir . mkdirs ( ) ; }	create a given class factory with the given class loader .
static boolean is same column ( constraint widget a , constraint widget b ) { return math . max ( a . get x ( ) , b . get x ( ) ) < math . min ( a . get x ( ) + a . get width ( ) , b . get x ( ) + b . get width ( ) ) ; }	are the two widgets in the same vertical area.
public boolean is existing command ( ) { return ( ! name . equals ( command tag handle . cmd unknown ) ) ; }	check whether the present commandtaghandle object represents a commandtag that exists on the server.
@ suppress warnings ( str ) protected void stop classifier ( ) { if ( m != null ) { m . interrupt ( ) ; m . stop ( ) ; } }	stops the currently running classifier ( if any ) .
private void sleep ( long sleeptime ) { try { thread . sleep ( sleeptime ) ; } catch ( interrupted exception e ) { } }	make the current thread sleep .
protected void build panels ( ) { key panels . clear ( ) ; in scroll pane . remove all ( ) ; for ( string key : order ) { string name = names . get ( key ) ; if ( name != null ) { string value = values . get property ( key ) ; key panel key panel = new key panel ( name , value ) ; key panel . set alignment x ( left alignment ) ; key panel . set maximum size ( gui size ) ; in scroll pane . add ( key panel ) ; key panels . put ( key , key panel ) ; } else { special setting special = specials . get ( key ) ; special . set alignment x ( left alignment ) ; in scroll pane . add ( special ) ; } } }	creates all key panels and special settings that have been registered .
public void load data string from file ( string s filename , boolean clear current data , string s encoding ) { try { byte array output stream bs out = new byte array output stream ( ) ; file input stream fi in = new file input stream ( s filename ) ; int i data = num ; while ( ( i data = fi in . read ( ) ) > - num ) bs out . write ( i data ) ; string s data string = bs out . to string ( ) ; set data string ( s data string , n , clear current data ) ; } catch ( io ioe ) { ioe . print stack trace ( ) ; set data string ( str , num , bool ) ; } }	loads the contents of a file as the datastring .
public final char next char ( char sequence csq ) { return csq . char at ( index ++ ) ; }	returns the next character at this cursor position.
private long drag started ago ( ) { if ( drag started == num ) { return - num ; } return system . current time millis ( ) - drag started ; }	returns the time in milliseconds how long ago the current drag started .
public date time zone builder add cutover ( int year , char mode , int month of year , int day of month , int day of week , boolean advance day of week , int millis of day ) { if ( i rule sets . size ( ) > num ) { of year of year = new of year ( mode , month of year , day of month , day of week , advance day of week , millis of day ) ; rule set last rule set = i rule sets . get ( i rule sets . size ( ) - num ) ; last rule set . set upper limit ( year , of year ) ; } i rule sets . add ( new rule set ( ) ) ; return this ; }	adds a cutover for added rules.
private boolean is null setting ( boolean make dest , mapping type mtd , mapping type mts , string builder result ) { if ( make dest && ( mtd == all fields || mtd == only valued fields ) && mts == only null fields ) { result . append ( str + string of set destination + str + new line ) ; return bool ; } return bool ; }	if it is a null setting returns the null mapping.
protected void find and init ( iterator it ) { while ( it . has next ( ) ) { find and init ( it . next ( ) ) ; } }	called when the menubar is a part of a beancontext , and it is added to the beancontext , or while other objects are added to the beancontext after that .
private boolean should emit typedef by name ( js real type ) { return real type . is record type ( ) || real type . is templatized type ( ) || real type . is function type ( ) ; }	whether the typedef should be emitted by name or by the type it is defining.
public static node select single node ( node context node , string str , node namespace node ) throws transformer exception { node iterator nl = select node iterator ( context node , str , namespace node ) ; return nl . next node ( ) ; }	use an xpath string to select a single node.
public static array list to array trim ( string list , string delimiter , int [ ] info ) { if ( delimiter . length ( ) == num ) return list to array trim ( list , delimiter . char at ( num ) , info ) ; if ( list . length ( ) == num ) return new array impl ( ) ; char [ ] del = delimiter . to char array ( ) ; char c ; outer : while ( list . length ( ) > num ) { c = list . char at ( num ) ; for ( int i = num ; i < del . length ; i ++ ) { if ( c == del [ i ] ) { info [ num ] ++ ; list = list . substring ( num ) ; continue outer ; } } break ; } int len ; outer : while ( list . length ( ) > num ) { c = list . char at ( list . length ( ) - num ) ; for ( int i = num ; i < del . length ; i ++ ) { if ( c == del [ i ] ) { info [ num ] ++ ; len = list . length ( ) ; list = list . substring ( num , len - num < num ? num : len - num ) ; continue outer ; } } break ; } return list to array ( list , delimiter ) ; }	casts a list to array object , remove all empty items at start and end of the list and store count to info.
public big integer calculate client evidence message ( ) throws crypto exception { if ( ( this . a == null ) || ( this . b == null ) || ( this . s == null ) ) { throw new crypto exception ( str + str ) ; } this . m1 = sr . calculate m1 ( digest , n , a , b , s ) ; return m1 ; }	computes the client evidence message m1 using the previously received values.
public void remove arguments ( string label ) { list < pb > remove = new array list < > ( ) ; for ( pb arg : l arguments ) { if ( arg . is label ( label ) ) remove . add ( arg ) ; } l arguments . remove all ( remove ) ; }	removes all argument with the specific label .
public pos ( string view name , string json ) { this . view name = view name ; this . counter = pos . read ( json ) ; }	construct the feature extractor given a trained counter in json format .
public static boolean ends with ignore case ( string src , string sub s ) { string sub = sub s . to lower case ( ) ; int sublen = sub . length ( ) ; int j = num ; int i = src . length ( ) - sublen ; if ( i < num ) { return bool ; } while ( j < sublen ) { char source = character . to lower case ( src . char at ( i ) ) ; if ( sub . char at ( j ) != source ) { return bool ; } j ++ ; i ++ ; } return bool ; }	tests if this string ends with the specified suffix .
private void prefix search ( string query ) { m cur node = m trie . find ( query ) ; if ( m cur node != null ) { iterator iter = trie iterator ( ) ; while ( iter . has next ( ) ) add internal ( ( tuple ) iter . next ( ) ) ; } }	issues a prefix search and collects the results.
private void send stage progress patch ( com . vmware . xenon . common . task state . task stage stage ) { service utils . log info ( this , str , stage ) ; task utils . send self patch ( this , build patch ( stage , null ) ) ; }	this method sends a patch operation to the current service instance to move to a new state .
@ nullable protected abstract object extract parameter ( @ nullable string cache name , string type name , type kind type kind , string field name , object obj ) throws cache exception ;	get field value from object for use as query parameter .
public static boolean is viewable value ( object value ) { if ( value instanceof composite data || value instanceof tabular data ) { return bool ; } if ( value instanceof composite data [ ] || value instanceof tabular data [ ] ) { return array . get length ( value ) > num ; } if ( value instanceof collection ) { collection < ? > c = ( collection < ? > ) value ; if ( c . is empty ( ) ) { return bool ; } else { return utils . is uniform collection ( c , composite data . class ) || utils . is uniform collection ( c , tabular data . class ) ; } } return bool ; }	the supplied value is viewable iff : - it ' s a compositedata / tabulardata , or - it ' s a non - empty array of compositedata / tabulardata , or - it ' s a non - empty collection of compositedata / tabulardata .
@ override public void reset ( ) throws io { f input stream . reset ( ) ; }	reset the stream . if the stream has been marked , then attempt to reposition it at the mark . if the stream has not been marked , then attempt to reset it in some way appropriate to the particular stream , for example by repositioning it to its starting point . not all character - input streams support the reset ( ) operation , and some support reset ( ) without supporting mark ( ) .
public byte [ ] encode ( ) { char type = get attribute type ( ) ; byte bin value [ ] = new byte [ header length + get data length ( ) + ( num - get data length ( ) % num ) % num ] ; bin value [ num ] = ( byte ) ( type > > num ) ; bin value [ num ] = ( byte ) ( type & num ) ; bin value [ num ] = ( byte ) ( get data length ( ) > > num ) ; bin value [ num ] = ( byte ) ( get data length ( ) & num ) ; system . arraycopy ( username , num , bin value , num , get data length ( ) ) ; return bin value ; }	returns a binary representation of this attribute .
public long stream ex prepend ( long stream other ) { return new long stream ex ( long stream . concat ( other , stream ( ) ) , context . combine ( other ) ) ; }	creates a lazily concatenated stream whose elements are all the elements of the other stream followed by all the elements of this stream.
public void disconnect ( ) { connected = bool ; synchronized ( conn lost wait ) { conn lost wait . notify ( ) ; } if ( mqtt != null ) { try { mqtt . disconnect ( ) ; } catch ( exception ex ) { set title text ( str ) ; ex . print stack trace ( ) ; system . exit ( num ) ; } } if ( led . is flashing ( ) ) { led . set flash ( ) ; } led . set red ( ) ; set connected ( bool ) ; synchronized ( this ) { write logln ( str ) ; } }	a wrapper for the mqtt disconnect method.
private void add cdata section element ( string uri and local name , vector v ) { string tokenizer tokenizer = new string tokenizer ( uri and local name , str , bool ) ; string s1 = tokenizer . next token ( ) ; string s2 = tokenizer . has more tokens ( ) ? tokenizer . next token ( ) : null ; if ( null == s2 ) { v . add element ( null ) ; v . add element ( s1 ) ; } else { v . add element ( s1 ) ; v . add element ( s2 ) ; } }	adds a uri / localname pair of strings to the list .
private void check permissions ( ) { security manager sm = system . get security manager ( ) ; if ( sm != null ) { enumeration < permission > enum = permissions . elements ( ) ; while ( enum . has more elements ( ) ) { sm . check permission ( enum . next element ( ) ) ; } } }	check that the current access control context has all of the permissions necessary to load classes from this loader .
public span manager delete ( int start , int end ) { sb . delete ( start , end ) ; adjust lists ( start , start - end ) ; if ( calculate src positions ) for ( int i = num ; i < end - start ; i ++ ) ib . remove ( start ) ; return this ; }	deletes the content between start ( included ) and end ( excluded ) .
@ on error public void on error ( session session , throwable t ) { call internal ( str , session , t . get message ( ) ) ; logger . error ( t . get message ( ) , t ) ; }	on error raised handler.
public void remove strategy ( final weighting strategy strategy ) { strategies . remove ( strategy ) ; }	removes the strategy from the weighting strategies collection .
public wildcard file filter ( string [ ] wildcards , io case sensitivity ) { if ( wildcards == null ) { throw new illegal argument exception ( str ) ; } this . wildcards = new string [ wildcards . length ] ; system . arraycopy ( wildcards , num , this . wildcards , num , wildcards . length ) ; this . case sensitivity = case sensitivity == null ? io . sensitive : case sensitivity ; }	construct a new wildcard filter for an array of wildcards specifying case - sensitivity.
public static pair < integer , boolean > parse info from filename ( string name ) { try { if ( name . starts with ( saved tab state file prefix incognito ) ) { int id = integer . parse int ( name . substring ( saved tab state file prefix incognito . length ( ) ) ) ; return pair . create ( id , bool ) ; } else if ( name . starts with ( saved tab state file prefix ) ) { int id = integer . parse int ( name . substring ( saved tab state file prefix . length ( ) ) ) ; return pair . create ( id , bool ) ; } } catch ( number format exception ex ) { } return null ; }	parse the tab id and whether the tab is incognito from the tab state filename .
protected void initialize connection ( mqtt provider ) throws exception { if ( ! is use ssl ( ) ) { provider . connect ( str + port ) ; } else { ssl ctx = ssl . get instance ( str ) ; ctx . init ( new key manager [ num ] , new trust manager [ ] { new default trust manager ( ) } , new secure random ( ) ) ; provider . set ssl context ( ctx ) ; provider . connect ( str + port ) ; } }	initialize an mqttclientprovider instance.
public void filter rows ( ) { if ( m parent == null ) return ; cascaded row manager rowman = ( cascaded row manager ) m rows ; int iterator crows = m rows . rows ( ) ; while ( crows . has next ( ) ) { int crow = crows . next int ( ) ; if ( ! m row filter . get boolean ( m parent . get tuple ( rowman . get parent row ( crow ) ) ) ) { remove cascaded row ( crow ) ; } } iterator ptuples = m parent . tuples ( m row filter ) ; while ( ptuples . has next ( ) ) { tuple pt = ( tuple ) ptuples . next ( ) ; int prow = pt . get row ( ) ; if ( rowman . get child row ( prow ) == - num ) add cascaded row ( prow ) ; } }	manually trigger a re - filtering of the rows of this table.
public int version point number ( ) { return integer . value of ( properties . get property ( str ) ) ; }	returns the point version number for the directory server .
private string [ ] split separator ( string sep , string s ) { vector v = new vector ( ) ; int token start = num ; int token end = num ; while ( ( token end = s . index of ( sep , token start ) ) != - num ) { v . add element ( s . substring ( token start , token end ) ) ; token start = token end + num ; } v . add element ( s . substring ( token start ) ) ; string [ ] ret val = new string [ v . size ( ) ] ; v . copy into ( ret val ) ; return ret val ; }	split a string based on the presence of a specified separator.
static boolean advance to first font ( attributed character iterator aci ) { for ( char ch = aci . first ( ) ; ch != character iterator . done ; ch = aci . set index ( aci . get run limit ( ) ) ) { if ( aci . get attribute ( text attribute . char replacement ) == null ) { return bool ; } } return bool ; }	when this returns , the aci ' s current position will be at the start of the first run which does not contain a graphicattribute.
private static int count ( string pattern , string [ ] possible values ) { int count = num ; for ( string r : possible values ) { if ( pattern . contains ( r ) ) { count ++ ; } } return count ; }	count the amount of renamer tokens per group.
public static module load ( int id ) { return modules . get ( id ) ; }	load the module by id.
public future < void > update table entity async ( table entity table entity , boolean commit ) { update table entity ( table entity , commit ) ; return new async result < void > ( null ) ; }	updates the solr document for the given table entity asynchronly.
boolean has next s ( ) { return ( s feature idx < s features . size ( ) ) ; }	checks for next s feature .
public void test value of long positive2 ( ) { long long val = num ; big integer a number = big integer . value of ( long val ) ; byte r bytes [ ] = { num , - num , num , num } ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = a number . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , a number . signum ( ) ) ; }	valueof ( long val ) : convert a positive long value to a biginteger.
private boolean process single event ( ) { if ( event buffer . remaining ( ) < num ) { return bool ; } try { event buffer . get int ( ) ; final int buffer length = event buffer . get int ( ) ; final int padding = ( num - buffer length ) & num ; if ( event buffer . remaining ( ) < buffer length + padding + num ) return bool ; final byte [ ] buffer = new byte [ buffer length ] ; event buffer . get ( buffer ) ; event buffer . position ( event buffer . position ( ) + padding ) ; int event count = num ; if ( buffer length > num ) { event count = isc vax integer ( buffer , buffer length - num , num ) ; } event buffer . get long ( ) ; int event id = event buffer . get int ( ) ; log . debug ( string . format ( str , event id , event count ) ) ; channel listener dispatcher . event received ( this , new asynchronous channel listener . event ( event id , event count ) ) ; return bool ; } catch ( buffer underflow exception ex ) { return bool ; } }	processes the event buffer for a single event .
@ override public string to string ( ) { return name ; }	the string representation of this object .
public static < t > git note writer < t > create note writer ( string review commit hash , final repository db , person ident author , string ref ) { return new git note writer < t > ( review commit hash , db , ref , author ) ; }	creates a writer to write comments to a given review .
private element to element ( schedule task task ) { element el = doc . create element ( str ) ; set attributes ( el , task ) ; return el ; }	translate a schedule task object to a xml element.
public static int int hash ( string ip string ) { int val = num ; string [ ] strs = ip string . split ( str ) ; int len = strs . length ; if ( len >= num ) { val = int val ( strs [ num ] ) ; val <<= num ; val |= int val ( strs [ num ] ) ; val <<= num ; val |= int val ( strs [ num ] ) ; val <<= num ; val |= int val ( strs [ num ] ) ; } return val ; }	this should be suitable for ipv6 as well but we will have to accommodate for the extra bytes later.
public fluent jdbc builder connection provider ( connection provider connection provider ) { check not null ( connection provider , str ) ; this . connection provider = optional . of ( connection provider ) ; return this ; }	sets the connectionprovider for fluentjdbc.
public static void register ( string model name , i model , int awesomeness ) { models . put ( model name , model ) ; if ( model name . equals ignore case ( user model choice ) ) { awesomeness = integer . max value ; } if ( awesomeness > best ) { best = awesomeness ; active model = model ; } }	registers a wind model.
public void notify transaction terminated ( composite transaction ct ) { boolean notify of terminated event = bool ; synchronized ( this ) { boolean already terminated = is terminated ( ) ; iterator < transaction context > it = all contexts . iterator ( ) ; while ( it . has next ( ) ) { transaction context b = it . next ( ) ; b . transaction terminated ( ct ) ; } if ( is terminated ( ) && ! already terminated ) notify of terminated event = bool ; } if ( notify of terminated event ) { if ( logger . is trace enabled ( ) ) logger . log trace ( this + str + this ) ; fire terminated event ( ) ; } }	notifies the session that the transaction was terminated .
public jc create ( diagnostic type kind , diagnostic source source , diagnostic position pos , string key , object ... args ) { return create ( kind , null , enum set . none of ( diagnostic flag . class ) , source , pos , key , args ) ; }	create a new diagnostic of the given kind , which is not mandatory and which has no lint category .
public void export tree ( tree tree ) { map < string , integer > id map = write nexus header ( tree ) ; out . println ( str ) ; write nexus tree ( tree , tree prefix + num , bool , id map ) ; out . println ( str ) ; }	export a tree with all its attributes .
archived desktop component add desktop component ( final org . simbrain . workspace . gui . gui component < ? > dc ) { return desktop component = new archived desktop component ( this , dc ) ; }	adds a desktop component to this component entry .
public static file create temp dir ( ) { return create temp dir ( new file ( system . get property ( str ) ) ) ; }	create a temporary directory in the directory given by java.
private void extend colour map ( int highest ) { for ( int i = m color list . size ( ) ; i < highest ; i ++ ) { color pc = m [ i % num ] ; int ija = i / num ; ija *= num ; for ( int j = num ; j < ija ; j ++ ) { pc = pc . brighter ( ) ; } m color list . add ( pc ) ; } }	add more colours to the colour map.
protected void process result ( final operation operation , final object result , final command command obj ) throws base collection exception { processor processor = null ; processor = operation . get processor ( ) ; if ( null != processor ) { list < object > args list = new array list < object > ( ) ; args list . add ( util . normalized read args ( key map , command obj . retreive arguments ( ) ) ) ; args list . add ( command obj . get command index ( ) ) ; processor . set prerequisite objects ( args list ) ; processor . process result ( operation , result , key map ) ; } else { logger . debug ( str ) ; } }	move the result to processor.
public static string string filter strict ( string search text ) { return search text . replace all ( str , str ) ; }	remove useless and unsafe characters.
public enumeration enumurate queue ( ) { vector elements = new vector ( ) ; synchronized ( lock ) { enumeration e = pending . elements ( ) ; while ( e . has more elements ( ) ) { elements . add element ( e . next element ( ) ) ; } } return elements . elements ( ) ; }	this method returns all pending connectiorequest connections .
public boolean has previous ( ) { return iterator . has previous ( ) ; }	similar to getting the iterator and calling hasprevious on it.
private void caption put ( int value , string text ) { caption map . put ( new integer ( value ) , text ) ; }	caption put . save a mouse caption ( string ) corresponding to a character value . do not include a character number in the caption ; that is added by captionget ( ) .
public void sort locations ( ) { if ( l locations . is empty ( ) ) return ; collections . sort ( l locations ) ; pb fst = l locations . get ( num ) , loc ; if ( ! fst . is type ( string const . empty ) ) { for ( int i = num ; i < l locations . size ( ) ; i ++ ) { loc = l locations . get ( i ) ; if ( loc . is type ( string const . empty ) ) { loc . set type ( fst . get type ( ) ) ; break ; } } fst . set type ( string const . empty ) ; } }	sorts the locations of this argument by their terminal ids and heights .
private static int uarimax gt ( double value , double [ ] bv , int bvi [ ] , binary operator b op ) throws dml { int ix max = bv . length ; if ( value <= bv [ num ] || value > bv [ bv . length - num ] ) return ix max ; int ix = arrays . binary search ( bv , value ) ; ix = math . abs ( ix ) - num ; ix max = bvi [ ix - num ] + num ; return ix max ; }	find out rowindexmax for greaterthan operator .
private void persist volume native id ( db client db client , uri volume id , string native id , calendar creation time ) throws io { volume volume = db client . query object ( volume . class , volume id ) ; volume . set creation time ( creation time ) ; volume . set native id ( native id ) ; volume . set native guid ( guid . generate native guid ( db client , volume ) ) ; db client . update object ( volume ) ; }	this method saves the native id info and creation time for the volume object.
public whitelist ( ) { this . patterns = collections . empty list ( ) ; this . status code = - num ; this . enabled = bool ; }	creates an empty , disabled whitelist .
protected node conditional expr promotion ( node node , type mirror dest type ) { type mirror node type = node . get type ( ) ; if ( types . is same type ( node type , dest type ) ) { return node ; } if ( types utils . is primitive ( node type ) && types utils . is boxed primitive ( dest type ) ) { return box ( node ) ; } boolean is boxed primitive = types utils . is boxed primitive ( node type ) ; type mirror unboxed node type = is boxed primitive ? types . unboxed type ( node type ) : node type ; type mirror unboxed dest type = types utils . is boxed primitive ( dest type ) ? types . unboxed type ( dest type ) : dest type ; if ( types utils . is numeric ( unboxed node type ) && types utils . is numeric ( unboxed dest type ) ) { if ( unboxed node type . get kind ( ) == type kind . byte && dest type . get kind ( ) == type kind . short ) { if ( is boxed primitive ) { node = unbox ( node ) ; } return widen ( node , dest type ) ; } type kind dest kind = dest type . get kind ( ) ; if ( dest kind == type kind . byte || dest kind == type kind . char || dest kind == type kind . short ) { if ( is boxed primitive ) { return unbox ( node ) ; } else if ( node type . get kind ( ) == type kind . int ) { return narrow ( node , dest type ) ; } } return binary numeric promotion ( node , dest type ) ; } if ( types utils . is primitive ( node type ) && ( dest type . get kind ( ) == type kind . declared || dest type . get kind ( ) == type kind . union || dest type . get kind ( ) == type kind . intersection ) ) { return box ( node ) ; } return node ; }	convert an operand of a conditional expression to the type of the whole expression .
public void remove connection ( connection conn ) { int removal index = find connection ( conn ) ; if ( removal index != - num ) { m connections . remove ( removal index ) ; } }	remove the given connection from this list .
public attr set read ( java . security . principal principal , guid guid , string attr names [ ] ) throws ums { string id = guid . get dn ( ) ; connection entry reader entry reader ; search request request = ldap . new search request ( id , search scope . base object , str , attr names ) ; entry reader = read ldap ( principal , request ) ; if ( entry reader == null ) { throw new access rights exception ( id ) ; } collection < attribute > attrs = new array list < > ( ) ; try ( connection entry reader reader = entry reader ) { while ( reader . has next ( ) ) { if ( reader . is reference ( ) ) { reader . read reference ( ) ; } search result entry entry = entry reader . read entry ( ) ; for ( attribute attr : entry . get all attributes ( ) ) { attrs . add ( attr ) ; } } if ( attrs . is empty ( ) ) { throw new entry not found exception ( i18n . get string ( iums . entry not found , new string [ ] { id } ) ) ; } return new attr set ( attrs ) ; } catch ( io e ) { throw new ums ( i18n . get string ( iums . unable to read entry , new string [ ] { id } ) , e ) ; } }	reads an ldap entry .
private function < string , tag state > new tag retriever ( tagging client client ) { return null ; }	builds a function to retrieve tags given and endpoint .
public static map < string , list < data file footer > > create data file footer mapping for segments ( list < table block info > table block info list ) throws index builder exception { map < string , list < data file footer > > segment block info mapping = new hash map < > ( ) ; for ( table block info block info : table block info list ) { list < data file footer > each segment blocks = new array list < > ( ) ; string seg id = block info . get segment id ( ) ; data file footer data file matadata = null ; list < data file footer > metadata list = segment block info mapping . get ( seg id ) ; try { data file matadata = carbon util . read metadat file ( block info . get file path ( ) , block info . get block offset ( ) , block info . get block length ( ) ) ; } catch ( carbon util exception e ) { throw new index builder exception ( e ) ; } if ( null == metadata list ) { each segment blocks . add ( data file matadata ) ; segment block info mapping . put ( seg id , each segment blocks ) ; } else { metadata list . add ( data file matadata ) ; } } return segment block info mapping ; }	to create a mapping of segment id and datafilefooter .
public t add ( t e ) { t old e = null ; while ( ! buffer . offer last ( e ) ) { old e = buffer . poll ( ) ; } return old e ; }	adding an element to the circular buffer implies adding the element to the tail of the deque.
static array list < string > load image ( file file ) throws file not found exception , runtime exception { if ( file == null ) return null ; scanner sc ; sc = new scanner ( file ) ; array list < string > rows = new array list < string > ( ) ; string s = sc . next line ( ) ; int len = s . length ( ) ; int idx = num ; rows . add ( s ) ; while ( sc . has next ( ) ) { idx ++ ; s = sc . next line ( ) ; if ( s . length ( ) != len ) { sc . close ( ) ; throw new runtime exception ( str + idx + str + s . length ( ) + str + len + str ) ; } rows . add ( s ) ; } sc . close ( ) ; return rows ; }	helper function to load up images .
public static string cutpoints to string ( double [ ] cut points , boolean [ ] cut and left ) { string buffer text = new string buffer ( str ) ; if ( cut points == null ) { text . append ( str ) ; } else { text . append ( str + cut points . length + str ) ; for ( int i = num ; i < cut points . length ; i ++ ) { text . append ( str + cut points [ i ] + str ) ; text . append ( str + cut and left [ i ] + str ) ; } text . append ( str ) ; } return text . to string ( ) ; }	returns a string representing the cutpoints.
private static int capacity ( int expected max size ) { return ( expected max size > maximum capacity / num ) ? maximum capacity : ( expected max size <= num * minimum capacity / num ) ? minimum capacity : integer . highest one bit ( expected max size + ( expected max size << num ) ) ; }	returns the appropriate capacity for the given expected maximum size.
private void resize name column ( int diff , boolean resize statistic panels ) { if ( diff != num ) { if ( name dim == null ) { name dim = new dimension ( dimension header attribute name . width + diff , dimension header attribute name . height ) ; } else { int new width = name dim . width + diff ; int min width = resize margin shrink ; int max width = column header panel . get width ( ) - ( dimension header missings . width + dimension header type . width + dimension search field . width + resize margin enlarge ) ; if ( new width > max width ) { new width = max width ; } if ( new width < min width ) { new width = min width ; } name dim = new dimension ( new width , name dim . height ) ; } sorting label att name . set minimum size ( name dim ) ; sorting label att name . set preferred size ( name dim ) ; column header panel . revalidate ( ) ; column header panel . repaint ( ) ; } if ( resize statistic panels ) { revalidate attribute panels ( ) ; } }	called when resizing event occurs to resize the attribute name column.
public void copy checkpoints from installation directory ( string destination checkpoints filename ) throws io { if ( destination checkpoints filename == null ) { return ; } file destination checkpoints = new file ( destination checkpoints filename ) ; if ( ! destination checkpoints . exists ( ) ) { file directory = new file ( str ) ; string current working directory = directory . get canonical path ( ) ; string file prefix = multi bit service . get file prefix ( ) ; string checkpoints filename = file prefix + multi bit service . checkpoints suffix ; string source checkpoints filename = current working directory + file . separator + checkpoints filename ; file source blockcheckpoints = new file ( source checkpoints filename ) ; if ( source blockcheckpoints . exists ( ) && ! destination checkpoints filename . equals ( source checkpoints filename ) ) { log . info ( str + source checkpoints filename + str + destination checkpoints filename + str ) ; copy file ( source blockcheckpoints , destination checkpoints ) ; long source length = source blockcheckpoints . length ( ) ; long destination length = destination checkpoints . length ( ) ; if ( source length != destination length ) { string error text = str + source checkpoints filename + str + source length + str + destination checkpoints filename + str + destination length ; log . error ( error text ) ; throw new file handler exception ( error text ) ; } } } }	to support multiple users on the same machine , the checkpoints file is installed into the program installation directory and is then copied to the user ' s application data directory when multibit is first used.
public static boolean is valid bed graph line ( string line ) { string [ ] bdg = line . split ( str ) ; if ( bdg . length < num ) { return bool ; } try { integer . parse int ( bdg [ num ] ) ; integer . parse int ( bdg [ num ] ) ; } catch ( number format exception e ) { return bool ; } return bool ; }	return true if line looks like a valid bedgraph record.
public boolean check arguments ( list arguments ) { boolean valid args = bool ; if ( arguments != null && arguments . size ( ) > num ) { string specified args = format args ( arguments ) ; debug . log ( str + specified args ) ; print console message ( loc hr msg invalid option , new object [ ] { specified args } ) ; valid args = bool ; } return valid args ; }	to make sure that migrate has no additional parameter .
public static final void init zk ( zoo keeper zkc , string self broker url ) { try { local zoo keeper connection service . check and create persist node ( zkc , owner info root ) ; cleanup namespace nodes ( zkc , owner info root , self broker url ) ; } catch ( exception e ) { log . error ( e . get message ( ) , e ) ; throw new runtime exception ( e ) ; } }	initzk is only called when the namespaceservice is initialized.
public e peek forward ( ) { int next pos = ( pos + num ) % size ; if ( next pos >= data . size ( ) || pos == end ) { return null ; } return data . get ( next pos ) ; }	return the next element ( if present ) , without moving the position in the history .
public boolean add all ( int index , collection c ) { int num new = c . size ( ) ; synchronized ( this ) { object [ ] elements = get array ( ) ; int len = elements . length ; if ( index > len || index < num ) throw new index out of bounds exception ( str + index + str + len ) ; if ( num new == num ) return bool ; int num moved = len - index ; object [ ] new elements ; if ( num moved == num ) new elements = copy of ( elements , len + num new ) ; else { new elements = new object [ len + num new ] ; system . arraycopy ( elements , num , new elements , num , index ) ; system . arraycopy ( elements , index , new elements , index + num new , num moved ) ; } for ( iterator itr = c . iterator ( ) ; itr . has next ( ) ; ) { object e = itr . next ( ) ; new elements [ index ++ ] = e ; } set array ( new elements ) ; return bool ; } }	inserts all of the elements in the specified collection into this list , starting at the specified position.
protected static boolean is valid classname ( string classname ) { return ( classname . index of ( str ) == - num ) ; }	checks whether the classname is a valid one , i.
public static internal distributed member read essential data ( data input in ) throws io , class not found exception { final internal distributed member mbr = new internal distributed member ( ) ; mbr . read essential data ( in ) ; return mbr ; }	this writes just the parts of the id that are needed for comparisons and communications.
private boolean eval ( final int value , final int threshold ) { logger . debug ( str + value + str + threshold ) ; if ( threshold < num ) { logger . debug ( value < math . abs ( threshold ) ) ; return value < math . abs ( threshold ) ; } else { logger . debug ( value >= math . abs ( threshold ) ) ; return value >= threshold ; } }	evaluates the given value against the provided threshold .
public string to string ( ) { long ncompleted ; int nworkers , nactive ; final reentrant lock main lock = this . main lock ; main lock . lock ( ) ; try { ncompleted = completed task count ; nactive = num ; nworkers = workers . size ( ) ; for ( worker w : workers ) { ncompleted += w . completed tasks ; if ( w . is locked ( ) ) ++ nactive ; } } finally { main lock . unlock ( ) ; } int c = ctl . get ( ) ; string rs = ( run state less than ( c , shutdown ) ? str : ( run state at least ( c , terminated ) ? str : str ) ) ; return super . to string ( ) + str + rs + str + nworkers + str + nactive + str + work queue . size ( ) + str + ncompleted + str ; }	returns a string identifying this pool , as well as its state , including indications of run state and estimated worker and task counts .
public static string hex ( float f ) { return integer . to hex string ( float . float to int bits ( f ) ) ; }	print a float type ' s internal bit representation in hex.
public synchronized object remove ( int index ) { object [ ] elements = get array ( ) ; int len = elements . length ; object old value = elements [ index ] ; int num moved = len - index - num ; if ( num moved == num ) set array ( copy of ( elements , len - num ) ) ; else { object [ ] new elements = new object [ len - num ] ; system . arraycopy ( elements , num , new elements , num , index ) ; system . arraycopy ( elements , index + num , new elements , index , num moved ) ; set array ( new elements ) ; } return old value ; }	removes the element at the specified position in this list.
public void test composite attribute can be null ( ) throws exception { html page page = get page ( str ) ; assert element attribute equals ( page , str , str , str ) ; assert element attribute equals ( page , str , str , str ) ; }	test for issue # 1986.
public static string double to string ( double d ) { if ( double . is infinite ( d ) || double . is na n ( d ) ) { return str ; } string string = double . to string ( d ) ; if ( string . index of ( str ) > num && string . index of ( str ) < num && string . index of ( str ) < num ) { while ( string . ends with ( str ) ) { string = string . substring ( num , string . length ( ) - num ) ; } if ( string . ends with ( str ) ) { string = string . substring ( num , string . length ( ) - num ) ; } } return string ; }	produce a string from a double.
@ override public enumeration < option > list options ( ) { vector < option > result = new vector < option > ( num ) ; result . add element ( new option ( str , str , num , str ) ) ; result . add element ( new option ( str + str , str , num , str ) ) ; result . add element ( new option ( str , str , num , str ) ) ; result . add element ( new option ( str + str , str , num , str ) ) ; result . add element ( new option ( str , str , num , str ) ) ; result . add element ( new option ( str + str , str , num , str ) ) ; result . add element ( new option ( str + str , str , num , str ) ) ; result . add element ( new option ( str + str , str , num , str ) ) ; result . add element ( new option ( str + str , str , num , str ) ) ; result . add element ( new option ( str , str , num , str ) ) ; result . add element ( new option ( str + str + str , str , num , str ) ) ; result . add all ( collections . list ( super . list options ( ) ) ) ; return result . elements ( ) ; }	returns an enumeration describing the available options .
public static vector3 ceil ( vector3 o ) { return new vector3 ( math . ceil ( o . x ) , math . ceil ( o . y ) , math . ceil ( o . z ) ) ; }	rounds the x , y , and z values of the given vector3 up to the nearest integer value .
static void import map ( input stream is , map < string , string > m ) throws io , invalid preferences format exception { try { document doc = load prefs doc ( is ) ; element xml map = doc . get document element ( ) ; string map version = xml map . get attribute ( str ) ; if ( map version . compare to ( map xml version ) > num ) throw new invalid preferences format exception ( str + map version + str + str + map xml version + str + str ) ; node list entries = xml map . get child nodes ( ) ; for ( int i = num , num entries = entries . get length ( ) ; i < num entries ; i ++ ) { element entry = ( element ) entries . item ( i ) ; m . put ( entry . get attribute ( str ) , entry . get attribute ( str ) ) ; } } catch ( sax e ) { throw new invalid preferences format exception ( e ) ; } }	import map from the specified input stream , which is assumed to contain a map document as per the prefs dtd.
@ deprecated protected void wait ( int duration , runnable call back ) { executor . schedule ( call back , duration , time unit . milliseconds ) ; }	unsafe method since not interruptible . use at own risk.
public synchronized void remove of ( of h ) { connected channel handlers . remove ( h ) ; }	remove ofchannelhandler . e . g . , due do disconnect .
public void clear cache ( ) { clear memory cache ( ) ; clear disk cache ( ) ; }	clears both the memory and disk cache associated with this imagecache object.
public void remove property change listener ( property change listener pcl ) { m pc support . remove property change listener ( pcl ) ; }	remove a property change listener.
@ suppress warnings ( str ) protected boolean is fast clock time ge ( int hr , int min ) { date now = fast clock . get time ( ) ; now hours = now . get hours ( ) ; now minutes = now . get minutes ( ) ; if ( ( ( now hours * num ) + now minutes ) >= ( ( hr * num ) + min ) ) { return bool ; } return bool ; }	this method tests time assuming both times are on the same day ( ignoring midnight ) it also sets nowminutes and nowhours to the latest fast clock values.
public void test neg pos same length ( ) { string num a = str ; string num b = str ; string res = str ; big integer a number = new big integer ( num a ) ; big integer b number = new big integer ( num b ) ; big integer result = a number . xor ( b number ) ; assert true ( res . equals ( result . to string ( ) ) ) ; }	xor for two numbers of different signs and the same length.
public void remove renaming callback ( one sheeld renaming callback renaming callback ) { if ( renaming callback != null && renaming callbacks . contains ( renaming callback ) ) renaming callbacks . remove ( renaming callback ) ; }	remove a renaming callback .
public boolean fill if live ( long timeout ) throws io { stream impl source = source ; byte [ ] read buffer = read buffer ; if ( read buffer == null || source == null ) { read offset = num ; read length = num ; return bool ; } if ( read offset > num ) { system . arraycopy ( read buffer , read offset , read buffer , num , read length - read offset ) ; read length -= read offset ; read offset = num ; } if ( read length == read buffer . length ) return bool ; int read length = source . read timeout ( read buffer , read length , read buffer . length - read length , timeout ) ; if ( read length >= num ) { read length += read length ; position += read length ; if ( is enable read time ) read time = current time . current time ( ) ; return bool ; } else if ( read length == read timeout ) { return bool ; } else { return bool ; } }	fills the buffer with a timed read , testing for the end of file.
public thread data ( string thread name , string thread state , long cpu time in nano seconds ) { this . thread name = thread name ; this . thread state = thread state ; this . cpu time in nano seconds = cpu time in nano seconds ; }	instantiates a new thread data .
protected j create chart ( category dataset dataset , string title , muom uom ) { j chart = chart factory . create bar chart3 d ( title , str , str , dataset , plot orientation . vertical , bool , bool , bool ) ; if ( uom == null || uom . is hour ( ) ) { chart = chart factory . create bar chart3 d ( title , msg . translate ( env . get ctx ( ) , str ) , msg . translate ( env . get ctx ( ) , str ) , dataset , plot orientation . vertical , bool , bool , bool ) ; } else { chart = chart factory . create bar chart3 d ( title , msg . translate ( env . get ctx ( ) , str ) , msg . translate ( env . get ctx ( ) , str ) , dataset , plot orientation . vertical , bool , bool , bool ) ; } return chart ; }	create chart using the data set and uom.
private value graph vertex find or create vertex ( register r ) { value graph vertex v = get vertex ( r ) ; if ( v == null ) { v = new value graph vertex ( r ) ; v . set label ( r , num ) ; graph . add graph node ( v ) ; name map . put ( r , v ) ; } return v ; }	find or create an valuegraphvertex corresponding to a given register.
public radius graph element accessor ( ) { this ( math . sqrt ( double . max value - num ) ) ; }	creates an instance with an effectively infinite default maximum distance .
public void remove latest update ( password password ) throws page exception { remove update ( password , bool ) ; }	run update from cfml engine.
public void notify query running ( final bound entity song ) { synchronized ( m running queries ) { m running queries . add ( song ) ; } }	notifies an async task has started processing the art for the provided entity.
public void test boolean options ( ) throws exception { database meta data dbmd = con . get meta data ( ) ; assert true ( str , dbmd . locators update copy ( ) ) ; assert true ( str , dbmd . supports get generated keys ( ) ) ; assert true ( str , dbmd . supports multiple open results ( ) ) ; assert true ( str , dbmd . supports named parameters ( ) ) ; assert false ( str , dbmd . supports result set holdability ( result set . hold cursors over commit ) ) ; assert false ( str , dbmd . supports result set holdability ( result set . close cursors at commit ) ) ; assert true ( str , dbmd . supports savepoints ( ) ) ; assert true ( str , dbmd . supports statement pooling ( ) ) ; }	test meta data functions that return boolean values .
private static properties create properties1 ( ) { properties props = new properties ( ) ; props . set property ( mcast port , str ) ; props . set property ( locators , str ) ; return props ; }	create properties for a loner vm.
public void connected ( ) { final string method name = str ; log . fine ( class name , method name , str ) ; this . connected = bool ; ping sender . start ( ) ; }	called when the client has successfully connected to the broker.
static float rotate x ( float p x , float p y , float c x , float c y , float angle in degrees ) { double angle = math . to radians ( angle in degrees ) ; return ( float ) ( math . cos ( angle ) * ( p x - c x ) - math . sin ( angle ) * ( p y - c y ) + c x ) ; }	rotate point p around center point c .
public boolean start ( float start scale , float target scale , float center x , float center y ) { if ( m running ) { return bool ; } m center x = center x ; m center y = center y ; m target scale = target scale ; m start time = system . current time millis ( ) ; m start scale = start scale ; m zooming in = m target scale > m start scale ; m velocity = ( m target scale - m start scale ) / zoom animation duration ; m running = bool ; m stop = bool ; m header . post ( this ) ; return bool ; }	starts the animation . there is no target scale bounds check .
private void dispatch on third party registration failed ( ) { synchronized ( this ) { for ( third party registration listener listener : m third party registration listeners ) { try { listener . on third party registration failed ( ) ; } catch ( exception e ) { log . e ( log tag , str + e . get localized message ( ) ) ; } } m third party registration listeners . clear ( ) ; } }	dispatch the onthirdpartyregistrationfailed to the listeners .
public void remove cos ( ) throws ums { array list a list = ( array list ) get cos ( ) ; for ( int i = num ; i < a list . size ( ) ; i ++ ) { cos cos template = ( cos ) a list . get ( i ) ; cos template . remove ( ) ; } }	removes all cos templates from this cos definition .
private void collect references ( final i node , final set < i > references ) { for ( final i reference : node . get references ( ) ) { if ( reference type . is code reference ( reference . get type ( ) ) ) { references . add ( reference . get target ( ) ) ; } } for ( final i child : node . get children ( ) ) { collect references ( child , references ) ; } }	collects all code references from an operand tree node and all of its children .
private apply deletes result close segment states ( index writer . reader pool pool , segment state [ ] seg states , boolean success , long gen ) throws io { int num readers = seg states . length ; throwable first exc = null ; list < segment commit info > all deleted = null ; long tot del count = num ; for ( int j = num ; j < num readers ; j ++ ) { segment state seg state = seg states [ j ] ; if ( success ) { tot del count += seg state . rld . get pending delete count ( ) - seg state . start del count ; seg state . reader . get segment info ( ) . set buffered deletes gen ( gen ) ; int full del count = seg state . rld . info . get del count ( ) + seg state . rld . get pending delete count ( ) ; assert full del count <= seg state . rld . info . info . max doc ( ) ; if ( full del count == seg state . rld . info . info . max doc ( ) ) { if ( all deleted == null ) { all deleted = new array list < > ( ) ; } all deleted . add ( seg state . reader . get segment info ( ) ) ; } } try { seg states [ j ] . finish ( pool ) ; } catch ( throwable th ) { if ( first exc != null ) { first exc = th ; } } } if ( success ) { io . re throw ( first exc ) ; } if ( info stream . is enabled ( str ) ) { info stream . message ( str , str + tot del count + str ) ; } return new apply deletes result ( tot del count > num , gen , all deleted ) ; }	close segment states previously opened with opensegmentstates .
private void handle yarn container change ( string container count as string ) throws io , yarn exception { string application id = yarn util . get running app id ( job name , job id ) ; int container count = integer . value of ( container count as string ) ; int current num task = get current num tasks ( ) ; int current num containers = get current num containers ( ) ; if ( container count == current num containers ) { log . error ( str ) ; return ; } if ( container count <= num ) { log . error ( str ) ; return ; } if ( container count > current num task ) { log . error ( str ) ; return ; } log . info ( str ) ; yarn util . kill application ( application id ) ; coordinator server url = null ; try { string state = yarn util . get application state ( application id ) ; thread . sleep ( num ) ; int count sleep = num ; while ( ! state . equals ( str ) ) { state = yarn util . get application state ( application id ) ; log . info ( str + application id + str ) ; thread . sleep ( num ) ; count sleep ++ ; if ( count sleep > num ) { throw new illegal state exception ( str ) ; } } } catch ( interrupted exception e ) { e . print stack trace ( ) ; } log . info ( str ) ; log . info ( str ) ; skip unread messages ( ) ; job runner job runner = new job runner ( config ) ; job runner . run ( bool ) ; }	this method handles setconfig messages that want to change the number of containers of a job.
public static boolean compare cell value ( double v1 , double v2 , double t , boolean ignore na n ) { if ( v1 == null ) v1 = num ; if ( v2 == null ) v2 = num ; if ( ignore na n && ( v1 . is na n ( ) || v1 . is infinite ( ) || v2 . is na n ( ) || v2 . is infinite ( ) ) ) return bool ; if ( v1 . equals ( v2 ) ) return bool ; return math . abs ( v1 - v2 ) <= t ; }	compares two double values regarding tolerance t.
public static int ping ( string url ) throws exception { url u = new url ( url ) ; url c = ( url ) u . open connection ( ) ; c . connect ( ) ; int code = c . get response code ( ) ; log . debug ( str + url + str + code ) ; c . disconnect ( ) ; return code ; }	ping the url , throw exception if occur error.
public static int secondary identity hash ( object key ) { return secondary hash ( system . identity hash code ( key ) ) ; }	computes an identity hash code and applies a supplemental hash function to defend against poor quality hash functions.
public config load installed codenvy config ( install type install type ) throws io { map < string , string > properties = load installed codenvy properties ( install type ) ; return new config ( properties ) ; }	loads appropriate codenvy config for given installation type .
public geo distance sort builder point ( double lat , double lon ) { points . add ( new geo point ( lat , lon ) ) ; return this ; }	the point to create the range distance facets from .
protected int index first of ( final string s , final string delims , int offset ) { if ( s == null || s . length ( ) == num ) { return - num ; } if ( delims == null || delims . length ( ) == num ) { return - num ; } if ( offset < num ) { offset = num ; } else if ( offset > s . length ( ) ) { return - num ; } int min = s . length ( ) ; final char [ ] delim = delims . to char array ( ) ; for ( int i = num ; i < delim . length ; i ++ ) { final int at = s . index of ( delim [ i ] , offset ) ; if ( at >= num && at < min ) { min = at ; } } return ( min == s . length ( ) ) ? - num : min ; }	get the earlier index that to be searched for the first occurrance in one of any of the given string .
public named color ( string [ ] names array , int r , int g , int b ) { super ( r , g , b ) ; names = new hash set < > ( ) ; names . add all ( arrays . as list ( names array ) ) ; names lowercase = new hash set < > ( ) ; for ( string this name : names array ) { names lowercase . add ( this name . to lower case ( ) ) ; } if ( names array . length == num ) { name = str ; } else { name = names array [ num ] ; } }	constructs a new color with the given names and rgb values.
public void show content ( ) { switch state ( content , null , null , null , null , null , collections . < integer > empty list ( ) ) ; }	hide all other states and show content.
public static boolean is valid template ( string template ) { template = template . trim ( ) ; if ( template . index of ( str ) == - num ) { return bool ; } string s = template . trim ( ) ; if ( s . last index of ( str ) != s . length ( ) - num ) { return bool ; } if ( get method signature ( template ) == null ) { return bool ; } if ( get method body ( template ) == null ) { return bool ; } return bool ; }	validates the provided template .
private void await operations available ( ) throws interrupted exception { flush lock . lock ( ) ; try { do { if ( write cache . sizex ( ) <= cache max size || cache max size == num ) { if ( cache flush freq > num ) can flush . await ( cache flush freq , time unit . milliseconds ) ; else can flush . await ( ) ; } } while ( write cache . sizex ( ) == num && ! stopping . get ( ) ) ; } finally { flush lock . unlock ( ) ; } }	this method awaits until enough elements in map are available or given timeout is over .
public string to string ( ) { string buffer buf = new string buffer ( ) ; if ( is boot || ( data chars [ num ] == sprog message . stx ) ) { for ( int i = num ; i < n data chars ; i ++ ) { buf . append ( str ) ; buf . append ( data chars [ i ] ) ; buf . append ( str ) ; } } else { for ( int i = num ; i < n data chars ; i ++ ) { buf . append ( ( char ) data chars [ i ] ) ; } } return buf . to string ( ) ; }	returns a string representation of this sprogreply.
public static boolean is native code loaded ( ) { return native code loader . is native code loaded ( ) ; }	checks whether the native code has been successfully loaded for the platform .
abstract void replay ( ) ;	reapplies the change to prefscache .
private boolean ready to connect ( ) { long now = system . current time millis ( ) ; long last exchange millis = m store . get long ( last exchange time key , - num ) ; boolean time since last ok ; if ( last exchange millis == - num ) { time since last ok = bool ; } else if ( now - last exchange millis < time between exchanges millis ) { time since last ok = bool ; } else { time since last ok = bool ; } if ( ! use minimal logging ) { log . info ( str + ( time since last ok && ( get connecting ( ) == null ) ) ) ; log . info ( str + get connecting ( ) ) ; log . info ( str + time since last ok ) ; } return time since last ok && ( get connecting ( ) == null ) ; }	check whether we can connect , according to our policies.
public static void put double ( long addr , double val ) { if ( unaligned ) unsafe . put double ( addr , val ) ; else put long by byte ( addr , double . double to long bits ( val ) , big endian ) ; }	stores given double value.
public void add ( t item ) { if ( items . add ( item ) ) { notify data set changed ( ) ; } }	adds a new item to the adapter ' s list .
public dsn layer structure ( collection < dsn layer > p layer list ) { arr = new dsn layer [ p layer list . size ( ) ] ; iterator < dsn layer > it = p layer list . iterator ( ) ; for ( int i = num ; i < arr . length ; ++ i ) { arr [ i ] = it . next ( ) ; } }	creates a new instance of layerstructure from a list of layers.
public void write next ( string [ ] next line , boolean apply quotes to all ) { if ( next line == null ) { return ; } string builder sb = new string builder ( initial string size ) ; for ( int i = num ; i < next line . length ; i ++ ) { if ( i != num ) { sb . append ( separator ) ; } string next element = next line [ i ] ; if ( next element == null ) { continue ; } boolean string contains special characters = string contains special characters ( next element ) ; if ( ( apply quotes to all || string contains special characters ) && quotechar != no quote character ) { sb . append ( quotechar ) ; } if ( string contains special characters ) { sb . append ( process line ( next element ) ) ; } else { sb . append ( next element ) ; } if ( ( apply quotes to all || string contains special characters ) && quotechar != no quote character ) { sb . append ( quotechar ) ; } } sb . append ( line end ) ; pw . write ( sb . to string ( ) ) ; }	writes the next line to the file .
public double [ ] incoming instance to vector field vals ( double [ ] incoming ) throws exception { double [ ] new inst = new double [ m vector fields . size ( ) ] ; for ( int i = num ; i < m vector fields . size ( ) ; i ++ ) { field ref fr = m vector fields . get ( i ) ; new inst [ i ] = fr . get result ( incoming ) ; } return new inst ; }	convert an incoming instance to an array of values that corresponds to the fields referenced by the support vectors in the vector dictionary.
public source resolve uri ( string base , string url string , source locator locator ) throws transformer exception , io { source source = null ; if ( null != m uri resolver ) { source = m uri resolver . resolve ( url string , base ) ; } if ( null == source ) { string uri = id . get absolute uri ( url string , base ) ; source = new stream source ( uri ) ; } return source ; }	this will be called by the processor when it encounters an xsl : include , xsl : import , or document ( ) function .
private static void log node properties ( org . osgi . service . prefs . preferences node ) { if ( node == null ) { return ; } try { log . info ( node . name ( ) + str ) ; log properties ( node ) ; string [ ] children names = node . children names ( ) ; for ( int i = num ; i < children names . length ; i ++ ) { log node properties ( node . node ( children names [ i ] ) ) ; } } catch ( exception t ) { log . error ( str , t ) ; } }	logs all properties of a preference node and calls lognodeproperties for all children of this node .
public static < t extends data object > t find in collection ( collection < t > col , t obj ) { if ( col != null && obj != null ) { return find in collection ( col , obj . get id ( ) ) ; } return null ; }	finds an dataobject in a collection by matching it by id.
public code viewer ( ) { set highlight color ( default highlight color ) ; init actions ( ) ; set layout ( new border layout ( ) ) ; code highlight bar = create code highlight bar ( ) ; code highlight bar . set visible ( bool ) ; add ( code highlight bar , border layout . north ) ; code panel = create code panel ( ) ; add ( code panel , border layout . center ) ; apply defaults ( ) ; }	creates a new instance of codeviewer.
@ override public boolean equals ( object obj ) { if ( this == obj ) return bool ; if ( obj == null ) return bool ; if ( get class ( ) != obj . get class ( ) ) return bool ; ifd structure other = ( ifd structure ) obj ; if ( count != other . count ) return bool ; if ( offset value != other . offset value ) return bool ; if ( tag != other . tag ) return bool ; if ( type != other . type ) return bool ; return bool ; }	returns whether this object is equal to the given object .
public boolean is absolute uri ( ) { return ( scheme != null ) ; }	tell whether or not this uri is absolute .
public synchronized boolean is consumer ( image consumer ic ) { return ics . contains ( ic ) ; }	determine if an imageconsumer is on the list of consumers currently interested in data for this image .
public boolean is mandatory ( ) { return flags . contains ( diagnostic flag . mandatory ) ; }	check whether or not this diagnostic is required to be shown .
public static alarm cache object create test alarm1 ( ) { alarm cache object alarm1 = new alarm cache object ( ) ; alarm1 . set id ( long . value of ( num ) ) ; alarm1 . set fault family ( str ) ; alarm1 . set fault member ( str ) ; alarm1 . set fault code ( num ) ; alarm condition condition = alarm condition . from config xml ( str + str ) ; alarm1 . set condition ( condition ) ; alarm1 . set info ( str ) ; alarm1 . set state ( alarm condition . terminate ) ; alarm1 . set timestamp ( new timestamp ( system . current time millis ( ) - num ) ) ; alarm1 . set data tag id ( num ) ; return alarm1 ; }	does not set reference to tag id .
public boolean just serialized ( ) { return serialized . get and set ( bool ) ; }	this is called on deserialization.
public object read ( string xml ) throws exception { return from xml ( m . read ( xml ) ) ; }	parses the given xml string ( can be xml or a filename ) and returns an object generated from the representation.
protected t new instance ( final class < ? extends t > cls , final i index manager , final nt nt , final properties properties ) { if ( cls == null ) throw new illegal argument exception ( ) ; if ( index manager == null ) throw new illegal argument exception ( ) ; if ( nt == null ) throw new illegal argument exception ( ) ; if ( properties == null ) throw new illegal argument exception ( ) ; final constructor < ? extends t > ctor ; try { ctor = cls . get constructor ( new class [ ] { i . class , string . class , long . class , properties . class } ) ; } catch ( exception e ) { throw new runtime exception ( str + cls . get name ( ) + str + e , e ) ; } final t r ; try { r = ctor . new instance ( new object [ ] { index manager , nt . get name ( ) , nt . get timestamp ( ) , properties } ) ; r . init ( ) ; if ( info ) { log . info ( str + r ) ; } return r ; } catch ( exception ex ) { throw new runtime exception ( str + ex , ex ) ; } }	create a new view of the relation .
public builder ( ) { }	creates a new property . builder.
protected map tile find covering ( int zoom , long i , long j ) { while ( zoom > num ) { zoom -- ; i = i / num ; j = j / num ; map tile candidate = find tile ( zoom , i , j ) ; if ( ( candidate != null ) && ( ! candidate . loading ( ) ) ) { return candidate ; } } return null ; }	find the " nearest " lower - zoom tile that covers a specific tile . this is used to find out what tile we have to show while a new tile is still loading.
@ override public string format ( object obj ) throws illegal argument exception { return format ( obj , new string buffer ( ) ) ; }	format a given object .
public boolean is empty ( ) { return ( ( values == null ) || ( values . is empty ( ) ) ) ; }	obtiene si la lista de valores esta vacia.
private static string [ ] process object classes ( final string object class ) { string [ ] object classes = null ; if ( object class != null ) { object classes = object class . split ( str ) ; } if ( object classes != null ) { string obj class = null ; for ( int i = num ; i < object classes . length ; i ++ ) { obj class = object classes [ i ] ; if ( obj class != null ) { object classes [ i ] = obj class . trim ( ) ; } } } return object classes ; }	procesa un string con clases separadas por , para devolver un array.
public static string [ ] filter light colors ( string [ ] a palette , int a threshold ) { list < string > filtered = new array list < string > ( ) ; for ( string color : a palette ) { if ( ! is too light ( color , a threshold ) ) { filtered . add ( color ) ; } } return ( string [ ] ) filtered . to array ( new string [ filtered . size ( ) ] ) ; }	filter out too light colors from the palette - those that do not show propely on a ligth background.
synchronized int lookup ( final object tx , final boolean insert ) { if ( tx == null ) { throw new illegal argument exception ( str ) ; } integer index = ( integer ) mapping . get ( tx ) ; if ( index == null ) { if ( insert ) { final int capacity = capacity ( ) ; final int nvertices = mapping . size ( ) ; if ( nvertices == capacity ) { throw new multiprogramming capacity exceeded exception ( str + capacity + str + nvertices ) ; } index = ( integer ) indices . remove ( num ) ; mapping . put ( tx , index ) ; final int ndx = index . int value ( ) ; if ( transactions [ ndx ] != null ) { throw new assertion error ( ) ; } transactions [ ndx ] = tx ; } else { return - num ; } } return index . int value ( ) ; }	lookup index assigned to transaction object .
public void deregister ( train schedule schedule ) { if ( schedule == null ) { return ; } integer old size = integer . value of ( schedule hash table . size ( ) ) ; schedule hash table . remove ( schedule . get id ( ) ) ; set dirty and fire property change ( listlength changed property , old size , integer . value of ( schedule hash table . size ( ) ) ) ; }	forget a namedbean object created outside the manager .
public int read le ( ) throws io { int byte1 , byte2 , byte3 , byte4 ; synchronized ( this ) { byte1 = in . read ( ) ; byte2 = in . read ( ) ; byte3 = in . read ( ) ; byte4 = in . read ( ) ; } if ( byte4 == - num ) { throw new eof ( ) ; } return ( byte4 << num ) + ( byte3 << num ) + ( byte2 << num ) + byte1 ; }	translates a little endian int into a big endian int.
public void initialize atoms for dp ( list < datum > data , string filename , random random ) { omega = new array list < > ( k ) ; dof = new double [ k ] ; beta = new double [ k ] ; if ( filename != null ) { try { loc = batch mixture model . initialize clusters from file ( filename , k ) ; log . debug ( str , loc ) ; if ( loc . size ( ) < k ) { loc = batch mixture model . gonzalez initialize mixture centers ( loc , data , k , random ) ; } } catch ( file not found exception e ) { log . debug ( str ) ; e . print stack trace ( ) ; loc = batch mixture model . gonzalez initialize mixture centers ( data , k , random ) ; } } else { loc = batch mixture model . gonzalez initialize mixture centers ( data , k , random ) ; } for ( int i = num ; i < k ; i ++ ) { beta [ i ] = num ; dof [ i ] = base nu ; omega . add ( num , algebra utils . invert matrix ( base omega inverse ) ) ; } }	initializes atom ( component ) distributions.
private string determine event type based on operational status ( hashtable < string , string > notification , string [ ] descs , string [ ] codes , string evt ok , string evt notok , list < string > prop descriptions , list < string > prop codes ) { log message ( str , new object [ ] { } ) ; string evt type = null ; string [ ] values = descs ; if ( values . length > num ) { evt type = evt notok ; for ( string value : values ) { if ( prop descriptions . contains ( value ) ) { evt type = evt ok ; break ; } } } else { values = codes ; if ( values . length > num ) { evt type = evt notok ; for ( string value : values ) { if ( prop codes . contains ( value ) ) { evt type = evt ok ; break ; } } } else { log message ( str , new object [ ] { } ) ; } } return evt type ; }	figure out the file and block related event type based on the operational status values available in the indication.
public static int to int access ( string access ) throws application exception { access = string util . to lower case ( access . trim ( ) ) ; if ( access . equals ( str ) ) return component . access package ; else if ( access . equals ( str ) ) return component . access private ; else if ( access . equals ( str ) ) return component . access public ; else if ( access . equals ( str ) ) return component . access remote ; throw new application exception ( str + access + str ) ; }	cast a strong access definition to the int type.
static byte [ ] ntlm2 session response ( final byte [ ] ntlm hash , final byte [ ] challenge , final byte [ ] client challenge ) throws authentication exception { try { final message digest md5 = message digest . get instance ( str ) ; md5 . update ( challenge ) ; md5 . update ( client challenge ) ; final byte [ ] digest = md5 . digest ( ) ; final byte [ ] session hash = new byte [ num ] ; system . arraycopy ( digest , num , session hash , num , num ) ; return lm response ( ntlm hash , session hash ) ; } catch ( exception e ) { if ( e instanceof authentication exception ) throw ( authentication exception ) e ; throw new authentication exception ( e . get message ( ) , e ) ; } }	calculates the ntlm2 session response for the given challenge , using the specified password and client challenge .
public boolean is ancestor of ( i e ) { i parent element = e . get parent ( ) ; while ( parent element != null && ! parent element . equals ( this ) ) { parent element = parent element . get parent ( ) ; } return parent element != null ; }	returns true if this element is an ancestor of the given element , otherwise false .
protected final void enable retransmission timer ( int tick count ) { if ( is invite transaction ( ) && ( this instanceof sip ) ) { retransmission timer ticks left = tick count ; } else { retransmission timer ticks left = math . min ( tick count , maximum retransmission tick count ) ; } retransmission timer last tick count = retransmission timer ticks left ; retransmission outdated time = system clock . elapsed realtime ( ) + retransmission timer ticks left * base timer interval ; }	enables retransmission timer events for this transaction to begin after the number of ticks passed to this routine .
void tidy ( int window start year ) { if ( last rule list . size ( ) == num ) { throw new illegal state exception ( str ) ; } if ( window end . equals ( local date time . max ) ) { max last rule start year = math . max ( max last rule start year , window start year ) + num ; for ( tz last rule : last rule list ) { add rule ( last rule . year , max last rule start year , last rule . month , last rule . day of month indicator , last rule . day of week , last rule . time , last rule . time end of day , last rule . time definition , last rule . saving amount secs ) ; last rule . year = max last rule start year + num ; } if ( max last rule start year == year max value ) { last rule list . clear ( ) ; } else { max last rule start year ++ ; } } else { int end year = window end . get year ( ) ; for ( tz last rule : last rule list ) { add rule ( last rule . year , end year + num , last rule . month , last rule . day of month indicator , last rule . day of week , last rule . time , last rule . time end of day , last rule . time definition , last rule . saving amount secs ) ; } last rule list . clear ( ) ; max last rule start year = year max value ; } collections . sort ( rule list ) ; collections . sort ( last rule list ) ; if ( rule list . size ( ) == num && fixed saving amount secs == null ) { fixed saving amount secs = num ; } }	adds rules to make the last rules all start from the same year.
private int [ ] determine dimensions ( int source code words , int error correction code words ) throws writer exception { float ratio = num ; int [ ] dimension = null ; for ( int cols = min cols ; cols <= max cols ; cols ++ ) { int rows = calculate number of rows ( source code words , error correction code words , cols ) ; if ( rows < min rows ) { break ; } if ( rows > max rows ) { continue ; } float new ratio = ( ( num * cols + num ) * default module width ) / ( rows * height ) ; if ( dimension != null && math . abs ( new ratio - preferred ratio ) > math . abs ( ratio - preferred ratio ) ) { continue ; } ratio = new ratio ; dimension = new int [ ] { cols , rows } ; } if ( dimension == null ) { int rows = calculate number of rows ( source code words , error correction code words , min cols ) ; if ( rows < min rows ) { dimension = new int [ ] { min cols , min rows } ; } } if ( dimension == null ) { throw new writer exception ( str ) ; } return dimension ; }	determine optimal nr of columns and rows for the specified number of codewords .
private void log after load ( ) { enumeration elem = properties . keys ( ) ; list lp = collections . list ( elem ) ; collections . sort ( lp ) ; iterator iter = lp . iterator ( ) ; finer ( str + properties . size ( ) + str ) ; finer ( str ) ; while ( iter . has next ( ) ) { string key = ( string ) iter . next ( ) ; string val = properties . get property ( key ) ; finer ( str + key + str + val ) ; } finer ( str ) ; }	writes a log of loaded properties to the plumbing.
public t remove item by position ( int position ) { if ( position < m objects . size ( ) && position != invalid position ) { m object deleted = m objects . remove ( position ) ; m has deleted position = position ; notify data set changed ( ) ; return m object deleted ; } else { throw new index out of bounds exception ( str ) ; } }	remove the specified object by the position .
public static q value of ( char sequence name ) { q q name = ( q ) full name to qname . get ( name ) ; return ( q name != null ) ? q name : q . create no namespace ( name . to string ( ) ) ; }	returns the qualified name corresponding to the specified character sequence representation ( may include the " { namespaceuri } " prefix ) .
protected final void put char ( char ch ) { if ( sp == sbuf . length ) { char [ ] newsbuf = new char [ sbuf . length * num ] ; system . arraycopy ( sbuf , num , newsbuf , num , sbuf . length ) ; sbuf = newsbuf ; } sbuf [ sp ++ ] = ch ; }	append a character to sbuf .
@ transactional ( read only = bool ) @ cacheable ( value = str , key = str ) public int count downloads by user since ( final user user , final long period ) { objects . require non null ( user , str ) ; objects . require non null ( period , str ) ; long current timestamp = system . current time millis ( ) ; if ( period < num || period > current timestamp ) { throw new illegal argument exception ( str ) ; } date date = new date ( current timestamp - period ) ; return network usage dao . count download by user since ( user , date ) ; }	returns number of downloads by a user on a given period .
public um ( string question , string question localized name , string answer , int data status ) { this . question = question . trim ( ) ; this . question localized name = question localized name ; this . answer = answer . trim ( ) ; this . data status = data status ; }	constructs a user password reset options data object.
private void assert char vectors ( int n ) { int k = num * n + num ; int limit = ( int ) math . pow ( num , k + num ) ; for ( int i = num ; i < limit ; i ++ ) { string encoded = integer . to string ( i , num ) ; assert lev ( encoded , n ) ; } }	tests all possible characteristic vectors for some n this exhaustively tests the parametric transitions tables .
static string expand environment variables ( string value ) { if ( null == value ) { return null ; } matcher m = env var pattern . matcher ( value ) ; string buffer sb = new string buffer ( ) ; while ( m . find ( ) ) { string env var value = null ; string env var name = null == m . group ( num ) ? m . group ( num ) : m . group ( num ) ; if ( env var name . starts with ( ( str ) ) ) { env var value = system . getenv ( env var name . substring ( num ) ) ; } else { env var value = system . get property ( env var name ) ; } m . append replacement ( sb , null == env var value ? str : matcher . quote replacement ( env var value ) ) ; } m . append tail ( sb ) ; return sb . to string ( ) ; }	return the string value , expanding any environment variables found in the expression.
public hash token session map ( environment environment ) { int session timeout value ; try { session timeout value = environment . get property ( api session timeout , num ) ; } catch ( guacamole exception e ) { logger . error ( str , e . get message ( ) ) ; logger . debug ( str , e ) ; session timeout value = num ; } logger . info ( str , session timeout value ) ; executor . schedule at fixed rate ( new session eviction task ( session timeout value * num ) , num , num , time unit . minutes ) ; }	create a new hashtokensessionmap configured using the given environment .
private int oidc claims usage count ( string uuid ) throws sso , sms { sms sms entry = new sms ( get token ( ) , get o dn ( ) ) ; map < string , set < string > > attributes = sms entry . get attributes ( ) ; try { set < string > sun key values = get map set throws ( attributes , str ) ; if ( sun key values . contains ( str + uuid ) ) { return num ; } } catch ( value not found exception ignored ) { } return num ; }	count how many times the script identified by the specified uuid is used in oidc claims .
public event expire thread ( ) { super ( str ) ; set daemon ( bool ) ; }	create a daemon thread.
public boolean is header ( int position ) { return position >= num && position < m header views . size ( ) ; }	jude is head view.
public void test case6 ( ) { byte a bytes [ ] = { num , num , num , num , num , num , num , num , num , num } ; byte b bytes [ ] = { num , num , num , num , num , num , num , num , num , num } ; int a sign = - num ; int b sign = - num ; byte r bytes [ ] = { num , num , num , num , num , num , num , num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . subtract ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( num , result . signum ( ) ) ; }	subtract two negative numbers of the same length.
public void clear breakpoints passive ( final breakpoint type type ) { preconditions . check not null ( type , str ) ; navi logger . info ( str , type ) ; switch ( type ) { case regular : throw new illegal state exception ( str ) ; case echo : echo breakpoint storage . clear ( ) ; return ; case step : step breakpoint storage . clear ( ) ; return ; default : throw new illegal state exception ( string . format ( str , type ) ) ; } }	clears all echo breakpoints without notifying the listeners about the deleted breakpoints .
public enumeration content ( ) { return table . elements ( ) ; }	returns enumeration of the elements of the hashtable " table " , which are pair of the form ( pair link , symbolnode sn ).
@ override @ suppress warnings ( str ) public synchronized < t > t [ ] to array ( t [ ] contents ) { if ( element count > contents . length ) { return null ; } system . arraycopy ( element data , num , contents , num , element count ) ; if ( element count < contents . length ) { contents [ element count ] = null ; } return contents ; }	returns an array containing all elements contained in this vector.
public synchronized void clear dynamic properties ( ) throws replicator exception { logger . info ( str ) ; if ( dynamic properties != null ) dynamic properties . clear ( ) ; if ( dynamic properties file . exists ( ) ) { if ( ! dynamic properties file . delete ( ) ) logger . error ( str + dynamic properties file . get absolute path ( ) ) ; } if ( dynamic role file != null ) { if ( dynamic role file . exists ( ) ) { if ( ! dynamic role file . delete ( ) ) logger . error ( str + dynamic role file . get absolute path ( ) ) ; } } }	clear in - memory dynamic properties and delete on - disk file , if it exists .
public string pull requests url ( string account , string collection , string repo id ) { objects . require non null ( repo id , str ) ; return get team base url ( account , collection ) + format ( pull requests , repo id ) + get api version ( ) ; }	returns the url for pull requests .
protected abstract string default column name ( ) ;	returns default name for cassandra column ( if it ' s not specified explicitly ) .
private void publish rtf ( resource resource , big decimal version ) throws publication exception { if ( is locked ( resource . get shortname ( ) ) ) { throw new publication exception ( publication exception . type . locked , str + resource . get shortname ( ) + str ) ; } document doc = new document ( ) ; file rtf file = data dir . resource rtf file ( resource . get shortname ( ) , version ) ; output stream out = null ; try { out = new file output stream ( rtf file ) ; rtf writer2 . get instance ( doc , out ) ; eml2 rtf . write eml into rtf ( doc , resource ) ; } catch ( file not found exception e ) { throw new publication exception ( publication exception . type . rtf , str + rtf file . get absolute path ( ) , e ) ; } catch ( document exception e ) { throw new publication exception ( publication exception . type . rtf , str + rtf file . get absolute path ( ) , e ) ; } catch ( exception e ) { throw new publication exception ( publication exception . type . rtf , str + e . get message ( ) , e ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( io e ) { log . warn ( str ) ; } } } }	publishes a new version of the rtf file for the given resource .
public boolean connect to broker ( final mqtt async connection connection ) { try { connection . connect ( new mqtt callback handler ( connection ) , new mqtt async connection runnable ( connection ) ) ; return bool ; } catch ( spy exception e ) { platform . run later ( new mqtt event handler ( new mqtt connection attempt failure event ( connection , e ) ) ) ; logger . error ( e . get message ( ) , e ) ; } return bool ; }	connects the specified connection to a broker .
public void update packet size ( final big decimal packet size ) { m repeat packet size = m repeat packet size . add ( packet size ) ; }	update total packet size to be downloaded / uploaded .
private string base phone number ( ) throws parse exception { string builder s = new string builder ( ) ; if ( debug ) dbg enter ( str ) ; try { int lc = num ; while ( lexer . has more chars ( ) ) { char w = lexer . look ahead ( num ) ; if ( lexer . is digit ( w ) || w == str || w == str || w == str || w == str ) { lexer . consume ( num ) ; s . append ( w ) ; lc ++ ; } else if ( lc > num ) break ; else throw create parse exception ( str + w ) ; } return s . to string ( ) ; } finally { if ( debug ) dbg leave ( str ) ; } }	parser for the base phone number .
public org . smpte ra . schemas . st2067 2 2016 . content version type build content version type ( string id , org . smpte ra . schemas . st2067 2 2016 . user text type value ) { content version type content version type = new content version type ( ) ; content version type . set id ( id ) ; content version type . set label text ( value ) ; return content version type ; }	a method to construct a contentversiontype object conforming to the 2016 schema.
protected void refill buffer ( ) { if ( pendinglen > num || eof ) return ; try { offset = num ; pendinglen = stream . read ( buf ) ; if ( pendinglen < num ) { close ( ) ; return ; } else return ; } catch ( io e ) { throw new pngj input exception ( e ) ; } }	if there are not pending bytes to be consumed tries to fill the buffer with bytes from the stream .
private static input stream open system file ( string filename ) throws file not found exception { try { return new file input stream ( filename ) ; } catch ( file not found exception e ) { string resname = filename . replace ( file . separator char , str ) ; input stream result = class loader . get system resource as stream ( resname ) ; if ( result == null ) { throw e ; } return result ; } }	private copy from fileutil , to avoid cross - dependencies.
static pair < byte [ ] , long > decompose name ( column column ) { byte buffer name buffer ; if ( column . is set name ( ) ) { name buffer = column . buffer for name ( ) ; } else { name buffer = byte buffer . wrap ( column . get name ( ) ) ; } return decompose ( name buffer ) ; }	convenience method to get the name buffer for the specified column and decompose it into the name and timestamp .
public request handle delete ( string url , response handler interface response handler ) { return delete ( null , url , response handler ) ; }	perform a http delete request .
public void add language ( string language id ) { query . append ( str + language id ) ; }	adds a language limit to the query.
public static list < base mqtt message > process message log ( final list < logged mqtt message > list , final progress updater progress , final long current , final long max ) { final list < base mqtt message > mqtt message list = new array list < base mqtt message > ( ) ; long item = num ; for ( final logged mqtt message logged message : list ) { if ( progress != null ) { if ( progress . is cancelled ( ) ) { logger . info ( str ) ; return null ; } item ++ ; if ( item % num == num ) { progress . update ( current + item , max ) ; } } mqtt message list . add ( convert to base mqtt message ( logged message ) ) ; } logger . info ( str , list . size ( ) ) ; return mqtt message list ; }	turns the given list of loggedmqttmessages into receivedmqttmessages .
public request handle delete ( context context , string url , header [ ] headers , request params params , response handler interface response handler ) { http delete http delete = new http delete ( get url with query string ( is url encoding enabled , url , params ) ) ; if ( headers != null ) http delete . set headers ( headers ) ; return send request ( http client , http context , http delete , null , response handler , context ) ; }	perform a http delete request .
public int [ ] update remaining attributes ( int [ ] selected attributes , int best attribute ) { int [ ] remaining attributes ; if ( column table . represents nominal attribute ( best attribute ) ) { remaining attributes = remove attribute ( best attribute , selected attributes ) ; } else { remaining attributes = selected attributes ; } return remaining attributes ; }	if the bestattribute is nominal , its number is removed from the selectedattributes , otherwise it stays the same .
public final void add element ( int value ) { if ( ( m first free + num ) >= m map size ) { m map size += m blocksize ; int new map [ ] = new int [ m map size ] ; system . arraycopy ( m map , num , new map , num , m first free + num ) ; m map = new map ; } m map [ m first free ] = value ; m first free ++ ; }	append a int onto the vector .
int parse tr block content ( int current offset , char open quote , char close quote ) { int block start offset = current offset ; char sequence buffer = get buffer ( ) ; int buffer end = get buffer end ( ) ; boolean is escaped = bool ; boolean is quote differs = open quote != close quote ; int quotes level = num ; while ( current offset < buffer end ) { char current char = buffer . char at ( current offset ) ; if ( ! is escaped && quotes level == num && current char == close quote ) { if ( current offset > block start offset ) { push preparsed token ( block start offset , current offset , string content ) ; } break ; } if ( is quote differs && ! is escaped ) { if ( current char == open quote ) { quotes level ++ ; } else if ( current char == close quote ) { quotes level -- ; } } is escaped = ( current char == str && ! is escaped ) ; current offset ++ ; } return current offset ; }	parsing tr block content till close quote.
public boolean item exists ( string name ) throws jms { hash map body = ( hash map ) body ; return body . contains key ( name ) ; }	check if an item exists in this mapmessage.
@ override public boolean e is set ( int feature id ) { switch ( feature id ) { case sexec package . step comment : return comment edefault == null ? comment != null : ! comment edefault . equals ( comment ) ; case sexec package . step caller : return caller != null && ! caller . is empty ( ) ; } return super . e is set ( feature id ) ; }	< ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
public string to display string ( ) { return to display string ( locale . get default ( ) ) ; }	gets localized string describing the key using the default locale .
private boolean condition c ( string value , int index ) { return ( ( contains ( value , num , num , str , str ) || contains ( value , num , num , str ) ) || contains ( value , index - num , num , str , str , str ) || contains ( value , index + num , num , str , str ) || ( ( contains ( value , index - num , num , str , str , str , str ) || index == num ) && ( contains ( value , index + num , num , l r n m b h f v w space ) || index + num == value . length ( ) - num ) ) ) ; }	complex condition 1 for ' ch '.
public void remove elements ( final int from , final int to ) { char arrays . ensure from to ( size , from , to ) ; system . arraycopy ( a , to , a , from , size - to ) ; size -= ( to - from ) ; }	removes elements of this type - specific list using optimized system calls .
public synchronized void add ( date x , double y ) { super . add ( x . get time ( ) , y ) ; }	adds a new value to the series .
public static string smart quote ( string s ) { if ( s . contains ( str ) ) { return dumb quote ( s ) ; } else { return s ; } }	quotes string when spaces are detected.
static boolean sleep ( final double how much ) { try { thread . sleep ( ( int ) ( num * how much ) ) ; return bool ; } catch ( @ suppress warnings ( str ) final interrupted exception ) { return bool ; } }	the current spartanmovie is not releaseable.
public static d to awt rectangle ( final rectangle rect ) { final d rect2d = new d . double ( ) ; rect2d . set rect ( rect . x , rect . y , rect . width , rect . height ) ; return rect2d ; }	transform a swt rectangle instance into an awt one .
private void test bug71396 statement multi check ( connection test conn , string [ ] queries , int [ ] exp row count ) throws sql { if ( queries . length != exp row count . length ) { fail ( str ) ; } statement test stmt = test conn . create statement ( ) ; test bug71396 statement multi check ( test stmt , queries , exp row count ) ; test stmt . close ( ) ; }	executes a set of queries using a statement ( newly created ) and tests if the results count is the expected .
public string knn ( ) { return str + str ; }	returns the tip text for this property .
public void remove protocols ( final set < string > protocols ) { if ( protocols != null && protocols != null ) { hash set < string > remove protocols = new hash set < string > ( ) ; remove protocols . add all ( protocols ) ; protocols . remove all ( remove protocols ) ; } }	remove the protocols from set of protocols in virtualpool .
private list < file > find duplicate files ( list < file > files ) { hash set < file > source file set = new hash set < > ( ) ; list < file > duplicate files = new array list < > ( ) ; for ( file file : files ) { if ( ! source file set . contains ( file ) ) { source file set . add ( file ) ; } else { duplicate files . add ( file ) ; } } return duplicate files ; }	returns a list of all duplicate files found in the specified list of files .
public static byte [ ] bitmap to jpg ( final bitmap image , final int quality ) { if ( image == null ) return null ; byte array output stream ba = new byte array output stream ( ) ; if ( image . compress ( compress format . jpeg , quality , ba ) ) return ba . to byte array ( ) ; else return null ; }	bitmap into compressed jpeg.
public class < ? > load class ( string name ) throws class not found exception { return init class loader . load class ( name ) ; }	return the class with the given name .
public boolean add all ( collection c ) { object [ ] a = c . to array ( ) ; int num new = a . length ; ensure capacity ( size + num new ) ; system . arraycopy ( a , num , element data , size , num new ) ; size += num new ; return num new != num ; }	appends all of the elements in the specified collection to the end of this list , in the order that they are returned by the specified collection ' s iterator.
private void delete file if empty ( ) throws io { if ( files . size ( preferences file path ) == num ) { files . delete ( preferences file path ) ; } }	it may happen that the file is empty when the process is forcibly killed , so remove the file if that happened .
public static < t extends throwable > t read stack trace ( t throwable , stream input in ) throws io { final int stack trace elements = in . read v ( ) ; stack trace element [ ] stack trace = new stack trace element [ stack trace elements ] ; for ( int i = num ; i < stack trace elements ; i ++ ) { final string declaring classs = in . read string ( ) ; final string file name = in . read optional string ( ) ; final string method name = in . read string ( ) ; final int line number = in . read v ( ) ; stack trace [ i ] = new stack trace element ( declaring classs , method name , file name , line number ) ; } throwable . set stack trace ( stack trace ) ; int num suppressed = in . read v ( ) ; for ( int i = num ; i < num suppressed ; i ++ ) { throwable . add suppressed ( in . read throwable ( ) ) ; } return throwable ; }	deserializes stacktrace elements as well as suppressed exceptions from the given output stream and adds it to the given exception .
public static int scan ( long v ) { if ( v == num ) { return - num ; } return long . number of trailing zeros ( v ) ; }	utility method with defined return value for 0 .
public int output sequence count ( ) { return out regression seqs . size ( ) + out error seqs . size ( ) ; }	returns the total number of test sequences generated to output , including both regression tests and error - revealing tests .
private void write output files ( ) { if ( config . get output network file ( ) != null && config . get output schedule file ( ) != null ) { try { schedule tools . write transit schedule ( schedule , config . get output schedule file ( ) ) ; network tools . write network ( network , config . get output network file ( ) ) ; } catch ( exception e ) { log . error ( str ) ; long t = system . nano time ( ) / num ; try { schedule tools . write transit schedule ( schedule , t + str ) ; network tools . write network ( network , t + str ) ; } catch ( exception e1 ) { throw new runtime exception ( str ) ; } } if ( config . get output street network file ( ) != null ) { network tools . write network ( network tools . filter network by link mode ( network , collections . singleton ( transport mode . car ) ) , config . get output street network file ( ) ) ; } } else { log . info ( str ) ; log . info ( str ) ; } }	write the schedule and network to output files ( if defined in config ).
public static int value of ( string name ) { for ( int opcode = num ; opcode < name array . length ; ++ opcode ) { if ( name . equals ignore case ( name array [ opcode ] ) ) { return opcode ; } } throw new illegal argument exception ( str + name ) ; }	gets the opcode corresponding to a given mnemonic .
public void fixup variables ( java . util . vector vars , int globals size ) { if ( null != m arg vec ) { int n args = m arg vec . size ( ) ; for ( int i = num ; i < n args ; i ++ ) { expression arg = ( expression ) m arg vec . element at ( i ) ; arg . fixup variables ( vars , globals size ) ; } } }	this function is used to fixup variables from qnames to stack frame indexes at stylesheet build time .
public boolean cancel task ( task task ) { for ( thread runnable thread runnable : runable map . key set ( ) ) { if ( thread runnable . task == task ) { future future = runable map . remove ( thread runnable ) ; if ( future != null ) { future . cancel ( bool ) ; } return bool ; } } return bool ; }	cancel a single task.
static string internal to binary class name ( string class name ) { if ( class name == null ) { return null ; } else { return class name . replace ( str , str ) ; } }	utility that returns the fully qualified binary class name from a path - like fqcn.
public static string read string ( file file ) throws io { file input stream in = new file input stream ( file ) ; try { return read string ( in ) ; } finally { in . close ( ) ; } }	read the contents as a string from the given file .
public boolean has value ( ) { return ! values . is empty ( ) ; }	indicates whether this argument has at least one value .
protected static compare op convert to h ( comparison operator comp ) { if ( comp == comparison operator . equal || comp == comparison operator . like || comp == comparison operator . contains || comp == comparison operator . in || comp == comparison operator . is ) { return compare op . equal ; } else if ( comp == comparison operator . less ) { return compare op . less ; } else if ( comp == comparison operator . less or equal ) { return compare op . less or equal ; } else if ( comp == comparison operator . greater ) { return compare op . greater ; } else if ( comp == comparison operator . greater or equal ) { return compare op . greater or equal ; } else if ( comp == comparison operator . not equal || comp == comparison operator . not like || comp == comparison operator . not contains || comp == comparison operator . is not || comp == comparison operator . not in ) { return compare op . not equal ; } else { log . error ( str , comp ) ; throw new illegal argument exception ( str + comp + str + arrays . to string ( comparison operator . values ( ) ) ) ; } }	convert comparisonoperator to native hbase compareop support : = , = ~ , contains , < , < = , > , > = , ! = , ! = ~.
public t < t < ? , ? > , t > new args ( list < object > args ) { require non null ( args , str ) ; final t < t < ? , ? > , t > new args = new args ( ) ; final int size = args . size ( ) ; for ( int i = num ; i < size ; i ++ ) { new args . set field value ( arg fields [ i ] , args . get ( i ) ) ; } return new args ; }	returns a new arguments instance .
protected void do write ( http servlet request request , http servlet response response , string tunnel uuid ) throws guacamole exception { guacamole tunnel tunnel = get tunnel ( tunnel uuid ) ; response . set content type ( str ) ; response . set header ( str , str ) ; response . set content length ( num ) ; try { guacamole writer writer = tunnel . acquire writer ( ) ; reader input = new input stream reader ( request . get input stream ( ) , str ) ; try { int length ; char [ ] buffer = new char [ num ] ; while ( tunnel . is open ( ) && ( length = input . read ( buffer , num , buffer . length ) ) != - num ) writer . write ( buffer , num , length ) ; } finally { input . close ( ) ; } } catch ( guacamole connection closed exception e ) { logger . debug ( str , e ) ; } catch ( io e ) { deregister tunnel ( tunnel ) ; tunnel . close ( ) ; throw new guacamole server exception ( str + e . get message ( ) , e ) ; } finally { tunnel . release writer ( ) ; } }	called whenever the javascript guacamole client makes a write request.
public final void test add all helper texts from array ( ) { char sequence helper text1 = str ; char sequence helper text2 = str ; char sequence [ ] helper texts1 = new char sequence [ num ] ; helper texts1 [ num ] = helper text1 ; helper texts1 [ num ] = helper text2 ; password edit text password edit text = new password edit text ( get context ( ) ) ; password edit text . add all helper texts ( helper texts1 ) ; password edit text . add all helper texts ( helper texts1 ) ; collection < char sequence > helper texts2 = password edit text . get helper texts ( ) ; assert equals ( helper texts1 . length , helper texts2 . size ( ) ) ; iterator < char sequence > iterator = helper texts2 . iterator ( ) ; assert equals ( helper text1 , iterator . next ( ) ) ; assert equals ( helper text2 , iterator . next ( ) ) ; }	tests the functionality of the method , which allows to add all helper texts , which are contained by an array .
public static < t extends object & comparable < ? super t > > t min ( collection < ? extends t > collection ) { iterator < ? extends t > it = collection . iterator ( ) ; t min = it . next ( ) ; while ( it . has next ( ) ) { t next = it . next ( ) ; if ( min . compare to ( next ) > num ) { min = next ; } } return min ; }	searches the specified collection for the minimum element .
public static string join ( list < ? > things , string delim ) { string builder builder = new string builder ( ) ; boolean first = bool ; for ( object thing : things ) { if ( first ) { first = bool ; } else { builder . append ( delim ) ; } builder . append ( thing . to string ( ) ) ; } return builder . to string ( ) ; }	returns a list joined together by the provided delimiter , for example , [ " a " , " b " , " c " ] could be joined into " a , b , c ".
private void add url ( string url , string text ) { add token ( token for url ( url , text ) ) ; }	adds the appropriate token for the given url.
public void add system class ( soot class sc ) { all system classes . add ( sc ) ; }	add the given class to the list of system classes.
public i iv ( final i value ) { super ( dte . extension ) ; this . value = value ; }	ctor with internal value specified .
public void log and system out ( string message ) { log and system out ( message , null ) ; }	sends the message to both logger and system . out ( for unit report ).
static char random char ( ) { return ( char ) test util . next int ( random ( ) , str , str ) ; }	returns random character ( a - z ).
private void initialize key map ( access profile access profile ) { key map . put ( constants . db client , db client ) ; key map . put ( constants . accessprofile , access profile ) ; key map . put ( constants . props , access profile . get props ( ) ) ; key map . put ( constants . serial id , access profile . getserial id ( ) ) ; key map . put ( constants . native gui , sets . new hash set ( ) ) ; }	populate keymap with required attributes .
public static bounding box create ( vector coords ) { int length = coords . size ( ) ; if ( length <= num ) { throw new runtime exception ( str ) ; } coord [ ] coords array = new coord [ length ] ; coords . copy into ( coords array ) ; return create ( coords array ) ; }	/ create a smallest bounding box that contains all of the given coordinates.
public static boolean is empty ( char sequence str ) { if ( str == null || str . length ( ) == num ) return bool ; else return bool ; }	returns true if the string is null or 0 - length .
public percent escaper ( string safe chars , boolean plus for space ) { if ( safe chars . matches ( str ) ) { throw new illegal argument exception ( str + str ) ; } if ( plus for space && safe chars . contains ( str ) ) { throw new illegal argument exception ( str ) ; } if ( safe chars . contains ( str ) ) { throw new illegal argument exception ( str ) ; } this . plus for space = plus for space ; this . safe octets = create safe octets ( safe chars ) ; }	constructs a uri escaper with the specified safe characters and optional handling of the space character .
public fs resolve font ( shared context ctx , string [ ] families , float size , ident value weight , ident value style , ident value variant ) { list < font > fonts = new array list < font > ( num ) ; if ( families != null ) { for ( int i = num ; i < families . length ; i ++ ) { font font = resolve font ( ctx , families [ i ] , size , weight , style , variant ) ; if ( font != null ) { fonts . add ( font ) ; } } } string family = str ; if ( style == ident value . italic ) { family = str ; } font fnt = create font ( ctx , available fonts hash . get ( family ) , size , weight , style , variant ) ; instance hash . put ( get font instance hash name ( ctx , family , size , weight , style , variant ) , fnt ) ; fonts . add ( fnt ) ; return new awtfs ( fonts , size ) ; }	resolves a list of font families .
private int [ ] parse months ( string line ) { int [ ] months = new int [ num ] ; string [ ] numbers = line . split ( str ) ; if ( numbers . length != num ) { throw new illegal argument exception ( str + arrays . to string ( numbers ) + str + numbers . length ) ; } for ( int i = num ; i < num ; i ++ ) { try { months [ i ] = integer . value of ( numbers [ i ] ) ; } catch ( number format exception nfe ) { throw new illegal argument exception ( str + numbers [ i ] ) ; } } return months ; }	parses the 12 months lengths from a property value for a specific year .
private static int find closest ( int desired factor , set < integer > factors ) { int best factor = num ; int best delta = desired factor ; for ( integer factor : factors ) { int test delta = math . abs ( desired factor - factor ) ; if ( test delta < best delta ) { best delta = test delta ; best factor = factor ; } } return best factor ; }	finds the factor that is closest to the desired factor , from an ordered list of factors .
private static long dos to java time ( long dtime ) { @ suppress warnings ( str ) date d = new date ( ( int ) ( ( ( dtime > > num ) & num ) + num ) , ( int ) ( ( ( dtime > > num ) & num ) - num ) , ( int ) ( ( dtime > > num ) & num ) , ( int ) ( ( dtime > > num ) & num ) , ( int ) ( ( dtime > > num ) & num ) , ( int ) ( ( dtime << num ) & num ) ) ; return d . get time ( ) ; }	converts dos time to java time ( number of milliseconds since epoch ) .
private void overshadow rect ( final d rect , final d g ) { d g2 = ( d ) g . create ( ) ; g2 . set color ( gray out ) ; g2 . fill ( rect ) ; g2 . dispose ( ) ; }	shadows the given rectangle.
private security function entity create security function entity ( string code ) { security function entity security function entity = new security function entity ( ) ; security function entity . set code ( code ) ; return herd dao . save and refresh ( security function entity ) ; }	creates and persists a security function entity .
public static < t > list < t > to list ( t obj1 ) { list < t > list = new linked list < t > ( ) ; list . add ( obj1 ) ; return list ; }	create a list from passed objx parameters.
public string to string ( final string name , final string header ) { final map < string , integer > items = contents . get ( name ) ; final string builder sb = new string builder ( header + str ) ; for ( final entry < string , integer > entry : items . entry set ( ) ) { sb . append ( entry . get key ( ) + str + entry . get value ( ) + str ) ; } return sb . to string ( ) ; }	converts a shop into a human readable form.
private void process e ( ) { }	create reauest / updates from email.
speed predictor ( ) { times = new double [ vector length ] ; wt window manager wm = wt window manager . get instance ( ) ; prediction = math helper . parse double default ( wm . get property ( speed property , double . to string ( initial predicted speed ) ) , initial predicted speed ) ; jitter = math helper . parse double ( wm . get property ( jitter property , str ) ) ; double average = turn length / prediction ; for ( int i = num ; i < vector length ; i ++ ) { times [ i ] = average ; } }	create a new speedpredictor with default initial prediction and history corresponding to that .
@ deactivate public void deactivate ( component context context ) { logger . debug ( str , config . get ( constants . service pid ) ) ; config = null ; authenticators . clear ( ) ; if ( auth filter wrapper != null ) { try { auth filter wrapper . reset ( ) ; } catch ( exception ex ) { logger . warn ( str , ex . get message ( ) , ex ) ; } } }	nulls the stored authentication jsonvalue .
public void write ( array list < key value > metadata , long image start , raster raster , data type data type ) throws io { output stream o stream = new file output stream ( file path ) ; if ( o stream != null ) { output stream = new buffered output stream ( o stream ) ; } label parser parser = new label parser ( ) ; buffered writer writer = new buffered writer ( new output stream writer ( output stream ) ) ; long size = parser . write object ( writer , metadata , str ) ; long pad = image start - size ; for ( int i = num ; i < pad ; ++ i ) { writer . write ( str ) ; } writer . flush ( ) ; data stream = new data output stream ( output stream ) ; write raster ( raster , data type ) ; }	write a raster to a file .
static void clean up ( ir ir ) { for ( enumeration < instruction > e = ir . forward instr enumerator ( ) ; e . has more elements ( ) ; ) { instruction s = e . next element ( ) ; if ( s . operator ( ) == pi ) { register operand result = guarded unary . get result ( s ) ; operator mv = ir . get move op ( result . get type ( ) ) ; operand val = guarded unary . get val ( s ) ; move . mutate ( s , mv , result , val ) ; } } ir . actual ssa = null ; }	change all pi nodes to int_move instructions < p > side effect : invalidates ssa state.
public string generate file name ( ) { return new unique test id ( ) . id + str + get current test class name ( ) + str + get current test method name ( ) + str + get current test method line number ( ) ; }	generates the filename for screenshot.
public backup upload status query backup upload status ( ) { coordinator client coordinator client = coordinator . get coordinator client ( ) ; configuration cfg = coordinator client . query configuration ( coordinator client . get site id ( ) , backup constants . backup upload status , constants . global id ) ; map < string , string > all items = ( cfg == null ) ? new hash map < string , string > ( ) : cfg . get all configs ( bool ) ; backup upload status upload status = new backup upload status ( all items ) ; log . info ( str , upload status ) ; return upload status ; }	query upload status from zk.
@ override public int process ( callback [ ] callbacks , int state ) throws login exception { switch ( state ) { case is . login start : { set user session property ( jwt session module . token idle time in minutes claim key , token idle time . to string ( ) ) ; set user session property ( jwt session module . max token life in minutes key , max token life . to string ( ) ) ; set user session property ( enforce client ip setting key , boolean . to string ( enforce client ip ) ) ; set user session property ( secure cookie key , boolean . to string ( secure cookie ) ) ; set user session property ( http only cookie key , boolean . to string ( http only cookie ) ) ; if ( cookie name != null ) { set user session property ( cookie name key , cookie name ) ; } string cookie domains string = str ; for ( string cookie domain : cookie domains ) { cookie domains string += cookie domain + str ; } set user session property ( cookie domains key , cookie domains string ) ; set user session property ( hmac key , encrypted hmac key ) ; final subject client subject = new subject ( ) ; message info message info = persistent cookie module wrapper . prepare message info ( get http servlet request ( ) , get http servlet response ( ) ) ; if ( process ( message info , client subject , callbacks ) ) { if ( principal != null ) { set authenticating user name ( principal . get name ( ) ) ; } return is . login succeed ; } throw new auth login exception ( auth resource bundle name , str , null ) ; } default : { throw new auth login exception ( auth resource bundle name , str , null ) ; } } }	overridden as to call different method on underlying jaspi jwtsessionmodule .
private int distance2 ( point p0 , point p1 ) { int d0 = math . abs ( p0 . x - p1 . x ) ; int d1 = math . abs ( p0 . y - p1 . y ) ; return d0 * d0 + d1 * d1 ; }	returns the distance to the power of 2 between two points.
public json writer ( o o data uri , entity data model entity data model ) { this . odata uri = check not null ( o data uri ) ; this . entity data model = check not null ( entity data model ) ; expanded properties . add all ( as java list ( get simple expand property names ( o data uri ) ) ) ; }	create an odata json writer .
protected static die die ( string why ) { return new die ( why ) ; }	create a new exception to indicate we won ' t continue .
public builder with solr xml ( path solr xml ) { try { this . solrxml = new string ( files . read all bytes ( solr xml ) , charset . default charset ( ) ) ; } catch ( io e ) { throw new runtime exception ( e ) ; } return this ; }	read solr . xml from the provided path.
public double double value ( ) { if ( val instanceof long || val instanceof integer ) { return ( double ) ( val . long value ( ) ) ; } return val . double value ( ) ; }	returns a double numeric value.
public void prune ( ) { const pool cp = compact0 ( ) ; array list new attributes = new array list ( ) ; attribute info invisible annotations = get attribute ( annotations attribute . invisible tag ) ; if ( invisible annotations != null ) { invisible annotations = invisible annotations . copy ( cp , null ) ; new attributes . add ( invisible annotations ) ; } attribute info visible annotations = get attribute ( annotations attribute . visible tag ) ; if ( visible annotations != null ) { visible annotations = visible annotations . copy ( cp , null ) ; new attributes . add ( visible annotations ) ; } attribute info signature = get attribute ( signature attribute . tag ) ; if ( signature != null ) { signature = signature . copy ( cp , null ) ; new attributes . add ( signature ) ; } array list list = methods ; int n = list . size ( ) ; for ( int i = num ; i < n ; ++ i ) { method info minfo = ( method info ) list . get ( i ) ; minfo . prune ( cp ) ; } list = fields ; n = list . size ( ) ; for ( int i = num ; i < n ; ++ i ) { field info finfo = ( field info ) list . get ( i ) ; finfo . prune ( cp ) ; } attributes = new attributes ; const pool = cp ; }	discards all attributes , associated with both the class file and the members such as a code attribute and exceptions attribute.
public void end group ( ) { stream . println ( str ) ; }	ends the current group .
public void test float value minus zero ( ) { string a = str ; big decimal a number = new big decimal ( a ) ; int minus zero = - num ; float result = a number . float value ( ) ; assert true ( str , float . float to int bits ( result ) == minus zero ) ; }	float value of a small negative bigdecimal.
public static parameter type make file parameter type ( parameter handler parameter handler , string parameter name , string description , port provider port provider , string ... file extensions ) { return make file parameter type ( parameter handler , parameter name , description , port provider , bool , file extensions ) ; }	creates the file parameter named by fileparametername that depends on whether or not the port returned by the given portprovider is connected .
public void save ( string key , object data , boolean is encrypted , string encrypt key ) { key = safety key ( key ) ; string wrapper json ; if ( data instanceof record ) { type type = jolyglot . new parameterized type ( data . get class ( ) , object . class ) ; wrapper json = jolyglot . to json ( data , type ) ; } else { wrapper json = jolyglot . to json ( data ) ; } file writer file writer = null ; try { file file = new file ( cache directory , key ) ; file writer = new file writer ( file , bool ) ; file writer . write ( wrapper json ) ; file writer . flush ( ) ; file writer . close ( ) ; file writer = null ; if ( is encrypted ) { file encryptor . encrypt ( encrypt key , new file ( cache directory , key ) ) ; } } catch ( exception e ) { throw new runtime exception ( e ) ; } finally { try { if ( file writer != null ) { file writer . flush ( ) ; file writer . close ( ) ; } } catch ( io e ) { e . print stack trace ( ) ; } } }	save in disk the object passed .
private void backup screens ( backup data output data ) throws io { content resolver cr = m context . get content resolver ( ) ; cursor cursor = cr . query ( launcher settings . workspace screens . content uri , screen projection , null , null , null ) ; try { cursor . move to position ( - num ) ; if ( debug ) log . d ( tag , str + m last backup restore time ) ; while ( cursor . move to next ( ) ) { final long id = cursor . get long ( id index ) ; final long update time = cursor . get long ( id modified ) ; key key = get key ( key . screen , id ) ; m keys . add ( key ) ; final string backup key = key to backup key ( key ) ; if ( ! m existing keys . contains ( backup key ) || update time >= m last backup restore time ) { write row to backup ( key , pack screen ( cursor ) , data ) ; } else { if ( verbose ) log . v ( tag , str + id ) ; } } } finally { cursor . close ( ) ; } }	write all modified screens to the data stream .
public static double simple test ( double [ ] test ) { double scale = num / ( test . length + num ) ; double maxdev = double . negative infinity ; for ( int i = num ; i < test . length ; i ++ ) { double expected = ( i + num ) * scale ; double dev = math . abs ( test [ i ] - expected ) ; if ( dev > maxdev ) { maxdev = dev ; } } return math . abs ( maxdev ) ; }	simplest version of the test : test if a sorted array is approximately uniform distributed on [ 0 : 1 ] .
private void open line ( boolean first entry ) throws io { if ( first entry ) { out . append ( str ) ; } }	begin the entry for a new line .
private long [ ] convert to array ( map < string , long > map , int size , boolean unit offset ) { long [ ] values = new long [ size ] ; int array offset = unit offset ? - num : num ; for ( map . entry < string , long > cursor : map . entry set ( ) ) { int offset = integer . parse int ( cursor . get key ( ) ) + array offset ; values [ offset ] = cursor . get value ( ) ; } return values ; }	will convert a ( possibly sparse ) map whose keys are string versions of numbers between 0 and size , to an array .
private static void sort anonymous ( list < i > anonymous , i anon type ) { source offset comparator source comparator = new source offset comparator ( ) ; final anonym class comparator class comparator = new anonym class comparator ( anon type , source comparator ) ; collections . sort ( anonymous , class comparator ) ; }	sort given anonymous classes in order like java compiler would generate output classes , in context of given anonymous type.
public static boolean is default use internal browser ( ) { return browser util . can use internal web browser ( ) ; }	returns whether the internal browser is used by default.
public ns [ ] objects at indexes ( int ... indexes ) { ns [ ] result = new ns [ indexes . length ] ; arrays . sort ( indexes ) ; for ( int i = num ; i < indexes . length ; i ++ ) result [ i ] = array [ indexes [ i ] ] ; return result ; }	returns a new array containing only the values stored at the given indices.
private static entry [ ] concat ( entry [ ] attrs1 , entry [ ] attrs2 ) { entry [ ] nattrs = new entry [ attrs1 . length + attrs2 . length ] ; system . arraycopy ( attrs1 , num , nattrs , num , attrs1 . length ) ; system . arraycopy ( attrs2 , num , nattrs , attrs1 . length , attrs2 . length ) ; return nattrs ; }	return a concatenation of the two arrays .
public static list < shape record > rectangle ( double start x , double start y , double width , double height ) { list < shape record > shape records = new array list < shape record > ( ) ; shape records . add ( move ( start x , start y ) ) ; shape records . add all ( straight edge ( start x , start y , width , start y ) ) ; shape records . add all ( straight edge ( width , start y , width , height ) ) ; shape records . add all ( straight edge ( width , height , start x , height ) ) ; shape records . add all ( straight edge ( start x , height , start x , start y ) ) ; return shape records ; }	creates a list of shaperecord to draw a rectangle from the given origin ( startx , starty ) for the specified width and height ( in pixels ) .
public glow server ( server config config ) { material value manager = new builtin material value manager ( ) ; this . config = config ; ops list = new uuid list file ( config . get file ( str ) ) ; whitelist = new uuid list file ( config . get file ( str ) ) ; name bans = new glow ban list ( this , type . name ) ; ip bans = new glow ban list ( this , type . ip ) ; bukkit . set server ( this ) ; load config ( ) ; }	creates a new server .
public fps remove child ( @ non null display base display base ) { display base . disable ( ) ; boolean a = m display list . remove ( display base ) ; return this ; }	removes the specified child from the display list .
static int mid pt ( final int a , final int b ) { return a + ( b - a ) / num ; }	returns the middle point between two values.
public static reactive seq < double > from double stream ( final double stream stream ) { objects . require non null ( stream ) ; return stream utils . reactive seq ( stream . boxed ( ) , optional . empty ( ) ) ; }	construct a reactiveseq from a stream.
string format ( date source , string buffer to append to ) { return source . to string ( ) ; }	format a given date .
public static list < string > available instances ( ) throws io { path conf path = paths . get ( system properties . get configuration proxy conf path ( ) ) ; return sub directory names ( conf path ) ; }	gets all existing subdirectory names from the configuration proxy configuration directory , which correspond to the configuration proxy instance ids .
public lazy future stream < integer > from ( final int stream stream ) { return from stream ( stream . boxed ( ) ) ; }	start a reactive dataflow from a stream .
protected void reset options ( ) { m train selector = new weka . attribute selection . attribute selection ( ) ; set evaluator ( new cfs subset eval ( ) ) ; set search ( new best first ( ) ) ; m = null ; }	set options to their default values.
protected void limit trans and scale ( matrix matrix ) { float [ ] vals = new float [ num ] ; matrix . get values ( vals ) ; float cur trans x = vals [ matrix . mtrans x ] ; float cur scale x = vals [ matrix . mscale x ] ; m scale x = math . max ( num , math . min ( get max scale ( ) , cur scale x ) ) ; float max trans x = - ( float ) m content rect . width ( ) * ( m scale x - num ) ; float new trans x = math . min ( math . max ( cur trans x , max trans x ) , num ) ; vals [ matrix . mtrans x ] = new trans x ; vals [ matrix . mscale x ] = m scale x ; matrix . set values ( vals ) ; }	limits the maximum scale and x translation of the given matrix.
public void test get input encoding ( ) throws exception { assert equals ( str , document a . get input encoding ( ) ) ; assert equals ( str , document b . get input encoding ( ) ) ; }	xml parsers are advised of the document ' s character set via two channels : via the declaration and also the document ' s input source.
protected void close dialog ok ( ) { dispose ( ) ; }	overrideen to perform specific clean up when dialog closed .
public static boolean is dangerous ( double d ) { return double . is infinite ( d ) || double . is na n ( d ) || d == num ; }	returns true if the argument is a " dangerous " double to have around , namely one that is infinite , nan or zero .
public static byte [ ] from base58 with checksum ( string s ) throws hyper ledger exception { byte [ ] b = from base58 ( s ) ; if ( b . length < num ) { throw new hyper ledger exception ( str + s ) ; } byte [ ] cs = new byte [ num ] ; system . arraycopy ( b , b . length - num , cs , num , num ) ; byte [ ] data = new byte [ b . length - num ] ; system . arraycopy ( b , num , data , num , b . length - num ) ; byte [ ] h = new byte [ num ] ; system . arraycopy ( hash . hash ( data ) , num , h , num , num ) ; if ( arrays . equals ( cs , h ) ) { return data ; } throw new hyper ledger exception ( str + s ) ; }	decode from base58 assuming a trailing checksum of four bytes.
public collection < class < ? extends closeable > > shard services ( ) { return collections . empty list ( ) ; }	per index shard service that will be automatically closed .
public static sparse int array adjust position ( sparse int array positions , int start position , int end position , int adjust by ) { sparse int array new positions = new sparse int array ( ) ; for ( int i = num , size = positions . size ( ) ; i < size ; i ++ ) { int position = positions . key at ( i ) ; if ( position < start position || position > end position ) { new positions . put ( position , positions . value at ( i ) ) ; } else if ( adjust by > num ) { new positions . put ( position + adjust by , positions . value at ( i ) ) ; } else if ( adjust by < num ) { if ( position > start position + adjust by && position <= start position ) { ; } else { new positions . put ( position + adjust by , positions . value at ( i ) ) ; } } } return new positions ; }	internal method to handle the selections if items are added / removed.
public int compare ( object o1 , object o2 ) { string s1 = o1 . to string ( ) ; if ( s1 == null ) s1 = str ; string s2 = o2 . to string ( ) ; if ( s2 == null ) s2 = str ; return s1 . compare to ( s2 ) ; }	compare based on name.
private final array list < awtree node leaf > to array ( ) { array list < awtree node leaf > result = new array list < awtree node leaf > ( leaf count ) ; awtree node curr node = root node ; if ( curr node == null ) return result ; for ( ; ; ) { while ( curr node instanceof awtree node fork ) { curr node = ( ( awtree node fork ) curr node ) . first child ; } result . add ( ( awtree node leaf ) curr node ) ; awtree node fork curr parent = curr node . parent ; while ( curr parent != null && curr parent . second child == curr node ) { curr node = curr parent ; curr parent = curr node . parent ; } if ( curr parent == null ) break ; curr node = curr parent . second child ; } return result ; }	inserts the leaves of this tree into an array list.
public void unregister ( ) throws payload exception , network exception { if ( s logger . is activated ( ) ) { s logger . debug ( str ) ; } m registration . de register ( ) ; m sip . close stack ( ) ; }	unregister from the ims.
public static int list find ( string list , string value ) { return list find ( list , value , str ) ; }	finds a value inside a list , case sensitive.
public flac stream reader ( random access file raf ) { this . raf = raf ; }	create instance for holding stream info.
public final void skip until ( final double when ) { this . skip until = when ; }	allow this snapshotgenerator to skip all snapshots up to , but not including , a give timestep.
public static byte [ ] serialize to byte array ( serializable value ) { try { byte array output stream buffer = new byte array output stream ( ) ; try ( object output stream oos = new object output stream ( new snappy output stream ( buffer ) ) ) { oos . write object ( value ) ; } return buffer . to byte array ( ) ; } catch ( io exn ) { throw new illegal argument exception ( str + value , exn ) ; } }	serializes the argument into an array of bytes , and returns it .
@ override public set < statement > gather ( final igas < set < statement > , set < statement > , set < statement > > state , final value u , final statement e ) { return collections . singleton ( e ) ; }	return the edge as a singleton set .
public void run ( e start ) { run ( collections . singleton ( start ) ) ; }	computes shortest paths to nodes in the graph .
private boolean too big ( basic block bb , int max cost ) { int cost = num ; for ( enumeration < instruction > e = bb . forward real instr enumerator ( ) ; e . has more elements ( ) ; ) { instruction s = e . next element ( ) ; if ( s . is call ( ) ) { cost += num ; } else if ( s . is allocation ( ) ) { cost += num ; } else { cost ++ ; } if ( cost > max cost ) return bool ; } return bool ; }	simplistic cost estimate ; since we are doing the splitting based on static hints , we are only willing to copy a very small amount of code .
@ override public boolean add entry ( principal caller , acl entry entry ) throws not owner exception { if ( ! is owner ( caller ) ) throw new not owner exception ( ) ; if ( entry list . contains ( entry ) ) return bool ; entry list . add element ( entry ) ; return bool ; }	adds an acl entry to this acl.
private boolean has colinear ( pla point int a point ) { int count = point alist . size ( ) ; if ( count < num ) return bool ; for ( int index = num ; index < count - num ; index ++ ) { pla point int start = point alist . get ( index ) ; pla point int end = point alist . get ( index + num ) ; if ( a point . side of ( start , end ) != pla side . collinear ) continue ; double d start p = start . distance square ( a point ) ; double d p end = a point . distance square ( end ) ; double d start end = start . distance square ( end ) ; if ( d start end >= d start p ) { if ( d start end >= d p end ) { return bool ; } else { point alist . set ( index , a point ) ; return bool ; } } else { if ( d start end >= d p end ) { point alist . set ( index + num , a point ) ; return bool ; } else { point alist . set ( index , a point ) ; return bool ; } } } return bool ; }	return true if the given point is colinear with two points in the list and should not be added now , the issue is that this point may be colinear ( on the same line ) but further away , so , it should be the one being kept , not the one currently in the list.
protected void incorporate digest method ( final element parent dom , final digest algorithm digest algorithm ) { final element digest method dom = document dom . create element ns ( xmlns , ds digest method ) ; final string digest algorithm xml id = digest algorithm . get xml id ( ) ; digest method dom . set attribute ( algorithm , digest algorithm xml id ) ; parent dom . append child ( digest method dom ) ; }	this method creates the ds : digestmethod dom object.
public static boolean is xm ( string name ) { final int length = name . length ( ) ; if ( length == num ) { return bool ; } int i = num ; char ch = name . char at ( num ) ; if ( ! is xm ( ch ) ) { if ( length > num && is xm ( ch ) ) { char ch2 = name . char at ( num ) ; if ( ! xml . is low surrogate ( ch2 ) || ! is xm ( xml . supplemental ( ch , ch2 ) ) ) { return bool ; } i = num ; } else { return bool ; } } while ( i < length ) { ch = name . char at ( i ) ; if ( ! is xm ( ch ) ) { if ( ++ i < length && is xm ( ch ) ) { char ch2 = name . char at ( i ) ; if ( ! xml . is low surrogate ( ch2 ) || ! is xm ( xml . supplemental ( ch , ch2 ) ) ) { return bool ; } } else { return bool ; } } ++ i ; } return bool ; }	check to see if a string is a valid name according to [ 5 ] in the xml 1 . 1 recommendation.
public string resolve path ( string path info ) { if ( ( path info == null ) || ( path info . index of ( str ) != - num ) ) { return null ; } int lib start = path info . index of ( str ) + num ; int lib end = path info . index of ( str , lib start ) ; if ( lib end == - num ) { lib end = path info . length ( ) ; } string libname = path info . substring ( lib start , lib end ) ; string subpath = path info . substring ( lib end ) ; string lib home = get path ( libname ) ; if ( lib home == null ) { return null ; } return lib home + str + subpath ; }	return a file object that the path resolves to.
protected int range upper ( string range ) { int hyphen index ; if ( ( hyphen index = range . index of ( str ) ) >= num ) { return math . max ( range upper ( range . substring ( num , hyphen index ) ) , range upper ( range . substring ( hyphen index + num ) ) ) ; } return range single ( range ) ; }	translates a range into it ' s upper index.
@ override public boolean equals ( object that ) { try { if ( that == null ) { return bool ; } rule based break iterator other = ( rule based break iterator ) that ; if ( checksum != other . checksum ) { return bool ; } if ( text == null ) { return other . text == null ; } else { return text . equals ( other . text ) ; } } catch ( class cast exception e ) { return bool ; } }	returns true if both breakiterators are of the same class , have the same rules , and iterate over the same text .
public static string extract response ( i log , string writer sw ) { string saml response field = str ; string response as string = sw . to string ( ) ; log . debug ( str + response as string ) ; int index = response as string . index of ( saml response field ) ; assert true ( index >= num ) ; int start index = index + saml response field . length ( ) ; int end index = response as string . index of ( str , start index ) ; assert true ( end index >= num ) ; string encoded saml response = response as string . substring ( start index , end index ) ; string decoded saml response = new string ( base64 . decode ( encoded saml response ) ) ; return decoded saml response ; }	extract saml response which was written to a stream.
public void test pow negative num to even exp ( ) { byte a bytes [ ] = { num , - num , num , num , num , num , num , - num , - num , num } ; int a sign = - num ; int exp = num ; byte r bytes [ ] = { num , num , - num , - num , - num , - num , - num , num , - num , num , - num , num , num , num , - num , - num , num , num , - num , num , num , - num , num , - num , - num , num , - num , num , num , num , - num , - num , num , - num , - num , - num , - num , - num , - num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer result = a number . pow ( exp ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	exponentiation of a negative number to an even exponent .
public void put attribute ( final string attr id , final list lt values ) { if ( map == null ) { map = new hash map ( ) ; } map . put ( attr id . to lower case ( ) , new vo ( attr id . to lower case ( ) , lt values ) ) ; }	permite aniadir un atributo a la entrada ldap.
protected java file object preferred file object ( java file object a , java file object b ) { if ( prefer source ) return ( a . get kind ( ) == java file object . kind . source ) ? a : b ; else { long adate = a . get last modified ( ) ; long bdate = b . get last modified ( ) ; return ( adate > bdate ) ? a : b ; } }	implement policy to choose to derive information from a source file or a class file when both are present.
public void evaluate ( final multivariate function evaluation function , final comparator < point value pair > comparator ) { for ( int i = num ; i < simplex . length ; i ++ ) { final point value pair vertex = simplex [ i ] ; final double [ ] point = vertex . get point ref ( ) ; if ( double . is na n ( vertex . get value ( ) ) ) { simplex [ i ] = new point value pair ( point , evaluation function . value ( point ) , bool ) ; } } arrays . sort ( simplex , comparator ) ; }	evaluate all the non - evaluated points of the simplex .
public void test to engineering string zero neg exponent ( ) { string a = str ; big decimal a number = new big decimal ( a ) ; string result = str ; assert equals ( str , result , a number . to engineering string ( ) ) ; }	convert a negative bigdecimal to an engineering string representation.
public select clause add ( expression expression ) { select list . add ( new select clause expression ( expression ) ) ; return this ; }	adds an expression to the select clause .
private void attempt response ( inet socket address addr , int timeout ) throws exception { socket s = new socket ( ) ; try { s . connect ( addr , timeout ) ; respond ( s ) ; } finally { try { s . close ( ) ; } catch ( io e ) { logger . log ( levels . handled , str , e ) ; } } }	attempt a connection to multicast request client.
protected void add to port map ( iof sw , mac address mac , vlan vid vlan , of port val ) { map < mac vlan pair , of > sw map = mac vlan to switch port map . get ( sw ) ; if ( vlan == vlan vid . full mask ) { vlan = vlan vid . of vlan ( num ) ; } if ( sw map == null ) { sw map = collections . synchronized map ( new lru < mac vlan pair , of > ( max macs per switch ) ) ; mac vlan to switch port map . put ( sw , sw map ) ; } sw map . put ( new mac vlan pair ( mac , vlan ) , port val ) ; }	adds a host to the mac / vlan - > switchport mapping.
public void save ( ) throws sso , sms { if ( read only ) { if ( debug . warning enabled ( ) ) { debug . warning ( str + str + dn ) ; } throw ( new sms ( sms . status no permission , str ) ) ; } save ( sso token ) ; }	save the modification ( s ) to the object.
public error dialog ( final safe html message ) { this ( ) ; body . add ( message . to block widget ( ) ) ; }	create a dialog box to show a single message string .
public list < annotation > find by project ( app context app , pk project pk , string order by ) { list < data store query field > query fields = new array list < data store query field > ( num ) ; query fields . add ( new data store query field ( str , project pk . get project id ( ) ) ) ; return super . find ( app , project pk , query fields , find by project cache , order by ) ; }	find a list of annotations of a given project .
private void add to map ( locator reg reg ) { undiscovered locators . add ( reg ) ; queue discovery task ( reg ) ; }	adds the given locatorreg object to the set containing the objects corresponding to the locators of desired lookup services that have not yet been discovered , and queues a discoverytask to attempt , through unicast discovery , to discover the associated lookup service .
public static string [ ] create fixed random strings ( int count ) { string [ ] strings = new string [ count ] ; random length random = new random ( ) ; length random . set seed ( seed ) ; random string random = new random ( ) ; string random . set seed ( seed ) ; for ( int i = num ; i < count ; i ++ ) { int next length = length random . next int ( max length - min length - num ) ; next length += min length ; strings [ i ] = random string utils . random ( next length , num , chars . length , bool , bool , chars , string random ) ; } return strings ; }	creates the same random sequence of strings .
protected void create filter toolbar ( ) { timer = new timer ( num , null ) ; timer . set initial delay ( num ) ; timer . set action command ( cmd filter changed ) ; timer . set repeats ( bool ) ; search filter = new search filter ( ) ; search filter . set filter text ( string utils . empty ) ; }	create the search filter for the toolbar.
public parse header state ( http headers headers , string builder logger ) { class < ? extends http headers > clazz = headers . get class ( ) ; this . context = arrays . < type > as list ( clazz ) ; this . class info = class info . of ( clazz , bool ) ; this . logger = logger ; this . array value map = new array value map ( headers ) ; }	initializes a new parseheaderstate .
void update day counter ( final long new messages ) { gregorian calendar cal = new gregorian calendar ( ) ; int current index = cal . get ( calendar . hour of day ) ; boolean b update = bool ; for ( int i = num ; i <= current index ; i ++ ) { if ( counters [ i ] > - num ) { b update = bool ; } if ( b update == bool ) { if ( counters [ i ] == - num ) { counters [ i ] = num ; } } } counters [ current index ] += new messages ; }	update day counter hour array elements.
public float read float ( ) throws io { return dis . read float ( ) ; }	read a float from the input stream .
private < t > stream < collection < t > > partitioned stream ( iterator < t > iterator ) { return stream support . stream ( spliterators . spliterator unknown size ( iterators . partition ( iterator , batch size ) , spliterator . ordered ) , bool ) ; }	partition a stream into a stream of collections , each with batchsize elements .
public void remove last ( ) { data change event [ ] events ; synchronized ( this ) { int row = get row count ( ) - num ; row r = new row ( this , row ) ; events = new data change event [ get column count ( ) ] ; for ( int col = num ; col < events . length ; col ++ ) { events [ col ] = new data change event ( this , col , row , r . get ( col ) , null ) ; } rows . remove ( row ) ; } notify data removed ( events ) ; }	removes the last row from the table .
public custom entry concurrent hash map ( final map < ? extends k , ? extends v > m ) { this ( math . max ( ( int ) ( m . size ( ) / default load factor ) + num , default initial capacity ) , default load factor , default concurrency level , bool ) ; put all ( m ) ; }	creates a new map with the same mappings as the given map.
public file read stream ( ) { }	create a new filereadstream .
public static string quote ( string s ) { if ( s == null ) return null ; if ( s . length ( ) == num ) return str ; string buffer b = new string buffer ( s . length ( ) + num ) ; quote ( b , s ) ; return b . to string ( ) ; }	quote a string . the string is quoted only if quoting is required due to embeded delimiters , quote characters or the empty string .
public void query sorted ( string type , int index , boolean ascending , int page , int limit , int visibility scope , cloud response < cloud object [ ] > response ) { try { query impl ( type , null , num , page , limit , visibility scope , num , index , ascending , bool , bool , response ) ; } catch ( cloud exception e ) { response . on error ( e ) ; } }	performs a query to the server finding the objects where the sort is equal to the given value.
private void log message ( string msg , object [ ] obj ) { if ( monitoring properties loader . is to log indications ( ) ) { logger . debug ( str + msg , obj ) ; } }	log the messages . this method eliminates the logging condition check every time when we need to log a message .
public void action performed ( action event e ) { action map map = tab pane . get action map ( ) ; if ( map != null ) { string action key ; if ( e . get source ( ) == scroll forward button ) { action key = str ; } else { action key = str ; } action action = map . get ( action key ) ; if ( action != null && action . is enabled ( ) ) { action . action performed ( new action event ( tab pane , action event . action performed , null , e . get when ( ) , e . get modifiers ( ) ) ) ; } } }	actionlistener for the scroll buttons .
public double entropy ( int g , int lag ) { double h = num ; int n = cases . length - lag ; double ln2 = math . log ( num ) ; int n0 = num ; for ( int i = num ; i < n ; i ++ ) { if ( cases [ i + lag ] [ g ] == num ) { n0 ++ ; } } double p ; if ( n0 == num || n0 == n ) { return h ; } else { p = ( double ) n0 / ( double ) n ; h = - ( p * math . log ( p ) + ( num - p ) * math . log ( num - p ) ) / ln2 ; } return h ; }	this method implements the same definition of entropy as above but this specialized version is intended to be used by the mutualinformation method ( viz ).
public on update clause add assignment ( expression expression ) { assignments . add ( new assignment ( expression ) ) ; return this ; }	adds a variable to set to the clause .
public short read short be ( ) throws io { return input stream . read short ( ) ; }	read a 16bit short in be.
public boolean remove metric collector ( final i c ) { if ( c == null ) throw new illegal argument exception ( ) ; return metric collectors . remove ( c ) ; }	remove a metrics collector .
private void fill comment combo ( combo combo ) { if ( previous comments == null ) { previous comments = new array list ( ) ; } for ( int i = previous comments . size ( ) - num ; i >= num ; i -- ) { combo . add ( ( ( string ) previous comments . get ( i ) ) ) ; } combo . select ( num ) ; }	fill the comments combobox with previous search entries .
public static synchronized void remove from disabled list ( string classname ) { disabled . remove ( classname ) ; }	remove the supplied fully qualified class name from the list of disabled plugins.
public void refresh ( cloud object [ ] objects , cloud response < integer > response ) { refresh impl ( objects , response ) ; }	refresh the given objects with data from the server if they were modified on the server ( this is the asynchronous version of the method ).
public static string approx time until ( final int seconds ) { final string builder sbuf = new string builder ( ) ; approx time until ( sbuf , seconds ) ; return sbuf . to string ( ) ; }	create a text representing a saying of approximate time until .
public static accessibility node info compat search focus ( traversal strategy traversal , accessibility node info compat current focus , int direction , node filter filter ) { if ( traversal == null || current focus == null ) { return null ; } if ( filter == null ) { filter = default filter ; } accessibility node info compat target node = accessibility node info compat . obtain ( current focus ) ; set < accessibility node info compat > seen nodes = new hash set < > ( ) ; try { do { seen nodes . add ( target node ) ; target node = traversal . find focus ( target node , direction ) ; if ( seen nodes . contains ( target node ) ) { log utils . log ( accessibility node info utils . class , log . error , str , target node . get info ( ) ) ; return null ; } } while ( target node != null && ! filter . accept ( target node ) ) ; } finally { accessibility node info utils . recycle nodes ( seen nodes ) ; } return target node ; }	search focus that satisfied specified node filter from currentfocus to specified direction according to ordertraversal strategy.
private void collect wrapper and suppressed info ( matcher matcher ) throws ade exception { m suppressed non wrapper message count ++ ; m suppressed messages remaining = integer . parse int ( matcher . group ( num ) ) ; m suppressed messages remaining -- ; m message instance waiting = m message text preprocessor . get extra message ( m prev message instance ) ; }	record the wrapper and suppressed messages information by adding / subtracting from counts.
private static void assert mp4 webvtt subtitle equals ( subtitle sub , cue ... expected cues ) { assert equals ( num , sub . get event time count ( ) ) ; assert equals ( num , sub . get event time ( num ) ) ; list < cue > subtitle cues = sub . get cues ( num ) ; assert equals ( expected cues . length , subtitle cues . size ( ) ) ; for ( int i = num ; i < subtitle cues . size ( ) ; i ++ ) { list < string > differences = get cue differences ( subtitle cues . get ( i ) , expected cues [ i ] ) ; assert true ( str + i + str + arrays . to string ( differences . to array ( ) ) , differences . is empty ( ) ) ; } }	asserts that the subtitle ' s cues ( which are all part of the event at t = 0 ) are equal to the expected cues .
public string concatenate ( string start , list < string > chunks ) { string buffer buf ; if ( start == null ) { buf = new string buffer ( ) ; } else { buf = new string buffer ( start ) ; } if ( chunks != null ) { for ( string chunk : chunks ) { if ( chunk != null ) { buf . append ( chunk ) ; } } } return ( buf . length ( ) == num ) ? null : buf . to string ( ) ; }	concatenates a single string and a list of string into a single long string .
public list < string > create entity ( string ... entities as json ) throws atlas service exception { return create entity ( new json ( arrays . as list ( entities as json ) ) ) ; }	create the given entity.
private void populate completed activiti steps ( job job , list < historic activity instance > historic activiti tasks ) { list < workflow step > completed workflow steps = new array list < > ( ) ; for ( historic activity instance historic activity instance : historic activiti tasks ) { completed workflow steps . add ( new workflow step ( historic activity instance . get activity id ( ) , historic activity instance . get activity name ( ) , herd date utils . get xml ( historic activity instance . get start time ( ) ) , herd date utils . get xml ( historic activity instance . get end time ( ) ) ) ) ; } job . set completed workflow steps ( completed workflow steps ) ; }	populates the job object with completed workflow steps .
public static string join ( string separator , double ... elements ) { if ( elements == null || elements . length == num ) { return str ; } list < number > list = new array list < number > ( elements . length ) ; for ( double elem : elements ) { list . add ( elem ) ; } return join ( separator , list ) ; }	returns a string with all double values concatenated by a specified separator .
public double entropy nmi ( ) { if ( entropy first ( ) * entropy second ( ) <= num ) { return entropy mutual information ( ) ; } return ( entropy mutual information ( ) / math . sqrt ( entropy first ( ) * entropy second ( ) ) ) ; }	get the sqrt - normalized mutual information ( normalized , 0 = unequal ).
public void apply all ( collection < ? extends i > changes ) throws bad location exception { final map < uri , list < i > > changes per file = organize ( changes ) ; for ( uri curr uri : changes per file . key set ( ) ) { final i document = get document ( curr uri ) ; apply all in same document ( changes per file . get ( curr uri ) , document ) ; } }	applies all given changes .
public static string now ( ) { calendar cal = calendar . get instance ( ) ; simple date format sdf = new simple date format ( date format now ) ; return sdf . format ( cal . get time ( ) ) ; }	get the current date and time in a format so that sorting the string will sort the date .
public void clear selections ( ) { m selected tags . clear ( ) ; refresh selected tags ( ) ; }	clears all the selected tags.
@ override public synchronized void add test set listener ( test set listener tsl ) { m listeners . add element ( tsl ) ; }	add a listener for test sets.
public void add observer ( observer observer ) { assert . not null ( str , observer ) ; observers . add if absent ( observer ) ; }	adds an observer to the set of observers for this object .
protected void apply value ( t value ) { bean . set value ( property , value ) ; }	applies the given value , which means that the property that this configurator configures is set to the value .
protected object convert attribute value ( object value ) { if ( value == null || value instanceof string || value instanceof byte || value instanceof long || value instanceof double || value instanceof boolean || value instanceof integer || value instanceof short || value instanceof float ) { return value ; } return value . to string ( ) ; }	convert the attribute value if necessary .
@ override public int hash code ( ) { int my position = position ; int hash = num ; long l ; while ( my position < limit ) { l = double . double to long bits ( get ( my position ++ ) ) ; hash = hash + ( ( int ) l ) ^ ( ( int ) ( l > > num ) ) ; } return hash ; }	calculates this buffer ' s hash code from the remaining chars.
public void lock ui ( process info pi ) { m is locked = bool ; }	lock user interface called from the worker before processing.
public static number ceil ( number a ) { if ( is floating point ( a ) ) { return math . ceil ( a . double value ( ) ) ; } else { return a . long value ( ) ; } }	returns the smallest integer value greater than or equal to the given number .
private void unregister ( ) { if ( close != null ) { close . remove action listener ( listener ) ; } }	removes the actionlistener from the close - button of the bubble.
private static shape bottom edge ( buffered image image ) { general path path = new general path ( ) ; d p1 = null ; d p2 = null ; d line = new d . float ( ) ; d p = new d . float ( ) ; int found point x = - num ; for ( int i = num ; i < image . get width ( ) ; i ++ ) { for ( int j = image . get height ( ) - num ; j >= num ; j -- ) { if ( ( image . get rgb ( i , j ) & num ) != num ) { p . set location ( i , j ) ; found point x = i ; break ; } } if ( found point x >= num ) { if ( p2 == null ) { p1 = new d . float ( found point x , num ) ; path . move to ( p1 . get x ( ) , p1 . get y ( ) ) ; p2 = new d . float ( ) ; p2 . set location ( p ) ; } else { p2 = detect line ( p1 , p2 , p , line , path ) ; } } } path . line to ( p . get x ( ) , p . get y ( ) ) ; if ( found point x >= num ) { path . line to ( found point x , num ) ; } path . close path ( ) ; return path ; }	trace the bottom of the image.
public void add sentences tone ( sentence tone analysis ) { sentences tone . add ( analysis ) ; }	adds the sentences tone .
public static boolean assert distribution ( final double [ ] da ) { double sum = num ; for ( final double d : da ) { exam . assert true ( utils . real format ( d ) , d >= num && d <= ( num + tolerance ) && ! double . is na n ( d ) ) ; sum += d ; } if ( exam . check equals ( num , sum , num ) ) { return bool ; } throw new exam . exam exception ( str + utils . real format ( sum ) + str + utils . real format array ( da ) ) ; }	assert that the array contains a valid probability distribution that sums to 1.
public void add ( i ticket ) { if ( tickets . contains ( ticket ) ) { return ; } tickets . add ( ticket ) ; tick |= ticket . should tick ( ) ; }	add a ticket to this tickets.
public static map bean create map bean ( projection proj , border border ) { map bean map beano = new buffered layer map bean ( ) ; map beano . set border ( border ) ; if ( proj != null ) { map beano . set projection ( proj ) ; map beano . set preferred size ( new dimension ( proj . get width ( ) , proj . get height ( ) ) ) ; } return map beano ; }	a static method that creates a mapbean and sets its projection and border to the values given .
public static boolean volume detached from full copies ( volume volume , db client db client ) { boolean detached = bool ; string set full copy ids = volume . get full copies ( ) ; if ( ( full copy ids != null ) && ( ! full copy ids . is empty ( ) ) ) { iterator < string > full copy ids iter = full copy ids . iterator ( ) ; while ( full copy ids iter . has next ( ) ) { string full copy id = full copy ids iter . next ( ) ; volume full copy volume = db client . query object ( volume . class , uri . create ( full copy id ) ) ; if ( ! is full copy detached ( full copy volume , db client ) ) { detached = bool ; } } } return detached ; }	verify that a volume with full copies can be deleted .
public final t xmlns ( string uri ) { return xmlns ( uri , null ) ; }	sets the default namespace on the last started tag .
public boolean is entity ( ) { return is string ( ) && string . starts with ( str ) && string . ends with ( str ) ; }	checks if the content is an entity.
public void save device profiles ( string username , string realm , list < json value > profiles ) throws internal server error exception { final am identity = get identity ( username , realm ) ; set < string > vals = new hash set < > ( ) ; try { final device service device service = service factory . create ( realm ) ; final device serialisation device serialisation = device service . get device serialisation strategy ( ) ; final string attr name = device service . get config storage attribute name ( ) ; for ( json value profile : profiles ) { vals . add ( device serialisation . device profile to string ( profile ) ) ; } map < string , set > attr map = new hash map < > ( ) ; attr map . put ( attr name , vals ) ; identity . set attributes ( attr map ) ; identity . store ( ) ; } catch ( sso | id repo exception | sms e ) { throw new internal server error exception ( e . get message ( ) , e ) ; } }	saves a user ' s device profiles .
@ request mapping ( value = str , method = request method . delete ) @ response body public rest wrapper delete ( @ path variable ( str ) integer app deployment status id , principal principal ) { rest wrapper rest wrapper = null ; try { app deployment queue status dao . delete ( app deployment status id . short value ( ) ) ; rest wrapper = new rest wrapper ( null , rest wrapper . ok ) ; logger . info ( recordwithid + app deployment status id + str + principal . get name ( ) ) ; } catch ( exception e ) { logger . error ( e ) ; return new rest wrapper ( e . get message ( ) , rest wrapper . error ) ; } return rest wrapper ; }	this method calls deletedeploystatus and fetches a record corresponding to the deploystatusid passed .
@ override public socket connect ( ) { log . d ( tag , str + address . get host address ( ) + str + integer . to string ( port ) ) ; final server socket temp socket ; try { temp socket = new server socket ( port , num , address ) ; } catch ( io e ) { report error ( str + e . get message ( ) ) ; return null ; } synchronized ( raw socket lock ) { if ( server socket != null ) { log . e ( tag , str ) ; } server socket = temp socket ; } try { return temp socket . accept ( ) ; } catch ( io e ) { report error ( str + e . get message ( ) ) ; return null ; } }	opens a listening socket and waits for a connection .
@ namespace permission ( fields = str , permissions = namespace permission enum . read ) private void mock method ( string namespace ) { }	do not invoke this method.
public boolean matches ( inventory crafting inv , world world in ) { item stack itemstack = null ; list < item stack > list = lists . < item stack > new array list ( ) ; for ( int i = num ; i < inv . get size inventory ( ) ; ++ i ) { item stack itemstack1 = inv . get stack in slot ( i ) ; if ( itemstack1 != null ) { if ( itemstack1 . get item ( ) instanceof item armor ) { item armor itemarmor = ( item armor ) itemstack1 . get item ( ) ; if ( itemarmor . get armor material ( ) != cyberware content . trench mat || itemstack != null ) { return bool ; } itemstack = itemstack1 ; } else { if ( itemstack1 . get item ( ) != items . dye ) { return bool ; } list . add ( itemstack1 ) ; } } } return itemstack != null && ! list . is empty ( ) ; }	used to check if a recipe matches current crafting inventory.
public void put delegate ( string alias , x509 extended key manager new delegate ) { if ( ! alias . equals ( alias . to lower case ( ) ) ) { throw new illegal argument exception ( str ) ; } delegates . put ( alias , new delegate ) ; }	add a delegate identified by the given unique key ( can be used to remove it later ).
@ override public void action performed ( action event e ) { file dialog chooser = new file dialog ( frame , str , file dialog . save ) ; chooser . set visible ( bool ) ; if ( chooser . get file ( ) != null ) { save ( chooser . get directory ( ) + file . separator + chooser . get file ( ) ) ; } }	opens a save dialog box when the user selects " save as " from the menu .
public void paint slider thumb border ( synth context context , graphics g , int x , int y , int w , int h , int orientation ) { paint border ( context , g , x , y , w , h , orientation ) ; }	paints the border of the thumb of a slider .
private void calculate at hash claim ( final o access token , final jws signing alg , final jwt . builder id claims , final set < string > response types ) { if ( response types . contains ( oidc . token ) ) { final url at hash = id token hash utils . get access token hash ( signing alg , access token ) ; id claims . claim ( oidc . at hash , at hash ) ; log . debug ( str , oidc . at hash , at hash ) ; } }	calculate at hash claim .
public static double [ ] round to significant digits ( double x , double y , int n signif ) { double [ ] rounded = new double [ num ] ; double diff = math . abs ( x - y ) ; if ( diff < num ) { rounded [ num ] = x ; rounded [ num ] = y ; return rounded ; } if ( diff > num ) { rounded [ num ] = math . rint ( x * math . pow ( num , n signif ) ) / math . pow ( num , n signif ) ; rounded [ num ] = math . rint ( y * math . pow ( num , n signif ) ) / math . pow ( num , n signif ) ; return rounded ; } else { int nzeros = ( int ) ( math . ceil ( math . abs ( math . log10 ( diff ) ) ) + n signif ) ; rounded [ num ] = math . rint ( x * math . pow ( num , nzeros ) ) / math . pow ( num , nzeros ) ; rounded [ num ] = math . rint ( y * math . pow ( num , nzeros ) ) / math . pow ( num , nzeros ) ; return rounded ; } }	function to round x and y to a number of digits enough to show the difference in range this is for pretty printing only .
public static string sanitize strings ( string str ) { char [ ] c = get chars ( str ) ; int idx = num ; string newstr = str ; string builder sb = null ; boolean instring = bool ; char stringsep = str ; int lastidx = num ; while ( idx < c . length ) { if ( instring && stringsep == c [ idx ] ) { instring = bool ; stringsep = str ; } else if ( ! instring ) { if ( str == c [ idx ] ) { instring = bool ; stringsep = str ; } else if ( str == c [ idx ] ) { instring = bool ; stringsep = str ; } } if ( instring ) { if ( str == c [ idx ] ) { if ( null == sb ) { sb = new string builder ( ) ; } sb . append ( c , lastidx , idx - lastidx ) ; sb . append ( str ) ; lastidx = idx + num ; } } idx ++ ; } if ( null != sb ) { if ( lastidx < c . length ) { sb . append ( c , lastidx , c . length - lastidx ) ; } newstr = sb . to string ( ) ; } return newstr ; }	replace whitespaces in strings enclosed in single quotes with ' % 20 '.
private void force quit ( ) { if ( stdout != null ) { stdout . close ( ) ; } try { if ( shell != null ) { shell . disconnect ( ) ; } } catch ( runtime exception e ) { log . error ( e . get message ( ) , e ) ; } finally { shell = null ; } try { if ( session != null ) { session . disconnect ( ) ; } } catch ( runtime exception e ) { log . error ( e . get message ( ) , e ) ; } finally { session = null ; } }	forcibly quits the session .
public boolean is blinking ( ) { return modifiers . contains ( sgr . blink ) ; }	returns true if this textcharacter has the blink modifier active.
@ inject public hbase schema service ( system configuration config ) { super ( config ) ; config = config ; }	creates a new hbaseschemaservice object .
public static string read output ( buffered reader in ) throws io { string buffer output = new string buffer ( ) ; string line = null ; while ( ( line = in . read line ( ) ) != null ) { output . append ( line ) ; output . append ( tools . get line separator ( ) ) ; } return output . to string ( ) ; }	reads the output of the reader and delivers it as string .
private boolean schedule next ( ) { final string tag = str + taskid + str ; try { log . finer ( tag + str + delay before next + str ) ; if ( cancelled || ! notify state change ( scheduled , str ) ) { log . finer ( tag + str ) ; return bool ; } final session task next task = new session task ( delay before next ) ; if ( ! schedule session ( next task , delay before next ) ) return bool ; log . finer ( tag + str ) ; } catch ( exception x ) { if ( log . is loggable ( level . finest ) ) { log . log ( level . finest , tag + str + x , x ) ; } else if ( log . is loggable ( level . fine ) ) { log . fine ( tag + str + x ) ; } } return bool ; }	schedule an identical task for next iteration .
@ override public double classify instance ( instance instance ) { return m ; }	classifies a given instance .
private void add json for entry ( final string builder result , entry entry , boolean include just text fields , boolean include user was sign in , boolean user was signed in , boolean force quotation to note ) throws io { result . append ( str + json builder . quote ( entry . get note or title ( str ) ) + str ) ; result . append ( str + json builder . quote ( entry . get quotation ( str ) ) + str ) ; result . append ( str + entry . get is public ( ) + str ) ; string type to add = entry . get type ( ) ; if ( type to add . equals ( db logic . constants . quotation ) ) { type to add = db logic . constants . note ; } result . append ( str + type to add + str ) ; if ( include user was sign in ) { result . append ( str + user was signed in + str ) ; } if ( include just text fields ) { result . append ( str + json builder . quote ( get note html ( entry , bool , entry . has quotation ( ) , bool ) ) + str ) ; result . append ( str + json builder . quote ( get quotation html ( entry , bool ) ) + str ) ; } else { final string builder inner result = new string builder ( ) ; add entry html to tree simple ( entry , inner result , null , num , ! entry . is notebook ( ) ) ; result . append ( str + json builder . quote ( inner result . to string ( ) ) + str ) ; } }	adds json for the entry .
public void add viewpoint ( int index , string name ) { viewpoint store vps = viewpoint node . get viewpoint ( name ) ; viewpoint list . add ( index , vps ) ; }	add a viewpoint to the list.
public static boolean is kanji ( char chr ) { string [ ] pinyin str = null ; try { pinyin str = pinyin helper . to hanyu pinyin string array ( chr , format ) ; } catch ( bad hanyu pinyin output format combination e ) { e . print stack trace ( ) ; } return ( null == pinyin str ) ? ( bool ) : ( bool ) ; }	judge chr is kanji.
public builder root source section equals ( source section ... section ) { verify not null ( section ) ; expressions . add ( new event filter expression . root source section equals ( section ) ) ; return this ; }	add a filter for all root sources sections that equal one of the given source sections.
public sorting ( double [ ] array , boolean copy array ) { if ( copy array ) { a = new double [ array . length ] ; system . arraycopy ( array , num , a , num , array . length ) ; } else { a = array ; } order = new int [ a . length ] ; for ( int i = num ; i < a . length ; i ++ ) { order [ i ] = i ; } sort ( a ) ; }	construct an ascending order .
public double cdf ( double x ) { if ( x <= num ) return num ; return num - math . exp ( - x * lambda ) ; }	returns the cumulative distribution function .
public byte buffer read ( final long off , final int nbytes ) throws io { final byte buffer tmp = byte buffer . allocate ( nbytes ) ; file channel utility . read all ( this , tmp , off ) ; tmp . flip ( ) ; return tmp ; }	read some data out of the file .
protected void init info ( ) { clear parameters ( ) ; init info ( num , str , m m id , m m id ) ; }	reset the criteria panel.
public static connection enlist connection ( xa xacon ) throws generic transaction exception { if ( xacon == null ) { return null ; } try { xa resource = xacon . get xa ( ) ; transaction util . enlist resource ( resource ) ; return xacon . get connection ( ) ; } catch ( sql e ) { throw new generic transaction exception ( str , e ) ; } }	enlists the given xaconnection and if a transaction is active in the current thread , returns a plain jdbc connection.
@ override public void run ( int conn id , string [ ] args ) { if ( ! can run restricted command ( conn id ) ) { server . send server chat ( conn id , str ) ; return ; } if ( args . length > num ) { string s final file = args [ num ] ; if ( ! s final file . ends with ( str ) && ! s final file . ends with ( str ) ) { s final file = s final file + str ; } if ( ! s final file . ends with ( str ) ) { s final file = s final file + str ; } load ( new file ( str , s final file ) , conn id ) ; } else { server . send server chat ( conn id , str ) ; } }	run this command with the arguments supplied.
private query result ( final query task task ) { m task = task ; }	construct a query result.
protected void delete family set ( ) { item palette . remove icon map ( item type , family ) ; family = null ; current icon map = null ; update families panel ( ) ; }	action item for delete family.
protected static modbus response read request ( int function code , int register , int count ) { udp trans ; udp connection = null ; try { connection = new udp ( inet address . get by name ( test utils . get first ip4 address ( ) ) ) ; connection . set port ( port ) ; connection . connect ( ) ; connection . set timeout ( num ) ; modbus request req = null ; switch ( function code ) { case modbus . read coils : req = new read coils request ( register , count ) ; break ; case modbus . read input discretes : req = new read input discretes request ( register , count ) ; break ; case modbus . read input registers : req = new read input registers request ( register , count ) ; break ; case modbus . read holding registers : req = new read multiple registers request ( register , count ) ; break ; default : fail ( string . format ( str , function code ) ) ; } req . set unit id ( unit id ) ; trans = new udp ( connection ) ; trans . set request ( req ) ; trans . execute ( ) ; return trans . get response ( ) ; } catch ( exception e ) { logger . debug ( e . get message ( ) ) ; } finally { if ( connection != null ) { connection . close ( ) ; } } return null ; }	executes a read transaction using the function code , register and count.
public static void load properties ( boolean reload ) { if ( reload || s prop . size ( ) == num ) { if ( is web start client ( ) ) { load web start properties ( ) ; } else { load properties ( get file name ( s client ) ) ; } } }	load ini parameters from disk.
static list < file > tidy database list ( list < file > database files ) { set < file > original as set = new hash set < file > ( database files ) ; list < file > tidied list = new array list < file > ( ) ; for ( file database file : database files ) { string database filename = database file . get path ( ) ; string sans suffix = remove suffix ( database filename , uninteresting filename suffixes ) ; if ( sans suffix . equals ( database filename ) || ! original as set . contains ( new file ( sans suffix ) ) ) { tidied list . add ( database file ) ; } } return tidied list ; }	attempt to smartly eliminate uninteresting shadow databases such as - journal and - uid.
public void select ( segment segment , boolean add to selection ) { if ( segment . is none ( ) ) { return ; } if ( ! add to selection ) { deselect all segments ( ) ; } if ( segment . is unpaired ( ) ) { if ( add to selection ) { boolean all segments selected = bool ; for ( segment other : segments . get paired segments ( segment ) ) { if ( ! is selected ( other ) ) { all segments selected = bool ; break ; } } if ( all segments selected ) { deselect segment ( segment ) ; return ; } } if ( is selected ( segment ) ) { deselect segment ( segment ) ; } else { select segment ( segment ) ; } } else { if ( is selected ( segment ) ) { deselect segment ( segment ) ; } else { select segment ( segment ) ; } } }	adds or removes the given segment to the selection.
public void test using proxy ( ) throws exception { mock server server = new mock server ( str ) ; mock server proxy = new mock server ( str ) ; url url = new url ( str + server . port ( ) ) ; url connection = ( url ) url . open connection ( new proxy ( proxy . type . http , new inet socket address ( str , proxy . port ( ) ) ) ) ; connection . set connect timeout ( num ) ; connection . set read timeout ( num ) ; server . start ( ) ; synchronized ( bound ) { if ( ! server . started ) bound . wait ( num ) ; } proxy . start ( ) ; synchronized ( bound ) { if ( ! proxy . started ) bound . wait ( num ) ; } connection . connect ( ) ; server . join ( ) ; proxy . join ( ) ; assert true ( str , connection . using proxy ( ) ) ; assert true ( str , proxy . accepted ) ; url huc = ( url ) url . open connection ( proxy . no proxy ) ; assert false ( huc . using proxy ( ) ) ; }	test checks if the proxy specified in openconnection method will be used for connection to the server.
static int convert units ( string units , int default suffix ) { if ( units == null ) { return - num ; } int factor = num ; int i = num ; boolean suffix found = bool ; for ( ; i < css . css length suffix . length ; i ++ ) { if ( units . ends with ( css . css length suffix [ i ] ) ) { factor = css length factors [ i ] ; units = units . substring ( num , units . length ( ) - num ) ; suffix found = bool ; break ; } } if ( ! suffix found ) { i = default suffix ; factor = css length factors [ i ] ; } try { int result = ( int ) ( float . parse float ( units ) * factor ) ; if ( ( i == length suffix em ) || ( i == length suffix ex ) ) { result += val ex ; } return result ; } catch ( number format exception nfe ) { return - num ; } }	converts the given css length string to pixels.
public static void hidden from encoded string ( project filter settings result , string s ) { if ( s . length ( ) > num ) { int bar = s . index of ( field delimiter ) ; string categories ; if ( bar >= num ) { categories = s . substring ( num , bar ) ; } else { categories = s ; } string tokenizer t = new string tokenizer ( categories , listitem delimiter ) ; while ( t . has more tokens ( ) ) { string category = t . next token ( ) ; result . remove category ( category ) ; } } }	set the hidden bug categories on the specifed projectfiltersettings from an encoded string.
public java . lang . string builder insert ( int offset , java . lang . object obj ) { return insert ( offset , obj . to string ( ) ) ; }	inserts the string representation of the object argument into this string buffer.
private void layout selected child ( layout params lp ) { int l = math . round ( lp . left ) ; int t = math . round ( lp . top ) ; int r = l + m selected child . get measured width ( ) ; int b = t + m selected child . get measured height ( ) ; lp . moved = bool ; m selected child . layout ( l , t , r , b ) ; }	this method can be used to force layout on a child to recalculate its hit - rect , otherwise outline border of the selected child is drawn at the old position.
public aem radio group select by value ( string value ) { for ( aem radio option option : values ) { if ( value . equals ( option . get value ( ) ) ) { option . set selected ( ) ; } } return this ; }	searches for the option by the option ' s value and selects it .
@ override public void close ( ) { try { reader . close ( ) ; } catch ( io e ) { throw db exception . convert io ( e , null ) ; } }	close the underlying reader .
void on response ( t result ) ;	the callback run on a valid response .
public static string report ( ) { string builder sb = new string builder ( ) ; for ( tap tap : dispatches copy ( ) ) { int length = sb . length ( ) ; tap . append report ( null , sb ) ; if ( sb . length ( ) > length ) { sb . append ( new line ) ; } } string result = sb . to string ( ) ; log . debug ( str + new line + new line + result + new line ) ; return result ; }	return a string containing a formatted report generated by traversing and appending results from all registered taps.
public final test subscriber assert complete ( ) { string prefix = str ; boolean passed = bool ; if ( done . get count ( ) != num ) { prefix = str ; fail ( str ) ; passed = bool ; } long c = completions ; if ( c == num ) { fail ( prefix , str , errors ) ; fail ( str ) ; passed = bool ; } else if ( c > num ) { fail ( prefix , str + c , errors ) ; fail ( str ) ; passed = bool ; } pass ( str , passed ) ; return this ; }	assert that this testsubscriber received exactly one oncomplete event .
public static int next smaller prime ( int n ) { if ( n <= num ) { return num ; } if ( n == num ) { return num ; } if ( ( n & num ) == num ) { n -- ; } else { n -= num ; } while ( n > num & ! is prime ( n ) ) { n -= num ; } return n ; }	returns the largest prime smaller than the given integer.
public synchronized void delete type substitution ( final i node ) throws couldnt delete exception { preconditions . check not null ( node , str ) ; final type substitution substitution = node . get type substitution ( ) ; types container . delete type substitution ( substitution ) ; backend . delete type substitution ( substitution ) ; node . set type substitution ( null ) ; notify substitutions deleted ( collections . singleton ( substitution ) ) ; }	removes the type substitution from the given tree node and deletes the corresponding database record .
private void paint background ( graphics graphics , j button ) { style util . fill background ( style , graphics , num , num , button . get width ( ) , button . get height ( ) ) ; }	draw the background image .
public string [ ] headers ( final string name ) { final map < string , list < string > > headers = headers ( ) ; if ( headers == null || headers . is empty ( ) ) return empty strings ; final list < string > values = headers . get ( name ) ; if ( values != null && ! values . is empty ( ) ) return values . to array ( new string [ values . size ( ) ] ) ; else return empty strings ; }	get all values of the given header from the response.
@ override public int hash code ( ) { int result ; long temp ; temp = double . double to long bits ( this . x1 ) ; result = ( int ) ( temp ^ ( temp > > > num ) ) ; temp = double . double to long bits ( this . x2 ) ; result = num * result + ( int ) ( temp ^ ( temp > > > num ) ) ; temp = double . double to long bits ( this . y1 ) ; result = num * result + ( int ) ( temp ^ ( temp > > > num ) ) ; temp = double . double to long bits ( this . y2 ) ; result = num * result + ( int ) ( temp ^ ( temp > > > num ) ) ; return result ; }	returns a hash code .
public object eval ( call stack callstack , interpreter interpreter ) throws eval error { try { name space namespace = callstack . top ( ) ; bsh type node = get type node ( ) ; class type = type node . get type ( callstack , interpreter ) ; bsh [ ] bvda = get declarators ( ) ; for ( int i = num ; i < bvda . length ; i ++ ) { bsh dec = bvda [ i ] ; object value = dec . eval ( type node , callstack , interpreter ) ; try { namespace . set typed variable ( dec . name , type , value , modifiers ) ; } catch ( util eval error e ) { throw e . to eval error ( this , callstack ) ; } } } catch ( eval error e ) { e . re throw ( str ) ; } return primitive . void ; }	evaluate the type and one or more variable declarators , e.
private void finish item list item ( string builder result ) { result . append ( str ) ; }	called to finish adding an item to an item list .
public static int launch file windows ( string path ) throws io { try { return system utils . open file ( path ) ; } catch ( io iox ) { throw new launch exception ( iox , path ) ; } }	launches the given file on windows .
private void profiles cb ( ) { profile profile ; string host ; profile = ( profile ) profiles combo box . get selected item ( ) ; if ( profile != null ) { host = profile . get host ( ) ; server field . set text ( host ) ; server port field . set text ( string . value of ( profile . get port ( ) ) ) ; username field . set text ( profile . get user ( ) ) ; password field . set text ( profile . get password ( ) ) ; } else { server port field . set text ( string . value of ( profile . default server port ) ) ; username field . set text ( str ) ; password field . set text ( str ) ; } }	called when a profile selection is changed .
public infoflow results run infoflow ( ) { return run infoflow ( null ) ; }	runs the data flow analysis.
private static string create tooltip ( string column name , string type , string role name ) { string builder tip builder = new string builder ( ) ; tip builder . append ( str ) ; tip builder . append ( n . get gui ( str ) ) ; tip builder . append ( str ) ; tip builder . append ( column name ) ; tip builder . append ( str ) ; tip builder . append ( n . get gui ( str ) ) ; tip builder . append ( str ) ; tip builder . append ( type ) ; tip builder . append ( str ) ; if ( role name != null ) { tip builder . append ( str ) ; tip builder . append ( n . get gui ( str ) ) ; tip builder . append ( str ) ; tip builder . append ( role name ) ; tip builder . append ( str ) ; } tip builder . append ( str ) ; return tip builder . to string ( ) ; }	creates the tooltip text for the table header .
@ override public boolean equals ( object obj ) { if ( obj == this ) { return bool ; } if ( ! ( obj instanceof default interval category dataset ) ) { return bool ; } default interval category dataset that = ( default interval category dataset ) obj ; if ( ! arrays . equals ( this . series keys , that . series keys ) ) { return bool ; } if ( ! arrays . equals ( this . category keys , that . category keys ) ) { return bool ; } if ( ! equal ( this . start data , that . start data ) ) { return bool ; } if ( ! equal ( this . end data , that . end data ) ) { return bool ; } return bool ; }	tests this dataset for equality with an arbitrary object .
public static string cut suffix ( string string , string suffix ) { if ( string . ends with ( suffix ) ) { string = string . substring ( num , string . length ( ) - suffix . length ( ) ) ; } return string ; }	cuts sufix if exists .
@ override public void put all ( map < ? extends k , ? extends v > m ) { try presize ( m . size ( ) ) ; for ( map . entry < ? extends k , ? extends v > e : m . entry set ( ) ) put val ( e . get key ( ) , e . get value ( ) , bool ) ; }	copies all of the mappings from the specified map to this one.
public data matrix merge ( data matrix that ) throws scope exception { merger merger = new merger ( this , that ) ; return merger . merge ( bool ) ; }	merge two matrix with different kpis but must be on the same space.
@ suppress warnings ( str ) private map < k , v > intercept get ( @ nullable collection < ? extends k > keys , map < k , v > map ) { if ( f . is empty ( keys ) ) return map ; cache interceptor < k , v > interceptor = cache cfg . get interceptor ( ) ; assert interceptor != null ; map < k , v > res = u . new hash map ( keys . size ( ) ) ; for ( map . entry < k , v > e : map . entry set ( ) ) { v val = interceptor . on get ( e . get key ( ) , e . get value ( ) ) ; if ( val != null ) res . put ( e . get key ( ) , val ) ; } if ( map . size ( ) != keys . size ( ) ) { for ( k key : keys ) { if ( key != null ) { if ( ! map . contains key ( key ) ) { v val = interceptor . on get ( key , null ) ; if ( val != null ) res . put ( key , val ) ; } } } } return res ; }	applies cache interceptor on result of ' get ' operation .
static int [ ] find nanp phone numbers ( char sequence text ) { array list < integer > list = new array list < integer > ( ) ; int start pos = num ; int end pos = text . length ( ) - nanp min digits + num ; if ( end pos < num ) { return new int [ ] { } ; } while ( start pos < end pos ) { while ( character . is whitespace ( text . char at ( start pos ) ) && start pos < end pos ) { start pos ++ ; } if ( start pos == end pos ) { break ; } int match end = find nanp match end ( text , start pos ) ; if ( match end > start pos ) { list . add ( start pos ) ; list . add ( match end ) ; start pos = match end ; } else { while ( ! character . is whitespace ( text . char at ( start pos ) ) && start pos < end pos ) { start pos ++ ; } } } int [ ] result = new int [ list . size ( ) ] ; for ( int i = list . size ( ) - num ; i >= num ; i -- ) { result [ i ] = list . get ( i ) ; } return result ; }	finds north american numbering plan ( nanp ) phone numbers in the input text .
public void write to stream ( output stream os , int len ) throws io { while ( len > num ) { if ( read length <= read offset ) { if ( ! read buffer ( ) ) return ; } int sublen = math . min ( len , read length - read offset ) ; os . write ( read buffer , read offset , sublen ) ; read offset += sublen ; len -= sublen ; } }	writes < code > len < code > bytes to the output stream from this stream .
public static void main ( string [ ] args ) { log . print line ( str ) ; try { int num user = num ; calendar calendar = calendar . get instance ( ) ; boolean trace flag = bool ; cloud sim . init ( num user , calendar , trace flag ) ; @ suppress warnings ( str ) datacenter datacenter0 = create datacenter ( str ) ; @ suppress warnings ( str ) datacenter datacenter1 = create datacenter ( str ) ; datacenter broker broker = create broker ( ) ; int broker id = broker . get id ( ) ; vmlist = create vm ( broker id , num ) ; cloudlet list = create cloudlet ( broker id , num ) ; broker . submit vm list ( vmlist ) ; broker . submit cloudlet list ( cloudlet list ) ; cloud sim . start simulation ( ) ; list < cloudlet > new list = broker . get cloudlet received list ( ) ; cloud sim . stop simulation ( ) ; print cloudlet list ( new list ) ; log . print line ( str ) ; } catch ( exception e ) { e . print stack trace ( ) ; log . print line ( str ) ; } }	creates main ( ) to run this example.
public void test ( ) throws sql { string sql = str + database creator . customers table + str + database creator . salespeople table + str ; result set result = statement . execute query ( sql ) ; hash map < integer , integer > value = new hash map < integer , integer > ( ) ; value . put ( num , num ) ; value . put ( num , num ) ; value . put ( num , num ) ; value . put ( num , num ) ; value . put ( num , num ) ; while ( result . next ( ) ) { int key = result . get int ( str ) ; object val = result . get object ( str ) ; assert true ( str , value . contains key ( key ) ) ; assert equals ( str , value . get ( key ) , ( integer ) val ) ; value . remove ( key ) ; } assert true ( str , value . is empty ( ) ) ; result . close ( ) ; }	selectfunctionalitytest # test_selectleftouterjoin ( ) . selects records from a table using left join.
void swap actions ( int row ) { conditional action temp = action list . get ( row ) ; for ( int i = row ; i > next in order ; i -- ) { action list . set ( i , action list . get ( i - num ) ) ; } action list . set ( next in order , temp ) ; next in order ++ ; if ( next in order >= action list . size ( ) ) { in reorder mode = bool ; } action table model . fire table data changed ( ) ; }	responds to the first / next ( delete ) button in the edit conditional window.
public static list < ? extends element > child element list ( element element , string child element name ) { if ( element == null ) return null ; list < element > elements = new linked list < element > ( ) ; node node = element . get first child ( ) ; if ( node != null ) { do { if ( node . get node type ( ) == node . element node && ( child element name == null || child element name . equals ( node . get node name ( ) ) ) ) { element child element = ( element ) node ; elements . add ( child element ) ; } } while ( ( node = node . get next sibling ( ) ) != null ) ; } return elements ; }	return a list of element objects that have the given name and are immediate children of the given element ; if name is null , all child elements will be included .
public void reset ( collection < e > collection , @ nullable diff util . callback callback ) { items . clear ( ) ; items . add all ( collection ) ; if ( callback != null ) { update items task = new update items task ( ) ; update items task . execute ( callback ) ; } else { notify data set changed ( ) ; } }	resets the current adapter state - clear current items , add new ones and execute updateitems task .
private js collect follow elements ( token source tokens , boolean strict , set < follow element > result ) { js parser = create parser ( ) ; parser . set strict ( strict ) ; try { observable xtext token stream token stream = new observable xtext token stream ( tokens , parser ) ; result . add all ( do get follow elements ( parser , token stream ) ) ; } catch ( infinite recursion infinite ) { result . add all ( parser . get follow elements ( ) ) ; } return parser ; }	first pass . use the tokens that have been computed from the production parser ' s result and collect the follow elements from those .
public d ( j parent ) { super ( parent ) ; set title ( res . get string ( str ) ) ; init components ( ) ; }	creates a new dsubjectalternativename dialog .
private string next host ( ) { current host ++ ; if ( current host == hosts array . length ) { current host = num ; } return hosts array [ current host ] ; }	return the string ip of the next host using round - robin technique.
public static void show error ( final string message text ) { j . show message dialog ( null , message text , translate ( str ) , j . error message ) ; }	shows an error message box to the user.
@ non null public list < tray item > query provider safe ( @ non null final uri uri ) { try { return query provider ( uri ) ; } catch ( tray exception e ) { return new array list < > ( ) ; } }	sends a query for trayitems to the provider , doesn ' t throw when the database access couldn ' t be established.
@ override public void count example ( example example ) { int label = class name map . get ( example . get nominal value ( label attribute ) ) ; int plabel = class name map . get ( example . get nominal value ( predicted label attribute ) ) ; double weight = num ; if ( weight attribute != null ) { weight = example . get value ( weight attribute ) ; } counter [ label ] [ plabel ] += weight ; }	increases the prediction value in the matrix .
void acc expand ( ) { int len = digits . length ; int old ones [ ] = digits ; digits = new int [ len + num ] ; system . arraycopy ( old ones , num , digits , num , len ) ; }	expand by one and release past ( internal ) memory.
protected double update distance ( double curr dist , double diff ) { double result ; result = curr dist ; diff = math . abs ( diff ) ; if ( diff > result ) result = diff ; return result ; }	updates the current distance calculated so far with the new difference between two attributes.
public string go back ( ) { if ( pointer > num ) { pointer -- ; } if ( messages . size ( ) > num ) { return messages . get ( pointer ) ; } return null ; }	go back in history.
private synchronized void add nodejs installs ( i [ ] cf , list < i > list ) { for ( i ce : cf ) { try { list . add ( new nodejs install ( ce ) ) ; trace . trace ( trace . extension point , str + ce . get attribute ( str ) ) ; } catch ( throwable t ) { trace . trace ( trace . severe , str + ce . get attribute ( str ) , t ) ; } } }	load the nodejs installs .
public static list < file > sample files ( file folder , int number , file filter filter ) { list < file > result = null ; if ( ! folder . exists ( ) || ! folder . is directory ( ) || ! folder . can read ( ) ) { log . error ( str + folder . get absolute path ( ) ) ; return null ; } file [ ] file list = folder . list files ( filter ) ; if ( file list . length > num ) { result = new array list < file > ( ) ; if ( file list . length < number ) { log . warn ( str + number + str + file list . length + str ) ; } int [ ] permutation = random permutation . get random permutation ( file list . length ) ; int index = num ; while ( result . size ( ) < number && index < permutation . length ) { result . add ( file list [ permutation [ index ++ ] - num ] ) ; } log . info ( str + result . size ( ) + str ) ; return result ; } else { log . warn ( str ) ; return null ; } }	the method samples from a filtered file list .
public instance place movie clip ( symbol symbol , transform matrix2 , alpha transform cxform , string name , actions [ ] clip actions ) { transform matrix = matrix2 ; int depth = timeline . get available depth ( ) ; instance inst = new instance ( symbol , depth ) ; timeline . set available depth ( depth + num ) ; if ( matrix == null ) { matrix = new transform ( ) ; } placement placement = new placement ( inst , matrix , cxform , name , - num , - num , frame number , bool , bool , clip actions ) ; placements . add ( placement ) ; return inst ; }	place a movie clip at the next available depth with the given properties .
public void message ( map headers , string body ) { transmit ( command . message , headers , body ) ; }	called by the server ; sends a message to this client .
protected light icon add light ( ) { light icon l = new light icon ( this ) ; icon adder editor = get icon editor ( str ) ; l . set off icon ( editor . get icon ( str ) ) ; l . set on icon ( editor . get icon ( str ) ) ; l . set inconsistent icon ( editor . get icon ( str ) ) ; l . set unknown icon ( editor . get icon ( str ) ) ; l . set light ( ( light ) editor . get table selection ( ) ) ; l . set display level ( lights ) ; set next location ( l ) ; put item ( l ) ; return l ; }	add a light indicator to the target.
public static boolean check if initiators for rp ( db client db client , string set initiator list ) { if ( db client == null || initiator list == null ) { return bool ; } list < initiator > initiators = new array list < initiator > ( ) ; for ( string initiator id : initiator list ) { initiator initiator = db client . query object ( initiator . class , uri . create ( initiator id ) ) ; if ( initiator != null ) { initiators . add ( initiator ) ; } } return check if initiators for rp ( initiators ) ; }	checks to see if the initiators passed in are for recoverpoint.
@ deprecated public static file create temp directory ( string prefix ) throws io { return create temp directory ( null , prefix ) ; }	create temporary directory and use ' java.
public int time passed ( ) { final long time = animation utils . current animation time millis ( ) ; final long start time = math . min ( m scroller x . m start time , m scroller y . m start time ) ; return ( int ) ( time - start time ) ; }	returns the time elapsed since the beginning of the scrolling .
private void create cache ( ) throws exception { if ( this . distributed system == null ) { this . distributed system = internal distributed system . get connected instance ( ) ; } this . cache = cache factory . create ( this . distributed system ) ; }	create the cache to be used by this migration server.
public abstract boolean do init ( boolean ignore cancel ) throws throwable ;	initialize the model checker.
public static void apply ( collection coll , function func ) { for ( iterator i = coll . iterator ( ) ; i . has next ( ) ; ) { func . execute ( i . next ( ) ) ; } }	executes a function on each item in a collection but does not accumulate the result.
public static boolean check connection ( connection conn ) { string sql = str ; statement stmt = null ; result set rs = null ; try { stmt = conn . create statement ( ) ; stmt . set query timeout ( num ) ; rs = stmt . execute query ( sql ) ; if ( rs != null && rs . next ( ) ) return bool ; return bool ; } catch ( exception ex ) { } finally { close ( rs ) ; close ( stmt ) ; } return bool ; }	check if the given jdbc connection is still good.
protected static dynamic field [ ] dynamic field list to sorted array ( list < dynamic field > dynamic field list ) { dynamic field [ ] d fields = dynamic field list . to array ( new dynamic field [ dynamic field list . size ( ) ] ) ; arrays . sort ( d fields ) ; log . trace ( str + arrays . to string ( d fields ) ) ; return d fields ; }	sort the dynamic fields and stuff them in a normal array for faster access .
protected void trigger preferred leader election ( zk utils zk utils , list < partition info > partition info list ) { scala . collection . mutable . hash set < topic and partition > scala partition info set = new scala . collection . mutable . hash set < > ( ) ; for ( partition info java partition info : partition info list ) { scala partition info set . add ( new topic and partition ( topic , java partition info . partition ( ) ) ) ; } preferred replica leader election command . write preferred replica election data ( zk utils , scala partition info set ) ; }	this runs the preferred replica election for all partitions .
public data view component ( master view master view , master view configuration master area configuration ) { init components ( ) ; create master view ( master view ) ; configure master view ( master area configuration ) ; }	creates new instance of dataviewcomponent .
public boolean delete entry ( int index ) { system . arraycopy ( entries , index + num , entries , index , num entries - index - num ) ; entries [ -- num entries ] = null ; return bool ; }	deletes the entry at the specified index and shifts all entries after the index to left .
public void remove item ( int position ) { m datas . remove ( position ) ; notify data set changed ( ) ; }	remove data for position.
public void resolve urls ( ) { try { pool = executors . new fixed thread pool ( num threads ) ; buffered reader buff read = new buffered reader ( new file reader ( new file ( urls file ) ) ) ; string url str = null ; while ( ( url str = buff read . read line ( ) ) != null ) { log . info ( str + url str ) ; pool . execute ( new resolver thread ( url str ) ) ; } buff read . close ( ) ; pool . await termination ( num , time unit . seconds ) ; } catch ( exception e ) { pool . shutdown now ( ) ; log . info ( string utils . stringify exception ( e ) ) ; } pool . shutdown ( ) ; log . info ( str + num total . get ( ) + str + num resolved . get ( ) + str + num errored . get ( ) + str + total time . get ( ) / num total . get ( ) ) ; }	creates a thread pool for resolving urls.
public void add text box ( sprite sprite , double x , double y , int text length ) { int sx = convert world x ( x ) ; int sy = convert world y ( y ) ; sy -= sprite . get height ( ) ; sx = keep sprite on map x ( sprite , sx ) ; sy = keep sprite on map y ( sprite , sy ) ; boolean found = bool ; int tries = num ; while ( found ) { found = bool ; synchronized ( texts ) { for ( final removable sprite item : texts ) { if ( ( item . get x ( ) == sx ) && ( item . get y ( ) == sy ) ) { found = bool ; sy += size unit pixels / num ; sy = keep sprite on map y ( sprite , sy ) ; break ; } } } tries ++ ; if ( tries > num ) { break ; } } texts . add ( new removable sprite ( sprite , sx , sy , math . max ( removable sprite . standard persistence time , text length * removable sprite . standard persistence time / num ) ) ) ; }	adds a text bubble at a give position .
public void dispose ( ) { m debug perspective model . remove listener ( m debug listener ) ; synchronize debugger ( m debug perspective model . get current selected debugger ( ) , null ) ; }	clears up allocated resources .
public string dump ( object data ) { list < object > list = new array list < object > ( num ) ; list . add ( data ) ; return dump all ( list . iterator ( ) ) ; }	serialize a java object into a yaml string .
private void decrement access count ( ) { if ( access count . get ( ) > num ) { access count . decrement and get ( ) ; } }	this method will decrement the access count for a column by 1 whenever a column usage is complete.
public tile directory ( ) { tilename = str ; this . tile id = - num ; westlon = eastlon = northlat = southlat = float . n ; }	construct an untiled tiledirectory . since this object does not have valid boundaries , it is an error to call inregion on it.
public boolean is letter or digit ahead ( ) { int pos = current position ; while ( pos < max position ) { if ( character . is letter or digit ( str . char at ( pos ) ) ) return bool ; pos ++ ; } return bool ; }	tells if there is a digit or a letter character ahead .
public static string add tt ( final string font path , string failed ) { check font tables initialised ( ) ; final file current dir = new file ( font path ) ; if ( ( current dir . exists ( ) ) && ( current dir . is directory ( ) ) ) { final string [ ] files = current dir . list ( ) ; if ( files != null ) { for ( final string current font : files ) { add font file ( current font , font path ) ; } } } else { if ( failed == null ) { failed = font path ; } else { failed = failed + str + font path ; } } return failed ; }	add a truetype font directory and contents to substitution.
public static string to hex ( string arg ) { return string . format ( str , new big integer ( num , arg . get bytes ( ) ) ) ; }	create queries with mid for type i.
public static string add to cart bulk requirements ( http servlet request request , http servlet response response ) { shopping cart cart = get cart object ( request ) ; delegator delegator = ( delegator ) request . get attribute ( str ) ; local dispatcher dispatcher = ( local dispatcher ) request . get attribute ( str ) ; shopping cart helper cart helper = new shopping cart helper ( delegator , dispatcher , cart ) ; string control directive ; map < string , object > result ; map < string , object > param map = util http . get parameter map ( request ) ; string catalog id = catalog worker . get current catalog id ( request ) ; result = cart helper . add to cart bulk requirements ( catalog id , param map ) ; control directive = process result ( result , request ) ; if ( control directive . equals ( error ) ) { return str ; } else { return str ; } }	adds a set of requirements to the cart.
public static void save as gnu step ascii ( ns root , file out ) throws io { file parent = out . get parent file ( ) ; if ( ! parent . exists ( ) && ! parent . mkdirs ( ) ) { throw new io ( str ) ; } output stream writer w = new output stream writer ( new file output stream ( out ) , str ) ; w . write ( root . to gnu step ascii ( ) ) ; w . close ( ) ; }	saves a property list with the given object as root into a ascii file .
protected rewritten outbound url process encode url ( http servlet response hs response , http servlet request hs request , boolean encode url has been run , string outbound url ) { if ( log . is debug enabled ( ) ) { log . debug ( str + outbound url ) ; } if ( outbound url == null ) { return new rewritten outbound url ( null , bool ) ; } boolean final encode outbound url = bool ; string final to url = outbound url ; final list outbound rules = conf . get outbound rules ( ) ; try { for ( int i = num ; i < outbound rules . size ( ) ; i ++ ) { final outbound rule outbound rule = ( outbound rule ) outbound rules . get ( i ) ; if ( ! encode url has been run && outbound rule . is encode first ( ) ) { continue ; } if ( encode url has been run && ! outbound rule . is encode first ( ) ) { continue ; } final rewritten outbound url rewritten url = outbound rule . execute ( final to url , hs request , hs response ) ; if ( rewritten url != null ) { if ( log . is debug enabled ( ) ) { log . debug ( str + outbound rule . get display name ( ) + str ) ; } final to url = rewritten url . get target ( ) ; final encode outbound url = rewritten url . is encode ( ) ; if ( outbound rule . is last ( ) ) { log . debug ( str ) ; break ; } } } } catch ( invocation target exception e ) { try { handle invocation target exception ( hs request , hs response , e ) ; } catch ( servlet exception e1 ) { log . error ( e1 ) ; } catch ( io e1 ) { log . error ( e1 ) ; } } return new rewritten outbound url ( final to url , final encode outbound url ) ; }	handles rewriting urls in jsp ' s etc , i.
@ override public iterator < shopping cart item > iterator ( ) { return cart lines . iterator ( ) ; }	returns an iterator of cart items .
public static string escape xml ( string buffer ) { int start = num ; int length = buffer . length ( ) ; char [ ] array buffer = buffer . to char array ( ) ; string buffer escaped buffer = null ; for ( int i = num ; i < length ; i ++ ) { char c = array buffer [ i ] ; if ( c <= highest special ) { char [ ] escaped = special characters representation [ c ] ; if ( escaped != null ) { if ( start == num ) { escaped buffer = new string buffer ( length + num ) ; } if ( start < i ) { escaped buffer . append ( array buffer , start , i - start ) ; } start = i + num ; escaped buffer . append ( escaped ) ; } } } if ( start == num ) { return buffer ; } if ( start < length ) { escaped buffer . append ( array buffer , start , length - start ) ; } return escaped buffer . to string ( ) ; }	performs the following substring replacements ( to facilitate output to xml / html pages ) : & - > & amp ; < - > & lt ; > - > & gt ; " - > & # 034 ; ' - > & # 039 ; see also outsupport.
private static short v ( jni env , int class jref , int method id , address arg address ) throws exception { if ( trace jni ) vm . sys write ( str ) ; runtime entrypoints . check jni gc ( ) ; try { object return obj = jni . invoke with var arg ( method id , arg address , type reference . short ) ; return reflection . unwrap short ( return obj ) ; } catch ( throwable unexpected ) { if ( trace jni ) unexpected . print stack trace ( system . err ) ; env . record exception ( unexpected ) ; return num ; } }	callstaticshortmethodv : invoke a static method that returns a short value.
private static string remove brackets ( string sub query ) { if ( sub query . index of ( str ) == num && sub query . last index of ( str ) == sub query . length ( ) - num ) { return sub query . substring ( num , sub query . length ( ) - num ) ; } return sub query ; }	removes the first and the last bracket from the sub - query .
public static string [ ] string array from string ( string string , char delimiter ) { list < string > result = new array list < string > ( num ) ; if ( string utils . is not blank ( string ) ) { raptor string tokenizer tok = new raptor string tokenizer ( string , string . value of ( delimiter ) , bool ) ; while ( tok . has more tokens ( ) ) { string token = tok . next token ( ) ; result . add ( token ) ; } } return result . to array ( new string [ num ] ) ; }	returns a string [ ] of strings from a string that is formatted in what tostring ( string [ ] ) returns .
public float text width ( string str ) { if ( text font == null ) { default font or death ( str ) ; } int length = str . length ( ) ; if ( length > text width buffer . length ) { text width buffer = new char [ length + num ] ; } str . get chars ( num , length , text width buffer , num ) ; float wide = num ; int index = num ; int start = num ; while ( index < length ) { if ( text width buffer [ index ] == str ) { wide = math . max ( wide , text width impl ( text width buffer , start , index ) ) ; start = index + num ; } index ++ ; } if ( start < length ) { wide = math . max ( wide , text width impl ( text width buffer , start , index ) ) ; } return wide ; }	return the width of a line of text.
protected void init class defaults ( ui table ) { super . init class defaults ( table ) ; final string windows package name = str ; object [ ] ui defaults = { str , windows package name + str , str , windows package name + str , str , windows package name + str , str , windows package name + str , str , windows package name + str , str , windows package name + str , str , windows package name + str , str , windows package name + str , str , windows package name + str , str , windows package name + str , str , windows package name + str , str , windows package name + str , str , windows package name + str , str , windows package name + str , str , windows package name + str , str , windows package name + str , str , windows package name + str , str , windows package name + str , str , windows package name + str , str , windows package name + str , str , windows package name + str , str , windows package name + str , str , windows package name + str , str , windows package name + str , str , windows package name + str , str , windows package name + str , str , windows package name + str , str , windows package name + str , str , windows package name + str , str , windows package name + str , str , windows package name + str , str , windows package name + str , str , windows package name + str , str , windows package name + str } ; table . put defaults ( ui defaults ) ; }	initialize the uiclassid to basiccomponentui mapping.
public named thread factory ( string name prefix ) { this . name prefix = name prefix ; delegate = executors . default thread factory ( ) ; }	constructs the thread factory .
private void write header line ( list < extension property > property list , int total columns , archive file af , writer writer ) throws io { string [ ] headers = new string [ total columns ] ; headers [ id column index ] = id column name ; int c = num ; for ( extension property property : property list ) { headers [ c ] = property . simple name ( ) ; c ++ ; } string header line = tab row ( headers ) ; af . set ignore header lines ( num ) ; writer . write ( header line ) ; }	write the header column line to file .
private list < usericon > parse chat icons ( string json , string stream ) { try { json parser = new json ( ) ; json root = ( json ) parser . parse ( json ) ; list < usericon > icons new = new array list < > ( ) ; add usericon ( icons new , usericon . type . mod , null , get chat icon url ( root , str , str ) ) ; add usericon ( icons new , usericon . type . sub , stream , get chat icon url ( root , str , str ) ) ; add usericon ( icons new , usericon . type . turbo , null , get chat icon url ( root , str , str ) ) ; add usericon ( icons new , usericon . type . broadcaster , null , get chat icon url ( root , str , str ) ) ; add usericon ( icons new , usericon . type . staff , null , get chat icon url ( root , str , str ) ) ; add usericon ( icons new , usericon . type . admin , null , get chat icon url ( root , str , str ) ) ; add usericon ( icons new , usericon . type . global mod , null , get chat icon url ( root , str , str ) ) ; return icons new ; } catch ( parse exception ex ) { logger . warning ( str + ex . get localized message ( ) ) ; return null ; } }	parses the icons info returned from the twitchapi into a chaticons object containing the urls .
public float distance ( vec3 b ) { float x = this . m [ num ] - b . m [ num ] ; float y = this . m [ num ] - b . m [ num ] ; float z = this . m [ num ] - b . m [ num ] ; float result = ( float ) math . sqrt ( x * x + y * y + z * z ) ; return result ; }	\ brief distance ( this , b ).
@ deprecated public spider ( extension spider extension , spider param spider param , connection param connection param , model model , context scan context ) { this ( str , extension , spider param , connection param , model , scan context ) ; }	instantiates a new spider .
private static boolean evaluate options rules ( list req options , list reg options ) { if ( req options == null || reg options == null || ( req options . size ( ) == num ) ) { return bool ; } iterator i = req options . iterator ( ) ; while ( i . has next ( ) ) { string option = ( string ) i . next ( ) ; if ( reg options . contains ( option ) ) { return bool ; } } return bool ; }	performs options matching for queries.
public void override button ( string button , boolean override ) { log . i ( str , str ) ; if ( button . equals ( str ) ) { web view . set button plumbed to js ( key event . keycode volume up , override ) ; } else if ( button . equals ( str ) ) { web view . set button plumbed to js ( key event . keycode volume down , override ) ; } else if ( button . equals ( str ) ) { web view . set button plumbed to js ( key event . keycode menu , override ) ; } }	override the default behavior of the android volume buttons.
public static boolean remove icon from cache ( context context , app info app info ) { file file = new file ( context . get cache dir ( ) , app info . get apk ( ) ) ; return file . delete ( ) ; }	delelete an app icon from cache folder.
private static int determine consecutive text count ( char sequence msg , int startpos ) { int len = msg . length ( ) ; int idx = startpos ; while ( idx < len ) { char ch = msg . char at ( idx ) ; int numeric count = num ; while ( numeric count < num && is digit ( ch ) && idx < len ) { numeric count ++ ; idx ++ ; if ( idx < len ) { ch = msg . char at ( idx ) ; } } if ( numeric count >= num ) { return idx - startpos - numeric count ; } if ( numeric count > num ) { continue ; } ch = msg . char at ( idx ) ; if ( ! is text ( ch ) ) { break ; } idx ++ ; } return idx - startpos ; }	determines the number of consecutive characters that are encodable using text compaction .
public static void do with fields ( class < ? > clazz , field callback fc , field filter ff ) { class < ? > target class = clazz ; do { field [ ] fields = target class . get declared fields ( ) ; for ( field field : fields ) { if ( ff != null && ! ff . matches ( field ) ) { continue ; } try { fc . do with ( field ) ; } catch ( illegal access exception ex ) { throw new illegal state exception ( str + field . get name ( ) + str + ex ) ; } } target class = target class . get superclass ( ) ; } while ( target class != null && target class != object . class ) ; }	invoke the given callback on all fields in the target class , going up the class hierarchy to get all declared fields .
private property descriptor [ ] property descriptors ( class c ) throws sql { bean info bean info ; try { bean info = introspector . get bean info ( c ) ; } catch ( introspection exception e ) { throw new sql ( str + e . get message ( ) ) ; } return bean info . get property descriptors ( ) ; }	returns a propertydescriptor [ ] for the given class .
@ override public list < app entry > load in background ( ) { list < application info > apps = m pm . get installed applications ( package manager . get uninstalled packages | package manager . get disabled components ) ; if ( apps == null ) { apps = new array list < > ( ) ; } final context context = get context ( ) ; list < app entry > entries = new array list < > ( apps . size ( ) ) ; for ( int i = num ; i < apps . size ( ) ; i ++ ) { app entry entry = new app entry ( this , apps . get ( i ) ) ; entry . load label ( context ) ; entries . add ( entry ) ; } collections . sort ( entries , alpha comparator ) ; return entries ; }	this is where the bulk of our work is done.
public static long parse duration ( string duration str ) { long duration = - num ; string [ ] component arr = duration str . split ( str ) ; switch ( component arr . length ) { case num : duration = parse duration from seconds ( duration str ) ; break ; case num : case num : duration str = ensure segmented duration ( duration str ) ; duration = parse duration from string ( duration str ) ; break ; default : break ; } return duration ; }	parses a duration string into milliseconds.
public boolean exists ( ) { return file . exists ( ) ; }	tells if the file exists .
private void start download repeat ( final string hostname , final int port , final string uri ) { m repeat download = bool ; m speed test socket . start download ( hostname , port , uri ) ; }	start download for download repeat .
public void init ( boolean for encryption , cipher parameters param ) { core . init ( for encryption , param ) ; if ( param instanceof parameters with random ) { parameters with random r param = ( parameters with random ) param ; key = ( rsa ) r param . get parameters ( ) ; random = r param . get random ( ) ; } else { key = ( rsa ) param ; random = new secure random ( ) ; } }	initialise the rsa engine .
public void exec ( final string service , final string action , final string callback id , final string raw args ) { cordova plugin plugin = get plugin ( service ) ; if ( plugin == null ) { log . d ( tag , str + service ) ; plugin result cr = new plugin result ( plugin result . status . class not found exception ) ; app . send plugin result ( cr , callback id ) ; return ; } callback context callback context = new callback context ( callback id , app ) ; try { long plugin start time = system . current time millis ( ) ; boolean was valid action = plugin . execute ( action , raw args , callback context ) ; long duration = system . current time millis ( ) - plugin start time ; if ( duration > slow exec warning threshold ) { log . w ( tag , str + service + str + action + str + duration + str ) ; } if ( ! was valid action ) { plugin result cr = new plugin result ( plugin result . status . invalid action ) ; callback context . send plugin result ( cr ) ; } } catch ( json e ) { plugin result cr = new plugin result ( plugin result . status . json exception ) ; callback context . send plugin result ( cr ) ; } catch ( exception e ) { log . e ( tag , str , e ) ; callback context . error ( e . get message ( ) ) ; } }	receives a request for execution and fulfills it by finding the appropriate java class and calling it ' s execute method.
public void push stream ( char [ ] in stream , int in fileid , string name , string in base dir , string in encoding ) { include stack . push ( new include state ( cursor , line , col , fileid , file name , base dir , encoding , stream ) ) ; cursor = num ; line = num ; col = num ; fileid = in fileid ; file name = name ; base dir = in base dir ; encoding = in encoding ; stream = in stream ; }	sets this mark ' s state to a new stream.
protected void stop output test ( ) { if ( test running && out test ) { out timer . stop ( ) ; status text1 . set text ( str + integer . to string ( num iterations ) + str ) ; status text1 . set visible ( bool ) ; status text2 . set text ( str ) ; status text2 . set visible ( bool ) ; } }	local method to stop an output test.
public builder ( ) { this . created = new date ( system . current time millis ( ) ) ; this . last modified = this . created ; }	constructs a new builder with the created and last modified time set to the current time.
@ override public table dto create ( @ nonnull qualified name name ) { table dto result = null ; log . info ( str , name ) ; optional < table dto > o table = table service . get ( name , bool ) ; if ( o table . is present ( ) ) { table dto table = o table . get ( ) ; string view name = create view name ( name ) ; qualified name target name = qualified name . of table ( name . get catalog name ( ) , view db name , view name ) ; log . info ( str , target name ) ; optional < table dto > o view table = optional . empty ( ) ; try { o view table = table service . get ( target name , bool ) ; } catch ( not found exception ignored ) { } if ( ! o view table . is present ( ) ) { log . info ( str , target name ) ; result = table service . copy ( table , target name ) ; } else { result = o view table . get ( ) ; } } else { throw new table not found exception ( new schema table name ( name . get database name ( ) , name . get table name ( ) ) ) ; } return result ; }	creates the materialized view using the schema of the give table assumes that the " franklinviews " database name already exists in the given catalog .
public int int header ( final string name , final int default value ) throws http request exception { close output quietly ( ) ; return connection . get header field int ( name , default value ) ; }	get an integer header value from the response falling back to the given default value if the header is missing or if parsing fails.
public string build jvm vendor ( ) { return properties . get property ( str ) ; }	returns the vendor for the jvm used to generate this build .
public static void value to document ( value value , string root node name , document document ) { element root = document . create element ( root node name ) ; document . append child ( root ) ; value to document ( value , root , document ) ; }	transforms a jolie . value object to an xml document instance .
public void stop logging ( ) { active = bool ; }	method to for asynchronous termination of sampling loops.
private void merge force collapse ( ) { while ( stack size > num ) { int n = stack size - num ; if ( n > num && run len [ n - num ] < run len [ n + num ] ) n -- ; merge at ( n ) ; } }	merges all runs on the stack until only one remains.
private void show about ( ) { if ( about == null ) { about = new common about dialog ( frame ) ; } about . set visible ( bool ) ; }	called when the user selects the " help - > about " menu item .
public list < linear constraint > normalize constraints ( collection < linear constraint > original constraints ) { list < linear constraint > normalized = new array list < linear constraint > ( original constraints . size ( ) ) ; for ( linear constraint constraint : original constraints ) { normalized . add ( normalize ( constraint ) ) ; } return normalized ; }	get new versions of the constraints which have positive right hand sides .
public os lib ( ) { }	create and oslib instance .
protected void tear down ( ) { obj array = null ; obj array2 = null ; hm = null ; }	tears down the fixture , for example , close a network connection.
@ override protected void init request ( ) { super . init request ( ) ; state = state . to active ( ) ; http buffer store buffer store = get http buffer store ( ) ; method . clear ( ) ; method string = null ; protocol . clear ( ) ; uri length = num ; if ( buffer store == null ) { uri = get small uri buffer ( ) ; header buffer = get small header buffer ( ) ; header keys = get small header keys ( ) ; header values = get small header values ( ) ; } uri host . clear ( ) ; host = null ; keepalive = keepalive state . init ; header size = num ; header length = num ; in offset = num ; is chunked in = bool ; is first = bool ; }	clear the request variables in preparation for a new request .
@ override public void remove data source listener ( data source listener dsl ) { m data listeners . remove ( dsl ) ; }	remove a data souce listener.
public static void do with fields ( class < ? > clazz , field callback fc ) throws illegal argument exception { do with fields ( clazz , fc , null ) ; }	invoke the given callback on all fields in the target class , going up the class hierarchy to get all declared fields .
public static distribution config impl produce ( properties props , boolean is connected ) { if ( props != null ) { object o = props . get ( ds config name ) ; if ( o instanceof distribution config impl ) { return ( distribution config impl ) o ; } } return new distribution config impl ( props , bool , is connected ) ; }	produce a distributionconfigimpl for the given properties and return it .
public shape create point ( d point ) { d . double point marker = new d . double ( num , num , size , size ) ; point marker . x = ( double ) ( point . get x ( ) - ( size / num ) ) ; point marker . y = ( double ) ( point . get y ( ) - ( size / num ) ) ; return point marker ; }	creates a shape representing a point .
private void repaint children ( final rectangle r ) { final rectangle content = get content size ( ) ; for ( final lw < ? , ? > child : get children ( ) ) { final rectangle child bounds = child . get bounds ( ) ; rectangle to paint = r . intersection ( child bounds ) ; to paint = to paint . intersection ( content ) ; to paint . translate ( - child bounds . x , - child bounds . y ) ; child . repaint peer ( to paint ) ; } }	paints all the child peers in the straight z - order , so the bottom - most ones are painted first .
private long calculate millis for ( mpp node , long common base ) { final big decimal qty = node . get qty to deliver ( ) ; long total duration = + node . get queuing time ( ) + node . get setup time required ( ) + node . get moving time ( ) + node . get waiting time ( ) ; final big decimal working time = routing service . estimate working time ( node , qty ) ; total duration += working time . double value ( ) ; return ( long ) ( total duration * common base * num ) ; }	calculate how many millis take to complete given qty on given node ( operation ) .
protected void add ( string type , string info ) { string seperator = seperator ; if ( start ( type ) ) { text = new string builder ( ) ; text . append ( timestamp ( ) ) ; text . append ( type ) ; text . append ( str ) ; seperator = str ; } text . append ( seperator ) ; text . append ( info ) ; length ++ ; if ( length >= max length ) { close ( ) ; } }	prints something in compact mode , meaning that nick events of the same type appear in the same line , for as long as possible.
public void resize capacity ( int new capacity ) { if ( new capacity == capacity ) return ; total quads = math . min ( total quads , new capacity ) ; capacity = new capacity ; byte buffer tbb = byte buffer . allocate direct ( cc quad2 . size * new capacity * num ) ; tbb . order ( byte order . native order ( ) ) ; float buffer tmp tex coords = tbb . as float buffer ( ) ; tmp tex coords . put ( texture coordinates ) ; texture coordinates = tmp tex coords ; texture coordinates . position ( num ) ; byte buffer vbb = byte buffer . allocate direct ( cc quad3 . size * new capacity * num ) ; vbb . order ( byte order . native order ( ) ) ; float buffer tmp vertex coords = vbb . as float buffer ( ) ; tmp vertex coords . put ( vertex coordinates ) ; vertex coordinates = tmp vertex coords ; vertex coordinates . position ( num ) ; byte buffer isb = byte buffer . allocate direct ( num * new capacity * num ) ; isb . order ( byte order . native order ( ) ) ; short buffer tmp indices = isb . as short buffer ( ) ; tmp indices . put ( indices ) ; indices = tmp indices ; indices . position ( num ) ; init indices ( ) ; if ( with color array ) { byte buffer cbb = byte buffer . allocate direct ( num * cc color4 b . size * new capacity * num ) ; cbb . order ( byte order . native order ( ) ) ; float buffer tmp colors = cbb . as float buffer ( ) ; tmp colors . put ( colors ) ; colors = tmp colors ; colors . position ( num ) ; } }	resize the capacity of the texture atlas.
public string convert statement ( string ora statement ) { convert . log migration script ( ora statement , null , null ) ; return ora statement ; }	convert an individual oracle style statements to target database statement syntax .
public void annotation added ( annotation annotation ) { added annotations . add ( annotation ) ; }	adds the given annotation to the set of annotations that are reported as being added from the model.
private void compute snaps ( collection seg strings , collection snap pts ) { for ( iterator i0 = seg strings . iterator ( ) ; i0 . has next ( ) ; ) { noded segment string ss = ( noded segment string ) i0 . next ( ) ; compute snaps ( ss , snap pts ) ; } }	computes nodes introduced as a result of snapping segments to snap points ( hot pixels ).
public short calc record length ( dbf table model model ) { int length = num ; int column count = model . get column count ( ) ; for ( int i = num ; i <= column count - num ; i ++ ) { length += model . get length ( i ) ; } length += num ; integer integer = new integer ( length ) ; return integer . short value ( ) ; }	calculates the length of the record by aggregating the length of each field.
public static void plan change accepted ( @ analytics cnsts . plan change string plan change type , double amount ) { date date = new date ( ) ; timestamp cur time = new timestamp ( date . get time ( ) ) ; string json = gson . to json ( new analytics plan change ( plan change type , amount , cur time ) , analytics plan change . class ) ; json json object = null ; try { json object = new json ( json ) ; json object . put ( str , str ) ; log . i ( str , str + json object . to string ( ) ) ; wl . log ( str , json object ) ; } catch ( json e ) { e . print stack trace ( ) ; } }	planchangeaccepted ( ) sends an operational analytics log anytime a user accepts a plan change .
private boolean equals ( object o , object p ) { return ( o == p || ( ( o != null ) && o . equals ( p ) ) ) ; }	convenient method to test equality in two objects , taking into account nulls .
public void add exception ( final string key , final string value ) { if ( value == null ) { key value exceptions . put ( key , null ) ; } else { set < string > values = map utils . get set ( key , key value exceptions ) ; values . add ( value ) ; } }	adds an exception to the filter , that is if this key and value appears , the filter will return false.
public boolean is configured ( ) { return pre calc match client . is configured ( ) ; }	utility method to confirm if this service is working .
protected object conditional copy ( object o ) { if ( is copy on read ( ) && ! token . is invalid ( o ) ) { return copy helper . copy ( o ) ; } else { return o ; } }	makes a copy , if copy - on - get is enabled , of the specified object .
private static boolean jwt has audience claim ( jwt claims set jwt claims ) throws auth login exception { list < string > audience claim = jwt claims . get audience ( ) ; return ( audience claim != null && ! audience claim . is empty ( ) ) ; }	check if the token has an authorized party ( " azp " ) entry .
protected test config create test config ( string temp dir , list < string > proto files ) { return new test config ( test data locator , temp dir , proto files ) ; }	creates the model object based on the input proto files .
@ override public void remove vetoable change listener ( string name , vetoable change listener vcl ) { m bc support . remove vetoable change listener ( name , vcl ) ; }	remove a vetoable change listener from this bean.
void update ( prepared statement prep , string trace message ) throws sql { test . trace ( trace message ) ; prep . execute update ( ) ; if ( test . is collect ( ) ) { executed statements . increment and get ( ) ; } }	execute an sql statement .
private void wrap ( string builder buffer , localizable message text ) { indent and wrap ( buffer , str , text ) ; }	wraps long lines without indentation .
@ side only ( side . client ) public void add special item tooltip ( int x pos , int y pos , item stack stack , array list < string > tool tips ) { if ( mouse x >= x pos && mouse y >= y pos && mouse x <= x pos + num && mouse y <= y pos + num ) { if ( stack != null ) { list < string > tooltip data = stack . get tooltip ( minecraft . get minecraft ( ) . the player , bool ) ; list < string > parsed tooltip = new array list ( ) ; boolean first = bool ; for ( string tip : tool tips ) tooltip data . add ( tip ) ; for ( string s : tooltip data ) { string s = s ; if ( ! first ) s = chat formatting . gray + s ; parsed tooltip . add ( s ) ; first = bool ; } render tooltip ( mouse x , mouse y , parsed tooltip , num , num ) ; } } }	adds a special tooltip in case you want to.
private int do cancel ( ) { int deselected = num ; set < selection key > cancelled keys = cancelled keys ( ) ; synchronized ( cancelled keys ) { if ( cancelled keys . size ( ) > num ) { for ( selection key current key : cancelled keys ) { mutable keys . remove ( current key ) ; deregister ( ( abstract selection key ) current key ) ; if ( mutable selected keys . remove ( current key ) ) { deselected ++ ; } } cancelled keys . clear ( ) ; } } return deselected ; }	removes cancelled keys from the key set and selected key set , and unregisters the corresponding channels.
public q ( string qname , element namespace context , prefix resolver resolver ) { this ( qname , namespace context , resolver , bool ) ; }	construct a qname from a string , resolving the prefix using the given namespace context and prefix resolver.
protected void merge cache ( list < object > objects ) { synchronized ( this ) { if ( this . object list != null ) { objects = new array list < > ( objects ) ; for ( int i = num ; i < objects . size ( ) ; i ++ ) { object new object = objects . get ( i ) ; string new object name = get object name ( new object ) ; for ( int k = num ; k < object list . size ( ) ; k ++ ) { object old object = object list . get ( k ) ; string old object name = get object name ( old object ) ; if ( new object name . equals ( old object name ) ) { objects . set ( i , old object ) ; break ; } } } } } set cache ( objects ) ; }	merges new cache with existing.
@ override public string to string ( ) { return date . to string ( ) ; }	generates a string representation of the date .
public void remove sub config ( string sub config name ) throws sms , sso { validate service config impl ( ) ; sub config name = sms . unescape name ( sub config name ) ; string sdn = str + sub config name + str + sc . get dn ( ) ; service config manager impl scm impl = service config manager impl . get instance ( token , get service name ( ) , get version ( ) ) ; service config impl s config impl = sc . get sub config ( token , sub config name ) ; if ( s config impl != null ) { service config impl . delete instance ( token , scm impl , null , sdn , str , s config impl . get group name ( ) , ( get component name ( ) + str + sms . escape special characters ( sub config name ) ) , bool , ss ) ; } sms c entry = sms . get instance ( token , sdn ) ; if ( c entry . is dirty ( ) ) { c entry . refresh ( ) ; } sms entry = c entry . get cloned sms ( ) ; entry . delete ( token ) ; c entry . refresh ( entry ) ; cached sub entries cse = cached sub entries . get instance ( token , sc . get dn ( ) ) ; cse . remove ( sub config name ) ; }	removes the service sub - configuration .
private static int string to hash ( string s ) { int len = s . length ( ) ; int hash = len ; hash <<= num ; hash += s . char at ( num ) - num ; int j = len ; for ( int i = num ; i < num && j > num ; i ++ ) { j -- ; hash <<= num ; hash += s . char at ( j ) - num ; } return hash ; }	this method has to return a unique integer for each well - known lower - cased element name .
@ override public void on action ( ) { on action ( action type . look closely ) ; }	perform the default action .
public void test equal objects ( ) { string value1 = str ; string value2 = str ; big integer a number1 = new big integer ( value1 ) ; big integer a number2 = new big integer ( value2 ) ; int code1 = a number1 . hash code ( ) ; int code2 = a number2 . hash code ( ) ; if ( a number1 . equals ( a number2 ) ) { assert true ( str , code1 == code2 ) ; } }	test hash codes for equal objects .
public void test validate ( ) { }	unit test for validating a write set against the current ground state.
@ override public string to string ( ) { if ( m == null ) { return str ; } else { string buffer sb = new string buffer ( ) ; sb . append ( str + m best result + str ) ; sb . append ( str + m best num its + str ) ; if ( m thresholds != null ) { sb . append ( str ) ; for ( int i = num ; i < m thresholds . length ; i ++ ) { sb . append ( m thresholds [ i ] + str ) ; } } sb . append ( str ) ; sb . append ( m . to string ( ) ) ; return sb . to string ( ) ; } }	returns a string describing the classifier .
private static boolean has modern rasterizer ( ) { try { class . for name ( awt utilities class name ) ; return bool ; } catch ( class not found exception e ) { return bool ; } }	checks and answers whether this java runtime has a modern rasterizer or not.
public set < access right > apply access rights ( app context ctx , set < access right > access rights , set < access right > new access rights ) { set < access right > rights to add = new hash set < access right > ( ) ; set < access right > rights to remove = new hash set < access right > ( ) ; set < access right > rights = new hash set < access right > ( access rights ) ; user user = ctx . get user ( ) ; for ( access right new right : new access rights ) { if ( ! access rights . contains ( new right ) ) { if ( has role ( user , new access rights , new right . get role ( ) ) ) { rights to add . add ( new right ) ; } else { throw new api ( str + new right . get role ( ) + str , ctx . is no error ( ) ) ; } } } if ( ! new access rights . is empty ( ) ) { for ( access right right : access rights ) { if ( ! new access rights . contains ( right ) ) { if ( has role ( user , new access rights , right . get role ( ) ) ) { rights to remove . add ( right ) ; } else { throw new api ( str + right . get role ( ) + str , ctx . is no error ( ) ) ; } } } } rights . add all ( rights to add ) ; rights . remove all ( rights to remove ) ; return rights ; }	compute the access rights to apply based on the current user rights . < br >.
public void add road ( road road ) { roads . add element ( road ) ; }	add a road to this intersection .
symbol find inherited member type ( env < attr context > env , type site , name name , type symbol c ) { symbol best so far = type not found ; symbol sym ; type st = types . supertype ( c . type ) ; if ( st != null && st . has tag ( class ) ) { sym = find member type ( env , site , name , st . tsym ) ; if ( sym . kind < best so far . kind ) best so far = sym ; } for ( list < type > l = types . interfaces ( c . type ) ; best so far . kind != ambiguous && l . non empty ( ) ; l = l . tail ) { sym = find member type ( env , site , name , l . head . tsym ) ; if ( best so far . kind < ambiguous && sym . kind < ambiguous && sym . owner != best so far . owner ) best so far = new ambiguity error ( best so far , sym ) ; else if ( sym . kind < best so far . kind ) best so far = sym ; } return best so far ; }	find a member type inherited from a superclass or interface .
public static boolean is initialized ( context ctx ) { vitamio package = ctx . get package name ( ) ; vitamio library path = context utils . get data dir ( ctx ) + str ; file dir = new file ( get library path ( ) ) ; if ( dir . exists ( ) && dir . is directory ( ) ) { string [ ] libs = dir . list ( ) ; if ( libs != null ) { arrays . sort ( libs ) ; for ( string l : get required libs ( ) ) { if ( arrays . binary search ( libs , l ) < num ) { log . e ( str , l ) ; return bool ; } } file lock = new file ( get library path ( ) + libs lock ) ; buffered reader buffer = null ; try { buffer = new buffered reader ( new file reader ( lock ) ) ; int app version = context utils . get version code ( ctx ) ; int lib version = integer . value of ( buffer . read line ( ) ) ; log . i ( str , app version , lib version ) ; if ( lib version == app version ) return bool ; } catch ( io e ) { log . e ( str , e ) ; } catch ( number format exception e ) { log . e ( str , e ) ; } finally { io . close silently ( buffer ) ; } } } return bool ; }	check if vitamio is initialized at this device.
@ override public set < statement > apply ( final igas < set < statement > , set < statement > , set < statement > > state , final value u , final set < statement > sum ) { if ( sum != null ) { final set < statement > us = state . get state ( u ) ; us . add all ( sum ) ; return us ; } return null ; }	union the gathered edges with those already decorating the vertex .
public void add predictions ( array list < prediction > predictions ) throws exception { for ( int i = num ; i < predictions . size ( ) ; i ++ ) { add prediction ( ( nominal prediction ) predictions . get ( i ) ) ; } }	includes a whole bunch of predictions in the confusion matrix .
protected abstract void action performed ( action event evt ) ;	change the underlying bean such that the it is consistent with the value displayed by this configurator .
synchronized void unregister to notifications ( ) throws jms { if ( event session == null ) { return ; } if ( logger . is loggable ( level . fine ) ) { logger . log ( level . fine , to string2 ( ) + str ) ; } try { event session . close ( ) ; } catch ( io e ) { if ( logger . is loggable ( level . fine ) ) { logger . log ( level . fine , to string2 ( ) + str + e ) ; } jms e1 = new jms ( str ) ; e1 . set linked exception ( e ) ; throw e1 ; } catch ( unknown lease exception e ) { if ( logger . is loggable ( level . fine ) ) { logger . log ( level . fine , to string2 ( ) + str + e ) ; } jms e1 = new jms ( str ) ; e1 . set linked exception ( e ) ; throw e1 ; } catch ( exception e ) { if ( logger . is loggable ( level . fine ) ) { logger . log ( level . fine , to string2 ( ) + str + e ) ; } jms e1 = new jms ( str ) ; e1 . set linked exception ( e ) ; throw e1 ; } finally { event session = null ; } }	closes the notifydelegator so no more notifications will arrive .
public double [ ] [ ] predict intervals ( instance instance , double confidence level ) throws exception { univariate interval estimator e = ( univariate interval estimator ) get density estimator ( instance , bool ) ; return e . predict intervals ( confidence level ) ; }	returns an n * 2 array , where n is the number of prediction intervals.
public static void register update listener ( update listener l ) { update listeners . add ( l ) ; }	register a callback for when the player service changes its state and the ui needs to be updated.
private int offset ( int i , int j ) { if ( i < num || j > max || i > j ) { throw new runtime exception ( string . format ( str , i , j , max ) ) ; } return i * ( max + num ) - i * ( i + num ) / num + j ; }	this computes the offset into the one - dimensional array for a given span .
protected double norm ( double x , int i ) { if ( double . is na n ( m [ i ] ) || utils . eq ( m [ i ] , m [ i ] ) ) { return num ; } else { return ( x - m [ i ] ) / ( m [ i ] - m [ i ] ) ; } }	normalizes a given value of a numeric attribute .
public builder ( string host , int port ) { this . host = host ; this . port = integer . to string ( port ) ; }	instantiates a new builder .
public static boolean has lower case char ( string s ) { char [ ] chars = s . to char array ( ) ; for ( char c : chars ) { if ( character . is lower case ( c ) ) { return bool ; } } return bool ; }	does the string have a lowercase character ?.
public value [ ] read row ( value [ ] row ) throws sql { statement builder buff = new statement builder ( str ) ; append column list ( buff , bool ) ; buff . append ( str ) ; append table name ( buff ) ; append key condition ( buff ) ; prepared statement prep = conn . prepare statement ( buff . to string ( ) ) ; set key ( prep , num , row ) ; result set rs = prep . execute query ( ) ; if ( ! rs . next ( ) ) { throw db exception . get ( error code . no data available ) ; } value [ ] new row = new value [ column count ] ; for ( int i = num ; i < column count ; i ++ ) { int type = result . get column type ( i ) ; new row [ i ] = data type . read value ( conn . get session ( ) , rs , i + num , type ) ; } return new row ; }	re - reads a row from the database and updates the values in the array .
private static double chi cell ( double freq , double expected , boolean yates ) { if ( utils . sm or eq ( expected , num ) ) { return num ; } double diff = math . abs ( freq - expected ) ; if ( yates ) { diff -= num ; if ( diff < num ) { diff = num ; } } return ( diff * diff / expected ) ; }	computes chi - value for one cell in a contingency table .
@ override public void initiaize ( file file , int entry count ) throws carbon sort key and group by exception { try { stream = new data output stream ( new buffered output stream ( new file output stream ( file ) , write buffer size ) ) ; stream . write int ( entry count ) ; } catch ( file not found exception e1 ) { throw new carbon sort key and group by exception ( e1 ) ; } catch ( io e ) { throw new carbon sort key and group by exception ( e ) ; } }	below method will be used to initialize the stream and write the entry count.
public void test number of neighbors ( ) { int i ; int inst index ; instances neighbors ; try { m . set instances ( m ) ; } catch ( exception e ) { fail ( str + e ) ; } for ( i = num ; i <= m ; i ++ ) { inst index = m . next int ( m . num instances ( ) ) ; try { neighbors = m . k nearest neighbours ( m . instance ( inst index ) , i ) ; assert equals ( str , i , neighbors . num instances ( ) ) ; } catch ( exception e ) { fail ( str + i + str + ( inst index + num ) + str + e ) ; } } }	tests whether the number of instances returned by the algorithms is the same as was requested.
public static long parse long ( string text ) { try { return long . parse long ( text ) ; } catch ( number format exception e ) { return num ; } }	parse long value from a string , if null or exception , return 0.
public immutable list < message type > filter documenting messages ( proto container element element ) { immutable list . builder < message type > builder = immutable list . builder ( ) ; for ( message type msg : element . get messages ( ) ) { if ( ! msg . is map entry ( ) ) { builder . add ( msg ) ; } } return builder . build ( ) ; }	return the list of messages within element which should be documented in ruby .
public static boolean is null ( final object model , final string column name ) { if ( model == null ) { return bool ; } else if ( grid tab wrapper . is handled ( model ) ) { return grid tab wrapper . is null ( model , column name ) ; } else if ( po . is handled ( model ) ) { return po . is null ( model , column name ) ; } else { throw new adempiere exception ( str + model + str + model . get class ( ) + str ) ; } }	check if given columnname ' s value is null.
private static int parse number ( char sequence offset id , int pos , boolean preceded by colon ) { if ( preceded by colon && offset id . char at ( pos - num ) != str ) { throw new date time exception ( str + offset id ) ; } char ch1 = offset id . char at ( pos ) ; char ch2 = offset id . char at ( pos + num ) ; if ( ch1 < str || ch1 > str || ch2 < str || ch2 > str ) { throw new date time exception ( str + offset id ) ; } return ( ch1 - num ) * num + ( ch2 - num ) ; }	parse a two digit zero - prefixed number .
public static int compare ( char [ ] str1 , char [ ] str2 ) { int len1 = str1 . length ; int len2 = str2 . length ; int n = math . min ( len1 , len2 ) ; int i = num ; while ( n -- != num ) { char c1 = str1 [ i ] ; char c2 = str2 [ i ++ ] ; if ( c1 != c2 ) { return c1 - c2 ; } } return len1 - len2 ; }	compares two strings lexicographically.
public static boolean equals ( float [ ] field1 , float [ ] field2 ) { if ( field1 == null || field1 . length == num ) { return field2 == null || field2 . length == num ; } else { return arrays . equals ( field1 , field2 ) ; } }	checks repeated float field equality ; null - value and 0 - length fields are considered equal .
public void test session protection ( ) { final properties p = get properties ( ) ; p . set property ( abstract transaction service . options . min release age , str ) ; final journal store = get journal ( p ) ; try { final irw bs = ( irw ) store . get buffer strategy ( ) ; final byte [ ] buf = new byte [ num ] ; r . next bytes ( buf ) ; final byte buffer bb = byte buffer . wrap ( buf ) ; final long faddr = store . write ( bb ) ; final i tx = bs . new tx ( ) ; byte buffer rd buf = store . read ( faddr ) ; bb . position ( num ) ; assert equals ( bb , rd buf ) ; store . delete ( faddr ) ; bb . position ( num ) ; rd buf = store . read ( faddr ) ; assert equals ( bb , rd buf ) ; tx . close ( ) ; store . commit ( ) ; } finally { store . destroy ( ) ; } }	tests whether tasks are able to access and modify data safely by emulating transactions by calling activatetx and deactivatetx directly .
public static int hash ( int hash , float item ) { return hash * prime + float . float to int bits ( item ) ; }	add a float value to a given hash .
public static boolean is key pair entry ( string alias , key store key store ) throws key store exception { return key store . is key entry ( alias ) && key store . get certificate chain ( alias ) != null && key store . get certificate chain ( alias ) . length != num ; }	is the named entry in the keystore a key pair entry ?.
public search source builder field data field ( string name ) { if ( field data fields == null ) { field data fields = new array list < > ( ) ; } field data fields . add ( name ) ; return this ; }	adds a field to load from the field data cache and return as part of the search request .
public boolean has more ( ) { return num left . compare to ( big integer . zero ) == num ; }	returns true if there are more combinations left .
public void add listener ( final file alteration listener listener ) { if ( listener != null ) { listeners . add ( listener ) ; } }	add a file system listener .
public void remove claims for ( int row , int col ) { effect claims . remove ( get key for coords ( row , col ) ) ; }	just removes all claims for the given row and column.
protected void load frame information ( rpf toc entry rpf toc entry ) { try { if ( bin file == null && a toc file path != null ) { bin file = new binary buffered file ( a toc file path ) ; bin file . byte order ( a toc byte order ) ; read frame information ( bin file , rpf toc entry ) ; bin file . close ( ) ; bin file = null ; } } catch ( io ioe ) { debug . error ( str + ioe ) ; } catch ( format exception fe ) { debug . error ( str + fe ) ; } }	should be called by the rpfframecachehandler before any frame files are loaded from a rpftocentry.
public static void debug ( final string message ) { debug logger . accept ( message ) ; }	logs a message to the configured debug logger .
public void remove notification listener ( notification listener listener ) throws listener not found exception { broadcaster . remove notification listener ( listener ) ; }	mbeannotification support - delegates to broadcaster .
public void test ( ) { string prompt = str ; try { password callback pc = new password callback ( prompt , bool ) ; assert not null ( str , pc ) ; assert equals ( prompt , pc . get prompt ( ) ) ; assert equals ( bool , pc . is echo on ( ) ) ; } catch ( exception e ) { fail ( str + e ) ; } try { password callback pc = new password callback ( prompt , bool ) ; assert not null ( str , pc ) ; assert equals ( prompt , pc . get prompt ( ) ) ; assert equals ( bool , pc . is echo on ( ) ) ; } catch ( exception e ) { fail ( str + e ) ; } try { password callback pc = new password callback ( null , bool ) ; fail ( str ) ; } catch ( illegal argument exception npe ) { } try { password callback pc = new password callback ( str , bool ) ; fail ( str ) ; } catch ( illegal argument exception npe ) { } }	javax . security . auth . callback . passwordcallback # passwordcallback ( string prompt , boolean echoon ) javax . security . auth . callback . passwordcallback # getprompt ( ) javax . security . auth . callback . passwordcallback # isechoon ( ).
static string value to string ( object value ) { if ( value == null || value . equals ( null ) ) { return str ; } if ( value instanceof string ) { return ( string ) value ; } if ( value instanceof float || value instanceof double || value instanceof byte || value instanceof short || value instanceof integer || value instanceof long ) { return number to string ( value ) ; } if ( value instanceof boolean || value instanceof map || value instanceof list ) { return value . to string ( ) ; } return quote ( value . to string ( ) ) ; }	make a json text of an object value.
public void test htree math address bits 8 ( ) { final int address bits = num ; final string builder sb = new string builder ( ) ; do h ( address bits , sb ) ; if ( log . is info enabled ( ) ) log . info ( sb . to string ( ) ) ; }	exercise the hash tree math for an 8 - bit address space .
protected final int is left ( double [ ] a , double [ ] b , double [ ] o ) { final double cross = get rx ( a , o ) * get ry ( b , o ) - get ry ( a , o ) * get rx ( b , o ) ; if ( cross == num ) { final double dista = math . abs ( get rx ( a , o ) ) + math . abs ( get ry ( a , o ) ) ; final double distb = math . abs ( get rx ( b , o ) ) + math . abs ( get ry ( b , o ) ) ; return double . compare ( dista , distb ) ; } return double . compare ( cross , num ) ; }	test whether a point is left of the other wrt.
public socket create socket ( ) throws io { socket s = new socket ( ) ; s . bind ( new inet socket address ( bind address , num ) ) ; return s ; }	the same as the similarly named javax.
private conversation start to join meeting ( ) { uri meeting uri = null ; conversation conversation = null ; try { meeting uri = new uri ( get string ( r . string . meeting url ) ) ; } catch ( uri e ) { e . print stack trace ( ) ; } try { m application = application . get instance ( this ) ; conversation = m application . join meeting anonymously ( get string ( r . string . user display name ) , meeting uri ) ; } catch ( sfb e ) { e . print stack trace ( ) ; } return conversation ; }	connect to an existing skype for business meeting with the uri you get from a server - side ucwa - based web service .
public static boolean is column hidden ( class < ? > controller class , string column name ) { return hidden columns cache . contains ( get column hash ( controller class , column name ) ) ; }	returns if the cache has any knowledge if the column is hidden .
protected void remove all current downloads ( ) { log . i ( log tag , str ) ; array list < long > ids = new array list < long > ( ) ; cursor cursor = m download manager . query ( new query ( ) ) ; try { if ( cursor . move to first ( ) ) { do { int index = cursor . get column index ( download manager . column id ) ; long download id = cursor . get long ( index ) ; ids . add ( download id ) ; } while ( cursor . move to next ( ) ) ; } } finally { cursor . close ( ) ; } for ( long id : ids ) { m download manager . remove ( id ) ; } cursor = m download manager . query ( new query ( ) ) ; try { assert equals ( num , cursor . get count ( ) ) ; } finally { cursor . close ( ) ; } }	helper to remove all downloads that are registered with the dl manager.
public boolean visible from ( ct class clazz ) { int mod = get modifiers ( ) ; if ( modifier . is public ( mod ) ) return bool ; else if ( modifier . is private ( mod ) ) return clazz == declaring class ; else { string decl name = declaring class . get package name ( ) ; string from name = clazz . get package name ( ) ; boolean visible ; if ( decl name == null ) visible = from name == null ; else visible = decl name . equals ( from name ) ; if ( ! visible && modifier . is protected ( mod ) ) return clazz . subclass of ( declaring class ) ; return visible ; } }	returns true if this member is accessible from the given class .
void copy to ( int set target ) { if ( target . elements . length < size ) { target . elements = arrays . copy of ( elements , elements . length ) ; } else { system . arraycopy ( elements , num , target . elements , num , size ) ; } target . size = size ; }	copies the contents of this set to the target set .
public void test shift left2 ( ) { byte a bytes [ ] = { num , - num , num , num , - num , - num , num , num , num , num , - num , num , num } ; int a sign = num ; int number = - num ; byte r bytes [ ] = { num , num , num , - num , - num , - num , num , - num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer result = a number . shift left ( number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	shiftleft ( int n ) , n < 0.
private static int resolve method ref offset ( constant pool constant pool , class < ? > lambda type ) { int offset = method ref offset ; if ( offset == - num ) { int constant pool size = constant pool . get size ( ) ; for ( int i = num ; i < constant pool size ; i ++ ) { try { constant pool . get member ref info at ( constant pool size - i ) ; offset = i ; break ; } catch ( illegal argument exception ignore ) { } } method ref offset = offset ; } if ( offset >= num ) return offset ; else throw new method ref offset resolution failed ( ) ; }	resolves method ref offset .
protected void write ( data output stream stream ) throws exception { stream . write int ( data . length ) ; stream . write ( data , num , data . length ) ; }	saving method . ( see nbt_tag ).
public boolean equal headers ( instances dataset ) { return ( equal headers msg ( dataset ) == null ) ; }	checks if two headers are equivalent .
public void store serializable ( final string key , final i bean ) { m map . put ( key , bean ) ; }	adds a new serializable to the cache.
public void initialize ( context context , time picker controller controller , boolean has inner circle , boolean disappears out , int selection degrees , boolean is inner circle ) { if ( m is initialized ) { log . e ( tag , str ) ; return ; } resources res = context . get resources ( ) ; int accent color = controller . get accent color ( ) ; m paint . set color ( accent color ) ; m paint . set anti alias ( bool ) ; m selection alpha = controller . is theme dark ( ) ? selected alpha theme dark : selected alpha ; m is24 hour mode = controller . is24 hour mode ( ) ; if ( m is24 hour mode ) { m circle radius multiplier = float . parse float ( res . get string ( r . string . mdtp circle radius multiplier 24 hour mode ) ) ; } else { m circle radius multiplier = float . parse float ( res . get string ( r . string . mdtp circle radius multiplier ) ) ; m am pm circle radius multiplier = float . parse float ( res . get string ( r . string . mdtp ampm circle radius multiplier ) ) ; } m has inner circle = has inner circle ; if ( has inner circle ) { m inner numbers radius multiplier = float . parse float ( res . get string ( r . string . mdtp numbers radius multiplier inner ) ) ; m outer numbers radius multiplier = float . parse float ( res . get string ( r . string . mdtp numbers radius multiplier outer ) ) ; } else { m numbers radius multiplier = float . parse float ( res . get string ( r . string . mdtp numbers radius multiplier normal ) ) ; } m selection radius multiplier = float . parse float ( res . get string ( r . string . mdtp selection radius multiplier ) ) ; m animation radius multiplier = num ; m transition mid radius multiplier = num + ( num * ( disappears out ? - num : num ) ) ; m transition end radius multiplier = num + ( num * ( disappears out ? num : - num ) ) ; m invalidate update listener = new invalidate update listener ( ) ; set selection ( selection degrees , is inner circle , bool ) ; m is initialized = bool ; }	initialize this selector with the state of the picker .
private void compute labels from depths ( ) { for ( iterator it = edge list . iterator ( ) ; it . has next ( ) ; ) { edge e = ( edge ) it . next ( ) ; label lbl = e . get label ( ) ; depth depth = e . get depth ( ) ; if ( ! depth . is null ( ) ) { depth . normalize ( ) ; for ( int i = num ; i < num ; i ++ ) { if ( ! lbl . is null ( i ) && lbl . is area ( ) && ! depth . is null ( i ) ) { if ( depth . get delta ( i ) == num ) { lbl . to line ( i ) ; } else { assert . is true ( ! depth . is null ( i , position . left ) , str ) ; lbl . set location ( i , position . left , depth . get location ( i , position . left ) ) ; assert . is true ( ! depth . is null ( i , position . right ) , str ) ; lbl . set location ( i , position . right , depth . get location ( i , position . right ) ) ; } } } } } }	update the labels for edges according to their depths.
public e put if absent ( int key , e value ) { if ( value == null ) { throw new null pointer exception ( ) ; } e prev ; if ( array . length <= key ) { array = arrays . copy of ( array , key * num / num + num ) ; prev = null ; } else { prev = ( e ) array [ key ] ; } if ( prev == null ) { array [ key ] = value ; size ++ ; } return prev ; }	if the specified key is not already associated with a value associates it with the given value and returns null , else returns the current value .
public void reset ( ) { un managed volume uris to process iterator = un managed volume uris to process . iterator ( ) ; current un managed volume uri = null ; }	resets the unmanagedvolume iterator and sets the current unmanagedvolume back to null.
public static int copy ( reader in , writer out ) throws io { assert . not null ( in , str ) ; assert . not null ( out , str ) ; try { int byte count = num ; char [ ] buffer = new char [ buffer size ] ; int bytes read = - num ; while ( ( bytes read = in . read ( buffer ) ) != - num ) { out . write ( buffer , num , bytes read ) ; byte count += bytes read ; } out . flush ( ) ; return byte count ; } finally { try { in . close ( ) ; } catch ( io ex ) { } try { out . close ( ) ; } catch ( io ex ) { } } }	copy the contents of the given reader to the given writer.
public static bidi map load mapping ( file input file ) throws io { object input stream input stream = new object input stream ( new file input stream ( input file ) ) ; try { return ( bidi map ) input stream . read object ( ) ; } catch ( class not found exception e ) { throw new io ( e ) ; } finally { io . close quietly ( input stream ) ; } }	loads a serialized bidimap from file.
public static string convert brackets from ptb ( string sentence ) { sentence = sentence . replace all ( str , str ) ; sentence = sentence . replace all ( str , str ) ; sentence = sentence . replace all ( str , str ) ; sentence = sentence . replace all ( str , str ) ; sentence = sentence . replace all ( str , str ) ; sentence = sentence . replace all ( str , str ) ; return sentence ; }	convert brackets from the penn treebank format ( which uses strings like - lrb - , - rrb - , etc to denote ' ( ' , ' ) ' , etc.
public void add property change listener ( property change listener listener ) { property support . add property change listener ( listener ) ; }	property change support for xbuilder.
public void update track point ( point p ) { int new loc x = math . min ( p . x , this . anchor . x ) ; int new loc y = math . min ( p . y , this . anchor . y ) ; int delta x = math . abs ( p . x - this . anchor . x ) ; int delta y = math . abs ( p . y - this . anchor . y ) ; set location ( new loc x , new loc y ) ; set size ( delta x , delta y ) ; }	updates the track point for the rubber band so that it extends from the initial location point to the point specified as the argument .
public static date parse date string ( string date string , java . util . locale locale , string date syntax ) { if ( debug . message enabled ( ) ) { debug . message ( str ) ; debug . message ( str + date string ) ; debug . message ( str + date syntax ) ; debug . message ( str + locale . to string ( ) ) ; } if ( ( date string == null ) || ( date string . length ( ) < num ) || ( date syntax == null ) || ( date syntax . length ( ) < num ) ) { return null ; } simple date format sdf = new simple date format ( date syntax ) ; sdf . set lenient ( bool ) ; parse position pos = new parse position ( num ) ; date date = sdf . parse ( date string , pos ) ; if ( date == null ) { debug . warning ( str ) ; } return date ; }	gets date object from date string with specified locale .
public void prepare pid pvs ( int obd service , pv list pv list ) { reset fixed pid ( ) ; hash map < string , ecu data pv > new list = new hash map < string , ecu data pv > ( ) ; for ( integer curr pid : pid supported ) { vector < ecu data item > items = data items . get pid data items ( obd service , curr pid ) ; if ( items == null ) { log . warn ( string . format ( str , curr pid ) ) ; conversion [ ] dummy cnvs = { ecu conversions . dflt cnv , ecu conversions . dflt cnv } ; ecu data item new item = new ecu data item ( curr pid , num , num , num , num , num , dummy cnvs , str , null , null , string . format ( str , curr pid ) ) ; data items . append item to service ( obd service , new item ) ; items = data items . get pid data items ( obd service , curr pid ) ; } for ( ecu data item pid pv : items ) { if ( pid pv != null ) { new list . put ( pid pv . to string ( ) , pid pv . pv ) ; } } } pv list . put all ( new list , pv change event . pv added , bool ) ; }	prepare process variables for each pid.
public void register extension ( string namespace ) { if ( namespace index ( namespace , m extensions ) == - num ) { int predef = namespace index ( namespace , m predef extensions ) ; if ( predef != - num ) m extensions . add ( m predef extensions . get ( predef ) ) ; else if ( ! ( m unregistered extensions . contains ( namespace ) ) ) m unregistered extensions . add ( namespace ) ; } }	if necessary , register the extension namespace found compiling a function or creating an extension element.
static boolean equals ( object o1 , object o2 ) { return o1 == o2 || ( o1 != null && o2 != null && o1 . equals ( o2 ) ) ; }	safe equals . null = = null , but null never equals anything else .
public static mov avg model minimize ( mov avg model model , evicting queue < double > train , double [ ] test ) { double temp = num ; double min temp = num ; int iterations = num ; double alpha = num ; mov avg model best model = model ; mov avg model old model = model ; double old cost = cost ( model , train , test ) ; double best cost = old cost ; while ( temp > min temp ) { for ( int i = num ; i < iterations ; i ++ ) { mov avg model new model = old model . neighboring model ( ) ; double new cost = cost ( new model , train , test ) ; double ap = acceptance probability ( old cost , new cost , temp ) ; if ( ap > math . random ( ) ) { old model = new model ; old cost = new cost ; if ( new cost < best cost ) { best cost = new cost ; best model = new model ; } } } temp *= alpha ; } return best model ; }	runs the simulated annealing algorithm and produces a model with new coefficients that , theoretically fit the data better and generalizes to future forecasts without overfitting .
private i [ ] as projects ( project set serialization context context , string [ ] reference strings , map < i , load info > info map ) throws svn { collection < i > result = new array list < i > ( ) ; for ( string reference string : reference strings ) { string tokenizer tokenizer = new string tokenizer ( reference string , str ) ; string version = tokenizer . next token ( ) ; if ( ! version . equals ( str ) ) { continue ; } load info info = new load info ( context , tokenizer ) ; i proj = info . get project ( ) ; result . add ( proj ) ; info map . put ( proj , info ) ; } return ( i [ ] ) result . to array ( new i [ result . size ( ) ] ) ; }	translate the reference strings into projects to be loaded and build a mapping of project to project load information .
@ override public synchronized void connection notification ( string event name , object source ) { super . connection notification ( event name , source ) ; if ( connection allowed ( event name ) ) { if ( event name . equals ( str ) ) { m data provider = bool ; m training provider = bool ; m test provider = bool ; } else if ( event name . equals ( str ) ) { m data provider = bool ; m training provider = bool ; m test provider = bool ; } else if ( event name . equals ( str ) ) { m data provider = bool ; m training provider = bool ; m test provider = bool ; } } }	notify this object that it has been registered as a listener with a source with respect to the supplied event name.
public info create info ( string value ) { information field info impl = new information field ( ) ; try { info impl . set value ( value ) ; } catch ( sdp exception s ) { s . print stack trace ( ) ; } return info impl ; }	returns info object with the specified value .
public static int find word start ( string line , int pos , string no word sep ) { char ch = line . char at ( pos - num ) ; if ( no word sep == null ) no word sep = str ; boolean select no letter = ( ! character . is letter or digit ( ch ) && no word sep . index of ( ch ) == - num ) ; int word start = num ; for ( int i = pos - num ; i >= num ; i -- ) { ch = line . char at ( i ) ; if ( select no letter ^ ( ! character . is letter or digit ( ch ) && no word sep . index of ( ch ) == - num ) ) { word start = i + num ; break ; } } return word start ; }	locates the start of the word at the specified position .
public void insert ( double x1 , double x2 , object item ) { super . insert ( new interval ( math . min ( x1 , x2 ) , math . max ( x1 , x2 ) ) , item ) ; }	inserts an item having the given bounds into the tree .
public map maker initial capacity ( int initial capacity ) { builder . initial capacity ( initial capacity ) ; return this ; }	sets a custom initial capacity ( defaults to 16 ).
public final static byte [ ] extract challenge from type2 message ( byte [ ] msg ) { byte [ ] challenge = new byte [ num ] ; system . arraycopy ( msg , num , challenge , num , num ) ; return challenge ; }	extracts the ntlm challenge from the type 2 message as an 8 byte array .
public static string to string ( local date data , string modelo ) { return data == null ? str : data . format ( formatter ( modelo ) ) ; }	converte localdatetime para string indicando o formato da tostring.
public d ( j parent , dialog . modality type modality , throwable error ) { super ( parent , modality ) ; this . error = error ; init components ( ) ; }	creates new derrordetail dialog where the parent is a frame .
public static < destin > list < destin > copy properties to new collections ( class < destin > dest class , collection < ? > src collection ) { list < destin > destin list = new array list < destin > ( ) ; if ( src collection == null ) { return destin list ; } for ( object src : src collection ) { destin list . add ( copy properties to new object ( dest class , src ) ) ; } return destin list ; }	convert a collection of beans of type a , to a collection of beans of type b , by copying a ' s properties into b ' s.
protected resource update resource version ( resource resource , big decimal old version , big decimal new version ) { preconditions . check not null ( resource ) ; preconditions . check not null ( old version ) ; preconditions . check not null ( new version ) ; if ( ! old version . equals ( new version ) ) { try { file old eml = data dir . resource eml file ( resource . get shortname ( ) , old version ) ; file new eml = data dir . resource eml file ( resource . get shortname ( ) , new version ) ; if ( old eml . exists ( ) && ! new eml . exists ( ) ) { files . move ( old eml , new eml ) ; } file old rtf = data dir . resource rtf file ( resource . get shortname ( ) , old version ) ; file new rtf = data dir . resource rtf file ( resource . get shortname ( ) , new version ) ; if ( old rtf . exists ( ) && ! new rtf . exists ( ) ) { files . move ( old rtf , new rtf ) ; } file old dwca = data dir . resource dwca file ( resource . get shortname ( ) , old version ) ; file new dwca = data dir . resource dwca file ( resource . get shortname ( ) , new version ) ; if ( old dwca . exists ( ) && ! new dwca . exists ( ) ) { files . move ( old dwca , new dwca ) ; } resource . set eml version ( new version ) ; } catch ( io e ) { log . error ( str + resource . get shortname ( ) , e ) ; throw new invalid config exception ( type . config write , str + resource . get shortname ( ) + str + e . get message ( ) ) ; } } return resource ; }	update a resource ' s version , and rename its eml , rtf , and dwca versioned files to have the new version also .
public static injector impl current ( class loader loader ) { if ( loader instanceof dynamic class loader ) { return local manager . get level ( loader ) ; } else { soft reference < injector impl > inject ref = loader manager map . get ( loader ) ; if ( inject ref != null ) { return inject ref . get ( ) ; } else { return null ; } } }	returns the current inject manager .
@ zap api ignore public boolean is confirm remove domain always in scope ( ) { return this . confirm remove domain always in scope ; }	tells whether or not the remotion of a " domain always in scope " needs confirmation .
protected void write ( data output stream stream ) throws exception { stream . write int ( data . length ) ; for ( int i = num ; i < data . length ; i ++ ) stream . write int ( data [ i ] ) ; }	saving method . ( see nbt_tag ).
private cluster < dendrogram model > make cluster ( dbid lead , double depth , dbi members ) { final string name ; if ( members . size ( ) == num ) { name = str + dbid . to string ( lead ) + str + depth ; } else if ( ! double . is na n ( depth ) && double . is infinite ( depth ) || ( members . size ( ) == num && members . contains ( lead ) ) ) { name = str + dbid . to string ( lead ) ; } else if ( ! double . is na n ( depth ) ) { name = str + dbid . to string ( lead ) + str + depth ; } else { name = str + dbid . to string ( lead ) ; } cluster < dendrogram model > cluster = new cluster < > ( name , members , new dendrogram model ( depth ) ) ; return cluster ; }	make the cluster for the given object.
public void write ( command command , int value , int index , byte buffer buffer ) throws usb exception { if ( m device handle != null ) { int transferred = lib usb . control transfer ( m device handle , usb request out , command . get value ( ) , ( short ) value , ( short ) index , buffer , usb timeout ms ) ; if ( transferred < num ) { throw new lib usb exception ( str , transferred ) ; } else if ( transferred != buffer . capacity ( ) ) { throw new lib usb exception ( str + transferred + str + buffer . capacity ( ) + str , transferred ) ; } } else { throw new lib usb exception ( str , lib usb . error no device ) ; } }	writes the buffer contents to the device.
private static void remove instrumentation from orig ( ir ir , hash map < basic block , basic block > orig to dup map ) { for ( basic block orig block : orig to dup map . key set ( ) ) { for ( enumeration < instruction > ie = orig block . forward instr enumerator ( ) ; ie . has more elements ( ) ; ) { instruction i = ie . next element ( ) ; if ( is instrumentation instruction ( i ) || ( is yieldpoint ( i ) && ir . options . adaptive remove yp from checking ) ) { if ( debug ) vm . sys write ( str + i + str ) ; i . remove ( ) ; } } } }	remove instrumentation from the original version of all duplicated basic blocks.
public xml ( string xml ) throws exception { document doc = xml . get xml ( new byte array input stream ( xml . get bytes ( str ) ) ) ; node root = xml . get root node ( doc , ds . root ) ; default server group = new server group ( xml . get named child node ( root , ds . servergroup , ds . name , ds . default ) ) ; sms server group = new server group ( xml . get named child node ( root , ds . servergroup , ds . name , str ) ) ; }	creates an object representing server configuration xml .
@ override public double diffusion discretization ( final d sp , final double t0 , final double x0 , final double dt ) { return sp . diffusion ( t0 , x0 ) * math . sqrt ( dt ) ; }	returns an approximation of the diffusion defined as < p > \ sigma ( t_0 , x_0 ) \ sqrt \ delta t } }.
public void notify listener ( om graphic , om action ) { if ( requestor != null ) { if ( debug ) { debug . output ( str ) ; } requestor . drawing complete ( graphic , action ) ; } if ( canvas != null ) { canvas . repaint ( ) ; } }	notify the listener of an action to a graphic .
public class runner ( class < ? > the class , string [ ] command args ) throws exception { set daemon ( bool ) ; class < ? > [ ] arg template = { string [ ] . class } ; m = command args ; m = the class . get method ( str , arg template ) ; if ( ( ( m . get modifiers ( ) & modifier . static ) == num ) || ( m . get modifiers ( ) & modifier . public ) == num ) { throw new no such method exception ( str + the class . get name ( ) + str ) ; } }	sets up the class runner thread .
public int wait for condition ( channel c , long timeout , int condition mask ) { long end time = num ; boolean end time set = bool ; synchronized ( c ) { while ( bool ) { int current cond = num ; int stdout avail = c . stdout writepos - c . stdout readpos ; int stderr avail = c . stderr writepos - c . stderr readpos ; if ( stdout avail > num ) current cond = current cond | channel condition . stdout data ; if ( stderr avail > num ) current cond = current cond | channel condition . stderr data ; if ( c . eof ) current cond = current cond | channel condition . eof ; if ( c . get exit status ( ) != null ) current cond = current cond | channel condition . exit status ; if ( c . get exit signal ( ) != null ) current cond = current cond | channel condition . exit signal ; if ( c . state == channel . state closed ) return current cond | channel condition . closed | channel condition . eof ; if ( ( current cond & condition mask ) != num ) return current cond ; if ( timeout > num ) { if ( ! end time set ) { end time = system . current time millis ( ) + timeout ; end time set = bool ; } else { timeout = end time - system . current time millis ( ) ; if ( timeout <= num ) return current cond | channel condition . timeout ; } } try { if ( timeout > num ) c . wait ( timeout ) ; else c . wait ( ) ; } catch ( interrupted exception e ) { } } } }	wait until for a condition .
@ override public void store state ( ) { partial buffer helper . store state ( ) ; for ( evolutionary process delegate evolutionary process delegate : evolutionary process delegates ) { evolutionary process delegate . store state ( ) ; } if ( use scale factors || use auto scaling ) { scale buffer helper . store state ( ) ; system . arraycopy ( scale buffer indices , num , stored scale buffer indices , num , scale buffer indices . length ) ; } flip = bool ; }	stores the additional state other than model components.
public static boolean is core file saver ( string classname ) { boolean result ; string [ ] classnames ; classnames = core file savers . split ( str ) ; result = ( arrays . binary search ( classnames , classname ) >= num ) ; return result ; }	checks whether the given class is one of the hardcoded core file savers .
private void assert constructor throws exception ( soap binding binding , security token service config config ) { boolean exception thrown = bool ; try { new security token service impl ( binding , config ) ; } catch ( illegal argument exception e ) { exception thrown = bool ; } finally { assert true ( exception thrown ) ; } }	asserts that an exception is thrown if one of the arguments is null.
public update log entry add file ( json value file ) { files . add ( file ) ; return this ; }	add a file to this entry ' s list of update files.
private < t extends v > map < string , list < t > > order properties by group ( list < t > properties ) { map < string , list < t > > grouped properties = new hash map < > ( ) ; for ( t property : properties ) { string group = property . get group ( ) ; if ( is empty ( group ) ) { continue ; } list < t > group properties list = grouped properties . get ( group ) ; if ( group properties list == null ) { group properties list = new array list < t > ( ) ; grouped properties . put ( group , group properties list ) ; } group properties list . add ( property ) ; } return grouped properties ; }	groups properties by their group name .
protected void open file ( file f ) { if ( f == null ) { return ; } if ( ! f . exists ( ) ) { debug . output ( str + get name ( ) + str ) ; return ; } e00 file = f ; if ( gui != null ) { label . set text ( e00 file . get name ( ) ) ; } }	description of the method.
public void add text ( string text ) { if ( null != text ) { texts . add ( new text properties ( text , current size , current color ) ) ; reclamp text ( ) ; invalidate ( ) ; } }	adds a text to be drawn over the image , above existing texts .
public void received ( byte buffer buffer ) { has received data = bool ; last receive time = system . current time millis ( ) ; }	method called when data is received .
public void resume ( ) { if ( ! is paused ) return ; set animation interval ( old animation interval ) ; last update = system . current time millis ( ) ; is paused = bool ; dt = num ; }	resumes the paused ccscene the scheduled timers will be activated again . the " delta time " will be 0 ( as if the game wasn ' t paused ).
private static string strip leading slash ( string name ) { if ( name . length ( ) < num || name . char at ( num ) != str ) { return name ; } return name . substring ( num ) ; }	removes a leading slash.
protected boolean remove if present estimate ( estimate map key key , load estimate task task ) { return estimate map . remove ( key , task ) ; }	remove the task from the estimate map at the given key .
public void test domain not automatically prefixed with dot ( ) { http cookie cookie = new http cookie ( str , str ) ; cookie . set domain ( str ) ; assert equals ( str , cookie . get domain ( ) ) ; }	from the spec , " if an explicitly specified value does not start with a dot , the user agent supplies a leading dot.
public builder delete nick name ( ) { delete fields . add ( str ) ; return this ; }	deletes the nickname of a existing user.
public boolean check password ( string password ) { try { random access file raf = new random access file ( s lock password filename , str ) ; final byte [ ] stored = new byte [ ( int ) raf . length ( ) ] ; int got = raf . read ( stored , num , stored . length ) ; raf . close ( ) ; if ( got <= num ) { return bool ; } return arrays . equals ( stored , password to hash ( password ) ) ; } catch ( file not found exception fnfe ) { return bool ; } catch ( io ioe ) { return bool ; } }	check to see if a password matches the saved password.
public static double string to double ( string val ) { return double . value of ( trim ( val ) ) ; }	converts string to double .
public static final void write double array xml ( double [ ] val , string name , xml serializer out ) throws xml pull parser exception , io { if ( val == null ) { out . start tag ( null , str ) ; out . end tag ( null , str ) ; return ; } out . start tag ( null , str ) ; if ( name != null ) { out . attribute ( null , str , name ) ; } final int n = val . length ; out . attribute ( null , str , integer . to string ( n ) ) ; for ( int i = num ; i < n ; i ++ ) { out . start tag ( null , str ) ; out . attribute ( null , str , double . to string ( val [ i ] ) ) ; out . end tag ( null , str ) ; } out . end tag ( null , str ) ; }	flatten a double [ ] into an xmlserializer.
public boolean to starting ( ) { lifecycle state state ; synchronized ( this ) { state = state ; if ( state . is after starting ( ) && ! state . is stopped ( ) ) { return bool ; } state = starting ; last change time = current time . current time ( ) ; if ( log != null && log . is loggable ( level ) && log . is loggable ( level . finer ) ) { log . finer ( str + name ) ; } } notify listeners ( state , starting ) ; return bool ; }	changes to the starting state .
public void stop ( ) { is alive = bool ; stats snap shot . stop ( ) ; holding buffer . clear ( ) ; io . close quietly ( this ) ; }	the method is called in the deactivate method of the operator.
static void check identifier ( final string name , final string msg ) { check identifier ( name , num , - num , msg ) ; }	checks that the given string is a valid java identifier .
public static double [ ] create random grid values ( int width , int height , double min , double max , int num iterations , double smoothness ) { int num values = width * height ; double [ ] values = new double [ num values ] ; for ( int i = num ; i < num iterations ; i ++ ) { double offset = num - ( i / ( double ) num iterations ) ; int x1 = ( int ) math . round ( math . random ( ) * ( width - num ) ) ; int x2 = ( int ) math . round ( math . random ( ) * ( width - num ) ) ; int y1 = ( int ) math . round ( math . random ( ) * ( height - num ) ) ; int y2 = ( int ) math . round ( math . random ( ) * ( height - num ) ) ; int dx1 = x2 - x1 ; int dy1 = y2 - y1 ; for ( int y = num ; y < height ; y ++ ) { int dy2 = y - y1 ; for ( int x = num ; x < width ; x ++ ) { int dx2 = x - x1 ; if ( ( dx2 * dy1 - dx1 * dy2 ) >= num ) values [ x + y * width ] += offset ; } } } smooth values ( width , height , values , smoothness ) ; scale values ( values , num values , min , max ) ; return values ; }	creates a 2d grid of random values with an optional smoothing parameter.
public zip entry ( zip entry e ) { objects . require non null ( e , str ) ; name = e . name ; xdostime = e . xdostime ; mtime = e . mtime ; atime = e . atime ; ctime = e . ctime ; crc = e . crc ; size = e . size ; csize = e . csize ; method = e . method ; flag = e . flag ; extra = e . extra ; comment = e . comment ; }	creates a new zip entry with fields taken from the specified zip entry .
public void remove all testing callbacks ( ) { testing callbacks . clear ( ) ; }	removes all board testing callbacks .
public static big decimal byte to big decimal ( byte [ ] raw ) { int scale = ( raw [ num ] & num ) ; byte [ ] unscale = new byte [ raw . length - num ] ; system . arraycopy ( raw , num , unscale , num , unscale . length ) ; big integer sig = new big integer ( unscale ) ; return new big decimal ( sig , scale ) ; }	this method will convert a byte value back to big decimal value.
public string output file tip text ( ) { return str ; }	returns the tip text for this property.
public void send message ( sip sip message , inet address receiver address , int receiver port ) throws io { long time = system . current time millis ( ) ; send message ( sip message , receiver address , receiver port , sip message instanceof sip ) ; log message ( sip message , receiver address , receiver port , time ) ; }	send a message given sip message .
protected void on service stopped ( ) { unregister receiver ( m bluetooth state broadcast receiver ) ; for ( final ble manager < ble manager callbacks > manager : m ble managers . values ( ) ) { manager . close ( ) ; manager . log ( log contract . log . level . info , str ) ; } m ble managers . clear ( ) ; m managed devices . clear ( ) ; m ble managers = null ; m managed devices = null ; }	called when the service has been stopped .
public byte string snapshot ( ) { if ( size > integer . max value ) { throw new illegal argument exception ( str + size ) ; } return snapshot ( ( int ) size ) ; }	returns an immutable copy of this buffer as a byte string .
public boolean remove middle of last three ( ) { if ( ! has three ( ) ) return bool ; int pos = points . size ( ) ; points . remove ( pos - num ) ; return bool ; }	returns middle of last three.
private void delete current file ( file file to delete ) throws io { logger . info ( str , file to delete ) ; if ( ! file to delete . exists ( ) ) { logger . warn ( str , file to delete ) ; return ; } if ( ! file to delete . delete ( ) ) { throw new io ( str + file to delete ) ; } delete meta file ( ) ; }	delete the given spooled file.
public void test constructor bytes zero ( ) { byte a bytes [ ] = { num , num , num , - num , + num , num , - num } ; byte r bytes [ ] = { num } ; big integer a number = new big integer ( a bytes ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = a number . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , a number . signum ( ) ) ; }	create a zero number from an array of zero bytes .
public bookmark manager ( final com . google . security . zynamics . binnavi . models . bookmarks . memory . bookmark manager bookmark manager ) { m bookmark manager = bookmark manager ; for ( final c bookmark : m bookmark manager ) { m bookmarks . add ( new bookmark ( bookmark ) ) ; } m bookmark manager . add listener ( m internal bookmark listener ) ; }	creates a new api bookmark manager object .
public void store ( output stream out , string header ) throws io { print writer writer = new print writer ( new output stream writer ( out , str ) ) ; string line ; string key ; string buffer s = new string buffer ( ) ; for ( int i = num ; i < line data . size ( ) ; i ++ ) { line = ( string ) line data . get ( i ) ; key = ( string ) key data . get ( i ) ; if ( key . length ( ) > num ) { format for output ( key , s , bool ) ; s . append ( str ) ; format for output ( ( string ) get ( key ) , s , bool ) ; writer . println ( s ) ; } else { writer . println ( line ) ; } } writer . flush ( ) ; }	write the properties to the specified outputstream.
public static void append md ( final string aligned query , final string aligned reference , final string builder buffer ) { buffer . append ( str ) ; int count matches = num ; boolean in deletion = bool ; for ( int i = num ; i < aligned query . length ( ) ; i ++ ) { final char q char = aligned query . char at ( i ) ; final char r char = aligned reference . char at ( i ) ; if ( q char == str ) { if ( count matches > num ) { buffer . append ( count matches ) ; count matches = num ; } if ( ! in deletion ) { buffer . append ( str ) ; in deletion = bool ; } buffer . append ( r char ) ; } else if ( r char != str ) { if ( q char == r char ) { count matches ++ ; } else { if ( in deletion ) buffer . append ( str ) ; if ( count matches > num ) { buffer . append ( count matches ) ; count matches = num ; } buffer . append ( r char ) ; } if ( in deletion ) in deletion = bool ; } } if ( count matches > num ) buffer . append ( count matches ) ; else if ( in deletion ) buffer . append ( num ) ; }	append the md string.
static int measure child for cells ( view child , int cell size , int cells remaining , int parent height measure spec , int parent height padding ) { final layout params lp = ( layout params ) child . get layout params ( ) ; final int child height size = measure spec . get size ( parent height measure spec ) - parent height padding ; final int child height mode = measure spec . get mode ( parent height measure spec ) ; final int child height spec = measure spec . make measure spec ( child height size , child height mode ) ; final action menu item view item view = child instanceof action menu item view ? ( action menu item view ) child : null ; final boolean has text = item view != null && item view . has text ( ) ; int cells used = num ; if ( cells remaining > num && ( ! has text || cells remaining >= num ) ) { final int child width spec = measure spec . make measure spec ( cell size * cells remaining , measure spec . at most ) ; child . measure ( child width spec , child height spec ) ; final int measured width = child . get measured width ( ) ; cells used = measured width / cell size ; if ( measured width % cell size != num ) cells used ++ ; if ( has text && cells used < num ) cells used = num ; } final boolean expandable = ! lp . is overflow button && has text ; lp . expandable = expandable ; lp . cells used = cells used ; final int target width = cells used * cell size ; child . measure ( measure spec . make measure spec ( target width , measure spec . exactly ) , child height spec ) ; return cells used ; }	measure a child view to fit within cell - based formatting.
public component time ( string strdate ) { timestamp = component time . string to stamp ( strdate ) ; }	construct from a date in this format : yyyy - mm - dd ' t ' hh : mi : ss . ffffff.
public void add extension ( string extension ) { if ( filters == null ) { filters = new hashtable < string , example file filter > ( num ) ; } if ( extension != null ) { filters . put ( extension . to lower case ( ) , this ) ; } full description = null ; }	adds a filetype " dot " extension to filter against.
private void log thread statistics ( ) { int thread count = thread mx . get thread count ( ) ; long total started threads = thread mx . get total started thread count ( ) ; string builder sb = new string builder ( ) ; sb . append ( str ) ; sb . append ( thread count ) ; sb . append ( str ) ; sb . append ( total started threads ) ; log . info ( sb . to string ( ) ) ; }	log the thread statistics .
private list find stabbed segments ( coordinate stabbing ray left pt ) { list stabbed segments = new array list ( ) ; for ( iterator i = subgraphs . iterator ( ) ; i . has next ( ) ; ) { buffer subgraph bsg = ( buffer subgraph ) i . next ( ) ; envelope env = bsg . get envelope ( ) ; if ( stabbing ray left pt . y < env . get min y ( ) || stabbing ray left pt . y > env . get max y ( ) ) continue ; find stabbed segments ( stabbing ray left pt , bsg . get directed edges ( ) , stabbed segments ) ; } return stabbed segments ; }	finds all non - horizontal segments intersecting the stabbing line.
public void discard undo ( ) { for ( undoable undoable : m undo actions ) { undoable . discard ( ) ; } m undo actions . clear ( ) ; m undo popup . dismiss ( ) ; }	discard all stored undos and hide the undo popup dialog .
public void update locations ( iterator i iter ) { if ( container list != null ) container list . clear ( ) ; container list = new array list ( ) ; while ( i iter . has next ( ) ) container list . add ( ( location ) i iter . next ( ) ) ; add behaviour ( new migrate behaviour ( ) ) ; }	updates the location list and schedules migrations .
public o ( int c ) { vector = new object [ math . max ( default capacity , c ) ] ; }	constructs a new vector with the specified capacity .
protected static void notify aci ( string dn , int event type ) { if ( debug . message enabled ( ) ) { debug . message ( str + dn ) ; } synchronized ( obj impl listeners ) { if ( obj impl listeners . is empty ( ) ) { return ; } am dp event = new am ( new am ( dn ) , event type ) ; switch ( event type ) { case am . object changed : case am . object renamed : if ( debug . message enabled ( ) ) { debug . message ( str + str ) ; } notify affected d ( dn , dp event ) ; break ; case am . object removed : if ( debug . message enabled ( ) ) { debug . message ( str + str ) ; } set obj impl set = ( set ) obj impl listeners . get ( dn . to lower case ( ) ) ; if ( obj impl set == null ) { return ; } iterator itr = obj impl set . iterator ( ) ; while ( itr . has next ( ) ) { am dp obj impl = ( am ) itr . next ( ) ; dp obj impl . send events ( dp event ) ; } break ; default : ; } } }	notifies aci change . this method will be called by the < code > amidrepolistener to send notifications to all interested amobjectimp ' s whenever an aci change occurs .
vertex ( final d location ) { this . location = location ; this . incoming = null ; this . outgoing = null ; this . lines = new array list < line > ( ) ; }	build a non - processed vertex not owned by any node yet .
@ override public completable future < optional < t > > find first ( ) { return completable future . supply async ( null , exec ) ; }	perform an asynchronous findany operation.
public static boolean is valid iana ( string iana encoding ) { if ( iana encoding != null ) { int length = iana encoding . length ( ) ; if ( length > num ) { char c = iana encoding . char at ( num ) ; if ( ( c >= str && c <= str ) || ( c >= str && c <= str ) ) { for ( int i = num ; i < length ; i ++ ) { c = iana encoding . char at ( i ) ; if ( ( c < str || c > str ) && ( c < str || c > str ) && ( c < str || c > str ) && c != str && c != str && c != str ) { return bool ; } } return bool ; } } } return bool ; }	returns true if the encoding name is a valid iana encoding.
private void append start tag ( string q name , attributes attributes ) { char buf . append ( str + q name ) ; for ( map . entry < string , string > entry : new namespace mappings . entry set ( ) ) { string prefix = entry . get key ( ) ; string namespace = entry . get value ( ) ; append namespace decl ( char buf , prefix , namespace ) ; } int att count = attributes . get length ( ) ; for ( int i = num ; i < att count ; i ++ ) { append attribute ( char buf , attributes . get q ( i ) , attributes . get value ( i ) ) ; } char buf . append ( str ) ; int colon idx = q name . index of ( str ) ; string prefix = ( colon idx > num ) ? q name . substring ( num , colon idx ) : str ; if ( ! xml literal prefixes . contains ( prefix ) && ! unknown prefixes in xml . contains ( prefix ) ) { unknown prefixes in xml . add ( prefix ) ; } }	appends a start tag to charbuf.
public void remove query execute listener ( query execute listener l ) { m . remove ( l ) ; }	removes the given listener from the list of listeners .
public static boolean is valid import string ( string s ) { if ( s . equals ( str ) ) return bool ; boolean valid = bool ; string t = s ; int index = t . index of ( str ) ; if ( index != - num ) { if ( index == t . length ( ) - num ) { if ( index - num >= num ) { valid = t . char at ( index - num ) == str ; t = t . substring ( num , t . length ( ) - num ) ; } } else return bool ; } if ( valid ) { string [ ] java ids = t . split ( str , t . length ( ) + num ) ; for ( string java id : java ids ) valid &= source version . is identifier ( java id ) ; } return valid ; }	return true if the argument string is a valid import - style string specifying claimed annotations ; return false otherwise .
public static graph request new upload video request ( access token access token , file file , callback callback ) throws file not found exception { parcel file descriptor descriptor = parcel file descriptor . open ( file , parcel file descriptor . mode read only ) ; bundle parameters = new bundle ( num ) ; parameters . put parcelable ( file . get name ( ) , descriptor ) ; return new graph request ( access token , my videos , parameters , http method . post , callback ) ; }	creates a new request configured to upload a video to the user ' s default video album.
public static long murmur ( final bit vector bv , final long prefix length , final long [ ] state , final long lcp ) { final int start state word = ( int ) ( math . min ( lcp , prefix length ) / long . size ) ; long h = state [ start state word ] , k ; long from = start state word * long . size ; while ( prefix length - from >= long . size ) { k = bv . get long ( from , from += long . size ) ; k *= m ; k ^= k > > > r ; k *= m ; h ^= k ; h *= m ; } if ( prefix length > from ) { k = bv . get long ( from , prefix length ) ; k *= m ; k ^= k > > > r ; k *= m ; h ^= k ; h *= m ; } k = prefix length ; k *= m ; k ^= k > > > r ; k *= m ; h ^= k ; h *= m ; return h ; }	constant - time murmurhash 64 - bit hashing reusing precomputed state partially .
public static range iterate to find z ( xyz dataset , list visible series keys , range x range , boolean include interval ) { param checks . null not permitted ( dataset , str ) ; param checks . null not permitted ( visible series keys , str ) ; param checks . null not permitted ( x range , str ) ; double minimum = double . positive infinity ; double maximum = double . negative infinity ; iterator iterator = visible series keys . iterator ( ) ; while ( iterator . has next ( ) ) { comparable series key = ( comparable ) iterator . next ( ) ; int series = dataset . index of ( series key ) ; int item count = dataset . get item count ( series ) ; for ( int item = num ; item < item count ; item ++ ) { double x = dataset . get x ( series , item ) ; double z = dataset . get z ( series , item ) ; if ( x range . contains ( x ) ) { if ( ! double . is na n ( z ) ) { minimum = math . min ( minimum , z ) ; maximum = math . max ( maximum , z ) ; } } } } if ( minimum == double . positive infinity ) { return null ; } else { return new range ( minimum , maximum ) ; } }	returns the range of z - values in the specified dataset for the data items belonging to the visible series and with x - values in the given range .
public class entry ( dynamic class loader loader , string name , path source path , path class path , code source code source ) { loader = loader ; name = name ; class path = class path ; set depend path ( class path ) ; if ( source path != null && ! source path . equals ( class path ) ) { source path = source path ; source last modified = source path . get last modified ( ) ; source length = source path . length ( ) ; } code source = code source ; }	create a loaded class entry.
public ranking image list provider in weeks ( int weeks ) { m time = integer . to string ( weeks ) + str ; return this ; }	sets time limit for a ranking list in weeks ( the default value is all time ) .
public abstract optional < boolean > wanted ( ) ;	is the blank line wanted ?.
private void rewrite save file ( iterable < track point > data ) { file output stream file output = null ; data output stream out = null ; try { file output = ctx . open file output ( savefile , context . mode private ) ; out = new data output stream ( new buffered output stream ( file output ) ) ; out . write int ( track point . format version ) ; for ( track point point : data ) { point . to stream ( out ) ; } } catch ( exception e ) { mark saving broken ( str , e ) ; } finally { saving helper . close ( out ) ; } }	saves the given data to disk , overwriting anything already saved.
public node add ( node n ) { node map . put ( n . get coordinate ( ) , n ) ; return n ; }	adds a node to the map , replacing any that is already at that location .
public static void print stuttering state ( int num ) { mp . print state ( ec . tlc state prin , new string [ ] { string . value of ( num + num ) } , ( tlc ) null , num + num ) ; }	reports that the state with a given number is stuttering.
public boolean is use compression ( ) { return this . use compression ; }	get method for configuration item - usecompression.
private void log missing regions ( partitioned region region ) { string names of missing = str ; if ( ! missing children . is empty ( ) ) { names of missing = string . join ( str , missing children ) ; } string multiple children ; string singular = str ; string plural = str ; multiple children = missing children . size ( ) > num ? plural : singular ; names of missing = string . join ( str , multiple children , names of missing ) ; logger . warn ( localized message . create ( localized strings . persistent data recovery of region prevented by offline colocated children , new object [ ] { region . get full path ( ) , names of missing } ) ) ; }	write the a logger warning for a pr that has colocated child regions that are missing .
public static string [ ] split ( string text , pattern pattern ) { if ( text . length ( ) == num ) { return empty string array ; } else { return pattern . split ( text , - num ) ; } }	splits a string on a pattern.
static void create password files ( string basedir , string keystore pwd , string key password ) throws io { write content ( basedir + str , key password ) ; write content ( basedir + str , keystore pwd ) ; copy ctx file ( str , str , basedir ) ; copy ctx file ( str , str , basedir ) ; am jceks = new am ( bool , basedir + str , str , str , str ) ; am jks = new am ( bool , basedir + str , str , str , str ) ; jceks . set key ( keystore pwd , key password ) ; jks . set key ( keystore pwd , key password ) ; try { jceks . store ( ) ; jks . store ( ) ; } catch ( certificate exception | no such algorithm exception | key store exception e ) { throw new io ( str , e ) ; } }	create the storepass and keypass files.
static optimized class descriptor class descriptor ( concurrent map < class , optimized class descriptor > cls map , int id , class loader ldr , marshaller context ctx , optimized marshaller id mapper mapper ) throws io , class not found exception { class cls ; try { cls = ctx . get class ( id , ldr ) ; } catch ( ignite checked exception e ) { throw new io ( str + id , e ) ; } optimized class descriptor desc = cls map . get ( cls ) ; if ( desc == null ) { optimized class descriptor old = cls map . put if absent ( cls , desc = new optimized class descriptor ( cls , resolve type id ( cls . get name ( ) , mapper ) , cls map , ctx , mapper ) ) ; if ( old != null ) desc = old ; } return desc ; }	gets descriptor for provided id .
private boolean open for writing ( ) { file root = new file ( properties . ctg dir ) ; if ( root . exists ( ) ) { if ( root . is directory ( ) ) { if ( ! root . can write ( ) ) { logger . error ( str + root . get absolute path ( ) ) ; return bool ; } } else { boolean deleted = root . delete ( ) ; if ( ! deleted ) { logger . error ( str + root + str ) ; return bool ; } else { if ( ! root . mkdirs ( ) ) { logger . error ( str + root . get absolute path ( ) ) ; return bool ; } } } } else { if ( ! root . mkdirs ( ) ) { logger . error ( str + root . get absolute path ( ) ) ; return bool ; } } file tests folder = get best test folder ( ) ; if ( ! tests folder . exists ( ) ) { if ( ! tests folder . mkdirs ( ) ) { logger . error ( str + tests folder . get absolute path ( ) ) ; return bool ; } } file seed folder = get seed in folder ( ) ; if ( ! seed folder . exists ( ) ) { if ( ! seed folder . mkdirs ( ) ) { logger . error ( str + seed folder . get absolute path ( ) ) ; } } return bool ; }	open connection to storage manager note : here we just make sure we can write on disk.
public static byte [ ] hex string to byte ( string hex string ) { if ( ( hex string . length ( ) & num ) == num ) hex string = str + hex string ; byte [ ] tmp = new byte [ hex string . length ( ) / num ] ; for ( int i = num ; i < tmp . length ; ++ i ) { string hex byte = hex string . substring ( i * num , i * num + num ) ; tmp [ i ] = ( byte ) integer . parse int ( hex byte , num ) ; } return tmp ; }	converts a hex string to byte [ ].
private void add field ( mapped class clazz , string [ ] parts ) { string original = str ; string new name = str ; string desc = str ; if ( parts . length == num ) { original = parts [ num ] ; new name = parts [ num ] ; desc = parts [ num ] ; } else if ( parts . length == num ) { original = parts [ num ] ; new name = parts [ num ] ; desc = parts [ num ] ; } else { return ; } if ( desc . contains ( str ) ) { desc = desc . replace ( str , str ) ; } mapped member mm = new mapped member ( clazz , find field ( clazz . get node ( ) , original , desc ) , - num , desc , original ) ; mm . set new name ( new name ) ; clazz . add field ( mm ) ; }	add a field to the given class .
public static void load registrations ( data input in ) throws io { while ( in . read int ( ) != num ) { class ds class = null ; boolean skip = bool ; try { ds class = data serializer . read class ( in ) ; } catch ( class not found exception ex ) { skip = bool ; } if ( skip ) { continue ; } register ( ds class , bool ) ; } }	read the data from in and register it with this class .
public static http2 headers to netty http2 ( http headers input headers ) { final http2 headers output headers = new default http2 headers ( bool , input headers . size ( ) ) ; output headers . set ( input headers ) ; output headers . remove ( http header names . connection ) ; output headers . remove ( http header names . transfer encoding ) ; output headers . remove ( http header names . trailer ) ; return output headers ; }	converts the specified armeria http / 2 headers into netty http / 2 headers .
public void error ( level level , string message id , string data [ ] , object session , map props ) throws log exception { if ( is error loggable ( level ) ) { sso auth sso = ( sso ) access controller . do privileged ( admin token action . get instance ( ) ) ; log record lr = get log record ( message id , data , session , props , auth sso ) ; if ( lr != null ) { error logger . log ( lr , auth sso ) ; } } }	writes error occurred in a component into a log .
protected population load population file ( final string filename , scenario sc ) { population plans = sc . get population ( ) ; log . info ( str ) ; matsim reader plans reader = new population reader ( sc ) ; plans reader . read file ( filename ) ; log . info ( str ) ; return plans ; }	load the plan file with the given path .
private void load theme ( ) { if ( ui . get look and feel ( ) instanceof metal look and feel ) { } else { primary1 . set enabled ( bool ) ; primary2 . set enabled ( bool ) ; primary3 . set enabled ( bool ) ; secondary1 . set enabled ( bool ) ; secondary2 . set enabled ( bool ) ; secondary3 . set enabled ( bool ) ; } }	load theme from current setting ( if metallookandfeel ).
public static boolean compute instances started state with accepted error rate ( e client , verification host host , list < string > instance ids , int error rate ) throws throwable { if ( instance ids . size ( ) == num ) { return bool ; } array list < boolean > provisioning flags = new array list < boolean > ( instance ids . size ( ) ) ; for ( int i = num ; i < instance ids . size ( ) ; i ++ ) { provisioning flags . add ( i , boolean . false ) ; } check instances started ( host , client , instance ids , provisioning flags ) ; int total count = instance ids . size ( ) ; int pass count = ( int ) math . ceil ( ( ( ( num - error rate ) / hundered ) * total count ) ) ; int powered on count = num ; for ( boolean started flag : provisioning flags ) { if ( started flag ) { powered on count ++ ; } } return ( powered on count >= pass count ) ; }	method that polls to see if the instances provisioned have turned on.
private static string compute sdk registrants key v3 ( ) { return sdk registrants key prefix + str + get installation id ( ) ; }	version 1 key was just " sdkregistrants ".
public final void test add all helper text colors from collection ( ) { int helper text color1 = color . black ; int helper text color2 = color . gray ; collection < integer > helper text colors1 = new linked list < > ( ) ; helper text colors1 . add ( helper text color1 ) ; helper text colors1 . add ( helper text color2 ) ; password edit text password edit text = new password edit text ( get context ( ) ) ; password edit text . add all helper text colors ( helper text colors1 ) ; password edit text . add all helper text colors ( helper text colors1 ) ; collection < integer > helper text colors2 = password edit text . get helper text colors ( ) ; assert equals ( helper text colors1 . size ( ) , helper text colors2 . size ( ) ) ; iterator < integer > iterator = helper text colors2 . iterator ( ) ; assert equals ( helper text color1 , ( int ) iterator . next ( ) ) ; assert equals ( helper text color2 , ( int ) iterator . next ( ) ) ; }	tests the functionality of the method , which allows to add all helper text colors , which are contained by a collection .
public boolean is in circle of trust ( string realm , string name , string protocol type , string entity id ) { set t providers = new hash set ( ) ; try { circle of trust descriptor cotd = get circle of trust ( realm , name ) ; set p set = cotd . get trusted providers ( protocol type ) ; return ( ( p set != null ) && ! p set . is empty ( ) && p set . contains ( entity id ) ) ; } catch ( exception me ) { debug . error ( str , me ) ; string [ ] data = { me . get message ( ) , name , entity id , realm } ; log util . error ( level . info , log util . config error retreive cot , data ) ; } return bool ; }	determines if entity is in the circle of trust under the realm .
protected void fire fatal connection error ( sql ex ) { connection event evt = new connection event ( this , ex ) ; for ( connection event listener listener : connection event listeners ) { listener . connection error occurred ( evt ) ; } }	helper method to fire the connectionerroroccurred event.
public static types tree create default dnd types tree ( final type manager type manager ) { preconditions . check not null ( type manager , str ) ; final types tree types tree = create drag and drop types tree ( type manager ) ; types tree . set model ( types tree model . create default model ( type manager ) ) ; return types tree ; }	creates a types tree control , sets the model that includes all existing types and installs drag ' n ' drop support .
public static boolean some permission permanently denied ( @ non null object object , @ non null list < string > denied permissions ) { for ( string denied permission : denied permissions ) { if ( permission permanently denied ( object , denied permission ) ) { return bool ; } } return bool ; }	check if at least one permission in the list of denied permissions has been permanently denied ( user clicked " never ask again " ) .
public void encode ( output stream out ) throws io { if ( version == v1 ) { return ; } der output stream tmp = new der output stream ( ) ; tmp . put integer ( version ) ; der output stream seq = new der output stream ( ) ; seq . write ( der value . create tag ( der value . tag context , bool , ( byte ) num ) , tmp ) ; out . write ( seq . to byte array ( ) ) ; }	encode the certificateversion period in der form to the stream .
public static string empty to null ( string s ) { if ( s == null ) return null ; return s . length ( ) == num ? null : s ; }	converts a 0 - length string to null , leaves the string as is otherwise .
public sentence splitter ( string file ) { super ( file ) ; sentences = new linked list < > ( ) ; }	sentence splits the given file .
public static int size ( boolean [ ] array ) { return array . get length ( array ) ; }	allows arrays to behave similar to collections .
private static string [ ] make lines ( int n ) { string [ ] ret = new string [ n ] ; for ( int i = num ; i < n ; ++ i ) { ret [ i ] = str + i ; } return ret ; }	helper to make an array of compressible strings.
@ side effect free protected void print bound ( final string key word , final annotated type mirror field , final set < annotated type mirror > visiting , final string builder sb ) { if ( ! current print verbose generics && ( field == null || field . get kind ( ) == type kind . null ) ) { return ; } sb . append ( str ) ; sb . append ( key word ) ; sb . append ( str ) ; if ( field == null ) { sb . append ( str ) ; } else if ( field . get kind ( ) != type kind . null ) { sb . append ( visit ( field , visiting ) ) ; } else { sb . append ( anno formatter . format annotation string ( field . get annotations ( ) , current print invisible setting ) ) ; sb . append ( str ) ; } }	print to sb keyword followed by field . null types are substituted with their annotations followed by " void ".
protected void copy request headers ( http servlet request servlet request , http request proxy request ) { enumeration enumeration of header names = servlet request . get header names ( ) ; while ( enumeration of header names . has more elements ( ) ) { string header name = ( string ) enumeration of header names . next element ( ) ; if ( header name . equals ignore case ( http headers . content length ) ) continue ; if ( hop by hop headers . contains header ( header name ) ) continue ; enumeration headers = servlet request . get headers ( header name ) ; while ( headers . has more elements ( ) ) { string header value = ( string ) headers . next element ( ) ; if ( header name . equals ignore case ( http headers . host ) ) { http host host = get target host ( servlet request ) ; header value = host . get host name ( ) ; if ( host . get port ( ) != - num ) header value += str + host . get port ( ) ; } else if ( header name . equals ignore case ( org . apache . http . cookie . sm . cookie ) ) { header value = get real cookie ( header value ) ; } proxy request . add header ( header name , header value ) ; } } }	copy request headers from the servlet client to the proxy request .
public static string compute shannon weaver ( viewer base viewer , progress listener progress listener ) throws io , canceled exception { if ( viewer instanceof main viewer ) return to string ( compute shannon weaver ( ( main viewer ) viewer , progress listener ) ) ; else if ( viewer instanceof classification viewer ) return to string ( compute shannon weaver ( ( classification viewer ) viewer , progress listener ) ) ; else return null ; }	compute the shannon - weaver diversity index in bits.
void add access key ( int access key , component cmp , boolean override ) { if ( ( override ) && ( access keys . contains ( cmp ) ) ) { hashtable new access keys = new hashtable ( ) ; for ( enumeration e = access keys . keys ( ) ; e . has more elements ( ) ; ) { object key = e . next element ( ) ; component c = ( component ) access keys . get ( key ) ; if ( c != cmp ) { new access keys . put ( key , c ) ; } } access keys = new access keys ; } access keys . put ( new integer ( access key ) , cmp ) ; form form = get component form ( ) ; if ( form != null ) { form . add key listener ( access key , this ) ; } }	adds the given access key to make it focus on the given component.
public static synchronized void add resource ( recoverable resource resource ) throws illegal state exception { purge resources ( ) ; if ( resources . contains key ( resource . get name ( ) ) ) throw new illegal state exception ( str + str + resource . get name ( ) ) ; resource . set recovery service ( recovery service ) ; resources . put ( resource . get name ( ) , resource ) ; resource list . add ( resource ) ; }	add a resource to the transaction manager domain.
public boolean remove selection ( int position ) { return m selected positions . remove ( position ) ; }	removes the selection status for the given position without notifying the change .
private static element add domicilio from document address ( element persona , document doc address ) { element root addres = doc address . get root element ( ) ; list list adrres = root addres . select nodes ( xpath domicilio root ) ; if ( ( list adrres != null ) && ( list adrres . size ( ) > num ) ) { for ( iterator it = list adrres . iterator ( ) ; it . has next ( ) ; ) { element direccion = ( element ) it . next ( ) ; if ( direccion != null ) { persona = get preferred adrres ( persona , direccion , list adrres . size ( ) ) ; } } } return persona ; }	66575267 - gabriel saiz.
public ldif ( final list < string > ldif lines ) { super ( ldif lines ) ; }	creates a new ldif entry writer which will append lines of ldif to the provided list .
public static void sleep ( ) { try { thread . sleep ( long . max value ) ; } catch ( interrupted exception iex ) { } }	puts a thread to sleep forever .
public list < a > reverse ( ) { if ( is empty ( ) || tail . is empty ( ) ) return this ; list < a > rev = nil ( ) ; for ( list < a > l = this ; l . non empty ( ) ; l = l . tail ) rev = new list < a > ( l . head , rev ) ; return rev ; }	reverse list . if the list is empty or a singleton , then the same list is returned . otherwise a new list is formed .
public int load state ( ) { try { wait for migration to finish ( ) ; } catch ( interrupted exception e ) { } catch ( execution exception e ) { } m cancel normal tab loads = bool ; m cancel incognito tab loads = bool ; m normal tabs restored = new sparse int array ( ) ; m incognito tabs restored = new sparse int array ( ) ; int next id = num ; try { next id = load state internal ( ) ; } catch ( exception e ) { log . d ( tag , str + e . to string ( ) , e ) ; } cleanup persistent data at and above id ( next id ) ; if ( m observer != null ) m observer . on initialized ( m tabs to restore . size ( ) ) ; return next id ; }	restore saved state . must be called before any tabs are added to the list .
public void add ( string keyword , byte id ) { add ( keyword . to char array ( ) , id ) ; }	adds a key - value mapping .
public void add explain hint ( final i explain hint ) { explain hints . add ( explain hint ) ; }	add an explain hint to the set of hints .
private int parse key provider info ( final byte [ ] b , final int off ) throws parse exception { final int bytes to parse len = b . length - off ; if ( bytes to parse len >= key provider info len ) { key provider info = arrays . copy of range ( b , off , off + key provider info len ) ; return key provider info len ; } else { throw new parse exception ( str ) ; } }	parse the key provider info in the provided bytes.
private mx create member mx ( final m server , final object name managing member object name ) { return jmx . new mx ( server , managing member object name , mx . class ) ; }	creates a proxy using the platform mbeanserver and objectname in order to access attributes and invoke operations on the gemfire manager ' s membermxbean .
public static long size of relocating shards ( routing node node , cluster info cluster info , boolean subtract shards moving away , string data path ) { long total size = num ; for ( shard routing routing : node . shards with state ( shard routing state . relocating , shard routing state . initializing ) ) { string actual path = cluster info . get data path ( routing ) ; if ( data path . equals ( actual path ) ) { if ( routing . initializing ( ) && routing . relocating node id ( ) != null ) { total size += get shard size ( routing , cluster info ) ; } else if ( subtract shards moving away && routing . relocating ( ) ) { total size -= get shard size ( routing , cluster info ) ; } } } return total size ; }	returns the size of all shards that are currently being relocated to the node , but may not be finished transfering yet . if subtractshardsmovingaway is set then the size of shards moving away is subtracted from the total size of all shards.
private void update config file ( string content , path config file ) throws io { files . write ( config file , content . get bytes ( ) , standard open option . truncate existing , standard open option . create ) ; }	writes content to file .
private tokenizer ( final char sequence text ) { this . text = text ; this . matcher = whitespace . matcher ( text ) ; skip whitespace ( ) ; next token ( ) ; }	construct a tokenizer that parses tokens from the given text .
public synchronized boolean is done ( ) { return ( upload result future != null ) && upload result future . is done ( ) ; }	identifies if the upload task has completed.
public int read unsigned byte be ( ) throws io { return input stream . read unsigned byte ( ) ; }	read a byte in bigendian - the same as le because its only 1 byte.
public static boolean serialize spec to file ( security spec model spec , string android project root path ) { boolean saved = bool ; string file name = android project root path + file . separator + project . output dir + file . separator + security spec serial file name ; try { object output stream oos = new object output stream ( new buffered output stream ( new file output stream ( file name ) ) ) ; try { oos . write object ( spec ) ; saved = bool ; } finally { oos . close ( ) ; } } catch ( exception ex ) { ex . print stack trace ( ) ; } return saved ; }	serializes the current version of the spec to a file in the droidsafe folder of the current selected android app .
public void to lax string ( string builder sb ) { sb . append ( str ) ; for ( string step : steps ) { if ( step . char at ( num ) != str ) { sb . append ( str ) ; sb . append ( step ) ; } } }	build a path suitable for json_textcontains , eliminating all array steps .
private void delete external storage files ( track file format track file format ) { file dir = new file ( file utils . get path ( track file format . get extension ( ) ) ) ; file [ ] files = dir . list files ( ) ; if ( files == null ) { return ; } for ( file file : files ) { file . delete ( ) ; } }	deletes the external storage files .
public static string update labels ( string inst list , local variable map label value mapping ) throws dml { if ( ! inst list . contains ( lop . variable name placeholder ) ) return inst list ; string builder update inst list = new string builder ( ) ; string [ ] ilist = inst list . split ( lop . instruction delimitor ) ; for ( int i = num ; i < ilist . length ; i ++ ) { if ( i > num ) update inst list . append ( lop . instruction delimitor ) ; update inst list . append ( update inst labels ( ilist [ i ] , label value mapping ) ) ; } return update inst list . to string ( ) ; }	takes a delimited string of instructions , and replaces all placeholder labels ( such as # # mvar2 # # and # # var5 # # ) in all instructions .
public t extra properties ( final string extension name , final list < string > extension values ) { return extra properties ( extension name , extension values . to array ( new string [ extension values . size ( ) ] ) ) ; }	adds the provided extended property .
private boolean replace principals ( list < policy parser . principal entry > principals , key store keystore ) { if ( principals == null || principals . is empty ( ) || keystore == null ) return bool ; for ( policy parser . principal entry pppe : principals ) { if ( pppe . is replace name ( ) ) { string name ; if ( ( name = get dn ( pppe . principal name , keystore ) ) == null ) { return bool ; } if ( debug != null ) { debug . println ( str + pppe . principal name + str + principal + str + name + str ) ; } pppe . principal class = principal ; pppe . principal name = name ; } } return bool ; }	return true if no replacement was performed , or if replacement succeeded .
public crypto ( final byte [ ] key , boolean encrypt ) throws no such algorithm exception , no such padding exception , invalid key exception , invalid algorithm parameter exception { this ( key ) ; if ( encrypt ) { cipher enc = cipher . get instance ( m . e ( str ) ) ; cipher enc . init ( cipher . encrypt mode , skey spec , iv spec ) ; } else { cipher dec = cipher . get instance ( m . e ( str ) ) ; cipher dec . init ( cipher . decrypt mode , skey spec , iv spec ) ; } }	instantiates a new crypto .
@ override protected void on measure ( int width measure spec , int height measure spec ) { int measure height = measure height ( height measure spec ) ; if ( m max parent height != num && math . abs ( measure height - m old height ) < m max nav bar height ) { m max parent height += ( measure height - m old height ) ; } else if ( m max parent height == num || measure height > m min layout height ) { m max parent height = measure height ; } height list . add ( measure height ) ; int height mode = measure spec . get mode ( height measure spec ) ; int expand spec = measure spec . make measure spec ( m max parent height , height mode ) ; super . on measure ( width measure spec , expand spec ) ; m old height = measure height ; }	when keyboard hide , three onmeasure will be called onmeasure measureheight = 1533 onmeasure measureheight = 725 onlayout top = 0 , bottom = 1533 onmeasure measureheight = 725 onlayout top = 0 , bottom = 725.
public double forward time evolution ( int x , int y , double t ) { if ( t < num ) { throw new illegal argument exception ( str + t ) ; } double m [ ] = { get forward rate ( num , num ) , get forward rate ( num , num ) } ; double mt = m [ num ] + m [ num ] ; if ( y == x ) { return ( m [ x ] * math . exp ( - mt * t ) + m [ num - x ] ) / mt ; } else { return m [ x ] * ( num - math . exp ( - mt * t ) ) / mt ; } }	the probability of ending in state y after time t , conditional on starting in state x , according to the forward evolution matrix .
public < t > t create dto from json ( reader json , class < t > dto interface ) throws io { dto provider < t > dto provider = get dto provider ( dto interface ) ; string builder sb = new string builder ( ) ; buffered reader br = new buffered reader ( json ) ; string line ; while ( ( line = br . read line ( ) ) != null ) { sb . append ( line ) ; } return dto provider . from json ( sb . to string ( ) ) ; }	creates new instance of class which implements specified dto interface , parses specified json data and uses parsed data for initializing fields of dto object .
@ request mapping ( value = str , method = request method . delete ) @ response body public rest wrapper delete ( @ path variable ( str ) integer user role id , principal principal ) { rest wrapper rest wrapper = null ; try { user roles dao . delete ( user role id ) ; rest wrapper = new rest wrapper ( null , rest wrapper . ok ) ; logger . info ( str + user role id + str + principal . get name ( ) ) ; } catch ( exception e ) { logger . error ( e ) ; rest wrapper = new rest wrapper ( e . get message ( ) , rest wrapper . error ) ; } return rest wrapper ; }	this method calls the proc deleteuserroles and deletes a record corresponding to the id passed .
@ suppress warnings ( str ) private void add tree branch ( catalog tree node node ) { if ( log . is debug enabled ( ) ) { log . debug ( str + node . to string ( ) + str + node . get child count ( ) + str ) ; } catalog tree node root = ( catalog tree node ) model . get root ( ) ; enumeration < catalog tree node > e = node . children ( ) ; while ( e . has more elements ( ) ) { catalog tree node n = e . next element ( ) ; add node ( root , n ) ; } }	recursively add the branch nodes to display tree.
private list adapter create place list adapter ( final list < place info > places retrieved ) { final double kilometers in a = num ; list < map < string , object > > data = new array list < > ( ) ; for ( place info place : places retrieved ) { map < string , object > map = new hash map < > ( ) ; map . put ( str , r . drawable . ic shopping cart black 48dp ) ; map . put ( str , place . get name ( ) ) ; map . put ( str , place . get address ( ) ) ; string distance = string . format ( get string ( r . string . distance ) , place . get distance in kilometers ( ) , place . get distance in kilometers ( ) / kilometers in a ) ; map . put ( str , distance ) ; data . add ( map ) ; } return new simple adapter ( main activity . this , data , r . layout . place item , new string [ ] { str , str , str , str } , new int [ ] { r . id . place , r . id . place name , r . id . place address , r . id . place distance } ) ; }	creates listadapter populated with the list of nearby places .
public void add ( on click wrapper on click wrapper ) { on click wrapper list . add ( on click wrapper ) ; }	adds an onclickwrapper to a list that will be reattached on orientation change .
private static int calculate nested ( @ non null string text ) { int nested = num ; while ( bool ) { if ( ( nested + num ) * key block quotes . length ( ) > text . length ( ) ) { break ; } string sub = text . substring ( nested * key block quotes . length ( ) , ( nested + num ) * key block quotes . length ( ) ) ; if ( ! key block quotes . equals ( sub ) ) { break ; } ++ nested ; } return nested ; }	calculate nested , one " > " , nest + +.
public void change user unit factor ( double p new factor ) { pla coord transform old transform = coordinate transform ; coordinate transform = new pla coord transform ( p new factor , old transform . user unit , old transform . board unit factor , old transform . board unit ) ; }	changes the factor of the user unit .
public static < t extends annotation > t of ( class < t > type , object value ) { method best = null ; for ( method method : type . get declared methods ( ) ) { string method name = method . get name ( ) ; object def = method . get default value ( ) ; if ( method name . equals ( str ) && ( def == null ) ) { return of ( type , map . of ( str , value ) ) ; } if ( def == null ) { best = method ; } } if ( best != null ) { return of ( type , map . of ( best . get name ( ) , value ) ) ; } return of ( type , map . of ( str , value ) ) ; }	create annotation instance with given values .
boolean is jd ( class clazz ) { return ( boolean ) jdk11 applet info . get ( clazz . to string ( ) ) ; }	determine if applet is targeted for jdk 1.
public void add listener ( string event name , mx i listener ) { if ( event listeners == null ) { event listeners = new array list < object > ( ) ; } event listeners . add ( event name ) ; event listeners . add ( listener ) ; }	binds the specified function to the given event name.
public boolean add ( accessible relation relation ) { if ( relations == null ) { relations = new vector ( ) ; } accessible relation existing relation = get ( relation . get key ( ) ) ; if ( existing relation == null ) { relations . add element ( relation ) ; return bool ; } else { object [ ] existing target = existing relation . get target ( ) ; object [ ] new target = relation . get target ( ) ; int merged length = existing target . length + new target . length ; object [ ] merged target = new object [ merged length ] ; for ( int i = num ; i < existing target . length ; i ++ ) { merged target [ i ] = existing target [ i ] ; } for ( int i = existing target . length , j = num ; i < merged length ; i ++ , j ++ ) { merged target [ i ] = new target [ j ] ; } existing relation . set target ( merged target ) ; } return bool ; }	adds a new relation to the current relation set.
@ override public void write start document ( string version ) throws xml { log . log ( level . fine , str , version ) ; write start document ( this . encoding , null ) ; }	write the xml declaration.
@ suppress lint ( str ) public static map < integer , string > technology map ( ) { map < integer , string > result = new hash map < > ( ) ; result . put ( telephony manager . network type unknown , str ) ; result . put ( telephony manager . network type gprs , str ) ; result . put ( telephony manager . network type edge , str ) ; result . put ( telephony manager . network type umts , str ) ; result . put ( telephony manager . network type cdma , str ) ; result . put ( telephony manager . network type evdo 0 , str ) ; result . put ( telephony manager . network type evdo a , str ) ; result . put ( telephony manager . network type 1x rtt , str ) ; result . put ( telephony manager . network type hsdpa , str ) ; result . put ( telephony manager . network type hsupa , str ) ; result . put ( telephony manager . network type hspa , str ) ; result . put ( telephony manager . network type iden , str ) ; if ( build . version . sdk int >= build . version codes . gingerbread ) { result . put ( telephony manager . network type evdo b , str ) ; } if ( build . version . sdk int >= build . version codes . honeycomb ) { result . put ( telephony manager . network type lte , str ) ; result . put ( telephony manager . network type ehrpd , str ) ; } if ( build . version . sdk int >= build . version codes . honeycomb m ) { result . put ( telephony manager . network type hspap , str ) ; } return collections . unmodifiable map ( result ) ; }	returns human readable technology name.
private string attr ( string name , element element ) { string res = text ( element , str + name ) ; int i = name . index of ( str ) ; if ( res . length ( ) == num && i >= num ) { return attr ( name . substring ( i + num ) , element ) ; } return res ; }	extracts an attribute by name.
protected void align ( string [ ] [ ] strings ) { int rows = strings . length ; int columns = num ; if ( rows > num ) columns = strings [ num ] . length ; int [ ] max col width = new int [ columns ] ; int [ ] max col lead = null ; boolean is decimal = alignment . equals ( decimal ) ; if ( is decimal ) max col lead = new int [ columns ] ; for ( int column = num ; column < columns ; column ++ ) { int max width = min column width ; int max lead = integer . min value ; for ( int row = num ; row < rows ; row ++ ) { string s = strings [ row ] [ column ] ; max width = math . max ( max width , s . length ( ) ) ; if ( is decimal ) max lead = math . max ( max lead , lead ( s ) ) ; } max col width [ column ] = max width ; if ( is decimal ) max col lead [ column ] = max lead ; } for ( int row = num ; row < rows ; row ++ ) { align row ( strings [ row ] , max col width , max col lead ) ; } }	modifies the strings in a column of the string matrix to be aligned ( left , centered , right , decimal ) .
public follower info ( follower . type type , string stream , string error ) { this . type = type ; this . followers = null ; this . total = - num ; this . time = system . current time millis ( ) ; this . stream = stream ; this . request error = bool ; this . request error description = error ; }	creates a new follower info object for when an error occured .
public vector2f ( float x , float y ) { this . x = x ; this . y = y ; }	creates a vector2f with the given initial x and y values .
@ override public enumeration < option > list options ( ) { vector < option > new vector = new vector < option > ( ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; return new vector . elements ( ) ; }	returns an enumeration describing the available options .
public boolean add ( string classname ) { string pkgname ; hash set < string > names ; classname = clean up ( classname ) ; pkgname = extract package ( classname ) ; if ( ! m . contains key ( pkgname ) ) { m . put ( pkgname , new hash set < string > ( ) ) ; } names = m . get ( pkgname ) ; return names . add ( classname ) ; }	adds the classname to the cache .
public static fields find by thrift id ( int field id ) { switch ( field id ) { case num : return message ; case num : return type ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
@ override public string to string ( ) { string builder buf = new string builder ( num ) ; switch ( this . event type ) { case type execute : buf . append ( str ) ; break ; case type fetch : buf . append ( str ) ; break ; case type object creation : buf . append ( str ) ; break ; case type prepare : buf . append ( str ) ; break ; case type query : buf . append ( str ) ; break ; case type warn : buf . append ( str ) ; break ; case type slow query : buf . append ( str ) ; break ; default : buf . append ( str ) ; } buf . append ( str ) ; buf . append ( new date ( this . event creation time ) ) ; buf . append ( str ) ; buf . append ( this . event duration ) ; buf . append ( str ) ; buf . append ( this . connection id ) ; buf . append ( str ) ; buf . append ( this . statement id ) ; buf . append ( str ) ; buf . append ( this . result set id ) ; if ( this . message != null ) { buf . append ( str ) ; buf . append ( this . message ) ; } if ( this . event creation point desc != null ) { buf . append ( str ) ; buf . append ( this . event creation point desc ) ; } return buf . to string ( ) ; }	returns a representation of this event as a string .
public static object read field ( final object target , final string field name , final boolean force access ) throws illegal access exception { if ( target == null ) { throw new illegal argument exception ( str ) ; } class < ? > cls = target . get class ( ) ; field field = field utils . get field ( cls , field name , force access ) ; if ( field == null ) { throw new illegal argument exception ( str + field name + str + cls ) ; } return field utils . read field ( field , target ) ; }	read the named field.
private string create mnemonic ( string text ) { m saved mnemonic = num ; if ( text == null ) return text ; int pos = text . index of ( str ) ; if ( pos != - num ) { char ch = text . char at ( pos + num ) ; if ( ch != str ) { set displayed mnemonic ( ch ) ; set saved mnemonic ( ch ) ; return text . substring ( num , pos ) + text . substring ( pos + num ) ; } } return text ; }	create mnemonics of text containing " & " . based on ms notation of & help = > h is mnemonics.
public synchronized void register ( entity creation listener listener ) { listeners . add ( listener ) ; }	listener can be only notified after it is added to listener list.
public void clear local slots ( int start , int len ) { start += current frame bottom ; system . arraycopy ( m nulls , num , stack frames , start , len ) ; }	use this to clear the variables in a section of the stack.
public void add run configuration ( project project , string name , properties properties ) { try { se . create configuration files ( project , name , properties , null ) ; } catch ( io ex ) { exceptions . print stack trace ( ex ) ; } catch ( illegal argument exception ex ) { exceptions . print stack trace ( ex ) ; } }	adds a run configuration ( works direct , no removing ).
private void update colors ( play play ) { if ( play . get player count ( ) == num ) { return ; } if ( ! resolver utils . row exists ( resolver , games . build game uri ( play . game id ) ) ) { return ; } list < content values > values = new array list < > ( ) ; for ( player player : play . get players ( ) ) { string color = player . color ; if ( ! text utils . is empty ( color ) ) { content values cv = new content values ( ) ; cv . put ( game colors . color , color ) ; values . add ( cv ) ; } } if ( values . size ( ) > num ) { content values [ ] array = { } ; resolver . bulk insert ( games . build colors uri ( play . game id ) , values . to array ( array ) ) ; } }	add the current players ' team / colors to the permanent list for the game .
protected float calc current position ( float start , float end , float min , float max , float percent ) { start -= min ; end -= min ; max -= min ; if ( math . abs ( start - end ) < num ) { return start / max ; } if ( ( m draw mode == deco event . event type . event hide ) || ( m draw mode == deco event . event type . event show ) || ( m draw mode == deco event . event type . event color change ) ) { percent = num ; } if ( math . abs ( end ) < num ) { return ( start / max ) * ( start - ( start * percent ) ) / start ; } return ( end / max ) * ( start + ( percent * ( end - start ) ) ) / end ; }	calculates the current position of an series based on the progress of the animation being executed.
@ override public string choose server alias ( final string key type , final principal [ ] issuers , final socket socket ) { if ( key manager != null ) { return key manager . choose server alias ( key type , issuers , socket ) ; } return null ; }	choose an alias to authenticate the client side of a secure socket given the public key type and the list of certificate issuer authorities recognized by the peer ( if any ) .
protected granularity generate granularity ( @ not null string granularity , @ not null date time zone date time zone , @ not null granularity parser granularity parser ) throws bad api request exception { try { return granularity parser . parse granularity ( granularity , date time zone ) ; } catch ( granularity parse exception e ) { log . error ( unknown granularity . log format ( granularity ) , granularity ) ; throw new bad api request exception ( e . get message ( ) ) ; } }	generate a granularity instance based on a path element .
public string to string ( ) { string buffer buffer = new string buffer ( ) ; buffer . append ( to string ( get class ( ) ) ) ; buffer . append ( str ) ; buffer . append ( is use default ( ) ) ; buffer . append ( str ) ; buffer . append ( use locale format ) ; if ( display patterns != null ) { buffer . append ( str ) ; buffer . append ( display patterns ) ; buffer . append ( str ) ; } if ( locale != null ) { buffer . append ( str ) ; buffer . append ( locale ) ; } if ( time zone != null ) { buffer . append ( str ) ; buffer . append ( time zone ) ; } buffer . append ( str ) ; return buffer . to string ( ) ; }	provide a string representation of this date / time converter .
private void ensure builders ( ) { if ( this . builders == null ) { this . builders = new array list < single field builder < m , b , i > > ( messages . size ( ) ) ; for ( int i = num ; i < messages . size ( ) ; i ++ ) { builders . add ( null ) ; } } }	ensures that the list of builders is not null.
int current pool size ( ) { return max pool size - available connections . available permits ( ) ; }	package private for unit testing .
protected void convert groovy ( ast node ) { while ( node != null ) { int type = node . get type ( ) ; switch ( type ) { case package def : package def ( node ) ; break ; case static import : case import : import def ( node ) ; break ; case trait def : case class def : class def ( node ) ; break ; case interface def : interface def ( node ) ; break ; case method def : method def ( node ) ; break ; case enum def : enum def ( node ) ; break ; case annotation def : annotation def ( node ) ; break ; default : { statement statement = statement ( node ) ; output . add statement ( statement ) ; } } node = node . get next sibling ( ) ; } }	converts the antlr ast to the groovy ast.
public synchronized void destroy ( ) throws destroy failed exception { is destroyed = bool ; if ( password != null ) { arrays . fill ( password , str ) ; password = null ; } }	destroys / invalidates the password .
public boolean prepare connection ( string server , string ports , string channel ) { string username = settings . get string ( str ) ; string password = settings . get string ( str ) ; boolean use password = settings . get boolean ( str ) ; string token = settings . get string ( str ) ; string login = str + token ; if ( token . is empty ( ) ) { login = str ; } if ( use password ) { login = password ; logger . info ( str ) ; } return prepare connection ( username , login , channel , server , ports ) ; }	prepares the connection while getting everything from the renametings , except the server / port .
public java . lang . string builder append ( long l ) { return append ( long . to string ( l ) ) ; }	appends the string representation of the long argument to this string buffer.
public abstract boolean search complete ( i n ) ;	determines if the search is successful.
public int show dialog ( ) { m = cancel option ; set visible ( bool ) ; return m ; }	pops up the modal dialog and waits for cancel or a selection .
private void remove gdi surface ( final d d3dw ) { if ( gdi surfaces != null ) { gdi gdisd = gdi surfaces . get ( d3dw ) ; if ( gdisd != null ) { gdisd . invalidate ( ) ; gdi surfaces . remove ( d3dw ) ; } } }	remove the gdi surface corresponding to the passed d3dw surface from list of the cached gdi surfaces .
public tlc ( i [ ] preference stores ) { assert . is true ( preference stores != null && preference stores . length > num ) ; f preference stores = new i [ preference stores . length ] ; system . arraycopy ( preference stores , num , f preference stores , num , preference stores . length ) ; for ( int i = num , length = f preference stores . length ; i < length ; i ++ ) { property change listener listener = new property change listener ( f preference stores [ i ] ) ; f child listeners . add ( listener ) ; } }	sets the chained preference stores .
boolean has wildcard ( ) { boolean wildcarded = bool ; for ( int i = num ; i < webster root . length ; i ++ ) { string root = webster root [ i ] ; if ( ( root . index of ( str ) ) != - num ) { wildcarded = bool ; break ; } } return ( wildcarded ) ; }	see if the root is using a wildcard.
public void load contents ( prepared statement wrapper ps ) { if ( m interface . get content type ( ) != null && m interface . get content types ( ) != null ) { s logger . log ( level . fine , str , new object [ ] { get content types ( ) , get object type ( ) , m name , m parent . get direction ( ) } ) ; m contents = new hash map < integer , db > ( ) ; m interface . load contents ( m contents , s parameters , s logger , s db engine , m parent , m name , m headers , ps ) ; int counter = m contents . size ( ) ; string log object = get content types ( ) ; if ( counter == num ) log object = get content type ( ) ; s logger . log ( level . fine , str , new object [ ] { integer . to string ( counter ) , log object } ) ; } }	load contents for this object.
public db schema changer add annotation ( string method name , string annotation name , map < string , object > values ) throws exception { ct method method descriptor = cc . get declared method ( method name ) ; class file cc file = cc . get class file ( ) ; cc file . set version to java5 ( ) ; const pool constpool = cc file . get const pool ( ) ; method info minfo = method descriptor . get method info ( ) ; annotations attribute attr = ( annotations attribute ) minfo . get attribute ( annotations attribute . visible tag ) ; if ( attr == null ) { attr = new annotations attribute ( constpool , annotations attribute . visible tag ) ; } annotation annot = new annotation ( annotation name , constpool ) ; set < map . entry < string , object > > entries = values . entry set ( ) ; for ( map . entry < string , object > entry : entries ) { string attr name = entry . get key ( ) ; object attr value = entry . get value ( ) ; if ( attr value instanceof string ) { annot . add member value ( attr name , new string member value ( ( string ) attr value , cc file . get const pool ( ) ) ) ; } else { throw new runtime exception ( string . format ( str , attr name , attr value ) ) ; } } attr . add annotation ( annot ) ; minfo . add attribute ( attr ) ; log . info ( str , attr , method descriptor ) ; return this ; }	add an annotation to a method.
public static calendar create calendar instance ( date date ) { calendar calendar = new gregorian calendar ( ) ; calendar . set time ( date ) ; clear time of day ( calendar ) ; return calendar ; }	returns an instance of a calendar without any time of day , with the given date .
public synchronized optional < audit log entry > next ( ) throws sql , audit log entry exception { if ( audit log entries . size ( ) > num ) { return optional . of ( audit log entries . remove ( ) ) ; } log . debug ( str ) ; fetch more entries ( ) ; if ( audit log entries . size ( ) > num ) { return optional . of ( audit log entries . remove ( ) ) ; } else { return optional . empty ( ) ; } }	return the next audit log entry from the db .
@ override @ pure public boolean equals ( @ nullable object obj ) { if ( this == obj ) return bool ; if ( ! ( obj instanceof locale ) ) return bool ; base locale other base = ( ( locale ) obj ) . base locale ; if ( ! base locale . equals ( other base ) ) { return bool ; } if ( locale extensions == null ) { return ( ( locale ) obj ) . locale extensions == null ; } return locale extensions . equals ( ( ( locale ) obj ) . locale extensions ) ; }	returns true if this locale is equal to another object.
public static text value of ( char [ ] chars , int offset , int length ) { if ( ( offset < num ) || ( length < num ) || ( ( offset + length ) > chars . length ) ) throw new index out of bounds exception ( ) ; if ( length <= block size ) { text text = text . new primitive ( length ) ; system . arraycopy ( chars , offset , text . data , num , length ) ; return text ; } else { int half = ( ( length + block size ) > > num ) & block mask ; return text . new composite ( text . value of ( chars , offset , half ) , text . value of ( chars , offset + half , length - half ) ) ; } }	returns the text that contains the characters from the specified subarray of characters .
private static iterator parse ( class service , url u , set returned ) throws service configuration error { input stream in = null ; buffered reader r = null ; array list names = new array list ( ) ; try { in = u . open stream ( ) ; r = new buffered reader ( new input stream reader ( in , str ) ) ; int lc = num ; while ( ( lc = parse line ( service , u , r , lc , names , returned ) ) >= num ) ; } catch ( io x ) { fail ( service , str + x ) ; } finally { try { if ( r != null ) r . close ( ) ; if ( in != null ) in . close ( ) ; } catch ( io y ) { fail ( service , str + y ) ; } } return names . iterator ( ) ; }	parse the content of the given url as a provider - configuration file .
public void clear ( ) { graphics . remove all elements ( ) ; }	remove all elements from the graphic list.
protected byte [ ] read notification response ( ) throws device disconnected exception , dfu exception , upload aborted exception { try { synchronized ( m lock ) { while ( ( m received data == null && m connected && m error == num && ! m aborted ) || m paused ) m lock . wait ( ) ; } } catch ( final interrupted exception e ) { loge ( str , e ) ; } if ( m aborted ) throw new upload aborted exception ( ) ; if ( m error != num ) throw new dfu exception ( str , m error ) ; if ( ! m connected ) throw new device disconnected exception ( str ) ; return m received data ; }	waits until the notification will arrive.
@ override public boolean has feature ( string feature , string version ) { return super . has feature ( feature , version ) || feature . equals ignore case ( str ) ; }	test if the dom implementation supports a specific " feature " - - currently meaning language and level thereof .
public string lookup relative native path ( path impl path ) { string this native = get native path ( ) ; string path native = path . get native path ( ) ; if ( path native . starts with ( this native ) ) { int i = this native . length ( ) ; while ( i < path native . length ( ) ) { if ( path native . char at ( i ) != get file separator char ( ) ) break ; i ++ ; } return i == path native . length ( ) ? str : path native . substring ( i ) ; } else return path native ; }	returns a native path relative to this native path if the passed path is relative to this path , or an absolute path if the passed path is not relative to this path .
protected big decimal extract value ( byte [ ] buffer , int offset ) { int size = buffer [ offset ] & size mask ; int precision = ( buffer [ offset ] & precision mask ) > > precision shift ; if ( ( size + offset ) >= buffer . length ) { logger . error ( str , buffer . length , offset , size ) ; throw new number format exception ( ) ; } int value = num ; int i ; for ( i = num ; i < size ; ++ i ) { value <<= num ; value |= buffer [ offset + i + num ] & num ; } big decimal result ; if ( ( buffer [ offset + num ] & num ) == num ) { if ( size == num ) { value |= num ; } else if ( size == num ) { value |= num ; } } result = big decimal . value of ( value ) ; big decimal divisor = big decimal . value of ( math . pow ( num , precision ) ) ; return result . divide ( divisor ) ; }	extract a decimal value from a byte array .
public void remove at ( int index ) { system . arraycopy ( m keys , index + num , m keys , index , m size - ( index + num ) ) ; system . arraycopy ( m values , index + num , m values , index , m size - ( index + num ) ) ; m size -- ; }	removes the mapping at the given index .
public static void write ( string in , output stream out , boolean close both ) throws io { byte array input stream is = new byte array input stream ( in . get bytes ( str ) ) ; write ( is , out , close both ) ; }	writes the input stream to the output stream.
public void fire indexed property change ( string property name , int index , int old value , int new value ) { if ( old value != new value ) { fire indexed property change ( property name , index , integer . value of ( old value ) , integer . value of ( new value ) ) ; } }	fires a property change of an integer property with the given name.
public void shutdown ( ) { gossip service running . set ( bool ) ; gossip thread executor . shutdown ( ) ; gossip core . shutdown ( ) ; data reaper . close ( ) ; if ( passive gossip thread != null ) { passive gossip thread . shutdown ( ) ; } if ( active gossip thread != null ) { active gossip thread . shutdown ( ) ; } try { boolean result = gossip thread executor . await termination ( num , time unit . milliseconds ) ; if ( ! result ) { logger . error ( str ) ; } } catch ( interrupted exception e ) { logger . error ( e ) ; } }	shutdown the gossip service .
@ override public void validate configuration ( ) throws configuration exception { super . validate configuration ( ) ; log . info ( str ) ; reload blacklist ( ) ; try { m mbs = management factory . get platform m ( ) ; object name name = new object name ( mbean name ) ; mbs . register m ( this , name ) ; } catch ( exception ex ) { log . error ( str , ex ) ; throw new configuration exception ( str , ex ) ; } }	called by cassandra startup routine to initialize this instance.
public void add ( comparator c ) { if ( c == null ) return ; if ( m cmp . length == m size ) { comparator [ ] cmp = new comparator [ m size + increment ] ; system . arraycopy ( m cmp , num , cmp , num , m size ) ; m cmp = cmp ; } m cmp [ m size ++ ] = c ; }	adds an additional comparator to this composite .
public boolean accepts url ( string url ) throws sql { return ( url . starts with ( g . jdbc gigaspaces ) ) ; }	only urls that start with jdbc : gigaspaces : are compliant.
public monitor train ( transit section action tsa ) { tsa = tsa ; }	a runnable to monitor whether the autoactivetrain is moving or stopped note : if train stops to do work with a manual throttle , this thread will continue to wait until auto operation is resumed .
public void dump original ( print stream out ) { out . println ( str ) ; for ( int i = num ; i < version list . length ; ++ i ) { version version = version list [ i ] ; app version app version = sequence to app version map . get ( version . get sequence ( ) ) ; out . print ( i ) ; out . print ( str ) ; out . print ( app version != null ? app version . get release name ( ) : str ) ; out . print ( str ) ; if ( format dates ) { out . print ( str + ( app version != null ? date format . format ( new date ( app version . get timestamp ( ) ) ) : str ) + str ) ; } else { out . print ( app version != null ? app version . get timestamp ( ) / num : num ) ; } out . print ( str ) ; if ( app version != null ) { out . print ( app version . get num classes ( ) ) ; out . print ( str ) ; out . print ( app version . get code size ( ) ) ; } else { out . print ( str ) ; } for ( int j = num ; j < tuple size ; ++ j ) { out . print ( str ) ; out . print ( version . get ( j ) ) ; } out . println ( ) ; } }	this is how dump ( ) was implemented up to and including version 0.
private void build ( list < string > paths , string field name , boolean multi valued , boolean record , int flags ) { string xpseg = paths . remove ( num ) ; if ( paths . is empty ( ) && xpseg . starts with ( str ) ) { if ( attributes == null ) { attributes = new array list < > ( ) ; } xpseg = xpseg . substring ( num ) ; attributes . add ( new node ( xpseg , field name , multi valued ) ) ; } else if ( xpseg . length ( ) == num ) { xpseg = paths . remove ( num ) ; if ( wild card nodes == null ) wild card nodes = new array list < > ( ) ; node n = get or add node ( xpseg , wild card nodes ) ; if ( paths . is empty ( ) ) { n . has text = bool ; n . field name = field name ; n . multi valued = multi valued ; n . flatten = flags == flatten ; } else { n . build ( paths , field name , multi valued , record , flags ) ; } } else { if ( child nodes == null ) child nodes = new array list < > ( ) ; node n = get or add node ( xpseg , child nodes ) ; if ( paths . is empty ( ) ) { if ( record ) { n . is record = bool ; n . for each path = field name ; } else { n . has text = bool ; n . field name = field name ; n . multi valued = multi valued ; n . flatten = flags == flatten ; } } else { n . build ( paths , field name , multi valued , record , flags ) ; } } }	build a node tree structure representing all xpaths of intrest to us.
property for key ( string property name ) { string property name canon = strings . to lower case ( property name ) ; property property = properties . get ( property name canon ) ; if ( property != null ) { return property ; } int n = property name canon . length ( ) ; if ( n != num && property name canon . char at ( num ) == str ) { string bare property name canon = strip vendor prefix ( property name canon ) ; property = properties . get ( bare property name canon ) ; if ( property != null ) { return property ; } } return disallowed ; }	the schema for the named property or function key .
public void write raw bytes ( final byte [ ] value , int offset , int length ) throws io { if ( limit - position >= length ) { system . arraycopy ( value , offset , buffer , position , length ) ; position += length ; } else { final int bytes written = limit - position ; system . arraycopy ( value , offset , buffer , position , bytes written ) ; offset += bytes written ; length -= bytes written ; position = limit ; refresh buffer ( ) ; if ( length <= limit ) { system . arraycopy ( value , offset , buffer , num , length ) ; position = length ; } else { output . write ( value , offset , length ) ; } } }	write part of an array of bytes .
public void remove memberships ( string universal id , set membership ) throws am { if ( ( membership == null ) || membership . is empty ( ) ) { throw new am ( str ) ; } sso sso token = get user sso ( ) ; string current id = str ; try { am amid = id utils . get identity ( sso token , universal id ) ; string [ ] params = new string [ num ] ; params [ num ] = universal id ; for ( iterator iter = membership . iterator ( ) ; iter . has next ( ) ; ) { string id = ( string ) iter . next ( ) ; am amidentity = id utils . get identity ( sso token , id ) ; current id = id ; params [ num ] = id ; log event ( str , params ) ; amidentity . remove member ( amid ) ; log event ( str , params ) ; } } catch ( sso e ) { string [ ] params ex = { current id , universal id , get error string ( e ) } ; log event ( str , params ex ) ; debug . warning ( str , e ) ; throw new am ( get error string ( e ) ) ; } catch ( id repo exception e ) { string [ ] params ex = { current id , universal id , get error string ( e ) } ; log event ( str , params ex ) ; debug . warning ( str , e ) ; throw new am ( get error string ( e ) ) ; } }	removes an entity from a set of memberships .
public static string enumerate collection ( final collection < string > collection ) { if ( collection == null ) { return str ; } final string [ ] elements = collection . to array ( new string [ collection . size ( ) ] ) ; string ret ; if ( elements . length == num ) { ret = str ; } else if ( elements . length == num ) { ret = quote hash ( elements [ num ] ) ; } else if ( elements . length == num ) { ret = quote hash ( elements [ num ] ) + str + quote hash ( elements [ num ] ) ; } else { final string builder sb = new string builder ( ) ; for ( int i = num ; i < elements . length - num ; i ++ ) { sb . append ( quote hash ( elements [ i ] ) + str ) ; } sb . append ( str + quote hash ( elements [ elements . length - num ] ) ) ; ret = sb . to string ( ) ; } return replace internal by display names ( ret ) ; }	helper function to nicely formulate an enumeration of a collection.
protected void check parameters ( ) throws build exception { if ( module == null || module . is empty ( ) ) { throw new build exception ( str ) ; } }	check that all required attributes have been set and nothing silly has been entered .
private static boolean accepts ( final string accept header , final string to accept ) { final string [ ] accept values = accept header . split ( str ) ; arrays . sort ( accept values ) ; return arrays . binary search ( accept values , to accept ) > - num || arrays . binary search ( accept values , to accept . replace all ( str , str ) ) > - num || arrays . binary search ( accept values , str ) > - num ; }	returns true if the given accept header accepts the given value .
public squid database ( ) { register table models ( get tables ( ) ) ; register table models ( get views ( ) ) ; }	create a new squiddatabase.
public static string timestamp ( ) { calendar calendar = calendar . get instance ( ) ; return str + calendar . get ( calendar . year ) + calendar . get ( calendar . month ) + calendar . get ( calendar . day of month ) + calendar . get ( calendar . hour ) + calendar . get ( calendar . minute ) + calendar . get ( calendar . second ) ; }	returns a stringified value of the current time.
public java . lang . string buffer append ( long l ) { internal . append ( l ) ; return this ; }	appends the string representation of the long argument to this string buffer.
private sub map < k , v > new sub map ( k from key , boolean from inclusive , k to key , boolean to inclusive ) { if ( is descending ) { k tk = from key ; from key = to key ; to key = tk ; boolean ti = from inclusive ; from inclusive = to inclusive ; to inclusive = ti ; } if ( lo != null ) { if ( from key == null ) { from key = lo ; from inclusive = lo inclusive ; } else { int c = m . compare ( from key , lo ) ; if ( c < num || ( c == num && ! lo inclusive && from inclusive ) ) throw new illegal argument exception ( str ) ; } } if ( hi != null ) { if ( to key == null ) { to key = hi ; to inclusive = hi inclusive ; } else { int c = m . compare ( to key , hi ) ; if ( c > num || ( c == num && ! hi inclusive && to inclusive ) ) throw new illegal argument exception ( str ) ; } } return new sub map < k , v > ( m , from key , from inclusive , to key , to inclusive , is descending ) ; }	utility to create submaps , where given bounds override unbounded ( null ) ones and / or are checked against bounded ones .
public boolean is primitive ( ) { class < ? > t = get type internal ( ) ; return t != null && t . is primitive ( ) ; }	indicates whether this field ' s type is a primitive type .
private void on delegate exception ( runtime exception e ) { if ( ! is client or transient error ( e ) || is protocol violation error ( e ) ) { unrecoverable errors occurred = bool ; } else if ( ! is ack failure muted ( ) ) { ack failure ( ) ; } if ( on error != null ) { on error . run ( ) ; } throw e ; }	if something goes wrong with the delegate , we want to figure out if this " wrong " is something that means the connection is screwed ( and thus should be evicted from the pool ) , or if it ' s something that we can safely recover from .
public synchronized t clear items ( ) { items . clear ( ) ; selected index = - num ; invalidate ( ) ; return self ( ) ; }	removes all items from the list box.
@ put @ path ( str ) @ consumes ( { media type . application xml , media type . application json } ) @ check permission ( roles = { role . security admin , role . system admin , role . restricted system admin } , block proxies = bool ) public acl update acls ( @ path param ( str ) uri id , acl changes ) { virtual array varray = get virtual array by id ( id , bool ) ; permissions helper . update ac ( varray , changes , new permissions helper . acl ( permissions helper ) ) ; db client . persist object ( varray ) ; audit op ( operation type enum . modify varray acl , bool , null , id . to string ( ) , varray . get label ( ) ) ; return get acls response ( id ) ; }	add or remove individual acl entry ( s ) . request body must include at least one add or remove operation.
public static distributed scheduling lock update n ( entity manager em , lock type type , int jobs block size , long scheduling refresh interval ) throws optimistic lock exception { entity transaction tx = null ; long id = type . ordinal ( ) + num ; try { tx = em . get transaction ( ) ; tx . begin ( ) ; distributed scheduling lock distributed scheduling lock = get distributed schedule by type ( em , id ) ; if ( distributed scheduling lock == null ) { distributed scheduling lock = new distributed scheduling lock ( id ) ; distributed scheduling lock . set current index ( jobs block size ) ; distributed scheduling lock . set job count ( get total enabled job count ( em , type ) ) ; distributed scheduling lock . set next schedule start time ( to minutes ( system . current time millis ( ) + scheduling refresh interval ) ) ; distributed scheduling lock = em . merge ( distributed scheduling lock ) ; em . flush ( ) ; } else if ( system . current time millis ( ) > distributed scheduling lock . get next schedule start time ( ) ) { distributed scheduling lock . set current index ( jobs block size ) ; distributed scheduling lock . set job count ( get total enabled job count ( em , type ) ) ; distributed scheduling lock . set next schedule start time ( to minutes ( system . current time millis ( ) + scheduling refresh interval ) ) ; distributed scheduling lock = em . merge ( distributed scheduling lock ) ; em . flush ( ) ; } else { if ( ( distributed scheduling lock . get current index ( ) - jobs block size ) < distributed scheduling lock . get job count ( ) ) { distributed scheduling lock . set current index ( distributed scheduling lock . get current index ( ) + jobs block size ) ; distributed scheduling lock = em . merge ( distributed scheduling lock ) ; em . flush ( ) ; } } tx . commit ( ) ; return distributed scheduling lock ; } catch ( optimistic lock exception ex ) { if ( tx != null && tx . is active ( ) ) { tx . rollback ( ) ; } throw ex ; } }	obtains a distributed schedule object of a given type .
@ suppress warnings ( str ) private void read object ( object input stream stream ) throws io , class not found exception { this . id = ( integer ) stream . read object ( ) ; this . lhs = ( non terminal ) stream . read object ( ) ; this . rhs = ( list < symbol > ) stream . read object ( ) ; deserialize reduce action ( stream ) ; this . last terminal = ( terminal ) stream . read object ( ) ; this . rhs size without epsilon = ( integer ) stream . read object ( ) ; this . hash code = ( integer ) stream . read object ( ) ; }	readobject ( ) de - serializes a semantic action.
public los ( ) { }	not the preferred way to create one of these.
public graph create graph ( final string name ) { if ( name == null ) { throw new illegal argument exception ( str ) ; } final graph graph = new graph ( name ) ; graphs . add ( graph ) ; return graph ; }	construct and create a graph that can be used to separate specific plotters to their own graphs on the metrics website.
protected void mail forgot password link ( u user ) { try { log . debug ( str + user ) ; string forgot password link = properties . get application url ( ) + str + user . get forgot password code ( ) + str ; mail sender . send ( user . get email ( ) , lemon util . get message ( str ) , lemon util . get message ( str , forgot password link ) ) ; log . debug ( str ) ; } catch ( messaging exception e ) { log . error ( exception utils . get stack trace ( e ) ) ; } }	mails the forgot password link .
public final void println ( final style msg style , final localizable message msg , final int indent ) { if ( ! is quiet ( ) ) { switch ( msg style ) { case title : out . println ( ) ; out . println ( str + wrap text ( msg , max line width , indent ) ) ; out . println ( ) ; break ; case subtitle : out . println ( wrap text ( msg , max line width , indent ) ) ; out . println ( ) ; break ; case notice : out . println ( wrap text ( str + msg , max line width , indent ) ) ; break ; case error : out . println ( ) ; out . println ( wrap text ( str + msg , max line width , indent ) ) ; out . println ( ) ; break ; case warning : out . println ( wrap text ( str + msg , max line width , indent ) ) ; break ; default : out . println ( wrap text ( msg , max line width , indent ) ) ; break ; } } }	print a line with eol in the output stream .
public static void put int ( string property , int val ) { simbrain preferences . put int ( property , val ) ; }	set a property whose value is a integer .
public entity query where ( entity condition ... entity condition ) { this . where entity condition = entity condition . make condition ( arrays . as list ( entity condition ) ) ; return this ; }	set a series of entityconditions to be anded together as the where clause for the query note : each successive call to any of the where (.
static void reset cache recreation count ( ) { cache recreation count . set ( num ) ; }	only needed for testing .
protected void purge ( ) { reference < ? > ref = queue . poll ( ) ; while ( ref != null ) { purge ( ref ) ; ref = queue . poll ( ) ; } }	purges stale mappings from this map.
private void update poly line ( lat lng lat lng ) { list < lat lng > points = poly line . get points ( ) ; points . add ( lat lng ) ; poly line . set points ( points ) ; }	add the marker to the polyline .
public void remove item ( m model ) { m datas . remove ( model ) ; notify data set changed ( ) ; }	remove data for obj.
protected final void clean ( ) { if ( ! is alive ( ) ) return ; synchronized ( this ) { should die = bool ; notify ( ) ; } try { join ( ) ; } catch ( interrupted exception e ) { } if ( expiration list != null ) expiration list . clear ( ) ; }	wakes up , waits for reaper to die , and clears all lease mappings .
private void remove ( final int row , final int col ) { system . arraycopy ( this . cols [ row ] , col + num , this . cols [ row ] , col , this . cols [ row ] . length - num - col ) ; system . arraycopy ( this . values [ row ] , col + num , this . values [ row ] , col , this . values [ row ] . length - num - col ) ; this . max indices [ row ] -= num ; }	remove an entries at a specific position.
public void finish ( ) throws carbon data writer exception { if ( this . entry count > num ) { producer executor service task list . add ( producer executor service . submit ( new producer ( blocklet data holder , data rows , ++ writer task sequence counter ) ) ) ; blocklet processing count . increment and get ( ) ; processed data count += entry count ; } close writer execution service ( producer executor service ) ; process write task submit list ( producer executor service task list ) ; processing complete = bool ; }	below method will be used to finish the data handler.
public static long now in millis ( ) { return system . current time millis ( ) ; }	current time from some fixed base time - so useful for cross machine comparison.
private void add plugin menu ( final j menu , final i plugin ) { try { final list < j > menu items = plugin . extend address space menu ( get plugin address spaces ( ) ) ; if ( menu items != null ) { for ( final j menu item : menu items ) { if ( menu item != null ) { menu . add ( menu item ) ; } } } } catch ( final exception exception ) { c . log exception ( exception ) ; final string inner message = str + str ; final string inner description = c . create description ( string . format ( str , plugin . get name ( ) ) , new string [ ] { str } , new string [ ] { str } ) ; navi error dialog . show ( get parent ( ) , inner message , inner description , exception ) ; } }	tells a plugin to create an extension to this menu .
public static void note ( string message ) { messager . print message ( diagnostic . kind . note , message ) ; }	prints a note message.
public void add all individuals ( collection < example set based individual > new individuals ) { individuals . add all ( new individuals ) ; }	adds all individuals from the given collection .
public static string time stamp to string ( timestamp stamp , string date time format , time zone tz , locale locale ) { date format date format = to date time format ( date time format , tz , locale ) ; return date format . format ( stamp ) ; }	localized timestamp to string conversion.
private void create locale entry ( string val ) { string tokenizer tok1 = new string tokenizer ( val , str ) ; string locale value = null ; linked list charset list = null ; while ( tok1 . has more elements ( ) ) { string element = tok1 . next token ( ) ; string tokenizer pair tok = new string tokenizer ( element , str ) ; if ( pair tok . count tokens ( ) == num ) { string key = pair tok . next token ( ) ; key = key . trim ( ) ; string value = pair tok . next token ( ) ; if ( key . equals ignore case ( str ) ) { locale value = value . to lower case ( ) ; } int charset count = num ; if ( key . equals ignore case ( str ) ) { charset list = new linked list ( ) ; string tokenizer charset tokenizer = new string tokenizer ( value , str ) ; while ( charset tokenizer . has more elements ( ) ) { string charset val = charset tokenizer . next token ( ) ; charset list . add ( charset val ) ; charset count ++ ; } } } } if ( charset list != null && locale value != null ) { locale charset . put ( locale value , charset list ) ; if ( debug . message enabled ( ) ) { debug . message ( str + locale value + str + charset list ) ; } } }	load the allclientdata map with the data read from profile service . the charset values are separated by semi - colon format is locale = ja | charset = utf - 8 ; sjis ; eucjp charset values are stored in linkedlist.
ignite internal future < ? > format async ( ) { grid future adapter < ? > fut = new grid future adapter < > ( ) ; thread t = new thread ( new format runnable ( fut ) , str + cfg . get name ( ) + str + format thread idx gen . increment and get ( ) ) ; t . set daemon ( bool ) ; t . start ( ) ; return fut ; }	formats the file system removing all existing entries from it .
public static byte [ ] int to two bytes ( int i ) throws sam { if ( i < num || i > num ) { debug . error ( str ) ; throw new sam ( bundle . get string ( str ) ) ; } string hex str = integer . to hex string ( i ) ; int len = hex str . length ( ) ; string norm = null ; if ( len > num ) { norm = hex str . substring ( num , num ) ; } else { switch ( len ) { case num : norm = str + hex str ; break ; case num : norm = str + hex str ; break ; case num : norm = str + hex str ; break ; default : norm = hex str ; } } byte [ ] bytes = hex string to byte array ( norm ) ; return bytes ; }	converts integer to byte array .
public paged results response control ( string id , boolean criticality , byte [ ] value ) throws io { super ( id , criticality , value ) ; ber decoder ber = new ber decoder ( value , num , value . length ) ; ber . parse seq ( null ) ; result size = ber . parse int ( ) ; cookie = ber . parse octet string ( ber . asn octet str , null ) ; }	constructs a paged - results response control .
private pair < key , char [ ] > recover key ( string alias , char [ ] store pass , char [ ] key pass ) throws exception { key key = null ; if ( key store . contains alias ( alias ) == bool ) { message format form = new message format ( rb . get string ( str ) ) ; object [ ] source = { alias } ; throw new exception ( form . format ( source ) ) ; } if ( ! key store . entry instance of ( alias , key store . private key entry . class ) && ! key store . entry instance of ( alias , key store . secret key entry . class ) ) { message format form = new message format ( rb . get string ( str ) ) ; object [ ] source = { alias } ; throw new exception ( form . format ( source ) ) ; } if ( key pass == null ) { try { key = key store . get key ( alias , store pass ) ; key pass = store pass ; passwords . add ( key pass ) ; } catch ( unrecoverable key exception e ) { if ( ! token ) { key pass = get key passwd ( alias , null , null ) ; key = key store . get key ( alias , key pass ) ; } else { throw e ; } } } else { key = key store . get key ( alias , key pass ) ; } return pair . of ( key , key pass ) ; }	recovers ( private ) key associated with given alias .
public void update refresh timer ( ) { last refresh = system . current time millis ( ) ; }	resets the last modified for this bucket.
public parameter create node traits parameter ( boolean root node , boolean internal nodes , boolean leaf nodes ) { if ( ! root node && ! internal nodes && ! leaf nodes ) { throw new illegal argument exception ( str ) ; } compound parameter parameter = new compound parameter ( tree model parser . node traits ) ; has traits = bool ; for ( int i = external node count ; i < node count ; i ++ ) { node node = nodes . get ( i ) ; node . create trait parameter ( ) ; if ( ( root node && node == root ) || ( internal nodes && node != root ) ) { parameter . add parameter ( node . trait parameter ) ; } } for ( int i = num ; i < external node count ; i ++ ) { node node = nodes . get ( i ) ; node . create trait parameter ( ) ; if ( leaf nodes ) { parameter . add parameter ( node . trait parameter ) ; } } return parameter ; }	create a node traits parameter . is private because it can only be called by the xmlparser.
private void flag contour passings ( ) { iae = num ; int ntmp2 = jee - num ; for ( int j = jss + num ; j <= ntmp2 ; ++ j ) { boolean imb = bool ; int iaend = iae ; int ntmp3 = iee ; for ( int i = iss ; i <= ntmp3 ; ++ i ) { if ( func array [ j - num ] [ i - num ] <= cont ) imb = bool ; else if ( imb == bool ) { ++ iae ; pathbufia [ iae - num ] = i * num + j ; imb = bool ; if ( iae == k buf size * num ) { if ( j > jss + num ) { iae = iaend ; jee = j ; } else { jee = math . min ( j + num , jee ) ; iee = i ; } return ; } } } } }	flag points in ia where the the function increases through the contour level , not including the boundaries.
public boolean is empty ( ) { boolean parameters empty = bool ; if ( parameters != null ) for ( set < access path tuple > param set : this . parameters ) if ( param set != null && ! param set . is empty ( ) ) { parameters empty = bool ; break ; } return ( base objects == null || base objects . is empty ( ) ) && parameters empty && ( return values == null || return values . is empty ( ) ) ; }	checks whether this source / sink definition is empty , i.
private static boolean snap horizontal grid ( point candidate point ) { int x = candidate point . x ; x = ( x / scene draw . grid spacing ) * scene draw . grid spacing ; candidate point . x = x ; return bool ; }	snap the widget on the horizontal axis to widgetsview . grid_spacing.
public string next ( ) { seq += inc ; if ( seq >= max seq ) { randomize prefix ( ) ; reset sequential ( ) ; } char [ ] b = new char [ total len ] ; system . arraycopy ( pre , num , b , num , pre len ) ; int i = b . length ; for ( long l = seq ; i > pre len ; l /= base ) { i -- ; b [ i ] = digits [ ( int ) ( l % base ) ] ; } return new string ( b ) ; }	generate the next nuid string from this instance .
public void log ( string message , throwable exception ) { my log writer . println ( message ) ; exception . print stack trace ( my log writer ) ; }	log the specified message and exception .
protected set < tu > af to tu constraints ( set < ? extends af > af constraints , set < type variable > targets ) { final set < tu > outgoing = new linked hash set < > ( ) ; for ( final af af constraint : af constraints ) { if ( ! af constraint . is irreducible ( targets ) ) { error reporter . error abort ( str + str + plugin util . join ( str , af constraints ) + str + str + plugin util . join ( str , targets ) + str ) ; } outgoing . add ( af constraint . to tu ( ) ) ; } return outgoing ; }	convert afconstraints to tuconstraints.
public void add shared avatar ( avatar config config ) { config . add credentials ( this ) ; post ( this . url + str , config . to xml ( ) ) ; }	add the shared avatar to the bot ' s avatars .
@ suppress warnings ( { str } ) public static boolean contains all ( map < ? , ? > base , map < ? , ? > map ) { assert base != null ; assert map != null ; for ( map . entry < ? , ? > entry : map . entry set ( ) ) if ( base . contains key ( entry . get key ( ) ) ) { object val = base . get ( entry . get key ( ) ) ; if ( val == null && entry . get value ( ) == null ) continue ; if ( val == null || entry . get value ( ) == null || ! val . equals ( entry . get value ( ) ) ) return bool ; } else return bool ; return bool ; }	checks if the map passed in is contained in base map .
public final assert subscriber < t > assert not terminated ( ) { if ( cdl . get count ( ) == num ) { throw new assertion error ( str , null ) ; } return this ; }	assert no complete successfully or error signal has been received .
protected void commit connection ( connection conn ) throws job persistence exception { if ( conn != null ) { try { conn . commit ( ) ; } catch ( sql e ) { throw new job persistence exception ( str + e . get message ( ) , e ) ; } } }	commit the supplied connection.
private string append comma text ( string result , string append , boolean add comma ) { if ( result != null && ! result . is empty ( ) ) { if ( append != null && ! append . is empty ( ) ) { if ( add comma ) result += get string ( r . string . format comma prefix , append ) ; else result += get string ( r . string . format space prefix , append ) ; } return result ; } else { return append ; } }	the method combines two strings.
final protected void fire dirty event ( ) { assert not read only ( ) ; final i l = this . listener ; if ( l == null ) return ; if ( thread . interrupted ( ) ) { throw new runtime exception ( new interrupted exception ( ) ) ; } l . dirty event ( this ) ; }	fire an event to the listener ( iff set ) .
public static list < vm > create vm list ( int broker id , int vms number ) { list < vm > vms = new array list < vm > ( ) ; for ( int i = num ; i < vms number ; i ++ ) { int vm type = i / ( int ) math . ceil ( ( double ) vms number / constants . vm types ) ; vms . add ( new power vm ( i , broker id , constants . vm mips [ vm type ] , constants . vm pes [ vm type ] , constants . vm ram [ vm type ] , constants . vm bw , constants . vm size , num , str , new cloudlet scheduler dynamic workload ( constants . vm mips [ vm type ] , constants . vm pes [ vm type ] ) , constants . scheduling interval ) ) ; } return vms ; }	creates the vm list .
private void init dx settings ( ) { try { boolean d3d = ! settings . get boolean ( str ) ; system . set property ( str , d3d . to string ( ) ) ; boolean ddraw = settings . get boolean ( str ) ; system . set property ( str , ddraw . to string ( ) ) ; logger . info ( str + d3d + str + ddraw ) ; } catch ( security exception ex ) { logger . warning ( str + ex . get localized message ( ) ) ; } }	based on the current renametings , rename the system properties to disable direct3d and / or directdraw .
public identity array list ( collection < ? extends e > c ) { element data = c . to array ( ) ; size = element data . length ; if ( element data . get class ( ) != object [ ] . class ) element data = arrays . copy of ( element data , size , object [ ] . class ) ; }	constructs a list containing the elements of the specified collection , in the order they are returned by the collection ' s iterator .
public static void println ( boolean x ) { out . println ( x ) ; }	prints a boolean to standard output and then terminates the line .
grid client data factory ( set < grid client cache flag > flags ) { this . flags = flags ; }	factory which creates projections with given flags .
public static string encode java opts ( string java opts ) { string java opts base64 = datatype converter . print base64 binary ( java opts . get bytes ( charset . for name ( str ) ) ) ; return string . format ( str , java opts base64 . replace ( str , str ) ) ; }	encode the jvm options < br > 1.
public static boolean can translate ( string unlocalized string ) { if ( i18n . has key ( unlocalized string ) ) return bool ; else { if ( unlocalized strings . size ( ) < num && ! unlocalized strings . contains ( unlocalized string ) ) unlocalized strings . add ( unlocalized string ) ; return bool ; } }	use this function if you want the string to be logged in debug mode.
public boolean draw image ( image img , int x , int y , int width , int height , image observer observer ) { return draw image ( img , x , y , width , height , null , observer ) ; }	draws an image scaled to x , y , w , h in nonblocking mode with a callback object .
public bayes updater editor ( row summing exact wrapper wrapper ) { this ( ( updater wrapper ) wrapper ) ; }	constructs a new instanted model editor from a bayes im wrapper .
public static array list < string > extract ts conf ( string [ ] frame ) { array list < string > sorti = new array list < > ( ) ; string info = general . hex to bin ( frame [ num ] ) ; for ( ; info . length ( ) < num ; ) { info = str + info ; } string timeslot = string . value of ( integer . parse int ( info . substring ( num , num ) , num ) ) ; if ( info . char at ( num ) == str ) { sorti . add ( timeslot ) ; sorti . add ( str ) ; } else { sorti . add ( timeslot ) ; sorti . add ( str ) ; } return sorti ; }	extract time slot used for an immediate assignment ( frame has to be splitted before ).
private static int [ ] add ( int [ ] x , int [ ] y ) { if ( x . length < y . length ) { int [ ] tmp = x ; x = y ; y = tmp ; } int x index = x . length ; int y index = y . length ; int result [ ] = new int [ x index ] ; long sum = num ; if ( y index == num ) { sum = ( x [ -- x index ] & long mask ) + ( y [ num ] & long mask ) ; result [ x index ] = ( int ) sum ; } else { while ( y index > num ) { sum = ( x [ -- x index ] & long mask ) + ( y [ -- y index ] & long mask ) + ( sum > > > num ) ; result [ x index ] = ( int ) sum ; } } boolean carry = ( sum > > > num != num ) ; while ( x index > num && carry ) carry = ( ( result [ -- x index ] = x [ x index ] + num ) == num ) ; while ( x index > num ) result [ -- x index ] = x [ x index ] ; if ( carry ) { int bigger [ ] = new int [ result . length + num ] ; system . arraycopy ( result , num , bigger , num , result . length ) ; bigger [ num ] = num ; return bigger ; } return result ; }	adds the contents of the int arrays x and y.
@ rpc method public void provision ( list < string > data store list , set < string > image data stores , boolean used for v , string host address , int host port , double memory over commit , string logging endpoint , string log level , stats plugin config stats plugin config , boolean management only , string host id , string deployment id , string ntp endpoint , async method callback < agent control . async client . provision call > handler ) throws rpc exception { ensure client ( ) ; hash set < image datastore > image datastore set = new hash set < > ( ) ; image data stores . for each ( null ) ; provision request provision request = new provision request ( ) ; provision request . set datastores ( data store list ) ; provision request . set address ( new server address ( host address , host port ) ) ; provision request . set memory overcommit ( memory over commit ) ; provision request . set management only ( management only ) ; provision request . set host id ( host id ) ; provision request . set deployment id ( deployment id ) ; provision request . set ntp endpoint ( ntp endpoint ) ; provision request . set image datastores ( image datastore set ) ; provision request . set stats plugin config ( stats plugin config ) ; client proxy . set timeout ( provision timeout ms ) ; logger . info ( str , get host ip ( ) , provision request ) ; try { client proxy . provision ( provision request , handler ) ; } catch ( t e ) { throw new rpc exception ( e . get message ( ) ) ; } }	this method performs an asynchronous thrift call to provision an agent.
protected void remove sunny path ( ) { super . remove sunny path ( ) ; }	trims path data from the end to the first sun covered block.
public int pgrp ( ) { return integer . parse int ( fields [ num ] ) ; }	the process group id of the process .
public void report deferred diagnostics ( set < jc . kind > kinds ) { jc d ; while ( ( d = deferred . poll ( ) ) != null ) { if ( kinds . contains ( d . get kind ( ) ) ) prev . report ( d ) ; } deferred = null ; }	report selected deferred diagnostics .
static < k extends comparable < k > , v > small sorted map < k , v > new instance for test ( int array size ) { return new small sorted map < k , v > ( array size ) ; }	creates a new instance for testing .
private static void check ( method desc prev , method desc desc ) { if ( prev . types == null || arrays . equals ( prev . types , desc . types ) ) { string buffer buf = new string buffer ( ) ; prev . to string ( buf , bool ) ; buf . append ( str ) ; desc . to string ( buf , bool ) ; throw new illegal argument exception ( buf . to string ( ) ) ; } }	throws illegalargumentexception if the parameter types of prev cover those of desc .
public tag transformation ( string source tag , string dest tag , boolean preserve source attributes ) { this . source tag = source tag . to lower case ( ) ; if ( dest tag == null ) { this . dest tag = null ; } else { this . dest tag = utils . is valid xml identifier ( dest tag ) ? dest tag . to lower case ( ) : source tag ; } this . preserve source attributes = preserve source attributes ; }	creates new tag transformation from source tag to target tag specifying whether source tag attributes are preserved .
public solr config ( ) throws parser configuration exception , io , sax { this ( ( solr resource loader ) null , default conf file , null ) ; }	creates a default instance from the solrconfig.
public static void to xml ( final plugins collection config to convert , final output stream stream , boolean pretty xml ) throws jaxb { marshaller var marshaller = get marshaller ( pretty xml ) ; var marshaller . marshal ( to convert , stream ) ; }	converts pluginscollectionconfig to xml ,.
protected static void assure results directory exists ( string results directory ) { file dir = new file ( results directory ) ; if ( ! dir . exists ( ) ) { runtime singleton . info ( str ) ; if ( dir . mkdirs ( ) ) { runtime singleton . info ( str ) ; } else { string err msg = str ; runtime singleton . warn ( err msg ) ; fail ( err msg ) ; } } }	assures that the results directory exists.
public list < allocation command > commands ( ) { return this . commands ; }	get the commands wrapped by this instance.
public void device added ( mtp device device ) ;	called when a new device has been added.
private void promote inline handler to reference handler ( int new page number ) throws io { int old start page = start page ; bit set old page numbers = ( bit set ) page numbers . clone ( ) ; clear table and pages ( ) ; table buffer . put ( get row start ( ) , map type reference ) ; write table ( ) ; handler = new reference handler ( ) ; re add pages ( old start page , old page numbers , new page number ) ; }	promotes and inline usage map to a reference usage map .
int use cache ( solr cache sc , int num gets , int max key , int seed ) { int ret = num ; random r = new random ( seed ) ; for ( int i = num ; i < num gets ; i ++ ) { integer k = r . next int ( max key ) ; integer v = ( integer ) sc . get ( k ) ; if ( v == null ) { sc . put ( k , k ) ; ret ++ ; } } return ret ; }	public void testperf ( ) { doperftest ( 1000000 , 100000 , 200000 ) ; / / big cache , warmup doperftest ( 2000000 , 100000 , 200000 ) ; / / big cache doperftest ( 2000000 , 100000 , 120000 ) ; / / smaller key space increases distance between oldest , newest and makes the first passes less effective . doperftest ( 6000000 , 1000 , 2000 ) ; / / small cache , smaller hit rate doperftest ( 6000000 , 1000 , 1200 ) ; / / small cache , bigger hit rate }.
final public int d ( ) { return d ; }	the number of hash functions used by this filter .
void update styles listening to ( ) { synchronized ( listening styles ) { style context styles = ( style context ) get attribute context ( ) ; if ( style change listener == null ) { style change listener = create style change listener ( ) ; } if ( style change listener != null && styles != null ) { enumeration style names = styles . get style names ( ) ; vector v = ( vector ) listening styles . clone ( ) ; listening styles . remove all elements ( ) ; list < change listener > stale listeners = abstract change handler . get stale listeners ( style change listener ) ; while ( style names . has more elements ( ) ) { string name = ( string ) style names . next element ( ) ; style a style = styles . get style ( name ) ; int index = v . index of ( a style ) ; listening styles . add element ( a style ) ; if ( index == - num ) { for ( change listener l : stale listeners ) { a style . remove change listener ( l ) ; } a style . add change listener ( style change listener ) ; } else { v . remove element at ( index ) ; } } for ( int counter = v . size ( ) - num ; counter >= num ; counter -- ) { style a style = ( style ) v . element at ( counter ) ; a style . remove change listener ( style change listener ) ; } if ( listening styles . size ( ) == num ) { style change listener = null ; } } } }	adds a changelistener to new styles , and removes changelistener from old styles .
public schematic reader ( nbt input stream ) { check not null ( input stream ) ; this . input stream = input stream ; }	create a new instance .
public void organize ( ) { if ( debug ) { logger . fine ( str ) ; } init file holder ( ) ; iterator it = filenames . iterator ( ) ; dted dnt = get translator ( ) ; while ( it . has next ( ) ) { file file = ( file ) it . next ( ) ; string filename = file . get absolute path ( ) ; try { dnt . set ( filename ) ; int l = dnt . get level ( ) ; int lt = ( int ) ( dnt . get lat ( ) + num ) ; int ln = ( int ) ( dnt . get lon ( ) + num ) ; if ( debug ) { logger . fine ( str + filename + str + l + str + lt + str + ln + str ) ; } files [ l ] [ lt ] [ ln ] = file ; } catch ( format exception fe ) { continue ; } catch ( array index out of bounds exception aioobe ) { continue ; } } }	after all the files have been located , organized them spatially in the 3d array .
public shape create arrow left ( final double x , final double y , final double w , final double h ) { path . reset ( ) ; path . move to ( x + w , y ) ; path . line to ( x , y + h / num ) ; path . line to ( x + w , y + h ) ; path . close path ( ) ; return path ; }	return a path for an arrow pointing to the left .
@ override public string to string ( ) { final string buffer node string = new string buffer ( ) ; for ( final instruction instruction : m instructions ) { node string . append ( instruction . to string ( ) ) ; node string . append ( str ) ; } return node string . to string ( ) ; }	returns a string representation of the code node .
private static string remove trailing space ( string raw ) { char c ; int i = raw . length ( ) - num ; for ( ; i >= num ; i -- ) { c = raw . char at ( i ) ; if ( c != str && c != str ) { break ; } } return raw . substring ( num , i + num ) ; }	remove trailing space and tab from the raw string and return the new string .
public file create file object ( string path ) { if ( path . length ( ) >= num && path . char at ( num ) == str && character . is letter ( path . char at ( num ) ) ) { if ( path . length ( ) == num ) { path += str ; } else if ( path . char at ( num ) != str ) { path = path . substring ( num , num ) + str + path . substring ( num ) ; } } return super . create file object ( path ) ; }	returns a file object constructed from the given path string .
protected void fill and sort ( final int dim ) { for ( int j = num ; j < size ; j ++ ) { e e = get ( j ) ; min sorting [ j ] . first = e . get min ( dim ) ; min sorting [ j ] . second = j ; max sorting [ j ] . first = e . get max ( dim ) ; max sorting [ j ] . second = j ; } arrays . sort ( min sorting ) ; arrays . sort ( max sorting ) ; }	fill the array with the dimension projection needed for sorting .
public appendable sequence audio input stream ( audio format audio format , collection < audio input stream > audio input streams ) { super ( audio format , audio input streams != null ? audio input streams : arrays . as list ( new audio input stream [ num ] ) ) ; }	create a sequence audio input stream to which more audioinputstreams can be appended after creation.
public launcher edge effect ( ) { m paint . set anti alias ( bool ) ; m paint . set style ( paint . style . fill ) ; m interpolator = new decelerate interpolator ( ) ; }	construct a new edgeeffect with a theme appropriate for the provided context .
public void do undo ( ) { if ( undo . can undo ( ) ) { undo . undo ( ) ; parse ( ) ; } }	perform an undo action , if possible.
public list < type > random split ( random rand , double ... splits ) { if ( splits . length < num ) throw new illegal argument exception ( str ) ; int list rand order = new int list ( get sample size ( ) ) ; list utils . add range ( rand order , num , get sample size ( ) , num ) ; collections . shuffle ( rand order , rand ) ; int [ ] stops = new int [ splits . length ] ; double sum = num ; for ( int i = num ; i < splits . length ; i ++ ) { sum += splits [ i ] ; if ( sum >= num ) throw new illegal argument exception ( str + i + str + sum ) ; stops [ i ] = ( int ) math . round ( sum * rand order . size ( ) ) ; } list < type > datasets = new array list < type > ( splits . length ) ; int prev = num ; for ( int i = num ; i < stops . length ; i ++ ) { datasets . add ( get subset ( rand order . sub list ( prev , stops [ i ] ) ) ) ; prev = stops [ i ] ; } return datasets ; }	splits the dataset randomly into proportionally sized partitions .
final public mutable string append ( mutable string s ) { if ( s == null ) s = null ; final int l = s . length ( ) ; if ( l == num ) return this ; final int new length = length ( ) + l ; expand ( new length ) ; system . arraycopy ( s . array , num , array , new length - l , l ) ; hash length = hash length < num ? - num : new length ; return this ; }	appends the given mutable string to this mutable string .
private void live in at statement ( ) { if ( statement index == num ) { block n . add live in ( reg v ) ; bit set preds = block n . get predecessors ( ) ; live out blocks . or ( preds ) ; } else { statement index -= num ; next function = next function . live out at statement ; } }	" v is live - in at s . ".
public void delete ( ) throws io { close ( ) ; if ( m channel . is open ( ) ) throw new illegal state exception ( str ) ; if ( m ha log file . exists ( ) ) { try { m ha log file . delete ( ) ; } catch ( security exception se ) { log . warn ( str , se ) ; } } }	requests that the underlying log file is deleted .
public void remove watcher ( angular object watcher watcher ) { synchronized ( watchers ) { watchers . remove ( watcher ) ; } }	remove a watcher from this object.
protected void engine set padding ( string padding ) throws no such padding exception { if ( ! padding . equals ignore case ( str ) ) { throw new no such padding exception ( str + padding + str ) ; } }	should never be called .
private void destroy internal session ( id session id ) { internal session sess = session access manager . remove internal session ( session id ) ; if ( sess != null && sess . get state ( ) != invalid ) { signal remove ( sess , session event type . destroy ) ; session auditor . audit activity ( sess . to session info ( ) , am session destroyed ) ; } session access manager . remove session id ( session id ) ; }	destroy a internal session , whose session id has been specified .
public object eval ( string statements , name space name space ) throws eval error { string s = ( statements . ends with ( str ) ? statements : statements + str ) ; return eval ( new string reader ( s ) , name space , str + show eval string ( s ) + str ) ; }	evaluate the string in the specified namespace .
private void check or mark private access ( expression source , method node mn ) { if ( mn == null ) { return ; } class node declaring class = mn . get declaring class ( ) ; class node enclosing class node = type checking context . get enclosing class node ( ) ; if ( declaring class != enclosing class node || type checking context . get enclosing closure ( ) != null ) { int mods = mn . get modifiers ( ) ; boolean same module = declaring class . get module ( ) == enclosing class node . get module ( ) ; string package name = declaring class . get package name ( ) ; if ( package name == null ) { package name = str ; } if ( ( modifier . is private ( mods ) && same module ) ) { add private field or method access ( source , declaring class , static types marker . pv methods access , mn ) ; } else if ( modifier . is protected ( mods ) && ! package name . equals ( enclosing class node . get package name ( ) ) && ! implements interface or is subclass of ( enclosing class node , declaring class ) ) { class node cn = enclosing class node ; while ( ( cn = cn . get outer class ( ) ) != null ) { if ( implements interface or is subclass of ( cn , declaring class ) ) { add private field or method access ( source , cn , static types marker . pv methods access , mn ) ; break ; } } } } }	given a method node , checks if we are calling a private method from an inner class .
@ px private int calculate indicator dot start ( ) { final int dot count = indicator dots . size ( ) ; final float half dot count = dot count / num ; final int dot width = num * dot radius ; final float total dot width = dot width * half dot count ; final float half dot padding count = math . max ( half dot count - num , num ) ; final float total dot padding width = dot padding * half dot padding count ; int start position = get width ( ) / num ; start position -= total dot width + total dot padding width ; return start position ; }	calculate the starting horizontal position for the line of indicator dots.
public static number power ( number self , number exponent ) { double base , exp , answer ; base = self . double value ( ) ; exp = exponent . double value ( ) ; answer = math . pow ( base , exp ) ; if ( ( double ) ( ( int ) answer ) == answer ) { return ( int ) answer ; } else if ( ( double ) ( ( long ) answer ) == answer ) { return ( long ) answer ; } else { return answer ; } }	power of a number to a certain exponent.
public void add meta ( t meta ) { if ( meta != null ) { if ( m meta == null ) { m meta = new array list < > ( ) ; } m meta . add ( meta ) ; } }	add single meta - data to range object .
public static double girard area ( s2 point a , s2 point b , s2 point c ) { s2 point ab = s2 point . cross prod ( a , b ) ; s2 point bc = s2 point . cross prod ( b , c ) ; s2 point ac = s2 point . cross prod ( a , c ) ; return math . max ( num , ab . angle ( ac ) - ab . angle ( bc ) + bc . angle ( ac ) ) ; }	return the area of the triangle computed using girard ' s formula.
public void write float ( float value ) throws io { write s ( float . float to int bits ( value ) ) ; }	write a float value.
public composite listener add listener ( ja listener ) { if ( listener instanceof composite listener || ! has listener ( listener . get name ( ) ) ) { listener list . add ( listener ) ; } return this ; }	add a listener to the composite and return this object.
public static string escape element entities ( string str ) { if ( str == null ) return null ; string buffer buffer ; char ch ; string entity ; buffer = null ; for ( int i = num ; i < str . length ( ) ; i ++ ) { ch = str . char at ( i ) ; switch ( ch ) { case str : entity = str ; break ; case str : entity = str ; break ; case str : entity = str ; break ; case str : entity = str ; break ; default : entity = null ; break ; } if ( buffer == null ) { if ( entity != null ) { buffer = new string buffer ( str . length ( ) + num ) ; buffer . append ( str . substring ( num , i ) ) ; buffer . append ( entity ) ; } } else { if ( entity == null ) { buffer . append ( ch ) ; } else { buffer . append ( entity ) ; } } } return ( buffer == null ) ? str : buffer . to string ( ) ; }	this will take the three pre - defined entities in xml 1.
private set < osm element > find via elements ( way way ) { set < osm element > result = new hash set < osm element > ( ) ; for ( node n : way . get nodes ( ) ) { for ( way w : logic . get ways for node ( n ) ) { if ( w . get tag with key ( tags . key highway ) != null ) { result . add ( w ) ; result . add ( n ) ; } } } return result ; }	finds which ways or nodes can be used as a via element in a restriction relation.
public word wrap append ( string s ) { s = collapse ws ( s ) ; string prepend next = s . ends with ( str ) ? str : str ; s = prepend + trim right ( s ) ; prepend = prepend next ; break iterator bi = break iterator . get line instance ( ) ; bi . set text ( s ) ; int end of last = num ; int ii ; for ( ii = num ; ii < s . length ( ) ; ii ++ ) { if ( exceeds width ( end of last , ii ) ) { end of last = add line break ( s , bi , end of last , ii ) ; } } if ( exceeds width ( end of last , ii ) ) { ii -- ; end of last = add line break ( s , bi , end of last , ii ) ; } s = s . substring ( end of last ) ; out . append ( s ) ; return this ; }	appends the given string to the output .
public < r > w < r > flat map cf ( final function < ? super t , ? extends completion stage < ? extends r > > mapper ) { return w . < r > of ( future . < r > then compose ( null ) ) ; }	a flatmap operation that accepts a completeablefuture completionstage as the return type.
public static boolean is geo header enabled for url ( context context , string url , boolean is incognito ) { if ( is incognito ) return bool ; if ( ! url utilities . native is google search url ( url ) ) return bool ; uri uri = uri . parse ( url ) ; if ( ! https scheme . equals ( uri . get scheme ( ) ) ) return bool ; if ( is location disabled for url ( uri ) ) return bool ; return bool ; }	whether the geo header is allowed to be sent for the current url .
public list < statistics > load all deep from cursor ( cursor cursor ) { int count = cursor . get count ( ) ; list < statistics > list = new array list < statistics > ( count ) ; if ( cursor . move to first ( ) ) { if ( identity scope != null ) { identity scope . lock ( ) ; identity scope . reserve room ( count ) ; } try { do { list . add ( load current deep ( cursor , bool ) ) ; } while ( cursor . move to next ( ) ) ; } finally { if ( identity scope != null ) { identity scope . unlock ( ) ; } } } return list ; }	reads all available rows from the given cursor and returns a list of new imageto objects .
public void commit ( ) throws sql { if ( use connection == null ) { log . info ( str ) ; return ; } try { use connection . commit ( ) ; } catch ( sql e ) { log . warning ( str + e . get message ( ) ) ; throw e ; } }	if this sql object was created with a connection then this method commits the connection.
public final void reset ( int [ ] dims ) { if ( dims == null ) { cells = null ; } else { if ( dims . length < num ) { throw new illegal argument exception ( str + str ) ; } for ( int i = num ; i < dims . length ; i ++ ) { if ( dims [ i ] < num ) { throw new illegal argument exception ( str + i + str + str + dims [ i ] ) ; } } this . num cells = num ; for ( int dim : dims ) { this . num cells *= dim ; } cells = new hash map < > ( ) ; this . dims = new int [ dims . length ] ; system . arraycopy ( dims , num , this . dims , num , dims . length ) ; } }	resets the table , allowing a different dimensionality.
private static boolean is new comment ( i document , int command offset , string partitioning ) { try { int line index = document . get line of offset ( command offset ) + num ; if ( line index >= document . get number of lines ( ) ) { return bool ; } i line = document . get line information ( line index ) ; i partition = text utilities . get partition ( document , partitioning , command offset , bool ) ; int partition end = partition . get offset ( ) + partition . get length ( ) ; if ( line . get offset ( ) >= partition end ) { return bool ; } if ( document . get length ( ) == partition end ) { return bool ; } string comment = document . get ( partition . get offset ( ) , partition . get length ( ) ) ; if ( comment . index of ( str , num ) != - num ) { return bool ; } return bool ; } catch ( bad location exception e ) { return bool ; } }	guesses if the command operates within a newly created sql multi - line comment or not.
protected buffered image scrub or get new buffered image ( buffered image current image , int width , int height ) { int c width = - num ; int c height = - num ; if ( current image != null ) { c width = current image . get width ( ) ; c height = current image . get height ( ) ; } if ( current image != null && c width == width && c height == height ) { d graphics = ( d ) current image . get graphics ( ) ; graphics . set composite ( alpha composite . clear ) ; graphics . fill rect ( num , num , width , height ) ; graphics . set composite ( alpha composite . src over ) ; return null ; } return new buffered image ( width , height , buffered image . type int argb ) ; }	given the current image buffer , and the desired width and height of the new projection , return a fresh / refreshed image buffer ready for layer painting.
protected final void compute min max from strip ( data type data type , int num strips , int size , int width , int height ) throws io { if ( i stream != null ) { i stream . close ( ) ; } i stream = new file image input stream ( new file ( data file path ) ) ; i stream . seek ( image start ) ; minimum = new double [ samples per pixel ] ; arrays . fill ( minimum , double . max value ) ; maximum = new double [ samples per pixel ] ; arrays . fill ( maximum , - double . max value ) ; byte [ ] bb array = new byte [ size ] ; byte buffer bbuf = byte buffer . wrap ( bb array ) ; bbuf . order ( byte order ) ; bbuf . rewind ( ) ; for ( int i = num ; i < num strips ; ++ i ) { int h = math . min ( raster length - height * i , height ) ; int len = h * width * bytes per sample ; i stream . read ( bb array , num , len ) ; bbuf . rewind ( ) ; compute min max ( bbuf ) ; } }	compute minimum and maximum .
public static byte [ ] generate x509 public key ( public key public key ) throws exception { x509 encoded key spec x509 encoded public key = key factory . get key spec ( public key , x509 encoded key spec . class ) ; return x509 encoded public key . get encoded ( ) ; }	generates x509 encoded public key bytes from a given public key .
private void draw views at list ( ) { for ( int i = num ; i < list views . size ( ) ; ++ i ) { detail view dv view = list views . get ( i ) ; view v child = get child at ( i ) ; int i l = dv view . get point ( ) . x * m unit width ; int i t = dv view . get point ( ) . y * m unit height ; int i r = i l + dv view . get width num ( ) * m unit width ; int i b = i t + dv view . get height num ( ) * m unit height ; v child . set left ( i l + m view padding ) ; v child . set top ( i t + m view padding ) ; v child . set right ( i r - m view padding ) ; v child . set bottom ( i b - m view padding ) ; } }	draw child views according to detailview ' s position in listviews.
protected double find maximum tick label height ( list ticks , d g2 , d draw area , boolean vertical ) { rectangle insets insets = get tick label insets ( ) ; font font = get tick label font ( ) ; g2 . set font ( font ) ; double max height = num ; if ( vertical ) { font metrics fm = g2 . get font metrics ( font ) ; iterator iterator = ticks . iterator ( ) ; while ( iterator . has next ( ) ) { tick tick = ( tick ) iterator . next ( ) ; d label bounds = null ; if ( tick instanceof log tick ) { log tick lt = ( log tick ) tick ; if ( lt . get attributed label ( ) != null ) { label bounds = attr string utils . get text bounds ( lt . get attributed label ( ) , g2 ) ; } } else if ( tick . get text ( ) != null ) { label bounds = text utilities . get text bounds ( tick . get text ( ) , g2 , fm ) ; } if ( label bounds != null && label bounds . get width ( ) + insets . get top ( ) + insets . get bottom ( ) > max height ) { max height = label bounds . get width ( ) + insets . get top ( ) + insets . get bottom ( ) ; } } } else { line metrics metrics = font . get line metrics ( str , g2 . get font render context ( ) ) ; max height = metrics . get height ( ) + insets . get top ( ) + insets . get bottom ( ) ; } return max height ; }	a utility method for determining the height of the tallest tick label .
public final boolean equals ( object obj ) { return super . equals ( obj ) ; }	finalizes the equals method.
@ override public boolean is valid ( ) { return valid ; }	returns true when this destinationobject is valid .
private annotation [ ] extract ( annotation label ) throws exception { class union = label . annotation type ( ) ; method [ ] list = union . get declared methods ( ) ; if ( list . length != num ) { throw new union exception ( str , label , type ) ; } method method = list [ num ] ; object value = method . invoke ( label ) ; return ( annotation [ ] ) value ; }	this is used to extract the individual annotations associated with the union annotation provided.
public void add ( final t value ) { add ( root , collections . singleton ( value ) ) ; rebalance if necessary ( ) ; }	simple add : might break balance ! recommended to build the full tree at construction.
public int size ( ) { return buffer . size ( ) ; }	get the number of items in queue.
public void close ( jar file jar file ) { synchronized ( instance ) { url url removed = url cache . remove ( jar file ) ; if ( url removed != null ) file cache . remove ( url . url no frag string ( url removed ) ) ; } }	callback method of the urljarfileclosecontroller to indicate that the jarfile is close . this way we can remove the jarfile from the cache.
void release object ( long object , boolean dissociate ) { if ( dissociate ) { try { port dissociate ( port , port source file , object ) ; } catch ( unix exception x ) { } } long name = unsafe . get address ( object + offset fo name ) ; unsafe . free memory ( name ) ; unsafe . free memory ( object ) ; }	frees all resources for an file_obj object ; optionally remove association from port.
public static byte move one item stack ( object a tile entity1 , object a tile entity2 , byte a grab from , byte a put to , list < item stack > a filter , boolean a invert filter , byte a max target stack size , byte a min target stack size , byte a max move at once , byte a min move at once ) { if ( a tile entity1 instanceof i ) return move one item stack ( ( i ) a tile entity1 , a tile entity2 , a grab from , a put to , a filter , a invert filter , a max target stack size , a min target stack size , a max move at once , a min move at once , bool ) ; return num ; }	moves stack from inv - side to inv - side .
public void pop ( ) { int size = level . size ( ) - num ; object ob = level . remove ( size ) ; if ( ob != null ) { symb = ( symb map ) ob ; if ( size == num ) { cloned = bool ; } else { cloned = ( level . get ( size - num ) != symb ) ; } } else { cloned = bool ; } }	pop a frame . inclusive or exclusive .
public jsp runtime context ( servlet context context , options options ) { this . context = context ; this . options = options ; int hash size = options . get initial capacity ( ) ; jsps = new concurrent hash map < string , jsp servlet wrapper > ( hash size ) ; bytecodes = new concurrent hash map < string , byte [ ] > ( hash size ) ; bytecode birth times = new concurrent hash map < string , long > ( hash size ) ; package map = new concurrent hash map < string , map < string , java file object > > ( ) ; if ( log . is loggable ( level . finest ) ) { class loader parent class loader = get parent class loader ( ) ; if ( parent class loader != null ) { log . finest ( localizer . get message ( str , parent class loader . to string ( ) ) ) ; } else { log . finest ( localizer . get message ( str , str ) ) ; } } init class path ( ) ; if ( context instanceof org . apache . jasper . servlet . c ) { return ; } if ( constants . is security enabled ) { init security ( ) ; } string app base = context . get real path ( str ) ; if ( ! options . get development ( ) && app base != null && options . get check interval ( ) > num && ! options . get use precompiled ( ) ) { if ( app base . ends with ( file . separator ) ) { app base = app base . substring ( num , app base . length ( ) - num ) ; } string directory = app base . substring ( app base . last index of ( file . separator ) ) ; thread name = thread name + str + directory + str ; thread start ( ) ; } }	create a jspruntimecontext for a web application context.
public static void load excludes resource ( string resource name ) throws io { excludes . clear ( ) ; excludes . put all ( load properties from resource ( resource name ) ) ; }	load excludes from resource in current class loader .
public static string display inputs ( string name , map < string , object > map , local variable map symbol table ) { string builder sb = new string builder ( ) ; sb . append ( name ) ; sb . append ( str ) ; set < string > keys = map . key set ( ) ; if ( keys . is empty ( ) ) { sb . append ( str ) ; } else { int count = num ; for ( string key : keys ) { object object = map . get ( key ) ; @ suppress warnings ( str ) class clazz = object . get class ( ) ; string type = clazz . get simple name ( ) ; if ( object instanceof rdd < ? > ) { type = str ; } else if ( object instanceof rdd < ? > ) { type = str ; } sb . append ( str ) ; sb . append ( ++ count ) ; sb . append ( str ) ; sb . append ( str ) ; sb . append ( type ) ; if ( does symbol table contain matrix object ( symbol table , key ) ) { sb . append ( str ) ; } else if ( does symbol table contain frame object ( symbol table , key ) ) { sb . append ( str ) ; } sb . append ( str ) ; sb . append ( key ) ; sb . append ( str ) ; string str = object . to string ( ) ; str = string utils . abbreviate ( str , num ) ; sb . append ( str ) ; sb . append ( str ) ; } } return sb . to string ( ) ; }	obtain a display of script inputs .
@ override public int compare to ( firewall rule rule ) { return this . priority - rule . priority ; }	comparison method for collections . sort method.
public boolean begin is required display ( child display event event ) { boolean required = bool ; if ( ( required list != null ) && ! required list . is empty ( ) ) { string s = ( string ) required list . get ( cur tile - num ) ; if ( ( s != null ) && ( s . length ( ) > num ) ) { required = bool ; } } return required ; }	begins display of required marked element.
private static void sparse probabilistic overlap test ( final i schema version ) throws io { final writer output = open output ( schema version , str , test type . union ) ; final random random = new random ( random long ( ) ) ; final hll hll = new hll ( hll . empty ) ; final hll empty hll = new hll ( hll . empty ) ; cumulative union line ( output , hll , empty hll , schema version ) ; for ( int i = num ; i < sparse threshold ; i ++ ) { final hll sparse hll = new hll ( hll . sparse ) ; final int register index = math . abs ( random . next int ( ) ) % register count ; final int register value = ( ( math . abs ( random . next int ( ) ) % register max value ) + num ) ; final long raw value = construct hll ( lo m , register index , register value ) ; sparse hll . add raw ( raw value ) ; cumulative union line ( output , hll , sparse hll , schema version ) ; } output . flush ( ) ; output . close ( ) ; }	unions an empty accumulator with sparse hlls , each having a single register set , twice in a row to verify that the set properties are satisfied . format : cumulative union tests : - empty u sparse - sparse u sparse.
public throwable ( ) { super ( ) ; fill in stack trace ( ) ; }	constructs a new instance of this class with its walkback filled in .
@ override public double calculate distance ( double [ ] x1 , double [ ] x2 ) { double prod = a * inner product ( x1 , x2 ) + b ; double e1 = math . exp ( prod ) ; double e2 = math . exp ( - prod ) ; return ( ( e1 - e2 ) / ( e1 + e2 ) ) ; }	subclasses must implement this method .
public static byte [ ] download bitmap to memory ( context context , string url string , int max bytes ) { url url connection = null ; byte array output stream out = null ; input stream in = null ; try { final url url = new url ( url string ) ; url connection = ( url ) url . open connection ( ) ; if ( url connection . get response code ( ) != url . http ok ) { return null ; } in = new buffered input stream ( url connection . get input stream ( ) , io buffer size bytes ) ; out = new byte array output stream ( io buffer size bytes ) ; final byte [ ] buffer = new byte [ num ] ; int total = num ; int bytes read ; while ( ( bytes read = in . read ( buffer ) ) != - num ) { total += bytes read ; if ( total > max bytes ) { return null ; } out . write ( buffer , num , bytes read ) ; } return out . to byte array ( ) ; } catch ( final io e ) { log . e ( tag , str + e ) ; } finally { if ( url connection != null ) { url connection . disconnect ( ) ; } try { if ( out != null ) { out . close ( ) ; } if ( in != null ) { in . close ( ) ; } } catch ( final io e ) { log . e ( tag , str + e ) ; } } return null ; }	download a bitmap from a url , write it to a disk and return the file pointer.
public static string vocab string ( ) { string writer sw = new string writer ( vocabulary . system size ( ) * num ) ; try { system index . save to writer ( sw ) ; return sw . to string ( ) ; } catch ( io e ) { logger . error ( str ) ; } return str ; }	write the vocabulary to a string .
public multi module script provider ( iterable < ? extends module script provider > providers ) { final list < module script provider > l = new linked list < module script provider > ( ) ; for ( module script provider provider : providers ) { l . add ( provider ) ; } this . providers = l . to array ( new module script provider [ l . size ( ) ] ) ; }	creates a new multiplexing module script provider tht gathers the specified providers.
private void insert snapshot ( final c snapshot ) { final c selection = new c ( snapshot , m state index ) ; for ( final navi node node : snapshot . get selection ( ) ) { selection . add ( new c ( node ) ) ; } m state index ++ ; m model . insert node into ( selection , ( c ) m model . get root ( ) , num ) ; }	adds a new selection state to the history chooser .
public final long decrement and get ( ) { for ( ; ; ) { long current = get ( ) ; long next = current - num ; if ( compare and set ( current , next ) ) return next ; } }	atomically decrements by one the current value .
private static boolean is segment expression ( final string value ) { return ( value . ends with ( str ) && is segment ( value . substring ( num , value . length ( ) - num ) ) ) ; }	this is needed to identify if a particular expression is a segment register .
public string to string ( ) { return string . format ( str , value ) ; }	return a hex representation of the byte .
@ override public resource create relative ( string relative path ) throws url { if ( relative path . starts with ( str ) ) { relative path = relative path . substring ( num ) ; } return new url resource ( new url ( this . url , relative path ) ) ; }	this implementation creates a urlresource , applying the given path relative to the path of the underlying url of this resource descriptor .
private void draw chunk ( image image , graphics g , boolean stretch , int dx1 , int dy1 , int dx2 , int dy2 , int sx1 , int sy1 , int sx2 , int sy2 , boolean x direction ) { if ( dx2 - dx1 <= num || dy2 - dy1 <= num || sx2 - sx1 <= num || sy2 - sy1 <= num ) { return ; } if ( stretch ) { g . draw image ( image , dx1 , dy1 , dx2 , dy2 , sx1 , sy1 , sx2 , sy2 , null ) ; } else { int x size = sx2 - sx1 ; int y size = sy2 - sy1 ; int delta x ; int delta y ; if ( x direction ) { delta x = x size ; delta y = num ; } else { delta x = num ; delta y = y size ; } while ( dx1 < dx2 && dy1 < dy2 ) { int new d = math . min ( dx2 , dx1 + x size ) ; int new d = math . min ( dy2 , dy1 + y size ) ; g . draw image ( image , dx1 , dy1 , new d , new d , sx1 , sy1 , sx1 + new d - dx1 , sy1 + new d - dy1 , null ) ; dx1 += delta x ; dy1 += delta y ; } } }	draws a portion of an image , stretched or tiled .
public void test cargo daemon welcome page ( ) throws exception { ping utils . assert ping true ( str , str , cargo daemon browser test . daemon url , logger ) ; }	test the daemon welcome page .
public static document jsoup2 dom ( org . jsoup . nodes . document jsoup document ) { document document = null ; try { document builder factory doc builder factory = document builder factory . new instance ( ) ; document builder doc builder = doc builder factory . new document builder ( ) ; document = doc builder . new document ( ) ; map < string , string > ns map = new hash map < string , string > ( ) ; create dom ( jsoup document , document , document , ns map ) ; } catch ( parser configuration exception pce ) { throw new runtime exception ( pce ) ; } return document ; }	returns a w3c dom that exposes the same content as the supplied jsoup document into a w3c dom .
protected void assert business object data ( integer expected data version , business object data actual business object data ) { assert business object data ( expected data version , get test attributes ( ) , get test business object data parents ( ) , actual business object data ) ; }	validates actualbusinessobjectdata contents against specified arguments and expected ( hard coded ) test values .
private static kdb group deserialize group ( kdb group last group , data input data input ) throws io { int field type ; kdb group group = new kdb group ( ) ; while ( ( field type = data input . read unsigned short ( ) ) != num ) { switch ( field type ) { case num : read ext data ( data input ) ; break ; case num : uuid uuid = new uuid ( num , read int ( data input ) ) ; group . set uuid ( uuid ) ; break ; case num : group . set name ( read string ( data input ) ) ; break ; case num : group . set creation time ( read date ( data input ) ) ; break ; case num : group . set last modification time ( read date ( data input ) ) ; break ; case num : group . set last access time ( read date ( data input ) ) ; break ; case num : group . set expiry time ( read date ( data input ) ) ; break ; case num : group . set icon ( new kdb icon ( read int ( data input ) ) ) ; break ; case num : int level = read short ( data input ) ; group . set parent ( compute parent group ( last group , level ) ) ; break ; case num : group . set flags ( read int ( data input ) ) ; break ; default : throw new illegal state exception ( str ) ; } } data input . read int ( ) ; return group ; }	deserialize a kdbgroup from a data source and attach it to the group structure of a database.
public int last index of ( string string ) { return last index of ( string , length ( ) ) ; }	searches in this string for the last index of the specified string.
public builder with trust store password ( string trust store password ) { properties . set property ( netty options . ssl trust store password , assert . not null ( trust store password , str ) ) ; return this ; }	sets the ssl trust store password .
private void send tap event ( bit set bitset , shift shift , boolean decision ) { if ( m symbol event tap != null ) { symbol event event = new symbol event ( bitset . get ( num , m symbol length ) , m symbol length , decision , shift ) ; m symbol event tap . receive ( event ) ; } }	sends instrumentation tap event to all registered listeners.
public final void add required imports ( set < declared type name > imports ) { imports . add ( type constants . property ) ; imports . add ( type constants . values storage ) ; imports . add ( get model superclass ( ) ) ; for ( property generator generator : property generators ) { generator . register required imports ( imports ) ; } add model specific imports ( imports ) ; plugin bundle . add required imports ( imports ) ; }	adds imports required by this model spec to the given accumulator set.
public void validate business object data availability ( business object data availability request request , list < business object data status > expected available statuses , list < business object data status > expected not available statuses , business object data availability actual business object data availability ) { assert not null ( actual business object data availability ) ; assert equals ( request . get namespace ( ) , actual business object data availability . get namespace ( ) ) ; assert equals ( request . get business object definition name ( ) , actual business object data availability . get business object definition name ( ) ) ; assert equals ( request . get business object format usage ( ) , actual business object data availability . get business object format usage ( ) ) ; assert equals ( request . get business object format file type ( ) , actual business object data availability . get business object format file type ( ) ) ; assert equals ( request . get business object format version ( ) , actual business object data availability . get business object format version ( ) ) ; assert equals ( request . get partition value filter ( ) , actual business object data availability . get partition value filter ( ) ) ; assert equals ( request . get business object data version ( ) , actual business object data availability . get business object data version ( ) ) ; assert equals ( request . get storage name ( ) , actual business object data availability . get storage name ( ) ) ; assert equals ( expected available statuses , actual business object data availability . get available statuses ( ) ) ; assert equals ( expected not available statuses , actual business object data availability . get not available statuses ( ) ) ; }	validates business object data availability against specified arguments and expected ( hard coded ) test values .
public void unlock ui ( ) { generate complete ( ) ; }	unlock user interface . called from the worker when processing is done.
public void remove ( t object ) { int pos ; synchronized ( m lock ) { pos = get position ( object ) ; if ( pos == - num ) return ; m objects . remove ( pos ) ; } if ( m notify on change ) notify item removed ( pos ) ; }	removes the specified object from the array .
private void pre buffer access ( ) { most recent use = system . current time millis ( ) ; lock . lock ( ) ; try { while ( flush pending ) { flush complete . await ( ) ; } ensure buffer available ( this ) ; ensure loaded ( ) ; buffer use count ++ ; } catch ( exception e ) { throw throwables . propagate ( e ) ; } finally { lock . unlock ( ) ; } }	called prior to reading from or writing to the block.
private void add method ( mapped class clazz , string [ ] parts ) { string original = str ; string new name = str ; string desc = str ; if ( parts . length == num ) { original = parts [ num ] ; new name = parts [ num ] ; desc = parts [ num ] ; } else if ( parts . length == num ) { original = parts [ num ] ; new name = parts [ num ] ; desc = parts [ num ] ; } else { return ; } if ( desc . contains ( str ) ) { desc = desc . replace ( str , str ) ; } mapped member mm = new mapped member ( clazz , find method ( clazz . get node ( ) , original , desc ) , - num , desc , original ) ; mm . set new name ( new name ) ; clazz . add method ( mm ) ; }	add a method to the given class .
public synchronized void animate pan and zoom to ( final d p , double scale , long duration ) { d pp = new d . double ( ) ; m itransform . transform ( p , pp ) ; animate pan and zoom to abs ( pp , scale , duration ) ; }	animate a pan to the specified location in screen ( pixel ) co - ordinates and zoom to the given scale using the provided duration .
private int modify all contacts ( iterator < string > contacts iter ) { int total contacts modified = num ; while ( contacts iter . has next ( ) ) total contacts modified += modify contact ( contacts iter . next ( ) , contacts iter . next ( ) ) ; return total contacts modified ; }	synchronously modify all contacts designated by the iterator .
public console print stream ( java . io . output stream out ) { super ( out , bool ) ; }	create a consoleprintstream on the specified outputstream , usually system.
void add changes recursively ( server server , list < material revision > out changes ) throws url , io { if ( ! changed ) { return ; } if ( ! is pipeline ( ) ) { if ( ! out changes . contains ( this ) ) out changes . add ( this ) ; } else { for ( modification m : modifications ) { matcher matcher = pipeline revision pattern . matcher ( m . revision ) ; if ( matcher . matches ( ) ) { string pipeline name = matcher . group ( num ) ; int pipeline counter = integer . parse int ( matcher . group ( num ) ) ; pipeline pipeline = server . get pipeline instance ( pipeline name , pipeline counter ) ; pipeline . add changes recursively ( server , out changes ) ; } else { log . error ( str + m . revision ) ; } } } }	collect all changed materialrevision objects , walking changed " pipeline " objects recursively instead of including them directly .
public boolean add member ( principal p ) { return bool ; }	adds the specified member to the group .
private parsed current parsed ( ) { return parsed . get ( parsed . size ( ) - num ) ; }	gets the currently active temporal objects .
public void commit ( ) { active values . clear ( ) ; active values . add all ( pending values ) ; }	makes the pending values active .
public void fire property change ( string property name , double old value , double new value ) { if ( change support == null || old value == new value ) { return ; } fire property change ( property name , double . value of ( old value ) , double . value of ( new value ) ) ; }	reports a bound property change .
protected list < i > update cache ( i parent , final isvn [ ] statuses ) throws core exception { final list < i > result = new array list < i > ( ) ; if ( statuses != null ) { for ( isvn status : statuses ) { i resource = svn . get resource for ( parent , status ) ; result . add ( update cache ( resource , status ) ) ; } } return result ; }	update the cache using the given statuses.
private boolean finish line ( boolean saw newline ) throws io { handle line ( line . to string ( ) , saw return ? ( saw newline ? str : str ) : ( saw newline ? str : str ) ) ; line = new string builder ( ) ; saw return = bool ; return saw newline ; }	called when a line is complete .
public static set < string > put set into map ( string key , map < string , set < string > > map , string value ) { set < string > set = new hash set < string > ( ) ; set . add ( value ) ; map . put ( key , set ) ; return set ; }	returns set of string.
static string to c ( string identifier ) { return identifier . replace ( str , str ) ; }	get the c + + representation of this identifier .
public static select manager jni create ( ) { try { if ( ! is enabled ( ) ) { return null ; } select manager jni poll manager = jni select manager . get ( ) ; if ( poll manager == null ) { poll manager = new select manager jni ( ) ; if ( poll manager . start ( ) ) { jni select manager . set ( poll manager ) ; } } return jni select manager . get ( ) ; } catch ( config exception e ) { log . finer ( e . to string ( ) ) ; } catch ( throwable e ) { log . log ( level . finer , e . to string ( ) , e ) ; } return null ; }	returns a jni select manager .
public listenable socket channel ( socket channel channel , executor executor , async selector selector thread ) throws io { logger . debug ( str , channel ) ; if ( channel == null || executor == null ) throw new illegal argument exception ( ) ; if ( channel . is blocking ( ) ) throw new illegal argument exception ( str ) ; this . channel = channel ; this . executor = executor ; this . selector = selector thread ; selector . register ( channel , num , sel listener ) ; }	create async - socket wrapper over given socket channel , given listener handling thread , and given selector thread .
public static routing key create ( object object ) { return new routing key ( object . hash code ( ) ) ; }	creates a routingkey by invoking hashcode on a given object.
private boolean run config ( ) { if ( line separator == null ) { logger . error ( str ) ; return bool ; } if ( category identifers == null ) { logger . error ( str ) ; return bool ; } if ( language identifers == null ) { logger . error ( str ) ; return bool ; } if ( image identifers == null ) { logger . error ( str ) ; return bool ; } if ( template parser == null ) { logger . error ( str ) ; return bool ; } return bool ; }	checks if the configuration is runnable .
private void connect ( inet address an addr , int a port , int timeout ) throws io { inet address normal addr = an addr . is any local address ( ) ? inet address . get local host ( ) : an addr ; if ( streaming && using socks ( ) ) { socks connect ( an addr , a port , num ) ; } else { io bridge . connect ( fd , normal addr , a port , timeout ) ; } super . address = normal addr ; super . port = a port ; }	connects this socket to the specified remote host address / port .
public double convert walk distance to walk time ( double walk distance ) { double walk time = null ; switch ( study area code ) { case num : double a = num ; double b = num ; double c = - num ; double d = num ; double wt = a + b * walk distance + c * math . pow ( walk distance , num ) + d * math . pow ( walk distance , num ) ; walk time = wt * num ; break ; default : break ; } return walk time ; }	converts a given walking distance value ( in meters ) into a walking time value ( in sec ) .
@ override protected statement class block ( run notifier notifier ) { return children invoker ( notifier ) ; }	implements behavior from : org.
public static boolean [ ] convert string to boolean arr ( string no dictionary col mapping ) { string [ ] splitted value = null != no dictionary col mapping ? no dictionary col mapping . split ( carbon common constants . coma spc character ) : new string [ num ] ; boolean [ ] no dictionary mapping = new boolean [ splitted value . length ] ; int index = num ; for ( string str : splitted value ) { no dictionary mapping [ index ++ ] = boolean . parse boolean ( str ) ; } return no dictionary mapping ; }	this will convert string to boolean [ ] .
@ deprecated protected void insert at boundry ( j editor , html doc , int offset , element insert element , string html , html . tag parent tag , html . tag add tag ) { element e ; element common parent ; boolean is first = ( offset == num ) ; if ( offset > num || insert element == null ) { e = doc . get default root element ( ) ; while ( e != null && e . get start offset ( ) != offset && ! e . is leaf ( ) ) { e = e . get element ( e . get element index ( offset ) ) ; } common parent = ( e != null ) ? e . get parent element ( ) : null ; } else { common parent = insert element ; } if ( common parent != null ) { int pops = num ; int pushes = num ; if ( is first && insert element != null ) { e = common parent ; while ( e != null && ! e . is leaf ( ) ) { e = e . get element ( e . get element index ( offset ) ) ; pops ++ ; } } else { e = common parent ; offset -- ; while ( e != null && ! e . is leaf ( ) ) { e = e . get element ( e . get element index ( offset ) ) ; pops ++ ; } e = common parent ; offset ++ ; while ( e != null && e != insert element ) { e = e . get element ( e . get element index ( offset ) ) ; pushes ++ ; } } pops = math . max ( num , pops - num ) ; insert html ( editor , doc , offset , html , pops , pushes , add tag ) ; } }	this is invoked when inserting at a boundary.
protected generic container deserialize with schema and version ( string topic , boolean is key , byte [ ] payload ) throws serialization exception { return ( generic container ) deserialize ( bool , topic , is key , payload , null ) ; }	deserializes the payload and includes schema information , with version information from the schema registry embedded in the schema .
public static boolean am fetcher ( ) { return is fetcher ( thread . current thread ( ) ) ; }	checks to see if the current thread is one of the imagefetchers .
public static int read ints ( final file f , final int file offset , final int file end , final common index a , final long offset , final long addend ) throws io { final int length = ( file end - file offset ) * num ; final byte [ ] b = new byte [ length ] ; try ( input stream stream = new file input stream ( f ) ) { int remaining = file offset * num ; long skipped ; while ( remaining > num && ( skipped = file utils . stream skip ( stream , remaining ) ) > num ) { remaining -= ( int ) skipped ; } if ( remaining > num ) { throw new io ( ) ; } int so far = num ; int read ; while ( so far < length && ( read = stream . read ( b , so far , length - so far ) ) > num ) { so far += read ; } if ( so far < length ) { throw new io ( ) ; } } for ( int i = num ; i < b . length ; i += num ) { a . set ( offset + i / num , io . bytes to int big endian ( b , i ) + addend ) ; } return b . length / num ; }	read an array of longs from a file .
thread new started thread ( runnable runnable ) { thread t = new thread ( runnable ) ; t . set daemon ( bool ) ; t . start ( ) ; return t ; }	returns a new started daemon thread running the given runnable .
protected void connection up ( ) { if ( connected status != null ) { connected status . set text ( status connected ) ; connected status . set background ( color . green ) ; } }	callback for the netmapreader to let it provide the connector with connection status .
public r params to json entity ( ) { try { m http entity = create json streamer entity ( null ) ; } catch ( io e ) { e . print stack trace ( ) ; } return ( r ) this ; }	convert params to json entity .
public static void debug ( final throwable throwable ) { final string writer errors = new string writer ( ) ; throwable . print stack trace ( new print writer ( errors ) ) ; debug logger . accept ( errors . to string ( ) ) ; }	logs the stacktrace of the throwable to the debug logger .
bleach composer ( color c ) { int color = c . get rgb ( ) ; int [ ] components = new int [ num ] ; split rgb ( color , components ) ; red = math . max ( num , components [ red ] ) ; green = math . max ( num , components [ green ] ) ; blue = math . max ( num , components [ blue ] ) ; }	create a new bleachcomposer for a color .
public boolean applies to ( string line , string route ) { if ( ! lines . is empty ( ) && ! lines . contains ( line ) ) return bool ; if ( ! routes . is empty ( ) && ! routes . contains ( route ) ) return bool ; return bool ; }	determines whether this pricing policy applies to a certain type of vehicle.
private void output warehouses ( properties ctx , print writer out , int org id , int warehouse id , boolean include any ) { out . println ( str + org id + str ) ; if ( include any ) { out . println ( str ) ; if ( warehouse id == num ) out . println ( str ) ; out . println ( str ) ; } for ( m warehouse : m . get for org ( ctx , org id ) ) { out . print ( str + warehouse . get m id ( ) + str ) ; if ( warehouse id == warehouse . get m id ( ) ) out . print ( str ) ; out . println ( str + util . mask html ( warehouse . get name ( ) ) + str ) ; } out . println ( str ) ; }	output xml list of warehouses.
private static void usage ( string s ) { err . println ( str + s + str ) ; err . println ( str ) ; err . println ( str ) ; err . println ( str ) ; err . println ( str ) ; err . println ( str ) ; system . exit ( num ) ; }	prints usage information about this program.
static public unique string resolve synonym ( unique string name ) { operator n = ( operator ) definition table . get ( name ) ; if ( n == null ) return name ; else return n . get identifier ( ) ; }	resolvesynonym has the property that * resolvesynonym ( a ) = resolvesynonym ( b ) * iff either a = b or a and b are synonyms ( like ( + ) and \ oplus ).
public static void start ( string [ ] args ) { started as service = bool ; start cmr ( ) ; }	start function . needed by procrun .
public static boolean recycle ( file file ) { if ( os . is windows ( ) && is loaded ) { string path = null ; try { path = file . get canonical path ( ) ; } catch ( io err ) { log . error ( str , err ) ; path = file . get absolute path ( ) ; } return recycle native ( path ) ; } else { return bool ; } }	moves a file to the platform - specific trash can or recycle bin .
public void update ( int from , int to ) { change . source < ? > source = id range change source . for items ( from , to , num ) ; executor service executor service = new thread pool executor ( num , num , num , time unit . seconds , new linked blocking queue < runnable > ( ) ) ; wikibase uris uris = new wikibase uris ( str ) ; update < ? > update = new update < > ( source , wikibase repository , rdf repository ( ) , munger , executor service , num , uris , bool ) ; update . run ( ) ; executor service . shutdown ( ) ; }	update all ids from from to to .
public void write ( byte [ ] b , int o , int len ) { while ( len > num ) { int n = len <= avail len ? len : avail len ; system . arraycopy ( b , o , buf , offset , n ) ; increment offset ( n ) ; len -= n ; o += n ; } }	this should rarely be used , the normal way ( to avoid double copying ) is to get the buffer and write directly to it.
public void write update ( log output stream out , object value ) throws exception { marshal output stream s = new marshal output stream ( out ) ; s . write object ( value ) ; s . flush ( ) ; }	writes the representation ( a serializable object ) of an update to a stream.
public static symbol get built in symbol ( string str , boolean pcal mode ) { symbol sym ; if ( pcal mode ) { sym = ( symbol ) pcal built in hash table . get ( str ) ; } else { sym = ( symbol ) built in hash table . get ( str ) ; } if ( sym == null || ( sym . pcal && ! pcal mode ) ) { return null ; } return sym ; }	returns the built - in symbol with string str.
@ override public data table sample ( int new size ) { int row count = get row number ( ) ; if ( row count <= new size ) { return this ; } int [ ] sampled selected indices = new int [ row count ] ; for ( int i = num ; i < row count ; ++ i ) { sampled selected indices [ i ] = i ; } random rng = new random ( num ) ; int swap idx ; int tmp value ; for ( int i = num ; i < row count ; ++ i ) { swap idx = rng . next int ( row count ) ; tmp value = sampled selected indices [ swap idx ] ; sampled selected indices [ swap idx ] = sampled selected indices [ i ] ; sampled selected indices [ i ] = tmp value ; } data table view sampled data table = new data table view ( this ) ; vector < integer > sampled selected indices vector = new vector < integer > ( new size ) ; for ( int i = num ; i < new size ; ++ i ) { sampled selected indices vector . add ( sampled selected indices [ i ] ) ; } sampled data table . set selected indices ( sampled selected indices vector ) ; return new sorted data table view ( sampled data table , sort provider ) ; }	performs a simple sampling without replacement.
public void update configuration ( @ not null configuration configuration ) { my configuration = configuration ; invalidate graphics renderer ( ) ; }	updates the current configuration.
protected void insert ( object [ ] row ) throws sql { string key = get key ( row ) ; int hash = key . hash code ( ) ; prep insert row . set int ( num , hash ) ; prep insert row . set int ( num , index . id ) ; prep insert row . set string ( num , key ) ; prep insert row . execute ( ) ; result set rs = prep insert row . get generated keys ( ) ; rs . next ( ) ; int row id = rs . get int ( num ) ; prep insert map . set int ( num , row id ) ; int [ ] word ids = get word ids ( row ) ; for ( int id : word ids ) { prep insert map . set int ( num , id ) ; prep insert map . execute ( ) ; } }	add a row to the index .
public pair < pair < string , string [ ] > , list < string > > rewrite ( list < string > results ) { string command id = null ; string [ ] args = null ; list < string > rewritten results = new array list < > ( ) ; for ( string result : results ) { triple triple = rewrite ( result ) ; rewritten results . add ( triple . m str ) ; command id = triple . m id ; args = triple . m args ; } return new pair < > ( new pair < > ( command id , args ) , rewritten results ) ; }	rewrites and returns the given results . todo : improve this.
public reliable log ( string dir path , log handler handler ) throws io { dir = new file ( dir path ) ; if ( ! ( dir . exists ( ) ? dir . is directory ( ) : dir . mkdirs ( ) ) ) { throw new log exception ( str + dir path ) ; } this . handler = handler ; try { data input stream in = new data input stream ( new file input stream ( f name ( version file ) ) ) ; try { version = in . read int ( ) ; } finally { in . close ( ) ; } } catch ( io ex ) { write version file ( ) ; } if ( version < num ) { throw new log exception ( str ) ; } }	creates a reliablelog to handle snapshots and logging in a stable storage directory , and sets up to recover any existing data from the stable storage directory.
public static long time taken string to int ( string time taken string ) { raptor string tokenizer tok = new raptor string tokenizer ( time taken string , str , bool ) ; int minutes = integer . parse int ( tok . next token ( ) ) ; int seconds = integer . parse int ( tok . next token ( ) ) ; int millis = integer . parse int ( tok . next token ( ) ) ; return ( minutes * num + seconds ) * num + millis ; }	parses a string in ( 0 : 00.
private as build unauthenticated attributes ( byte [ ] time stamp token ) throws io { if ( time stamp token == null ) return null ; string id time stamp token = str ; as tempstream = new as ( new byte array input stream ( time stamp token ) ) ; as unauth attributes = new as ( ) ; as v = new as ( ) ; v . add ( new as ( id time stamp token ) ) ; as seq = ( as ) tempstream . read object ( ) ; v . add ( new der ( seq ) ) ; unauth attributes . add ( new der ( v ) ) ; return unauth attributes ; }	added by aiken sam , 2006 - 11 - 15 , modifed by martin brunecky 07 / 12 / 2007 to start with the timestamptoken ( signeddata 1.
public boolean remove entry ( t e ) { if ( e == null ) return bool ; boolean removed = m y . remove ( e ) ; if ( removed ) { float val = e . get val ( ) ; m y -= val ; calc min max ( ) ; } return removed ; }	removes an entry from the datasets entries array.
@ override public void on item click ( adapter view < ? > parent , view view , int position , long id ) { check box enable component checkbox = ( check box ) view . find view by id ( r . id . enable component checkbox ) ; enable component checkbox . perform click ( ) ; }	called when an entry of item is clicked .
public void test long conversion and ordering ( ) throws exception { bytes ref previous = null ; bytes ref current = new bytes ref ( new byte [ long . bytes ] ) ; for ( long value = - num ; value < num ; value ++ ) { numeric utils . long to sortable bytes ( value , current . bytes , current . offset ) ; if ( previous == null ) { previous = new bytes ref ( new byte [ long . bytes ] ) ; } else { assert true ( str , previous . compare to ( current ) < num ) ; } assert equals ( str , value , numeric utils . sortable bytes to long ( current . bytes , current . offset ) ) ; system . arraycopy ( current . bytes , current . offset , previous . bytes , previous . offset , current . length ) ; } }	generate a series of encoded longs , each numerical one bigger than the one before.
private static boolean is payment type recurse ( generic value payment type , string input type id ) throws generic entity exception { string parent type id = payment type . get string ( str ) ; if ( parent type id == null ) { return bool ; } if ( parent type id . equals ( input type id ) ) { return bool ; } return is payment type recurse ( payment type . get related one ( str , bool ) , input type id ) ; }	recurses up payment type tree via parenttypeid to see if input payment type id is in tree .
public static double pdf ( double x , double k , double theta , double shift ) { if ( x <= shift || x == double . positive infinity ) { return num ; } x = ( x - shift ) * theta ; final double ex = math . exp ( x ) ; return ex < double . positive infinity ? math . exp ( k * x - ex - gamma distribution . log gamma ( k ) ) * theta : num ; }	expgamma distribution pdf ( with 0 . 0 for x & lt ; 0 ).
public address rmul ( final object rhs ) { return new address ( m value . multiply ( get big integer ( rhs ) ) ) ; }	used to support reverse mul operations on addresses in python scripts .
public rule name rule name ( ) { string label str = to string ( ) ; int colon location = label str . last index of ( str ) ; int rule name start = colon location + num ; string rule name str = label str . substring ( rule name start ) ; return rule name . create ( rule name str ) ; }	extract the rule name from a label.
public void exception ( throwable e ) { final string msg = e . get message ( ) ; log ( level . severe , msg != null ? msg : str , e ) ; }	log an exception at the ' severe ' level .
public static boolean contains modified message ( tls context tls context ) { return ( get modified message position ( tls context ) != - num ) ; }	returns true in case there is a message with a modification issued by our peer.
public void remove ( history reference href ) { synchronized ( href list ) { int index = href list . index of ( href ) ; if ( index >= num ) { href list . remove ( index ) ; fire table rows deleted ( index , index ) ; } } }	removes the scan result for a particular uri and method.
private static boolean is assignable from ( type from , parameterized type to , map < string , type > type var map ) { if ( from == null ) { return bool ; } if ( to . equals ( from ) ) { return bool ; } class < ? > clazz = gson types . get raw type ( from ) ; parameterized type ptype = null ; if ( from instanceof parameterized type ) { ptype = ( parameterized type ) from ; } if ( ptype != null ) { type [ ] t args = ptype . get actual type arguments ( ) ; type variable < ? > [ ] t params = clazz . get type parameters ( ) ; for ( int i = num ; i < t args . length ; i ++ ) { type arg = t args [ i ] ; type variable < ? > var = t params [ i ] ; while ( arg instanceof type variable < ? > ) { type variable < ? > v = ( type variable < ? > ) arg ; arg = type var map . get ( v . get name ( ) ) ; } type var map . put ( var . get name ( ) , arg ) ; } if ( type equals ( ptype , to , type var map ) ) { return bool ; } } for ( type itype : clazz . get generic interfaces ( ) ) { if ( is assignable from ( itype , to , new hash map < string , type > ( type var map ) ) ) { return bool ; } } type s type = clazz . get generic superclass ( ) ; return is assignable from ( s type , to , new hash map < string , type > ( type var map ) ) ; }	private recursive helper function to actually do the type - safe checking of assignability .
public static int prefix coded to int ( final bytes ref val ) { int sortable bits = num ; for ( int i = val . offset + num , limit = val . offset + val . length ; i < limit ; i ++ ) { sortable bits <<= num ; final byte b = val . bytes [ i ] ; if ( b < num ) { throw new number format exception ( str + integer . to hex string ( b & num ) + str + ( i - val . offset ) + str ) ; } sortable bits |= b ; } return ( sortable bits << get prefix coded int shift ( val ) ) ^ num ; }	returns an int from prefixcoded bytes.
@ nullable public static string merge xml ( @ not null rendering context context , string source xml , string target xml , file target file ) { boolean ok ; string file name = target file . get name ( ) ; string contents ; if ( file name . equals ( sdk constants . fn android manifest xml ) ) { document current document = xml utils . parse document silently ( target xml , bool ) ; assert current document != null : target xml + str ; document fragment = xml utils . parse document silently ( source xml , bool ) ; assert fragment != null : source xml + str ; contents = merge manifest ( target file , target xml , source xml ) ; ok = contents != null ; } else { string parent folder name = target file . get parent file ( ) . get name ( ) ; resource folder type folder type = resource folder type . get folder type ( parent folder name ) ; contents = merge resource file ( context , target xml , source xml , file name , folder type ) ; ok = contents != null ; } if ( ! ok ) { contents = wrap with merge conflict ( target xml , source xml ) ; context . get warnings ( ) . add ( string . format ( str , target file . get name ( ) ) ) ; } return contents ; }	merges sourcexml into targetxml / targetfile ( targetxml is the contents of targetfile ).
synchronized pair < string , map < variant set type , list < variant > > > next set ( ) throws io { final pair < string , map < variant set type , list < variant > > > set = m variant set . next set ( ) ; if ( set == null ) { return null ; } final string name = set . get a ( ) ; synchronized ( m names ) { m names . add ( name ) ; } return set ; }	loads a set from the underlying variant set with synchronization .
public static string builder left shift ( string builder self , object value ) { self . append ( value ) ; return self ; }	overloads the left shift operator to provide syntactic sugar for appending to a stringbuilder .
public boolean parse kml ( file file ) { m local file = file ; log . d ( bonus pack helper . log tag , str + m local file . get absolute path ( ) ) ; input stream stream ; boolean ok ; try { stream = new buffered input stream ( new file input stream ( m local file ) ) ; ok = parse kml ( stream , null ) ; stream . close ( ) ; } catch ( exception e ) { e . print stack trace ( ) ; ok = bool ; } return ok ; }	parse a kml document from a file , to build the kml structure .
private boolean is redundant ( coordinate pt ) { if ( pt list . size ( ) < num ) return bool ; coordinate last pt = ( coordinate ) pt list . get ( pt list . size ( ) - num ) ; double pt dist = pt . distance ( last pt ) ; if ( pt dist < minimim vertex distance ) return bool ; return bool ; }	tests whether the given point is redundant relative to the previous point in the list ( up to tolerance ) .
private void write esc ut ( string s , int start , int length , boolean is att val ) throws sax { string sub string = s . substring ( start , start + length ) ; write ( string escape utils . escape html4 ( sub string ) ) ; }	write an array of data characters with escaping .
public void run test ( ) throws throwable { document doc ; node list element list ; node name node ; character data child ; string child data ; doc = ( document ) load ( str , bool ) ; element list = doc . get elements by tag name ( str ) ; name node = element list . item ( num ) ; child = ( character data ) name node . get first child ( ) ; child . append data ( str ) ; child data = child . get data ( ) ; assert equals ( str , str , child data ) ; }	runs the test case .
public void remove ( string key ) { iterator < pair < string , array list < string > > > it = store . iterator ( ) ; while ( it . has next ( ) ) { string this key = it . next ( ) . first ; if ( key . equals ( this key ) ) { it . remove ( ) ; break ; } } }	remove a given key from the file .
public string to string ( ) { string buffer s = new string buffer ( ) ; boolean colon = bool ; s . append ( str ) ; for ( type node type node : type node list ) { if ( colon ) { s . append ( str ) ; } else { colon = bool ; } s . append ( type node ) ; } s . append ( str ) ; return s . to string ( ) ; }	returns a string representation of this object.
public final assert subscriber < t > await ( ) { if ( cdl . get count ( ) == num ) { return this ; } try { cdl . await ( ) ; } catch ( interrupted exception ex ) { throw new assertion error ( str , ex ) ; } return this ; }	blocking method that waits until a complete successfully or error signal is received .
public static float compute discard scale ( float amount , float range , boolean from click ) { if ( math . abs ( amount ) < num ) return num ; float t = amount / range ; float end scale = from click ? discard end scale click : discard end scale swipe ; return math utils . interpolate ( num , end scale , math . abs ( t ) ) ; }	computes the scale of the tab based on its discard status .
public boolean finish ( ) { if ( ! started ) return bool ; boolean ok = bool ; started = bool ; try { out . write ( num ) ; out . flush ( ) ; if ( close stream ) { out . close ( ) ; } } catch ( io e ) { ok = bool ; } return ok ; }	flushes any pending data and closes output file.
public d ( j parent , string title , x509 certificate cert ) throws crypto exception { super ( parent , title , dialog . modality type . document modal ) ; this . cert = cert ; init components ( ) ; }	creates a new dviewcertcsrpem dialog .
public static byte string value of utf8 ( final char sequence s ) { if ( s . length ( ) == num ) { return empty ; } return wrap ( static utils . get bytes ( s ) ) ; }	returns a byte string containing the utf - 8 encoded bytes of the provided char sequence .
public advanced state map . builder ignore ( i < ? > ... properties ) { collections . add all ( this . ignored , properties ) ; return this ; }	add properties that will not be used to compute all possible states of a block , used for block rendering to ignore some property that does not alter block ' s appearance.
private static void close safe ( closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( io ignored ) { } } }	close the given closeable object ( stream ) in a safe way : check if it is null and catch - log exception thrown .
@ override public double java2 d ( double java2 d , d plot area , rectangle edge edge ) { range range = get range ( ) ; double axis min = switched log10 ( range . get lower bound ( ) ) ; double axis max = switched log10 ( range . get upper bound ( ) ) ; double plot min = num ; double plot max = num ; if ( rectangle edge . is top or bottom ( edge ) ) { plot min = plot area . get x ( ) ; plot max = plot area . get max x ( ) ; } else if ( rectangle edge . is left or right ( edge ) ) { plot min = plot area . get max y ( ) ; plot max = plot area . get min y ( ) ; } if ( is inverted ( ) ) { return switched pow10 ( axis max - ( ( java2 d - plot min ) / ( plot max - plot min ) ) * ( axis max - axis min ) ) ; } else { return switched pow10 ( axis min + ( ( java2 d - plot min ) / ( plot max - plot min ) ) * ( axis max - axis min ) ) ; } }	converts a coordinate in java2d space to the corresponding data value , assuming that the axis runs along one edge of the specified plotarea .
private void do test ( step normalizer mode mode , step normalizer bounds bounds , double [ ] expected , boolean reverse ) throws math illegal argument exception , math illegal state exception { ode integ = new gragg bulirsch stoer integrator ( num , num , num , num ) ; integ . add step handler ( new step normalizer ( num , this , mode , bounds ) ) ; double [ ] y = { num } ; double start = reverse ? get end ( ) : get start ( ) ; double end = reverse ? get start ( ) : get end ( ) ; output = new array list < double > ( ) ; integ . integrate ( this , new ode ( start , y ) , end ) ; double [ ] actual = new double [ output . size ( ) ] ; for ( int i = num ; i < actual . length ; i ++ ) { actual [ i ] = output . get ( i ) ; } assert . assert array equals ( expected , actual , num ) ; }	the actual step normalizer output test code , shared by all the unit tests .
public static void wait for or kill ( process self , long number of millis ) { process runner runnable = new process runner ( self ) ; thread thread = new thread ( runnable ) ; thread . start ( ) ; runnable . wait for or kill ( number of millis ) ; }	wait for the process to finish during a certain amount of time , otherwise stops the process .
public void write to ( stream output out ) throws io { out . write string ( name ) ; out . write string ( type ) ; settings . write settings to stream ( settings , out ) ; }	writes repository metadata to stream output.
public string time2 utc str ( long time ) { date date = new date ( time ) ; return ( utc date format . format ( date ) ) ; }	convert unix time to the utc format recognized by spice .
public void test url decoder ignores unnecessary charset ( ) throws exception { try { assert equals ( str , url . decode ( str , str ) ) ; } catch ( unsupported charset exception expected ) { } }	the ri looks up the charset lazily ; android looks it up eagerly.
public element remove element from registry ( element element ) { remove element from registry ( integer . to string ( element . hash code ( ) ) ) ; return ( this ) ; }	removes an element from the element registry.
public final < t > collection < t > parse array and close ( class < ? > destination collection class , class < t > destination item class ) throws io { return parse array and close ( destination collection class , destination item class , null ) ; }	parse a json array from the given json parser ( which is closed after parsing completes ) into the given destination collection .
public void test timed invoke any5 ( ) throws throwable { executor service e = new fork join pool ( num ) ; pool cleaner cleaner = null ; try { cleaner = cleaner ( e ) ; long start time = system . nano time ( ) ; list < callable < string > > l = new array list < callable < string > > ( ) ; l . add ( new string task ( ) ) ; l . add ( new string task ( ) ) ; string result = e . invoke any ( l , long delay ms , milliseconds ) ; assert same ( test string , result ) ; assert true ( millis elapsed since ( start time ) < long delay ms ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }	timed invokeany ( c ) returns result of some task in c.
public void finish ( ) throws io { close entry ( ) ; cd offset = new zip long ( written ) ; for ( int i = num ; i < entries . size ( ) ; i ++ ) { write central file header ( entries . element at ( i ) ) ; } cd length = new zip long ( written - cd offset . get value ( ) ) ; write central directory end ( ) ; offsets . clear ( ) ; entries . remove all elements ( ) ; }	finishs writing the contents and closes this as well as the underlying stream .
private calendar in utc ( calendar cal ) { calendar utc = calendar . get instance ( time zone . get time zone ( str ) ) ; utc . set time in millis ( cal . get time in millis ( ) ) ; return utc ; }	gets the calendar in utc time .
public static < t extends object & java . lang . comparable < ? super t > > t max ( collection < ? extends t > collection ) { iterator < ? extends t > it = collection . iterator ( ) ; t max = it . next ( ) ; if ( number comparator . is number ( max ) ) { return ( t ) max ( collection , number comparator . create comparator ( max . get class ( ) ) ) ; } while ( it . has next ( ) ) { t next = it . next ( ) ; if ( max . compare to ( next ) < num ) { max = next ; } } return max ; }	searches the specified collection for the maximum element .
@ suppress warnings ( str ) @ override public void on restore instance state ( parcelable state ) { if ( state instanceof bundle ) { bundle bundle = ( bundle ) state ; ui auto label ui = bundle . get parcelable ( key instance state settings ) ; if ( auto label ui != null ) { set settings ( auto label ui ) ; } reset labels counter ( ) ; list < label values > labels added = ( list < label values > ) bundle . get serializable ( key instance state labels ) ; if ( labels added != null ) { for ( int i = num ; i < labels added . size ( ) ; i ++ ) { label values label values = labels added . get ( i ) ; if ( label values . get key ( ) == - num ) { add label ( label values . get value ( ) ) ; } else { add label ( label values . get value ( ) , label values . get key ( ) ) ; } } } state = bundle . get parcelable ( key instance state general ) ; } super . on restore instance state ( state ) ; }	retrieve the state of the labels when orientation screen changed .
public static key store create empty key store ( string key store type , string provider ) { if ( key store type == null ) { key store type = str ; } key store key store ; try { if ( provider == null ) { key store = key store . get instance ( key store type ) ; } else { key store = key store . get instance ( key store type , provider ) ; } key store . load ( null , null ) ; } catch ( key store exception | certificate exception | no such algorithm exception | no such provider exception | io e ) { throw new key store access exception ( str + key store type , e ) ; } return key store ; }	creates and initializes an empty keystore using the specified keystoretype .
public boolean check for string attributes ( ) { return check for attribute type ( attribute . string ) ; }	checks for string attributes in the dataset.
public void stop ( ) { write . lock ( ) ; try { sorted . clear ( ) ; for ( route route : routes . values ( ) ) { route . destroy ( ) ; } routes . clear ( ) ; } finally { write . unlock ( ) ; } }	stops this handler , shutting down and clearing all the managed routes .
public static void clear ( ) { long lock stamp = lock . write lock ( ) ; try { id to string = new array list < > ( ) ; string to id = new hash map < > ( ) ; id to string . add ( unknown id , unknown word ) ; string to id . put ( unknown word , unknown id ) ; } finally { lock . unlock write ( lock stamp ) ; } }	clears the vocabulary and initializes it with an unknown word.
public static void decomposition ( image input img , image coarse img , image horizontal img , image vertical img , image diagonal img , filter filter g , filter filter h , int method ) { image temp img = null ; temp img = new image ( coarse img . get width ( ) , input img . get height ( ) ) ; convolute lines ( temp img , input img , filter h , method ) ; convolute rows ( coarse img , temp img , filter h , method ) ; convolute rows ( horizontal img , temp img , filter g , method ) ; temp img = new image ( vertical img . get width ( ) , input img . get height ( ) ) ; convolute lines ( temp img , input img , filter g , method ) ; convolute rows ( vertical img , temp img , filter h , method ) ; convolute rows ( diagonal img , temp img , filter g , method ) ; }	method to decompose the image.
public void log number of wallet busy listeners ( ) { log . debug ( str + wallet busy listeners . size ( ) + str ) ; }	log the number of wallet busy listeners.
protected void write stroke ( stroke stroke ) throws io { if ( stroke instanceof basic stroke ) { basic stroke ns = ( basic stroke ) stroke ; int current cap = - num , current join = - num ; float current width = - num , current limit = - num , current dash phase = - num ; float [ ] current dash array = null ; if ( ( current stroke != null ) && ( current stroke instanceof basic stroke ) ) { basic stroke cs = ( basic stroke ) current stroke ; current cap = cs . get end cap ( ) ; current join = cs . get line join ( ) ; current width = cs . get line width ( ) ; current limit = cs . get miter limit ( ) ; current dash array = cs . get dash array ( ) ; current dash phase = cs . get dash phase ( ) ; } float width = ns . get line width ( ) ; write width ( width ) ; int cap = ns . get end cap ( ) ; if ( current cap != cap ) { write cap ( cap ) ; } int join = ns . get line join ( ) ; if ( current join != join ) { write join ( join ) ; } float limit = ns . get miter limit ( ) ; if ( ( current limit != limit ) && ( limit >= num ) ) { write miter limit ( limit ) ; } if ( ns . get dash array ( ) != null ) { write dash ( ns . get dash array ( ) , ns . get dash phase ( ) ) ; } else { write dash ( new float [ num ] , ns . get dash phase ( ) ) ; } } }	writes the current stroke.
@ override public drag source context peer create drag source context peer ( drag gesture event dge ) throws d { final lightweight frame f = sun toolkit . get lightweight frame ( dge . get component ( ) ) ; if ( f != null ) { return f . create drag source context peer ( dge ) ; } return w . create drag source context peer ( dge ) ; }	create the peer for a dragsourcecontext.
public boolean generate ( projection proj ) { proj . forward ( llp1 , pt1 ) ; proj . forward ( llp2 , pt2 ) ; double dx = pt2 . x - pt1 . x ; double dy = pt2 . y - pt1 . y ; at . set to translation ( pt1 . x , pt1 . y ) ; at . rotate ( math . atan2 ( dy , dx ) - angle , num , num ) ; double sc = math . sqrt ( dx * dx + dy * dy ) ; badprojection = ( double . is na n ( sc ) || sc / distance * proj . get scale ( ) > num ) ; if ( badprojection ) debug . message ( str , str + str ) ; else { sc /= w ; at . scale ( sc , sc ) ; } return bool ; }	generate with a new projection.
public static double pdf ( double x , double lambda ) { if ( x < num ) return num ; return lambda * math . exp ( - lambda * x ) ; }	probability density function of the exponential distribution ( mean = 1 / lambda ).
public static buffered writer new writer ( path self ) throws io { return files . new buffered writer ( self , charset . default charset ( ) ) ; }	create a buffered writer for this file .
public static boolean is stdio ( string filename ) { return stdio name . equals ( filename ) ; }	returns true if the input file is the stdin / stdout indicator.
public string encrypt password ( ) { string nonce = get nonce ( ) ; string timestamp = get utc ( ) ; string before encryption = nonce + timestamp + password ; byte [ ] encrypted raw ; try { encrypted raw = sha1 ( before encryption ) ; } catch ( no such algorithm exception e ) { e . print stack trace ( ) ; return null ; } string encoded = base64 . encode base64 string ( encrypted raw ) ; return encoded ; }	returns encrypted version of given password like algorithm like in ws - usernametoken.
public string to string ( ) { string buffer result = new string buffer ( ) ; result . append ( str + utils . double to string ( m coefficient , num , num ) ) ; for ( int i = num ; i < m field names . length ; i ++ ) { result . append ( str + m field names [ i ] ) ; } result . append ( str ) ; return result . to string ( ) ; }	return a textual description of this predictor term .
public string [ ] list ( ) throws remote exception { if ( ! is running ( ) ) { throw new illegal state exception ( str ) ; } return registry . list ( ) ; }	returns an array of the names bound in the rmiregistry.
public string merge name ( string a , string b ) throws merge failed { if ( qa . both null or equals ( a , b ) ) return a ; if ( empty names . contains ( a ) && ! empty names . contains ( b ) ) return b ; if ( empty names . contains ( b ) && ! empty names . contains ( a ) ) return a ; return a ; }	merge two identifiers : - if they ' re equal , return one.
public void add ( k key , v [ ] items ) { set < v > values = map . get ( key ) ; if ( values == null ) { values = ( sorted ? new tree set < v > ( ) : new hash set < v > ( ) ) ; map . put ( key , values ) ; } values . add all ( arrays . as list ( items ) ) ; }	adds all items to the set of values associated with the key.
public static placemark create with image ( position position , image source image source ) { return new placemark ( position , placemark attributes . create with image ( image source ) ) ; }	this factory method creates a placemark and an associated placemarkattributes bundle that draws the given image centered on the supplied position .
public boolean is inactive ( ) { return ( m audio output . get last activity timestamp ( ) + audio timeout ) < system . current time millis ( ) ; }	indicates if audio output is current inactive , meaning that the audio output hasn ' t recently processed any audio packets .
public void println ( object o , boolean line ) { if ( o == null ) { ps ( str ) ; return ; } if ( o instanceof object [ ] ) { print array ( ( object [ ] ) o ) ; return ; } if ( o instanceof int [ ] ) { print array ( ( int [ ] ) o ) ; } if ( o instanceof string ) { ps ( ( string ) o , line ) ; return ; } if ( o instanceof exception ) { ps ( stack to string ( ( exception ) o ) ) ; return ; } if ( o instanceof vector ) { print vector ( ( vector ) o ) ; return ; } if ( o instanceof hashtable ) { print hashtable ( ( hashtable ) o ) ; return ; } if ( o instanceof date ) { print date ( ( date ) o ) ; return ; } if ( o instanceof calendar ) { print calendar ( ( calendar ) o ) ; return ; } ps ( o . to string ( ) , line ) ; }	description of the method.
public void add value ( i key , boolean val ) throws header card exception { add value ( key . key ( ) , val , key . comment ( ) ) ; }	add or replace a key with the given boolean value and comment .
public static list < test diagnostic line > read diagnostics jfo ( java file object to read , boolean omit empty diagnostics ) { list < test diagnostic line > lines = new array list < > ( ) ; java diagnostic reader reader = new java diagnostic reader ( to read , java comment codec ) ; while ( reader . has next ( ) ) { test diagnostic line line = reader . next ( ) ; if ( ! omit empty diagnostics || line . has diagnostics ( ) ) { lines . add ( line ) ; } } reader . close ( ) ; return lines ; }	reads diagnostic lines from the comments of a set of java file .
public static void sin and cos ( double angle , double wrapper sine , double wrapper cosine ) { if ( use jdk math ) { sine . value = strict math ? strict math . sin ( angle ) : math . sin ( angle ) ; cosine . value = strict math ? strict math . cos ( angle ) : math . cos ( angle ) ; return ; } boolean negate result ; if ( angle < num ) { angle = - angle ; negate result = bool ; } else { negate result = bool ; } if ( angle > sin cos max value for int modulo ) { angle = remainder two pi ( angle ) ; if ( angle < num ) { angle += num * math . pi ; } } int index = ( int ) ( angle * sin cos indexer + num ) ; double delta = ( angle - index * sin cos delta hi ) - index * sin cos delta lo ; index &= ( sin cos tabs size - num ) ; double index sin = sin tab [ index ] ; double index cos = cos tab [ index ] ; double result = index sin + delta * ( index cos + delta * ( - index sin * one div + delta * ( - index cos * one div + delta * index sin * one div ) ) ) ; sine . value = negate result ? - result : result ; cosine . value = index cos + delta * ( - index sin + delta * ( - index cos * one div + delta * ( index sin * one div + delta * index cos * one div ) ) ) ; }	computes sine and cosine together , at the cost of.
public float [ ] generate transformed values line ( list < ? extends entry > entries , float phase x , float phase y , int from , int to ) { final int count = ( int ) math . ceil ( ( to - from ) * phase x ) * num ; float [ ] value points = new float [ count ] ; for ( int j = num ; j < count ; j += num ) { entry e = entries . get ( j / num + from ) ; if ( e != null ) { value points [ j ] = e . get x ( ) ; value points [ j + num ] = e . get val ( ) * phase y ; } } point values to pixel ( value points ) ; return value points ; }	transforms an list of entry into a float array containing the x and y values transformed with all matrices for the linechart .
public long reset ( ) { long now ns = system . nano time ( ) ; try { return time value . nsec to m ( now ns - start ns ) ; } finally { start ns = now ns ; } }	resets and returns elapsed time in milliseconds .
public long add meeting member remind to room ( string sid , long room id , string firstname , string lastname , string email , string base url , long language id ) throws axis fault { try { long users id = session management . check session ( sid ) ; long user level = user management . get user level by id ( users id ) ; if ( auth level management . check web service level ( user level ) ) { appointment appointment = appointment dao . get appointment by room ( room id ) ; if ( appointment == null ) { return - num ; } long member id = meeting member logic . add meeting member ( firstname , lastname , str , str , appointment . get appointment id ( ) , null , email , base url , null , new boolean ( bool ) , language id , bool , str , null , null , str ) ; return member id ; } else { return - num ; } } catch ( exception err ) { log . error ( str , err ) ; throw new axis fault ( err . get message ( ) ) ; } }	add a meeting member to a certain room.
private void write object ( object output stream s ) throws io { s . default write object ( ) ; for ( e e : this ) { if ( e instanceof serializable ) { s . write object ( e ) ; } } s . write object ( null ) ; }	write the listeners to a stream .
public static boolean is system application ( package manager package manager , string package name ) { if ( package manager == null || package name == null || package name . length ( ) == num ) { return bool ; } try { application info app = package manager . get application info ( package name , num ) ; return ( app != null && ( app . flags & application info . flag system ) > num ) ; } catch ( name not found exception e ) { logger . e ( e ) ; } return bool ; }	whether packagename is system application.
private boolean is spurious ( temp cluster clus , boolean is core ) { return clus != null ? clus . is spurious ( min cl size ) : ( min cl size > num || ! is core ) ; }	spurious , also for non - materialized clusters .
public static string extract ( string s ) { string result ; result = s ; result = result . replace all ( str , str ) ; result = result . replace all ( str , str ) ; result = result . replace all ( str , str ) ; return result ; }	extracts the revision string .
protected set < resource > do find matching file system resources ( file root dir , string sub pattern ) throws io { if ( logger . is debug enabled ( ) ) { logger . debug ( str + root dir . get path ( ) + str ) ; } set < file > matching files = retrieve matching files ( root dir , sub pattern ) ; set < resource > result = new linked hash set < resource > ( matching files . size ( ) ) ; for ( file file : matching files ) { result . add ( new file system resource ( file ) ) ; } return result ; }	find all resources in the file system that match the given location pattern via the ant - style pathmatcher .
public void debug print ( string name , print stream out ) throws ade exception { if ( name != null ) { out . println ( str + name + str + get ll ( ) ) ; } if ( m point scores != null && ! m point scores . is empty ( ) ) { for ( entry < integer , double > point score : m point scores . entry set ( ) ) { out . println ( str + point score . get key ( ) + str + point score . get value ( ) ) ; } out . println ( str + - m log half ) ; } }	print out the object state for debugging purposes .
public static void write centroids to file ( clusters clusters , flag config flag config ) { ram centroids output = new ram ( flag config ) ; for ( int i = num ; i < clusters . centroids . length ; ++ i ) { centroids output . put vector ( integer . to string ( i ) , clusters . centroids [ i ] ) ; } try { vector store writer . write vectors ( str , flag config , centroids output ) ; } catch ( io e ) { e . print stack trace ( ) ; } }	utility method that writes cluster centroids to a file called " cluster_centroids.
protected association request ( association session type type ) { this ( type , null ) ; }	creates an association request message with the specified association type and " no - encryption " session.
public void add signature timestamp ( byte [ ] timestamp der ) throws exception { element unsigned properties = get first element by tag name ( document , xades element ( unsigned signature props tag ) ) ; element signature time stamp element = document . create element ( xades element ( signature timestamp tag ) ) ; string timestamp der = encode base64 ( timestamp der ) ; signature time stamp element . set text content ( timestamp der ) ; unsigned properties . insert before ( signature time stamp element , unsigned properties . get first child ( ) ) ; }	adds the signaturetimestamp element containing the base64 encoded timestamp der .
public static string hash m ( string str ) { return hash m ( str . get bytes ( ) ) ; }	returns the md5 hash of a string .
public smali class detail loader ( zip file apk file , boolean translate instructions ) { array list < zip entry > dex entries = new array list < zip entry > ( ) ; dex entries . add ( apk file . get entry ( str ) ) ; for ( int i = num ; i < num ; ++ i ) { final zip entry e = apk file . get entry ( str + i + str ) ; if ( e != null ) { dex entries . add ( e ) ; } else { break ; } } final int n = dex entries . size ( ) ; if ( n == num ) { log . err ( str ) ; } this . translate instructions = translate instructions ; this . resolver = translate instructions ? new invocation resolver ( ) : null ; final opcodes opcodes = opcodes . for api ( settings . api level ) ; try { dex files = new dex file [ n ] ; for ( int i = num ; i < n ; ++ i ) { dex files [ i ] = dex backed dex file . from input stream ( opcodes , new buffered input stream ( apk file . get input stream ( dex entries . get ( i ) ) ) ) ; } } catch ( io e ) { log . err ( str ) ; log . err ( e ) ; } }	create a loader that loads from an apk file ( could contain multiple dex files ) , optionally loading instructions.
protected void filter members ( collection < internal distributed member > mbrs , set < internal distributed member > matching members , short request type ) { set < internal distributed member > requests = get pending request i ( request type ) ; if ( ! requests . is empty ( ) ) { logger . debug ( str + requests . size ( ) + str + request type ) ; iterator < internal distributed member > itr = requests . iterator ( ) ; while ( itr . has next ( ) ) { internal distributed member member id = itr . next ( ) ; if ( mbrs . contains ( member id ) ) { test flag for removal request = bool ; matching members . add ( member id ) ; } } } }	this gets pending requests and returns the ids of any that are in the given collection.
public boolean free ( t obj ) { int top = top . get ( ) ; if ( top < free stack . length ( ) ) { boolean is free = free stack . compare and set ( top , null , obj ) ; top . compare and set ( top , top + num ) ; return is free ; } else return bool ; }	frees the object . if the free list is full , the object will be garbage collected .
public void update session management ( boolean session management ) throws security exception { check write access ( ) ; boolean has access = config web util . has access ( config , security manager . type setting ) ; if ( ! has access ) throw new security exception ( str ) ; element scope = get root element ( str ) ; scope . set attribute ( str , caster . to string ( session management , str ) ) ; }	enable or desable session management.
private static void build name line ( final i node , final zy label content content , final boolean show function information ) { final i function = node . get function ( ) ; string information string = str ; if ( function . get basic block count ( ) > num ) { final string builder builder = new string builder ( ) ; builder . append ( str ) ; builder . append ( function . get basic block count ( ) ) ; builder . append ( str ) ; if ( function . get basic block count ( ) > num ) { builder . append ( str ) ; } if ( function . get edge count ( ) > num ) { builder . append ( str ) ; builder . append ( function . get edge count ( ) ) ; builder . append ( str ) ; if ( function . get edge count ( ) > num ) { builder . append ( str ) ; } } builder . append ( str ) ; information string = builder . to string ( ) ; } final zy line content name line = new zy line content ( function . get name ( ) + information string , normal font , null ) ; content . add line content ( name line ) ; }	builds the name line of a function node .
protected void rehash ( int new capacity ) { int old capacity = set . length ; k old keys [ ] = ( k [ ] ) set ; int old vals [ ] = values ; set = new object [ new capacity ] ; arrays . fill ( set , free ) ; values = new int [ new capacity ] ; for ( int i = old capacity ; i -- > num ; ) { if ( old keys [ i ] != free && old keys [ i ] != removed ) { k o = old keys [ i ] ; int index = insertion index ( o ) ; if ( index < num ) { throw object contract violation ( set [ ( - index - num ) ] , o ) ; } set [ index ] = o ; values [ index ] = old vals [ i ] ; } } }	rehashes the map to the new capacity .
public static void connection accepted ( ) { num connections . get and increment ( ) ; }	informs system metrics of a connection accepted event .
private static void map resource ( work item resource , map < i , list < work item > > projects map , boolean check java project ) { i project = resource . get project ( ) ; if ( check java project && ! project utilities . is java project ( project ) ) { return ; } list < work item > resources = projects map . get ( project ) ; if ( resources == null ) { resources = new array list < work item > ( ) ; projects map . put ( project , resources ) ; } if ( ! contains parents ( resources , resource ) ) { resources . add ( resource ) ; } }	maps the resource into its project.
@ suppress warnings ( str ) @ json creator public static client detail response v2 from parts ( @ json property ( str ) string name , @ json property ( str ) string description , @ json property ( str ) long created at seconds , @ json property ( str ) long updated at seconds , @ json property ( str ) string created by , @ json property ( str ) string updated by , @ json property ( str ) optional < long > last seen seconds ) { return new auto value client detail response v2 ( name , description , created at seconds , updated at seconds , created by , updated by , last seen seconds ) ; }	static factory method used by jackson for deserialization.
private synchronized int activity count ( ) { return m activities . size ( ) ; }	returns the number of scheduled activities.
double [ ] create real data ( final int n ) { final random random = new random ( seed ) ; final double [ ] data = new double [ n ] ; for ( int i = num ; i < n ; i ++ ) { data [ i ] = num * random . next double ( ) - num ; } return data ; }	returns a random array of doubles.
default properties as properties ( ) { return as properties ( null ) ; }	get a copy of these configuration properties as a properties object .
public string to string ( ) { string buffer buf = new string buffer ( ) ; string indent = str ; buf . append ( indent + str + integer . to hex string ( get version ( ) ) + str ) ; buf . append ( indent + str + get ascent ( ) + str ) ; buf . append ( indent + str + get descent ( ) + str ) ; buf . append ( indent + str + get line gap ( ) + str ) ; buf . append ( indent + str + get advance width max ( ) + str ) ; buf . append ( indent + str + get min left side bearing ( ) + str ) ; buf . append ( indent + str + get min right side bearing ( ) + str ) ; buf . append ( indent + str + get x ( ) + str ) ; buf . append ( indent + str + get caret slope rise ( ) + str ) ; buf . append ( indent + str + get caret slope run ( ) + str ) ; buf . append ( indent + str + get caret offset ( ) + str ) ; buf . append ( indent + str + get metric data format ( ) + str ) ; buf . append ( indent + str + get num of long hor metrics ( ) + str ) ; return buf . to string ( ) ; }	create a pretty string.
private static int [ ] make positive ( byte a [ ] ) { int keep , k ; int byte length = a . length ; for ( keep = num ; keep < byte length && a [ keep ] == - num ; keep ++ ) ; for ( k = keep ; k < byte length && a [ k ] == num ; k ++ ) ; int extra byte = ( k == byte length ) ? num : num ; int int length = ( ( byte length - keep + extra byte ) + num ) > > > num ; int result [ ] = new int [ int length ] ; int b = byte length - num ; for ( int i = int length - num ; i >= num ; i -- ) { result [ i ] = a [ b -- ] & num ; int num bytes to transfer = math . min ( num , b - keep + num ) ; if ( num bytes to transfer < num ) num bytes to transfer = num ; for ( int j = num ; j <= num * num bytes to transfer ; j += num ) result [ i ] |= ( ( a [ b -- ] & num ) << j ) ; int mask = - num > > > ( num * ( num - num bytes to transfer ) ) ; result [ i ] = ~ result [ i ] & mask ; } for ( int i = result . length - num ; i >= num ; i -- ) { result [ i ] = ( int ) ( ( result [ i ] & long mask ) + num ) ; if ( result [ i ] != num ) break ; } return result ; }	takes an array a representing a negative 2 ' s - complement number and returns the minimal ( no leading zero bytes ) unsigned whose value is - a .
private void calculate sphere size ( double scale , k params ) { int i ; double sphere size , minprob = num ; double pstar ; double pstar sum = num ; double pstar square sum = num ; double inc ; for ( i = num ; i < m ; i ++ ) { if ( m [ i ] < num ) { continue ; } else { pstar = p ( m [ i ] , scale ) ; if ( minprob > pstar ) { minprob = pstar ; } inc = pstar / m ; pstar sum += inc ; pstar square sum += inc * inc ; } } sphere size = ( pstar square sum == num ? num : pstar sum * pstar sum / pstar square sum ) ; params . sphere = sphere size ; params . avg prob = pstar sum ; params . min prob = minprob ; }	calculates the size of the " sphere of influence " defined as : sphere = sum ( p ) ^ 2 / sum ( p ^ 2 ) where p ( i ) = root * exp ( - 2 * i * root ).
private void keep annotated ( path path ) throws file not found exception { for ( class path element element : path . get elements ( ) ) { for clazz : for ( string name : element . list ( ) ) { if ( name . ends with ( class extension ) ) { direct class file clazz = path . get class ( name ) ; if ( has runtime visible annotation ( clazz ) ) { files to keep . add ( name ) ; } else { method list methods = clazz . get methods ( ) ; for ( int i = num ; i < methods . size ( ) ; i ++ ) { if ( has runtime visible annotation ( methods . get ( i ) ) ) { files to keep . add ( name ) ; continue for clazz ; } } field list fields = clazz . get fields ( ) ; for ( int i = num ; i < fields . size ( ) ; i ++ ) { if ( has runtime visible annotation ( fields . get ( i ) ) ) { files to keep . add ( name ) ; continue for clazz ; } } } } } } }	keep classes annotated with runtime annotations .
private list < search hit > limit list ( int limit , list < search hit > hit list ) { if ( log . is debug enabled ( ) ) { log . debug ( str + hit list . size ( ) + str + limit + str ) ; } search hit [ ] limited hits = new search hit [ limit ] ; system . arraycopy ( hit list . to array ( new search hit [ hit list . size ( ) ] ) , num , limited hits , num , limit ) ; return arrays . as list ( limited hits ) ; }	reduce size of hitlist to given limit ( cuts of all elements after position $ limit ).
public void add rule ( delphi rule delphi rule ) { delphi rules . add ( delphi rule ) ; }	adds rule to set.
private void prepare directory ( string path ) { file dir = new file ( path ) ; if ( ! dir . exists ( ) ) { if ( ! dir . mkdirs ( ) ) { log . e ( tag , str + path + str ) ; } } else { log . i ( tag , str + path ) ; } }	prepare directory on external storage.
void drop resource ( final r resource ) { final thread tx = thread . current thread ( ) ; synchronized ( resource queues ) { final resource queue < r , thread > resource queue = resource queues . get ( resource ) ; if ( resource queue == null ) { throw new illegal argument exception ( str + resource ) ; } resource queue . clear ( tx ) ; resource queues . remove ( resource ) ; } }	drop a resource . the caller must have lock on the resource . all tasks blocked waiting for that resource will be aborted .
public static void put object to stream ( object obj , output stream os ) throws io { object output stream oos = new object output stream ( os ) ; oos . write object ( obj ) ; oos . flush ( ) ; oos . close ( ) ; }	serializes specified object to an output stream .
public static void write image to ppm ( int [ ] [ ] image , string ppm file name ) throws io { try ( buffered writer ppm out = new buffered writer ( new file writer ( ppm file name ) ) ) { int rows = image . length ; int cols = image [ num ] . length ; ppm out . write ( str ) ; ppm out . write ( str + rows + str + cols + str ) ; for ( int [ ] an image : image ) { string builder s = new string builder ( ) ; for ( int j = num ; j < cols ; j ++ ) { s . append ( an image [ j ] + str + an image [ j ] + str + an image [ j ] + str ) ; } ppm out . write ( s . to string ( ) ) ; } } }	writes the given image in the given file using the ppm data format .
public bitmap pop ( long timeout , time unit unit ) throws interrupted exception { check not main thread ( ) ; ensure scheduled ( ) ; return finished . poll ( timeout , unit ) ; }	returns a previously drawn frame from this drawable or null , if no drawable can be popped right now . this function has a timeout.
default t call ( source section source , t lhs ) { return call ( source , lhs , collections . empty list ( ) ) ; }	helper function : create a call with no arguments .
static public string show table ( final path [ ] a ) { return show table ( a , null ) ; }	comma delimited table showing the estimated join hit ratio , the estimated cardinality , and the set of vertices for each of the specified join paths .
public unload stranded turn ( int [ ] ids ) { super ( i . player none ) ; if ( null == ids ) { throw new illegal argument exception ( str ) ; } if ( num == ids . length ) { throw new illegal argument exception ( str ) ; } entity ids = new int [ ids . length ] ; system . arraycopy ( ids , num , entity ids , num , ids . length ) ; }	any player that owns an entity whose id is in the passed array should be given a chance to unload it .
@ override void check after unmarshalled ( ) { super . check after unmarshalled ( ) ; assert equals ( short val . short value ( ) , num ) ; assert equals ( long val , num ) ; assert null ( a arr ) ; assert equals ( double val , num ) ; }	checks correctness of the state after unmarshalling .
private void finish kb mode ( boolean update displays ) { m in kb mode = bool ; if ( ! m typed times . is empty ( ) ) { int values [ ] = get entered time ( null ) ; m time picker . set time ( new timepoint ( values [ num ] , values [ num ] , values [ num ] ) ) ; if ( ! m is24 hour mode ) { m time picker . set am or pm ( values [ num ] ) ; } m typed times . clear ( ) ; } if ( update displays ) { update display ( bool ) ; m time picker . try setting input enabled ( bool ) ; } }	get out of keyboard mode.
public boolean is annotation present ( class java class , string property , class < ? extends annotation > annotation class ) { field field ; try { field = java class . get declared field ( property ) ; return field . is annotation present ( annotation class ) ; } catch ( no such field exception e ) { class superclass = java class . get superclass ( ) ; while ( superclass != null ) { try { field = superclass . get declared field ( property ) ; return field . is annotation present ( annotation class ) ; } catch ( no such field exception e1 ) { superclass = superclass . get superclass ( ) ; } } throw new runtime exception ( str + property ) ; } }	determine whether the given annotation is present in the object ' s class or in any of its superclasses .
@ override public int read ( byte [ ] b , int off , int len ) throws io { if ( closed ) { throw new file upload exception ( item skipped exception ) ; } if ( len == num ) { return num ; } int res = available ( ) ; if ( res == num ) { res = make available ( ) ; if ( res == num ) { return - num ; } } res = math . min ( res , len ) ; system . arraycopy ( buffer , head , b , off , res ) ; head += res ; total += res ; return res ; }	reads bytes into the given buffer .
public void add range ( double min value , double max value ) { if ( ! double . is na n ( max value ) && max value > max data ) { max data = max value ; } if ( ! double . is na n ( min value ) && min value < min data ) { min data = min value ; } is calibrated = bool ; }	adds the range to the existing range , widening if neccessary.
public boolean can get ( class type ) { if ( type == null ) return bool ; if ( m column type . is primitive ( ) ) { boolean prim types = type . is assignable from ( m column type ) || ( type lib . is numeric type ( m column type ) && type lib . is numeric type ( type ) ) ; return prim types || type . is assignable from ( type lib . get wrapper type ( m column type ) ) || type . is assignable from ( string . class ) ; } else { return type . is assignable from ( m column type ) ; } }	indicates if the get method can be called without an exception being thrown for the given type .
public vector3 floor ( ) { return new vector3 ( math . floor ( x ) , math . floor ( y ) , math . floor ( z ) ) ; }	rounds the x , y , and z values of this vector3 down to the nearest integer value .
public string check key and get database name ( string db ) { if ( key == null ) { return db ; } if ( key . equals ( db ) ) { return key database ; } throw db exception . get ( error code . wrong user or password ) ; }	if no key is set , return the original database name.
public boolean is empty ( ) { return active queues . size ( ) == num && inactive queues . size ( ) == num ; }	is the this empty.
private static double round ( double value , int decimal places ) { return math . round ( value * math . pow ( num , decimal places ) ) / math . pow ( num , decimal places ) ; }	rounds a decimal value to the given decimal place .
public void dont notify ( final turn listener turn listener ) { for ( final map . entry < integer , set < turn listener > > map entry : register . entry set ( ) ) { final set < turn listener > set = map entry . get value ( ) ; final set < turn listener > to be removed = new hash set < turn listener > ( ) ; if ( set . contains ( turn listener ) ) { to be removed . add ( turn listener ) ; } for ( final turn listener event : to be removed ) { set . remove ( event ) ; } } }	forgets all registered notification entries for the given turnlistener where the entry ' s message equals the given one .
@ override public int hash code ( ) { int code = super . hash code ( ) ; if ( e conditions != null ) { for ( entitlement condition e condition : e conditions ) { code = num * code + e condition . hash code ( ) ; } } if ( p condition name != null ) { code = num * code + p condition name . hash code ( ) ; } return code ; }	returns hash code of the object.
@ transactional public void delete ( t persistent object ) { if ( ! entity manager . contains ( persistent object ) ) { persistent object = entity manager . merge ( persistent object ) ; } entity manager . remove ( persistent object ) ; }	remove an object from persistent storage in the database.
public void add locations ( collection < pb > locations ) { l locations . add all ( locations ) ; }	adds the specific collection of locations to this argument .
@ reference ( title = str , authors = str , booktitle = str , url = str ) private static double deviance term ( double x , double np ) { if ( math . abs ( x - np ) < num * ( x + np ) ) { final double v = ( x - np ) / ( x + np ) ; double s = ( x - np ) * v ; double ej = num * x * v ; for ( int j = num ; ; j ++ ) { ej *= v * v ; final double s1 = s + ej / ( num * j + num ) ; if ( s1 == s ) { return s1 ; } s = s1 ; } } return x * math . log ( x / np ) + np - x ; }	evaluate the deviance term of the saddle point approximation . bd0 ( x , np ) = x * ln ( x / np ) + np - x.
void check and remove header row ( int position ) { if ( is update list empty ( ) ) { for ( iterator < displayable > it = displayable list . iterator ( ) ; it . has next ( ) ; ) { displayable displayable = it . next ( ) ; if ( displayable instanceof update header row ) { it . remove ( ) ; notify item removed ( position ) ; } } } }	check if there ' s any update on the displayablelist and if so , removes the update header.
public list < json > values ( ) { return collections . unmodifiable list ( values ) ; }	returns a list of the values in this array in document order.
public boolean is selection user defined roster group ( ) { return ( selected roster group != null && ! selected roster group . equals ( roster . allentries ) ) ; }	is the selected roster group user or system defined .
public void init ( action listener done action ) { update = bool ; supress dragging = bool ; bottom1 panel = new j ( ) ; add show button to bottom ( ) ; add update button to bottom ( done action ) ; init icon families panel ( ) ; add ( icon family panel ) ; add ( bottom1 panel ) ; }	init for conversion of plain track to indicator track.
private void update entries ( cache < integer , integer > cache , int new val , boolean invoke , set < integer > keys ) { if ( invoke ) cache . invoke all ( keys , new integer set value ( new val ) ) ; else { final map < integer , integer > entries = new hash map < > ( entry count ) ; for ( final integer key : keys ) entries . put ( key , new val ) ; cache . put all ( entries ) ; } }	update the cache using either invokeall ( ) or putall ( ) .
void update days ( wheel view year , wheel view month , wheel view day ) { calendar calendar = calendar . get instance ( ) ; calendar . set ( calendar . year , calendar . get ( calendar . year ) + year . get current item ( ) ) ; calendar . set ( calendar . month , month . get current item ( ) ) ; int max days = calendar . get actual maximum ( calendar . day of month ) ; day . set view adapter ( new date numeric adapter ( this , num , max days , calendar . get ( calendar . day of month ) - num ) ) ; int cur day = math . min ( max days , day . get current item ( ) + num ) ; day . set current item ( cur day - num , bool ) ; }	updates day wheel . sets max days according to selected month and year.
private static boolean add to evaluator ( array deque < filter value set param > remaining parameters , filter handle filter callback , event evaluator event evaluator , array deque < event type index builder index lookupable pair > tree path info , filter service granular lock factory lock factory ) { if ( event evaluator instanceof filter handle set node ) { filter handle set node node = ( filter handle set node ) event evaluator ; add to node ( remaining parameters , filter callback , node , tree path info , lock factory ) ; return bool ; } filter param index base next index = ( filter param index base ) event evaluator ; filter value set param parameter = index helper . find parameter ( remaining parameters , next index ) ; if ( parameter != null ) { remaining parameters . remove ( parameter ) ; tree path info . add ( new event type index builder index lookupable pair ( next index , parameter . get filter for value ( ) ) ) ; add to index ( remaining parameters , filter callback , next index , parameter . get filter for value ( ) , tree path info , lock factory ) ; return bool ; } return bool ; }	add filter callback to an event evaluator , which could be either an index node or a set node .
protected regex prompt ( string pattern ) { this ( pattern . compile ( pattern ) ) ; }	creates a new prompt with pattern , calls pattern . compile.
public void subscriber ( class < ? > api , @ pin service ref amp service ref , result < ? super cancel > result ) { string path = api . get name ( ) ; string address = address ( path ) ; event node asset node = lookup pub sub node ( address ) ; cancel cancel = node . subscribe impl ( service ref ) ; result . ok ( cancel ) ; }	subscribe a callback to a location .
int secure hash ( int x ) { arrays . fill ( data , ( byte ) num ) ; write int ( data , num , x ) ; aes . encrypt ( data , num , num ) ; return read int ( data , num ) ; }	calculate a hash using aes .
public void write to ( dex file file , annotated output out ) { finish processing if necessary ( ) ; if ( out . annotates ( ) ) { annotate entries ( str , null , out ) ; } int table size = table . size ( ) ; for ( int i = num ; i < table size ; i ++ ) { catch table . entry one = table . get ( i ) ; int start = one . get start ( ) ; int end = one . get end ( ) ; int insn count = end - start ; if ( insn count >= num ) { throw new unsupported operation exception ( str + hex . u4 ( start ) + str + hex . u4 ( end ) ) ; } out . write int ( start ) ; out . write short ( insn count ) ; out . write short ( handler offsets . get ( one . get handlers ( ) ) ) ; } out . write ( encoded handlers ) ; }	writes this instance to the given stream .
private virtual pool change param convert new virtual pool change param to old param ( volume virtual pool change param new param ) { virtual pool change param old param = new virtual pool change param ( ) ; old param . set virtual pool ( new param . get virtual pool ( ) ) ; old param . set protection ( new param . get protection ( ) ) ; old param . set consistency group ( new param . get consistency group ( ) ) ; old param . set transfer speed param ( new param . get transfer speed param ( ) ) ; old param . set migration suspend before commit ( new param . is migration suspend before commit ( ) ) ; old param . set migration suspend before delete source ( new param . is migration suspend before delete source ( ) ) ; return old param ; }	copy the contents from new virtual pool change param to old param.
public boolean empty ( ) { return vstack . empty ( ) ; }	indicate whether the stack is empty .
public void add input param ( fb param ) { if ( input params . size ( ) < param . get position ( ) + num ) { input params . set size ( param . get position ( ) + num ) ; } input params . set ( param . get position ( ) , param ) ; }	add an input parameter to this procedure call .
public static float read float ( final json json object , final string key , final boolean required , final boolean not null ) throws json { if ( required ) { return ( float ) json object . get double ( key ) ; } if ( not null && json object . is null ( key ) ) { throw new json ( string . format ( locale . us , null value format object , key ) ) ; } float value = num ; if ( ! json object . is null ( key ) ) { value = ( float ) json object . get double ( key ) ; } return value ; }	reads the float value from the json object for specified tag .
public void test case22 ( ) { byte r bytes [ ] = { num } ; big integer a number = big integer . one ; big integer b number = big integer . one ; big integer result = a number . add ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	add one to one.
public void paint ( d g2 d , int page no , d page start , properties ctx , boolean is view ) { d . double location = get absolute location ( page start ) ; rectangle allocation = m renderer . get allocation ( ) ; g2 d . translate ( location . x , location . y ) ; m renderer . paint ( g2 d , allocation ) ; g2 d . translate ( - location . x , - location . y ) ; }	/ paint / print.
@ override public void handle click ( int x , int y , plot rendering info info ) { d data area = info . get data area ( ) ; if ( data area . contains ( x , y ) ) { value axis xaxis = get domain axis ( ) ; if ( xaxis != null ) { double hvalue = xaxis . java2 d ( x , info . get data area ( ) , get domain axis edge ( ) ) ; set domain crosshair value ( hvalue ) ; } value axis yaxis = get range axis ( ) ; if ( yaxis != null ) { double vvalue = yaxis . java2 d ( y , info . get data area ( ) , get range axis edge ( ) ) ; set range crosshair value ( vvalue ) ; } } }	handles a ' click ' on the plot by updating the anchor values .
private static string convert to quoted string ( string string ) { if ( string == null || string . length ( ) == num ) { return null ; } if ( string . char at ( num ) == str && string . char at ( string . length ( ) - num ) == str ) { return string ; } return str + string + str ; }	encloses the incoming string inside double quotes , if it isn ' t already quoted .
public int edge index ( triangulation point p1 , triangulation point p2 ) { if ( points [ num ] == p1 ) { if ( points [ num ] == p2 ) { return num ; } else if ( points [ num ] == p2 ) { return num ; } } else if ( points [ num ] == p1 ) { if ( points [ num ] == p2 ) { return num ; } else if ( points [ num ] == p2 ) { return num ; } } else if ( points [ num ] == p1 ) { if ( points [ num ] == p2 ) { return num ; } else if ( points [ num ] == p2 ) { return num ; } } return - num ; }	get the neighbor that share this edge.
public void connection closed ( connection event event ) { if ( is active ) { managed connection conn = ( managed connection ) event . get source ( ) ; xa xar = null ; if ( xa resources map . get ( conn ) != null ) xar = ( xa ) xa resources map . get ( conn ) ; xa resources map . remove ( conn ) ; try { transaction txn = trans manager . get transaction ( ) ; if ( txn != null && xar != null ) { txn . delist resource ( xar , xa . tmsuccess ) ; } } catch ( exception se ) { string exception = str + se ; if ( logger . is debug enabled ( ) ) { logger . debug ( exception , se ) ; } } mann pool cache . return pooled connection to pool ( conn ) ; } }	callback for connection closed .
public void write to lucene stream ( index output output stream , int k ) { to cartesian ( ) ; for ( int i = num ; i < k * num ; ++ i ) { try { output stream . write int ( float . float to int bits ( coordinates [ i ] ) ) ; } catch ( io e ) { e . print stack trace ( ) ; } } }	transforms vector to cartesian form and writes vector out in dense format , truncating the vectors to the assigned dimensionality.
public static xmp parse ( object input , parse options options ) throws xmp { parameter asserts . assert not null ( input ) ; options = options != null ? options : new parse options ( ) ; document document = parse xml ( input , options ) ; boolean xmpmeta required = options . get require xmp ( ) ; object [ ] result = new object [ num ] ; result = find root node ( document , xmpmeta required , result ) ; if ( result != null && result [ num ] == xmp rdf ) { xmp xmp = rdf . parse ( ( node ) result [ num ] ) ; xmp . set packet header ( ( string ) result [ num ] ) ; if ( ! options . get omit normalization ( ) ) { return xmp . process ( xmp , options ) ; } else { return xmp ; } } else { return new xmp ( ) ; } }	parses the input source into an xmp metadata object , including de - aliasing and normalisation .
public static void dispose graphics config ( long p config info ) { d rq = get instance ( ) ; rq . lock ( ) ; try { render buffer buf = rq . get buffer ( ) ; rq . ensure capacity and alignment ( num , num ) ; buf . put int ( dispose config ) ; buf . put long ( p config info ) ; rq . flush now ( ) ; } finally { rq . unlock ( ) ; } }	disposes the native memory associated with the given native graphics config info pointer on the single queue flushing thread .
public static int object equals ( object obj1 , object obj2 ) { return obj1 . equals ( obj2 ) ? true : false ; }	helper function that is called instead of object . equals.
public void add loop ( array comprehension loop acl ) { assert not null ( acl ) ; loops . add ( acl ) ; acl . set parent ( this ) ; }	adds a child loop node , and sets its parent to this node .
void read sin ( ) throws io { while ( bool ) { string s = isr . read line ( ) ; if ( s == null ) return ; if ( s . starts with ( str ) ) return ; } }	read sin records ( in fact does nothing ).
public static object deserialize ( string input ) throws io , class not found exception { byte [ ] decoded = base64 . decode base64 ( input . get bytes ( str ) ) ; return deserialize ( decoded ) ; }	base64 decodes a string into a decoded byte array , then deserializes the object .
public static string bind ( string message , object [ ] bindings ) { return message format . format ( message , bindings ) ; }	bind the given message ' s substitution locations with the given string values .
protected dbi compute subspace for gene ( short [ ] gene , array list < array list < dbi > > ranges ) { dbi m = null ; for ( int i = num ; i < gene . length ; i ++ ) { if ( gene [ i ] != dont care ) { dbi current = ranges . get ( i ) . get ( gene [ i ] - gene offset ) ; if ( m == null ) { m = dbid . new hash set ( current ) ; } else { m . retain all ( current ) ; } } } assert ( m != null ) : str ; return m ; }	get the dbids in the current subspace .
public final string to string ( string codeset ) { string buffer sb = new string buffer ( ) ; if ( doctype != null ) sb . append ( doctype . to string ( get codeset ( ) ) ) ; sb . append ( html . to string ( get codeset ( ) ) ) ; return ( sb . to string ( ) ) ; }	override the tostring ( ) method so that it prints something meaningful .
public list < pdf document > extract page ranges ( list < page range > page ranges ) { list < pdf document > split documents = new array list < > ( ) ; for ( page range current page range : page ranges ) { pdf document current pdf document = create pdf document ( current page range ) ; split documents . add ( current pdf document ) ; pdf document . copy pages to ( current page range . get all pages ( ) , current pdf document ) ; } return split documents ; }	extracts the specified page ranges from a document .
public stax writer ( final q qname map , final xml out , final boolean write enclosing document , final boolean namespace repairing mode , final name coder name coder ) throws xml { super ( name coder ) ; this . qname map = qname map ; this . out = out ; this . write enclosing document = write enclosing document ; this . namespace repairing mode = namespace repairing mode ; if ( write enclosing document ) { out . write start document ( ) ; } }	allows a staxwriter to be created for partial xml output.
void sleep ( long millis ) { try { thread . sleep ( millis ) ; } catch ( interrupted exception ie ) { assertion failed error afe = new assertion failed error ( str ) ; afe . init cause ( ie ) ; throw afe ; } }	sleeps until the given time has elapsed.
private void copy attributes ( attribute map dest , attribute map source ) { for ( entry < attribute < ? > , ? > a : source . entry set ( ) ) { dest . put ( ( attribute < object > ) a . get key ( ) , a . get value ( ) ) ; } }	copy attribute from source attributemap to destination attributemap .
protected void assert result ( string expected , statement stat , string sql ) throws sql { result set rs = stat . execute query ( sql ) ; if ( rs . next ( ) ) { string actual = rs . get string ( num ) ; assert equals ( expected , actual ) ; } else { assert equals ( expected , null ) ; } }	check that the result set of a query is exactly this value .
public log file ( string name , string mode ) throws file not found exception , io { super ( name , mode ) ; this . fd = get fd ( ) ; }	constructs a logfile and initializes the file descriptor .
public void remove url change listener ( url change listener url change listener ) { url change listeners . remove ( url change listener ) ; }	un registers the listener.
@ suppress warnings ( str ) public list < product > read ( list < long > ids ) { if ( ( ids == null ) || ids . is empty ( ) ) return immutable list . of ( ) ; string facet = str ; string logic op = str ; for ( long id : ids ) { facet += str + logic op + str + id ; logic op = str ; } return ( list < product > ) find ( str + entity class . get name ( ) + str + facet ) ; }	retrieve a list of products to their ids.
public static double area ( coordinate a , coordinate b , coordinate c ) { return math . abs ( ( ( c . x - a . x ) * ( b . y - a . y ) - ( b . x - a . x ) * ( c . y - a . y ) ) / num ) ; }	computes the 2d area of a triangle.
public void add table header ( final j new table header ) { if ( ! registred table headers . contains ( new table header ) ) { if ( table header == null ) { table header = new table header ; } new table header . add mouse listener ( mouse listener ) ; new table header . set default renderer ( new sortable header renderer ( new table header . get default renderer ( ) ) ) ; registred table headers . add ( new table header ) ; } }	for more than one table use this method to register the table header ' s .
public boolean perform action ( ) { return ! actions . is empty ( ) ; }	indicates if an action has to be performed or not .
public multi error exception check ( boolean valid , string message key , object ... args ) { return check ( null , valid , message key , args ) ; }	adds a global - error if the given condition isn ' t true.
public void remove search listener ( search listener l ) { m . remove ( l ) ; }	removes the specified listener from the internal list of listeners .
public emote condition ( final string player action ) { this . player action = player action . trim ( ) ; }	creates a new admincondition for high level admins .
public boolean is hidden file ( file f ) { return f . is hidden ( ) ; }	returns whether a file is hidden or not .
private void validate num cores ( ) { string num cores str = carbon properties . get property ( carbon common constants . num cores , carbon common constants . num cores default val ) ; try { int num cores = integer . parse int ( num cores str ) ; if ( num cores < carbon common constants . num cores min val || num cores > carbon common constants . num cores max val ) { logger . info ( str + num cores str + str + carbon common constants . num cores default val ) ; carbon properties . set property ( carbon common constants . num cores , carbon common constants . num cores default val ) ; } } catch ( number format exception e ) { logger . info ( str + num cores str + str + carbon common constants . num cores default val ) ; carbon properties . set property ( carbon common constants . num cores , carbon common constants . num cores default val ) ; } }	this method validates the number cores specified.
public generator ( int base width , int bese height ) { this . base width = base width ; this . bese height = bese height ; xstream . autodetect annotations ( bool ) ; this . res file = new file ( str ) ; if ( ! res file . exists ( ) ) { res file . mkdir ( ) ; } }	using basewidth and baseheight to generator.
public dbms poll ( ) throws interrupted exception { return queue . poll ( ) ; }	removes and returns next event from the queue , returning null if empty.
public static category create category ( final string raw json ) throws twitter exception { try { final json json = new json ( raw json ) ; return category constructor . new instance ( json ) ; } catch ( final instantiation exception e ) { throw new twitter exception ( e ) ; } catch ( final illegal access exception e ) { throw new assertion error ( e ) ; } catch ( final invocation target exception e ) { throw new twitter exception ( e ) ; } catch ( final json e ) { throw new twitter exception ( e ) ; } }	constructs a category object from rawjson string .
public void remove all plots ( ) { m plot . remove all plots ( ) ; }	removes all the plots .
public synchronized void update n ( string column name , java . io . reader reader , int length ) throws sql { update n ( find column ( column name ) , reader , length ) ; }	jdbc 4 . 0 update a column with a character stream value . the updatexxx ( ) methods are used to update column values in the current row , or the insert row . the updatexxx ( ) methods do not update the underlying database , instead the updaterow ( ) or insertrow ( ) methods are called to update the database .
list < file > add collection files ( file new basedir ) throws io { final directory scanner ds = new directory scanner ( ) ; ds . set basedir ( new basedir ) ; if ( this . includes != null && this . includes . length > num ) { ds . set includes ( this . includes ) ; } else { ds . set includes ( default includes ) ; } ds . set excludes ( this . excludes ) ; ds . add default excludes ( ) ; ds . set case sensitive ( bool ) ; ds . set follow symlinks ( bool ) ; ds . scan ( ) ; list < file > found files = new array list < > ( ) ; for ( string filename : ds . get included files ( ) ) { found files . add ( new file ( new basedir , filename ) ) ; } return found files ; }	add source files to the files list .
static int read type ref ( type reference type ref , data input stream input , int [ ] constant pool ) throws io , class format error { int my type index = input . read unsigned short ( ) ; type reference my type ref = get type ref ( constant pool , my type index ) ; if ( my type ref != type ref ) { if ( ! vm . verify assertions ) { throw new class format error ( str + type ref . get name ( ) + str + my type ref . get name ( ) + str ) ; } else { throw new class format error ( str + type ref . get name ( ) + str + my type ref . get name ( ) + str + type ref + str + my type ref ) ; } } return my type index ; }	read the class ' typereference.
private boolean do acquire shared nanos ( long arg , long nanos timeout ) throws interrupted exception { if ( nanos timeout <= num ) return bool ; final long deadline = system . nano time ( ) + nanos timeout ; final node node = add waiter ( node . shared ) ; boolean failed = bool ; try { for ( ; ; ) { final node p = node . predecessor ( ) ; if ( p == head ) { long r = try acquire shared ( arg ) ; if ( r >= num ) { set head and propagate ( node , r ) ; p . next = null ; failed = bool ; return bool ; } } nanos timeout = deadline - system . nano time ( ) ; if ( nanos timeout <= num ) return bool ; if ( should park after failed acquire ( p , node ) && nanos timeout > spin for timeout threshold ) lock support . park nanos ( this , nanos timeout ) ; if ( thread . interrupted ( ) ) throw new interrupted exception ( ) ; } } finally { if ( failed ) cancel acquire ( node ) ; } }	acquires in shared timed mode .
public c ( final string name , final string description , final list < c > steps ) { m name = preconditions . check not null ( name , str ) ; m description = preconditions . check not null ( description , str ) ; m steps = new array list < c > ( preconditions . check not null ( steps , str ) ) ; preconditions . check argument ( ! steps . is empty ( ) , str ) ; }	creates a new tutorial object .
private file create new format ( int ad id , http servlet request request , grid tab m cur tab , m m query ) { web session ctx wsc = web session ctx . get ( request ) ; m pf = m . create from table ( wsc . ctx , ad id ) ; file file = launch report ( pf , request , m cur tab , m query ) ; return file ; }	create and launch new format for table.
public void add all ( rule set that ) { rules . add all ( that . rules ) ; rule array = null ; }	adds all the rules to this ruleset from the given other rule set .
public synchronized boolean acquire ( ) throws replicator exception { if ( is locked ( ) ) return bool ; try { raf = new random access file ( lock file , str ) ; file channel channel = raf . get channel ( ) ; lock = channel . try lock ( ) ; } catch ( file not found exception e ) { throw new replicator exception ( str + lock file . get absolute path ( ) ) ; } catch ( exception e ) { throw new replicator exception ( str + lock file . get absolute path ( ) , e ) ; } finally { if ( lock == null && raf != null ) { close ( raf ) ; } } if ( lock == null ) { if ( raf != null ) close ( raf ) ; return bool ; } else if ( lock . is shared ( ) ) { release ( ) ; return bool ; } else return bool ; }	attempt to acquire write lock.
public void test write bit ( ) throws exception { byte array output stream out = new byte array output stream ( ) ; bit output stream b out = new bit output stream ( out ) ; b out . write bit ( bool ) ; byte [ ] bytes = out . to byte array ( ) ; assert . assert equals ( num , bytes . length ) ; b out . close ( ) ; bytes = out . to byte array ( ) ; assert . assert equals ( num , bytes [ num ] ) ; }	test single bit write .
public static uri change scheme ( uri bind addr , string scheme ) throws uri { return new uri ( scheme , bind addr . get user info ( ) , bind addr . get host ( ) , bind addr . get port ( ) , bind addr . get path ( ) , bind addr . get query ( ) , bind addr . get fragment ( ) ) ; }	given a uri value create and return a new uri that matches the target one but with the scheme value supplied to this method .
public session start ssh session and obtain session ( ) { session session = null ; try { j jsch = new j ( ) ; if ( ssh meta . get ssh login type ( ) == ssh login type . key ) { string working dir = system . get property ( str ) ; string priv key abs path = working dir + str + ssh meta . get priv key relative path ( ) ; logger . debug ( str + priv key abs path ) ; if ( ! pc file network io utils . is file exist ( priv key abs path ) ) { throw new runtime exception ( str + priv key abs path ) ; } if ( ssh meta . is priv key use passphrase ( ) && ssh meta . get passphrase ( ) != null ) { jsch . add identity ( priv key abs path , ssh meta . get passphrase ( ) ) ; } else { jsch . add identity ( priv key abs path ) ; } } session = jsch . get session ( ssh meta . get user name ( ) , target host , ssh meta . get ssh port ( ) ) ; if ( ssh meta . get ssh login type ( ) == ssh login type . password ) { session . set password ( ssh meta . get password ( ) ) ; } session . set config ( str , str ) ; } catch ( exception t ) { throw new runtime exception ( t ) ; } return session ; }	start ssh session and obtain session .
public map < integer , integer > pop missing ( ) { hash map < integer , integer > map = new hash map < > ( ) ; for ( int i = num ; i < missing blocks . length ; i ++ ) { int count = missing blocks [ i ] ; if ( count > num ) { map . put ( i , count ) ; } } arrays . fill ( missing blocks , num ) ; return map ; }	gets the list of missing blocks and clears the list for the next operation .
public static string interpolate ( string input , final map < string , string > named args , final map < string , string > default args ) { if ( named args == null || input == null ) { return input ; } final map < string , string > interpolation args = create final interpolation map ( named args , default args ) ; return str substitutor . replace ( input , interpolation args , prefix , suffix ) ; }	performs variable interpolation using the named arguments from an action on a single string.
public int max ( ) { return max ; }	the upper bound for the value .
public static void add to invoke later ( final runnable runnable ) { final application application = application manager . get application ( ) ; final boolean unit test mode = application . is unit test mode ( ) ; if ( unit test mode ) { ui . invoke later if needed ( runnable ) ; } else if ( application . is headless environment ( ) || application . is dispatch thread ( ) ) { runnable . run ( ) ; } else { transfer to edt queue . offer ( runnable ) ; } }	adds runnable to event dispatch queue if we aren ' t in unittest of headless environment mode.
public byte array data source ( byte [ ] data , string type ) { m data = data ; if ( type != null && type . length ( ) > num ) m type = type ; }	create a datasource from a byte array.
public static void check operational pattern1 a ( list < partition pack > partition packs ) { imf imf error logger = new imf ( ) ; for ( partition pack partition pack : partition packs ) { byte [ ] bytes = partition pack . get operational pattern ( ) ; for ( int i = num ; i < bytes . length ; i ++ ) { if ( ( mxf a . operational patter a key mask [ i ] != num ) && ( mxf a . operational patter a key [ i ] != bytes [ i ] ) ) { imf error logger . add error ( imf . imf . error codes . imf essence component error , imf . imf . error levels . fatal , mxf a . o a exception prefix + string . format ( str , bytes [ i ] , i , mxf a . operational patter a key [ i ] ) ) ; } } if ( partition pack . get number of essence container u ( ) < num ) { imf error logger . add error ( imf . imf . error codes . imf essence component error , imf . imf . error levels . fatal , mxf a . o a exception prefix + string . format ( str , partition pack . get number of essence container u ( ) ) ) ; } } if ( imf error logger . has fatal errors ( ) ) { throw new mxf ( string . format ( str ) , imf error logger ) ; } }	checks the compliance of partition packs found in an mxf file with st378 : 2004 . a runtime exception is thrown in case of non - compliance.
public barabasi albert generator ( supplier < graph < v , e > > graph factory , supplier < v > vertex factory , supplier < e > edge factory , int init vertices , int num edges to attach , set < v > seed vertices ) { this ( graph factory , vertex factory , edge factory , init vertices , num edges to attach , ( int ) system . current time millis ( ) , seed vertices ) ; }	constructs a new instance of the generator , whose output will be an undirected graph , and which will use the current time as a seed for the random number generation .
private boolean add hisorical record ( historical record historical record ) { synchronized ( m instance lock ) { final boolean added = m historical records . add ( historical record ) ; if ( added ) { m historical records changed = bool ; prune excessive historical records locked ( ) ; persist historical data ( ) ; sort activities ( ) ; } return added ; } }	adds a historical record .
private static int to even ( float value ) { int i = math . round ( value ) ; return ( i % num == num ) ? i - num : i ; }	casts the value to an even integer .
private void write object ( object output stream oos ) throws io { oos . default write object ( ) ; oos . write int ( index . size ( ) ) ; for ( int i = num , sz = index . size ( ) ; i < sz ; ++ i ) { oos . write utf ( index . get ( i ) ) ; } }	custom serializer . this is possible since the index is guaranteed to assign contiguous values .
public static byte [ ] read file to byte array ( file file ) throws io { input stream in = null ; try { in = open input stream ( file ) ; return io . to byte array ( in , file . length ( ) ) ; } finally { io . close quietly ( in ) ; } }	reads the contents of a file into a byte array.
public void export ( data output stream out ) throws io { out . write int ( seq id ) ; if ( info . is row block enabled ( ) ) out . write int ( n rows ) ; export ( out , primary key ) ; for ( byte array cb : cell blocks ) { export ( out , cb ) ; } }	write data to given output stream , like serialize.
public boolean is sealed ( url url ) { return seal base != null && seal base . same file ( url ) ; }	indicates whether this package is sealed with respect to the specified url .
private boolean check validation ( final source data tag current source data tag , final value update update ) { if ( ! is timestamp valid ( current source data tag , update ) ) { return bool ; } if ( ! is convertible ( current source data tag , update ) ) { return bool ; } if ( is number ( current source data tag . get data type ( ) ) && ! is in range ( current source data tag , update ) ) { return bool ; } return bool ; }	helper method which validates the new tag value and triggers an invalidation in case of a problem.
public deterministic key ( immutable list < child number > child number path , byte [ ] chain code , big integer priv , @ nullable deterministic key parent , int depth , int parent fingerprint ) { super ( priv , compress point ( ec . public point from private ( priv ) ) ) ; check argument ( chain code . length == num ) ; this . parent = parent ; this . child number path = check not null ( child number path ) ; this . chain code = arrays . copy of ( chain code , chain code . length ) ; this . depth = depth ; this . parent fingerprint = ascertain parent fingerprint ( parent , parent fingerprint ) ; }	constructs a key from its components , including its private key data and possibly - redundant information about its parent key.
static public boolean is equal ( float a , float b , float tolerance ) { return math . abs ( a - b ) <= tolerance ; }	returns true if a is nearly equal to b .
static private string to upper case fast ( final string s ) { boolean different = bool ; final int mx = s . length ( ) ; char [ ] chars = new char [ mx ] ; for ( int i = num ; i < mx ; i ++ ) { char ch = s . char at ( i ) ; if ( str <= ch && ch <= str ) { ch = ( char ) ( ch + ( str - str ) ) ; different = bool ; } chars [ i ] = ch ; } final string upper ; if ( different ) upper = string . value of ( chars ) ; else upper = s ; return upper ; }	a fast and cheap way to uppercase a string that is only made of printable ascii characters.
private static void encode ( int tag , int length , string builder buffer ) { if ( tag == pattern iso zone && length >= num ) { throw new illegal argument exception ( str + length ) ; } if ( length < num ) { buffer . append ( ( char ) ( tag << num | length ) ) ; } else { buffer . append ( ( char ) ( ( tag << num ) | num ) ) ; buffer . append ( ( char ) ( length > > > num ) ) ; buffer . append ( ( char ) ( length & num ) ) ; } }	encodes the given tag and length and puts encoded char ( s ) into buffer .
public independence test ind test subset ( list vars ) { if ( vars . is empty ( ) ) { throw new illegal argument exception ( str ) ; } int [ ] indices = new int [ vars . size ( ) ] ; int j = - num ; for ( int i = num ; i < variables . size ( ) ; i ++ ) { if ( ! vars . contains ( variables . get ( i ) ) ) { continue ; } indices [ ++ j ] = i ; } data set new data set = data set . subset columns ( indices ) ; return new g ( new data set , alpha ) ; }	creates a new indtestgsquare for a subset of the variables .
public void start ( ) { if ( show logs ) logger . v ( tag , str ) ; synchronized ( m state ) { if ( show logs ) logger . v ( tag , str + m state ) ; switch ( m state . get ( ) ) { case idle : case initialized : case preparing : case started : throw new illegal state exception ( str + m state ) ; case stopped : case playback completed : case prepared : case paused : if ( show logs ) logger . v ( tag , str + m state + str ) ; m media player . start ( ) ; start position update notifier ( ) ; m state . set ( state . started ) ; break ; case error : case end : throw new illegal state exception ( str + m state ) ; } } if ( show logs ) logger . v ( tag , str ) ; }	play or resume video.
private static void dump configuration properties ( install log install log , map < string , object > properties ) { sorted map < string , object > sorted properties = new tree map < string , object > ( string . case insensitive order ) ; sorted properties . put all ( properties ) ; for ( string key : sorted properties . key set ( ) ) { if ( config items to hash list . contains ( key ) ) { install log . write ( key + str + str ) ; } else { install log . write ( key + str + sorted properties . get ( key ) + str ) ; } } }	iterate over the supplied properties ( sorted by property name ) and write them out to the passed install log.
public void update users ( gh remote pr ) throws io { paged iterable < gh > gh issue comments = remote pr . list comments ( ) ; for ( gh comment : gh issue comments ) { if ( is null ( whitelist user pattern ) ) { whitelist user pattern = pattern . compile ( whitelist user msg ) ; } } }	add / remove users / orgs internal state.
public builder add hideable view ( int view id ) { hideable views . add ( view id ) ; return this ; }	view id that is at the same hierarchy level as yt overlay . will be hidden while player is in landscape mode optional.
public static void show information ( final component parent , final string msg ) { j . show message dialog ( is iconified ( parent ) ? null : parent , msg , system . get property ( default window title property ) , j . information message ) ; }	shows an informational message .
private static boolean is valid scheme ( final string scheme ) { final int length = scheme . length ( ) ; if ( length <= num ) { return bool ; } char c = scheme . char at ( num ) ; if ( ! character . is letter ( c ) ) { return bool ; } for ( int i = num ; i < length ; i ++ ) { c = scheme . char at ( i ) ; if ( ! character . is letter or digit ( c ) && c != str && c != str && c != str ) { return bool ; } } return bool ; }	checks if it is a valid scheme .
protected static modbus response read request ( int function code , int register , int count ) { tcp transport = null ; tcp trans ; try { socket socket = new socket ( localhost , port ) ; transport = new tcp ( socket ) ; modbus request req = null ; switch ( function code ) { case modbus . read coils : req = new read coils request ( register , count ) ; break ; case modbus . read input discretes : req = new read input discretes request ( register , count ) ; break ; case modbus . read input registers : req = new read input registers request ( register , count ) ; break ; case modbus . read holding registers : req = new read multiple registers request ( register , count ) ; break ; default : fail ( string . format ( str , function code ) ) ; } req . set unit id ( unit id ) ; trans = ( tcp ) transport . create transaction ( ) ; trans . set request ( req ) ; trans . set reconnecting ( bool ) ; trans . execute ( ) ; return trans . get response ( ) ; } catch ( exception e ) { logger . debug ( e . get message ( ) ) ; } finally { if ( transport != null ) { try { transport . close ( ) ; } catch ( io e ) { logger . error ( e . get message ( ) ) ; } } } return null ; }	executes a read transaction using the function code , register and count.
public static string keep cart updated ( http servlet request request , http servlet response response ) { local dispatcher dispatcher = ( local dispatcher ) request . get attribute ( str ) ; http session session = request . get session ( ) ; shopping cart cart = get cart object ( request ) ; if ( cart . get user login ( ) == null ) { generic value user login = ( generic value ) session . get attribute ( str ) ; if ( user login != null ) { try { cart . set user login ( user login , dispatcher ) ; } catch ( cart item modify exception e ) { debug . log warning ( e , module ) ; } } } if ( cart . get auto user login ( ) == null ) { generic value auto user login = ( generic value ) session . get attribute ( str ) ; if ( auto user login != null ) { if ( cart . get user login ( ) == null ) { try { cart . set auto user login ( auto user login , dispatcher ) ; } catch ( cart item modify exception e ) { debug . log warning ( e , module ) ; } } else { cart . set auto user login ( auto user login ) ; } } } locale locale = util http . get locale ( request ) ; if ( cart . get locale ( ) == null || ! locale . equals ( cart . get locale ( ) ) ) { cart . set locale ( locale ) ; } return str ; }	update the cart ' s userlogin object if it isn ' t already set .
@ procedure @ performs writes @ description ( str ) public stream < node result > merge nodes ( @ name ( str ) list < node > nodes ) { if ( nodes . is empty ( ) ) return stream . empty ( ) ; iterator < node > it = nodes . iterator ( ) ; node first = it . next ( ) ; while ( it . has next ( ) ) { node other = it . next ( ) ; merge nodes ( other , first , bool ) ; } return stream . of ( new node result ( first ) ) ; }	merges the nodes onto the first node.
protected void process special attributes ( node node ) { process state attributes ( node , component ) ; }	process special attributes , like " id ".
@ override public void handle request ( request context rc ) throws cli { super . handle request ( rc ) ; ldap login ( ) ; meta alias = get string option value ( argument metadata ) ; bulk fed data = get string option value ( argument bulk data ) ; spec = federation manager . get idff ( rc ) ; string [ ] params = { meta alias , bulk fed data , spec } ; write log ( log writer . log access , level . info , str , params ) ; try { if ( spec . equals ( federation manager . default specification ) ) { saml2 get role and entity id ( ) ; map name ids = new hash map ( ) ; validate file ( name ids ) ; handle sam ( name ids ) ; write log ( log writer . log access , level . info , str , params ) ; } else if ( spec . equals ( cli . idff specification ) ) { idff get role and entity id ( ) ; map name ids = new hash map ( ) ; validate file ( name ids ) ; handle idff ( name ids ) ; write log ( log writer . log access , level . info , str , params ) ; } else { throw new cli ( get resource string ( str ) , exit codes . request cannot be processed ) ; } } catch ( cli e ) { string [ ] args = { meta alias , bulk fed data , spec , e . get message ( ) } ; write log ( log writer . log error , level . info , str , args ) ; throw e ; } }	imports bulk federation data .
public void test set key entry ljava lang security c security cert ( ) throws exception { certificate factory cf = certificate factory . get instance ( str ) ; x509 certificate cert [ ] = new x509 certificate [ num ] ; cert [ num ] = ( x509 certificate ) cf . generate certificate ( cert array ) ; cert [ num ] = ( x509 certificate ) cf . generate certificate ( cert array2 ) ; key store key test = key store . get instance ( key store . get default type ( ) ) ; try { key test . set key entry ( str , get private key ( ) , pss word , cert ) ; fail ( ) ; } catch ( key store exception expected ) { } key test . load ( null , null ) ; key test . set key entry ( str , get private key ( ) , pss word , cert ) ; assert true ( str , key test . is key entry ( str ) ) ; try { key test . set key entry ( str , get private key ( ) , pss word , new certificate [ ] { } ) ; fail ( ) ; } catch ( illegal argument exception expected ) { } }	java . security . keystore # setkeyentry ( java . lang . string , java . security . key , char [ ] , java . security . cert . certificate [ ] ).
public static vec back sub ( matrix u , vec y ) { if ( y . length ( ) != u . rows ( ) ) throw new arithmetic exception ( str ) ; vec x = y instanceof sparse vector ? new sparse vector ( u . cols ( ) ) : new dense vector ( u . cols ( ) ) ; final int start = math . min ( u . rows ( ) , u . cols ( ) ) - num ; for ( int i = start ; i >= num ; i -- ) { double x i = y . get ( i ) ; for ( int j = i + num ; j <= start ; j ++ ) x i -= u . get ( i , j ) * x . get ( j ) ; x i /= u . get ( i , i ) ; if ( double . is infinite ( x i ) ) x i = num ; x . set ( i , x i ) ; } return x ; }	solves for the vector x such that u x = y.
public static string increment at index ( final string s , final int index ) { final char [ ] chars = s . to char array ( ) ; chars [ index ] = ( char ) ( chars [ index ] + num ) ; return new string ( chars ) ; }	increments a single character in the specified string .
public void write ( final byte [ ] b ) throws io { stream . write ( b ) ; }	writes to the stream .
public void disable crash uploading ( ) { m crash uploading enabled = bool ; }	provides a way to disable crash uploading entirely , regardless of the preferences.
public void create data channel ( ) { if ( null != call reference ) { respoke call call = call reference . get ( ) ; if ( null != call ) { peer connection peer connection = call . get peer connection ( ) ; data channel = peer connection . create data channel ( str , new data channel . init ( ) ) ; data channel . register observer ( this ) ; } } }	establish a new direct connection instance with the peer connection for the call.
public static final void write byte array xml ( byte [ ] val , string name , xml serializer out ) throws xml pull parser exception , io { if ( val == null ) { out . start tag ( null , str ) ; out . end tag ( null , str ) ; return ; } out . start tag ( null , str ) ; if ( name != null ) { out . attribute ( null , str , name ) ; } final int n = val . length ; out . attribute ( null , str , integer . to string ( n ) ) ; string builder sb = new string builder ( val . length * num ) ; for ( int i = num ; i < n ; i ++ ) { int b = val [ i ] ; int h = b > > num ; sb . append ( h >= num ? ( str + h - num ) : ( str + h ) ) ; h = b & num ; sb . append ( h >= num ? ( str + h - num ) : ( str + h ) ) ; } out . text ( sb . to string ( ) ) ; out . end tag ( null , str ) ; }	flatten a byte [ ] into an xmlserializer.
void start custom exception handler ( ) { list < crash reporting service > services = get enabled services for type ( crash reporting service . class ) ; if ( services != null && ! services . is empty ( ) ) { if ( custom exception handler == null ) { custom exception handler = new custom exception handler ( context , services , foam api keys . wifi only ( ) ) ; } if ( ! custom exception handler . is running ( ) ) { custom exception handler . start ( ) ; } } }	start foam custom exception handler class .
public string clusterer tip text ( ) { return str ; }	returns the tip text for this property.
@ safe varargs public final assert subscriber < t > assert values ( t ... expected values ) { return assert value sequence ( arrays . as list ( expected values ) ) ; }	assert the specified values have been received in the declared order.
void reset ( ) { system . arraycopy ( iv , num , counter , num , block size ) ; used = block size ; }	resets the iv to its original value.
private void test equals ignore case ( locale locale ) { locale default locale = locale . get default ( ) ; locale . set default ( locale ) ; try { for ( string a : latin i variants ) { for ( string b : latin i variants ) { if ( ! a . equals ignore case ( b ) ) { fail ( str + a + str + b + str + locale ) ; } } } } finally { locale . set default ( default locale ) ; } }	string . equalsignorecase should not depend on the locale .
public void test radix out of range ( ) { string value = str ; int radix = num ; big integer a number = new big integer ( value , radix ) ; string result = a number . to string ( num ) ; assert true ( result . equals ( value ) ) ; }	if 36 < radix < 2 it should be set to 10.
private void send trap pdu ( inet address addr , snmp pdu packet pdu ) throws snmp status exception , io { snmp message msg = null ; try { msg = ( snmp message ) pdu factory . encode snmp pdu ( pdu , buffer size ) ; if ( msg == null ) { throw new snmp status exception ( snmp definitions . snmp rsp authorization error ) ; } } catch ( snmp too big exception x ) { if ( snmp adaptor logger . is loggable ( level . finest ) ) { snmp adaptor logger . logp ( level . finest , dbg tag , str , str + str ) ; } throw new snmp status exception ( snmp definitions . snmp rsp too big ) ; } open trap socket if needed ( ) ; if ( addr != null ) { msg . address = addr ; try { send trap message ( msg ) ; } catch ( snmp too big exception x ) { if ( snmp adaptor logger . is loggable ( level . finest ) ) { snmp adaptor logger . logp ( level . finest , dbg tag , str , str + str + msg . address ) ; } } } close trap socket if needed ( ) ; }	send the specified trap pdu to the specified destination .
private void add storage files with retry ( business object data key business object data key , uploader input manifest dto manifest , s3 file transfer request params dto params , string storage name , integer max retry attempts , integer retry delay secs ) throws io , jaxb , uri { int retry count = num ; while ( bool ) { try { uploader web client . add storage files ( business object data key , manifest , params , storage name ) ; break ; } catch ( io | jaxb | uri e ) { if ( retry count >= max retry attempts ) { logger . warn ( str + max retry attempts + str ) ; throw e ; } else { logger . warn ( str , e . to string ( ) , e ) ; logger . warn ( str + retry delay secs + str + ( max retry attempts - retry count ) + str ) ; retry count ++ ; herd thread helper . sleep ( retry delay secs * num ) ; } } } }	add storage files to a business object data with a retry on error .
public string data type ( byte [ ] buf ) { this . s = new string ( buf , charset . for name ( str ) ) ; }	construct a stringdatatype from the bytes in buf .
public workflow . method zone rollback method ( uri export group uri , string context key ) { return new workflow . method ( str , export group uri , context key ) ; }	returns the workflow . method for a zonerollback operation .
public long nswap ( ) { return long . parse long ( fields [ num ] ) ; }	number of pages swapped ( not maintained ) .
private date helper ( ) { }	prevent initializing this class .
public static string to string ( char [ ] [ ] c ) { string buffer sb = new string buffer ( ) ; for ( int i = num , max = c . length ; i < max ; ++ i ) { if ( i != num ) sb . append ( str ) ; sb . append ( c [ i ] ) ; } return sb . to string ( ) ; }	converts a char [ ] [ ] to string , where segments are separated by '.
private void create hosts ( test environment cloud store environment , list < host service . state > hosts ) throws throwable { for ( host service . state host : hosts ) { operation result = cloud store environment . send post and wait ( host service factory . self link , host ) ; assert that ( result . get status code ( ) , equal to ( num ) ) ; } }	given the host descriptions created by createhostdescriptions , post them to cloudstore .
protected void autoscale axes ( ) { if ( data . is empty ( ) ) { return ; } for ( string axis name : get axes names ( ) ) { autoscale axis ( axis name ) ; } }	tries to automatically set the ranges of all axes that are set to auto - scale .
public string to string ( ) { string builder buf = new string builder ( ) ; buf . append ( str ) ; buf . append ( type ) ; int len = values . length ( ) ; if ( len > num ) { buf . append ( str ) ; boolean first = bool ; for ( pair < method symbol , attribute > value : values ) { if ( ! first ) buf . append ( str ) ; first = bool ; name name = value . fst . name ; if ( len > num || name != name . table . names . value ) { buf . append ( name ) ; buf . append ( str ) ; } buf . append ( value . snd ) ; } buf . append ( str ) ; } return buf . to string ( ) ; }	returns a string representation of this annotation . string is of one of the forms :.
protected void add line ( print writer file , string string ) { log . debug ( string ) ; if ( file != null ) { file . println ( string ) ; } }	writes string to file.
@ override public int count by field2 ( boolean field2 ) { finder path finder path = finder path count by fiel ; object [ ] finder args = new object [ ] { field2 } ; long count = ( long ) finder cache . get result ( finder path , finder args , this ) ; if ( count == null ) { string bundler query = new string bundler ( num ) ; query . append ( sql count foo where ) ; query . append ( finder column fiel fiel 2 ) ; string sql = query . to string ( ) ; session session = null ; try { session = open session ( ) ; query q = session . create query ( sql ) ; query pos q pos = query pos . get instance ( q ) ; q pos . add ( field2 ) ; count = ( long ) q . unique result ( ) ; finder cache . put result ( finder path , finder args , count ) ; } catch ( exception e ) { finder cache . remove result ( finder path , finder args ) ; throw process exception ( e ) ; } finally { close session ( session ) ; } } return count . int value ( ) ; }	returns the number of foos where field2 = & # 63 ; .
public static void fill rectange ( d g2 d , j c , boolean round ) { compiere color cc = null ; boolean std cc = c . get client property ( compiere look and feel . background fill ) != null ; try { cc = ( compiere color ) c . get client property ( compiere look and feel . background ) ; } catch ( exception e ) { std cc = bool ; } if ( std cc ) cc = compiere color . get default background ( ) ; if ( cc != null ) { cc . paint ( g2 d , c ) ; } else { paint paint = c . get background ( ) ; g2 d . set paint ( paint ) ; rectangular shape rec = null ; if ( round ) rec = new d . float ( num , num , c . get width ( ) , c . get height ( ) , num , num ) ; else rec = new rectangle ( num , num , c . get width ( ) , c . get height ( ) ) ; g2 d . fill ( rec ) ; } }	fill background with color . ( ususlly called from update methods ).
public workflow . method update consistency group read only state method ( list < uri > vplex volume ur , boolean is read only ) { return new workflow . method ( str , vplex volume ur , is read only ) ; }	method to update consistencygroup read - only state , must match args of updateconsistencygroupreadonlystate ( except stepid ).
public void test create document type1 ( ) throws throwable { string public id = str ; string system id = str ; string malformed name = str ; document doc ; dom dom impl ; doc = ( document ) load ( str , builder ) ; dom impl = doc . get implementation ( ) ; { boolean success = bool ; try { dom impl . create document type ( malformed name , public id , system id ) ; } catch ( dom ex ) { success = ( ex . code == dom . namespace err ) ; } assert true ( str , success ) ; } }	runs the test case .
protected boolean is temporary destination ( ) { boolean result = bool ; if ( m queue name . starts with ( temp queue prefix ) ) { result = bool ; } return result ; }	this method determines whether a particular destination instance refers to a temporary destination .
public double gaussian potential upside ( double percentile ) { ql . require ( percentile < num && percentile >= num , str ) ; double result = gaussian percentile ( percentile ) ; return math . max ( result , num ) ; }	percentile must be in range [ 90 % - 100 % ).
void add rule ( int start year , int end year , int month , int day of month indicator , int day of week , local time time , boolean time end of day , time definition time definition , int saving amount secs ) { if ( fixed saving amount secs != null ) { throw new illegal state exception ( str ) ; } if ( rule list . size ( ) >= num ) { throw new illegal state exception ( str ) ; } boolean last rule = bool ; if ( end year == year max value ) { last rule = bool ; end year = start year ; } int year = start year ; while ( year <= end year ) { tz rule = new tz ( year , month , day of month indicator , day of week , time , time end of day , time definition , saving amount secs ) ; if ( last rule ) { last rule list . add ( rule ) ; } else { rule list . add ( rule ) ; } max last rule start year = math . max ( start year , max last rule start year ) ; year ++ ; } }	adds a rule to the current window .
public void remove mapping ( string virtual ) throws expression exception , security exception { check write access ( ) ; remove mapping ( virtual ) ; }	delete a mapping on system.
protected boolean track message ( function streaming reply message m ) { this . msgs processed ++ ; if ( m . is last message ( ) ) { this . num msgs = m . get message number ( ) + num ; } return this . msgs processed == this . num msgs ; }	return true if this is the very last reply msg to process for this member.
protected < t > void register service ( class < t > clazz , t instance ) { application container . register component instance ( clazz . get name ( ) , instance ) ; }	register your mock implementations here before executing your test cases .
@ suppress warnings ( str ) @ override public void run ( ) { synchronized ( thread monitor object ) { if ( incoming queue . is empty ( ) ) { try { thread monitor object . wait ( ) ; } catch ( interrupted exception e ) { logger . error ( str ) ; } } } while ( handler enabled || ! incoming queue . is empty ( ) ) { while ( ! incoming queue . is empty ( ) ) { synchronized ( thread monitor object ) { incoming queue . drain to ( copy list ) ; } while ( ! copy list . is empty ( ) ) { try { method to call . invoke ( object to call , copy list . poll first ( ) ) ; } catch ( illegal argument exception e ) { logger . error ( str , e . get message ( ) ) ; } catch ( illegal access exception e ) { logger . error ( str , e . get message ( ) ) ; } catch ( invocation target exception e ) { logger . error ( str , e . get message ( ) ) ; } catch ( exception e ) { logger . error ( str , e . get message ( ) ) ; } } } synchronized ( thread monitor object ) { if ( incoming queue . is empty ( ) ) { try { thread monitor object . wait ( ) ; } catch ( interrupted exception e ) { logger . error ( str ) ; e . print stack trace ( ) ; } } } } }	start the thread . expires once shutdown has been called .
static void merge sort no copy ( final int [ ] x , final int [ ] y , final int [ ] aux x , final int [ ] aux y , final int to index , final int insertion sort index ) { if ( ( to index > x . length ) || ( to index > y . length ) || ( to index > aux x . length ) || ( to index > aux y . length ) ) { throw new array index out of bounds exception ( str + to index ) ; } merge sort ( x , y , x , aux x , y , aux y , insertion sort index , to index ) ; if ( ( insertion sort index == num ) || ( aux x [ insertion sort index - num ] <= aux x [ insertion sort index ] ) ) { system . arraycopy ( aux x , num , x , num , to index ) ; system . arraycopy ( aux y , num , y , num , to index ) ; return ; } for ( int i = num , p = num , q = insertion sort index ; i < to index ; i ++ ) { if ( ( q >= to index ) || ( ( p < insertion sort index ) && ( aux x [ p ] <= aux x [ q ] ) ) ) { x [ i ] = aux x [ p ] ; y [ i ] = aux y [ p ] ; p ++ ; } else { x [ i ] = aux x [ q ] ; y [ i ] = aux y [ q ] ; q ++ ; } } }	modified merge sort : input arrays are in both auxx / auxy ( sorted : 0 to insertionsortindex ) and x / y ( unsorted : insertionsortindex to toindex ) outputs are stored in x / y arrays.
public script builder op ( int opcode ) { return op ( chunks . size ( ) , opcode ) ; }	adds the given opcode to the end of the program .
public void add flakes ( int quantity ) { for ( int i = num ; i < quantity ; ++ i ) { flakes . add ( flake . create flake ( get width ( ) , droid , get context ( ) ) ) ; } set num flakes ( num flakes + quantity ) ; }	add the specified number of droidflakes .
public void add ( component comp , object constraints ) { if ( comp == null ) { throw new runtime exception ( str ) ; } if ( comp instanceof dock wrapper ) { debug . error ( str ) ; super . add ( comp , constraints ) ; } else { if ( constraints . equals ( background ) ) { background = ( j ) comp ; super . add ( comp , constraints ) ; set layer ( comp , background layer . int value ( ) ) ; } else if ( constraints instanceof dock constraint ) { if ( comp instanceof j ) { j t = ( j ) comp ; t . set floatable ( bool ) ; } set constraint ( ( j ) comp , ( dock constraint ) constraints ) ; if ( ! already added ( comp ) ) { create dock wrapper ( ( j ) comp ) ; } } else { debug . error ( str + constraints ) ; } } }	we need to handle adding the component specially.
public shape create slider thumb discrete ( final int x , final int y , final int w , final int h , final corner size size ) { final double top arc = size . get radius ( w , h ) ; final double bottom arc h = size == corner size . interior ? num : num ; final double bottom arc w = num ; path . reset ( ) ; path . move to ( x , y + top arc ) ; path . quad to ( x , y , x + top arc , y ) ; path . line to ( x + w - top arc , y ) ; path . quad to ( x + w , y , x + w , y + top arc ) ; path . line to ( x + w , y + h / num ) ; path . quad to ( x + w - bottom arc w , y + h - bottom arc h , x + w / num , y + h ) ; path . quad to ( x + bottom arc w , y + h - bottom arc h , x , y + h / num ) ; path . close path ( ) ; return path ; }	return a path for a discrete slider thumb ' s concentric sections .
public sms text message ( string msg ) { if ( haswidth char ( msg ) ) set text ( msg , sms dcs . get general data coding dcs ( sms alphabet . uc , sms msg class . class unknown ) ) ; else set text ( msg , sms dcs . get general data coding dcs ( sms alphabet . ascii , sms msg class . class unknown ) ) ; }	creates an smstextmessage with default 7bit gsm alphabet.
protected < t > database make simple database ( string filename , int expected size ) { return make simple database ( filename , expected size , new list parameterization ( ) , null ) ; }	generate a simple doublevector database from a file .
private static boolean is partition tag ( string [ ] partitions , string tag name ) { if ( partitions != null ) { for ( string partition : partitions ) { if ( partition . equals ( tag name ) ) { return bool ; } } } return bool ; }	check if the tagname is one of the partition tags.
protected void on no update ( ) { if ( log configuration . logging is enabled ( ) ) { logger . log ( level . info , str ) ; } ui handler . hide message ( ) ; updating = bool ; fire application cache event ( cache event . on noupdate ) ; }	called when a noupdate event is triggered.
private boolean is noise word ( string term ) { int len = term . length ( ) ; if ( min word len > num && len < min word len ) { return bool ; } if ( max word len > num && len > max word len ) { return bool ; } return stop words != null && stop words . contains ( term ) ; }	determines if the passed term is likely to be of interest in " more queryfromdocuments " comparisons.
@ override public inet address address remote ( ) { socket channel s = channel ; if ( s != null ) { try { inet socket address addr = ( inet socket address ) s . get remote address ( ) ; return addr . get address ( ) ; } catch ( io e ) { throw new runtime exception ( e ) ; } } else { return null ; } }	returns the remote client ' s inet address .
public boolean is annotation present ( object object , string property , class < ? extends annotation > annotation class ) { objects . require non null ( object , str ) ; return is annotation present ( object . get class ( ) , property , annotation class ) ; }	determine whether the given annotation is present in the object ' s class or in any of its superclasses .
public static matrix read lav ( string file name , boolean ignore first line ) { linked list < string > file rows = general lib . read file rows ( file name ) ; matrix string matrix = new matrix ( ) ; int max number of tabs = num ; for ( string row : file rows ) { int number of tabs = row . split ( str ) . length ; if ( number of tabs > max number of tabs ) { max number of tabs = number of tabs ; } } for ( string row : file rows ) { string [ ] columns = row . split ( str ) ; int number of tabs = columns . length ; if ( number of tabs == max number of tabs ) { if ( ignore first line ) { ignore first line = bool ; } else { array list < string > row list = general lib . convert string array to array list ( columns ) ; string matrix . add row ( row list ) ; } } else { debug lib . empty function for setting break point ( ) ; } } if ( string matrix . get number of rows ( ) == num ) { debug lib . stop system and report inconsistency ( str + max number of tabs ) ; } return string matrix ; }	todo : write test for this .
void load image ( string src , image loading span loading span ) ;	a callback to load an image found in a markdown document .
private array list < string > split values ( array list < string > values , preset item preset , string key ) { array list < string > result = new array list < string > ( ) ; string delimiter = matcher . quote replacement ( str + preset . get delimiter ( key ) + str ) ; if ( values == null ) { return null ; } for ( string v : values ) { if ( v == null ) { return null ; } for ( string s : v . split ( delimiter ) ) { result . add ( s . trim ( ) ) ; } } return result ; }	split multi select values with the preset defined delimiter character.
public void clear account disabled state ( ) { operations . add ( password policy state operation type . clear account disabled state ) ; }	clears the account disabled state .
public static < t > collection < t > intersection ( collection < t > c1 , collection < t > c2 ) { set < t > set1 = new hash set < > ( c1 ) ; set1 . retain all ( new hash set < > ( c2 ) ) ; return set1 ; }	returns the intersection of the given collections .
public boolean is protected ( ) { return modifier . is protected ( flags ) ; }	utility method to query the modifier flags of this member .
public void skip bytes ( long length ) throws io { long skipped = num ; while ( skipped < length ) { int val = in . read ( ) ; if ( val < num ) { throw new io ( str ) ; } skipped ++ ; } bytes read += length ; }	skip a number of bytes from the input stream.
@ suppress warnings ( str ) public static collection < x509 certificate > read certificates ( string base64data ) throws exception { try ( input stream is = new byte array input stream ( decode base64 ( base64data ) ) ) { return ( collection < x509 certificate > ) cert factory . generate certificates ( is ) ; } }	reads x509certificate object from given base64 data .
public static void o ( double [ ] [ ] a ) { o ( a , parameters . output field width , parameters . output frac places ) ; }	prints a 2 - dimensional array of doubles in default e format .
@ override public list < event object > retrieve headless events ( ) { return m headless events ; }	get the list of events processed in headless mode . may return null or an empty list if not running in headless mode or no events were processed.
public version ( string version ) throws version exception { this ( version , str ) ; }	construct a version object from the supplied string assuming that the string delimiter used is '.
private void enlarge capacity ( int key ) { int diff = off count - offset ; int min capacity = math . max ( arr . length , key + offset + diff + num ) ; if ( min capacity > arr . length ) { int old capacity = arr . length ; int new capacity = old capacity + ( old capacity > > num ) ; if ( new capacity - min capacity < num ) new capacity = min capacity ; if ( new capacity - max array size > num ) new capacity = huge capacity ( min capacity ) ; arr = arrays . copy of ( arr , new capacity ) ; } }	! ! ! all methods that use this method must be sync enlarge the inner array to given size.
public d ( j parent ) { super ( parent ) ; set title ( res . get string ( str ) ) ; init components ( ) ; }	creates a new dnetscapecertificaterenewalurl dialog .
default < v > throwing bi function < t1 , t2 , v , e > and then ( final throwing function < ? super r , ? extends v , e > after ) { objects . require non null ( after ) ; return null ; }	performs provided action on the result of this throwingbifunction instance.
public collection < m > offer m ( ) { return collections . empty set ( ) ; }	optionally allow the directoryfactory to request registration of some mbeans .
public boolean is pannable ( ) { return pannable ; }	returns whether the plot area in the panel can be panned .
private static string [ ] fracture ( string str , string sep ) { if ( str . length ( ) == num ) { return new string [ num ] ; } array list < string > res = new array list < string > ( ) ; int in = num ; int cur pos = num ; int i = str . index of ( sep ) ; int len = sep . length ( ) ; while ( i != - num ) { string s = str . substring ( cur pos , i ) ; res . add ( s ) ; in ++ ; cur pos = i + len ; i = str . index of ( sep , cur pos ) ; } len = str . length ( ) ; if ( cur pos <= len ) { string s = str . substring ( cur pos , len ) ; in ++ ; res . add ( s ) ; } return res . to array ( new string [ in ] ) ; }	helper method to avoid stringtokenizer using .
protected boolean synthesized element ( element elem ) { if ( match name attribute ( elem . get attributes ( ) , html . tag . implied ) ) { return bool ; } return bool ; }	returns true if the element is a synthesized element.
public static void write xml ( document doc , string filename ) { try { transformer factory transformer factory = transformer factory . new instance ( ) ; transformer transformer ; transformer = transformer factory . new transformer ( ) ; transformer . set output property ( output keys . indent , str ) ; dom source = new dom ( doc ) ; stream result result = new stream result ( new file ( filename ) ) ; transformer . transform ( source , result ) ; log . fine ( str + filename + str ) ; } catch ( transformer configuration exception e ) { log . warning ( e . get message ( ) ) ; } catch ( transformer exception e ) { log . warning ( e . get message ( ) ) ; } }	writes the xml document to the particular file specified as argument.
public set < string > sub entries ( sso token , string obj name , string filter , int num of entries , boolean sort results , boolean ascending order ) throws sms , sso { if ( ( obj name == null ) || ( obj name . length ( ) == num ) || ( filter == null ) || ( filter . length ( ) == num ) || ( num of entries < num ) ) { throw new illegal argument exception ( str + str + str + obj name == null ? str : obj name + str + filter == null ? str : filter + str ) ; } set < string > subentries = null ; try { subentries = get sub entries ( obj name , filter , null , num of entries , sort results , ascending order ) ; } catch ( service not found exception e ) { subentries = new case insensitive hash set ( ) ; } if ( m debug . message enabled ( ) ) { m debug . message ( str + str + filter + str + obj name + str + subentries . size ( ) + str ) ; } return subentries ; }	returns a set of sub - entry names that match the given filter .
final public boolean ends with ignore case ( final string suffix ) { final int l = suffix . length ( ) ; int length = length ( ) ; if ( l > length ) return bool ; int i = l ; final char [ ] a = array ; char c , d ; while ( i -- != num ) { c = character . to lower case ( character . to upper case ( suffix . char at ( i ) ) ) ; d = character . to lower case ( character . to upper case ( a [ -- length ] ) ) ; if ( c != d ) return bool ; } return bool ; }	returns whether this mutable string ends with the given string disregarding case .
public kl ( string device ) { try { set device name ( device ) ; } catch ( exception ex ) { log . fatal ( ex ) ; } comm timer = new timer ( comm timeout time , comm timeout handler ) ; comm timer . set initial delay ( comm timeout time ) ; comm timer . stop ( ) ; }	construct with connecting to device.
public static double gamma ( double z ) { if ( z < num ) { return ( internalgamma ( z ) ) ; } else { double multiplier = math . floor ( z / num ) ; double remainder = z / multiplier ; double coef1 = math . pow ( num * math . pi , ( num * ( num - multiplier ) ) ) ; double coef2 = math . pow ( multiplier , ( ( multiplier * remainder ) - num ) ) ; int n = ( int ) multiplier ; double prod = num ; for ( int k = num ; k < n ; k ++ ) { prod *= internalgamma ( remainder + ( ( double ) k / multiplier ) ) ; } return coef1 * coef2 * prod ; } }	gamma function ( from dstat , used by permission ).
public void add page ( lexicon page page ) { pages . add ( page ) ; }	adds a page to the list of pages .
public static number format make number format ( int digits ) { switch ( digits ) { case num : return n ; case num : return n ; case num : return n ; case num : return n ; case num : return n ; case num : return n ; } final number format nf = number format . get instance ( locale . us ) ; nf . set maximum fraction digits ( digits ) ; nf . set minimum fraction digits ( digits ) ; nf . set grouping used ( bool ) ; return nf ; }	initialize a number format with elki standard options ( us locale , no grouping ) .
public static synchronized type t array ( type elem ) { string sig = new string ( sig array + elem . get type signature ( ) ) ; type t = ( type ) type hash . get ( sig ) ; if ( t == null ) { t = new array type ( sig , elem ) ; } return t ; }	create an array type .
@ override public void read external ( object input in ) throws io , class not found exception { super . read external ( in ) ; this . knn distance = in . read double ( ) ; }	calls the super method and reads the knn distance of this entry from the specified input stream .
public static boolean contains ( string s1 , string s2 ) { if ( s1 == null || s2 == null ) { return bool ; } return s1 . contains ( s2 ) ; }	check if one string contains another string .
public static void main ( string [ ] args ) throws io { list < byte > bin book = create bin book ( ) ; file output stream out = new file output stream ( str ) ; int book len = bin book . size ( ) ; byte [ ] bin book a = new byte [ book len ] ; for ( int i = num ; i < book len ; i ++ ) bin book a [ i ] = bin book . get ( i ) ; out . write ( bin book a ) ; out . close ( ) ; }	creates the book . bin file .
@ override public void draw ( d g2 , dial plot plot , d frame , d view ) { d f = dial plot . rectangle by radius ( frame , this . radius , this . radius ) ; d arc = new d . double ( f , this . angle , num , d . open ) ; d pt = arc . get start point ( ) ; g2 . set paint ( this . paint ) ; g2 . set font ( this . font ) ; text utilities . draw aligned string ( this . label , g2 , ( float ) pt . get x ( ) , ( float ) pt . get y ( ) , this . anchor ) ; }	draws the background to the specified graphics device.
public void remove ( t line ) { int idx = list . index of ( line ) ; if ( idx != - num ) remove ( idx ) ; }	helper - function that resolves to remove ( int ).
public string pickup engine ( engine engine ) { string builder builder = new string builder ( ) ; for ( string attribute : setup . get pickup engine message format ( ) ) { builder . append ( get engine attribute ( engine , attribute , pickup ) ) ; } return builder . to string ( ) ; }	returns the pick up string for a loco.
public generator property iterator panel ( experiment exp ) { this ( ) ; set experiment ( exp ) ; }	creates the property iterator panel and sets the experiment .
private void add global attributes to intent ( intent intent ) { if ( ! intent . has extra ( event . attribute time ) ) { insert time stamp ( intent ) ; } if ( ! intent . has extra ( event . attribute location ) ) { insert location data ( intent ) ; } }	add global attributes of an event to the extra values of the intent .
public static string to string ( local date time data , string modelo ) { return data == null ? str : data . format ( formatter ( modelo ) ) ; }	converte localdatetime para string indicando o formato da tostring.
public dns add answer ( dns in , inet address addr , int port , dns out , dns rec ) throws io { dns new out = out ; if ( new out == null ) { new out = new dns ( dns . flags qr response | dns . flags aa , bool , in . get sender udp ( ) ) ; } try { new out . add answer ( in , rec ) ; } catch ( final io e ) { new out . set flags ( new out . get flags ( ) | dns . flags tc ) ; new out . set id ( in . get id ( ) ) ; send ( new out ) ; new out = new dns ( dns . flags qr response | dns . flags aa , bool , in . get sender udp ( ) ) ; new out . add answer ( in , rec ) ; } return new out ; }	add an answer to a question . deal with the case when the outgoing packet overflows.
public int dns domain levels ( string host ) { int count = num ; int start pos = num ; while ( ( start pos = host . index of ( str , start pos + num ) ) > - num ) { count ++ ; } return count ; }	returns the number of dns domain levels ( number of dots ) in the host name .
public boolean is overwrite ( ) { return overwrite ; }	checks if is overwrite .
private list < pair < scene view , scene view > > images with common features ( double n , list < scene view > img list ) { list < pair < scene view , scene view > > images = new array list < > ( ) ; for ( int i = num ; i < img list . size ( ) ; i ++ ) { scene view img i = img list . get ( i ) ; for ( int j = num ; j < img list . size ( ) ; j ++ ) { if ( j > i ) { scene view img j = img list . get ( j ) ; collection < feature > f = img j . get common features ( img i ) ; if ( f . size ( ) >= n ) { images . add ( new pair < > ( img i , img j ) ) ; } } } } return images ; }	returns list of pairs of images with common features.
@ override public boolean write ( byte [ ] data , int offset , int length ) throws io { if ( m seq size + length <= m limit ) { m seq data . write ( data , offset , length ) ; m seq size += length ; m checksum seq . update ( data , offset , length ) ; return bool ; } return bool ; }	writes sequence bytes to disk .
private static string read as string ( input stream stream ) throws io { string writer writer = new string writer ( ) ; reader reader = new buffered reader ( new input stream reader ( stream , str ) ) ; while ( bool ) { int c = reader . read ( ) ; if ( c < num ) { break ; } writer . write ( c ) ; } return writer . to string ( ) ; }	reads an inputstream and converts it to a string .
public final double squared distance ( final int x , final int y ) { final double other middle x = x + num ; final double other middle y = y + num ; final d this area = get area ( ) ; final double this middle x = this area . get center x ( ) ; final double this middle y = this area . get center y ( ) ; double x distance = math . abs ( other middle x - this middle x ) - ( area . get width ( ) + num ) / num ; double y distance = math . abs ( other middle y - this middle y ) - ( area . get height ( ) + num ) / num ; if ( x distance < num ) { x distance = num ; } if ( y distance < num ) { y distance = num ; } return x distance * x distance + y distance * y distance ; }	this returns square of the distance from this entity to a specific point.
@ override public boolean equals ( object p test ) { if ( p test instanceof uri ) { uri test uri = ( uri ) p test ; if ( ( ( m scheme == null && test uri . m scheme == null ) || ( m scheme != null && test uri . m scheme != null && m scheme . equals ( test uri . m scheme ) ) ) && ( ( m userinfo == null && test uri . m userinfo == null ) || ( m userinfo != null && test uri . m userinfo != null && m userinfo . equals ( test uri . m userinfo ) ) ) && ( ( m host == null && test uri . m host == null ) || ( m host != null && test uri . m host != null && m host . equals ( test uri . m host ) ) ) && m port == test uri . m port && ( ( m path == null && test uri . m path == null ) || ( m path != null && test uri . m path != null && m path . equals ( test uri . m path ) ) ) && ( ( m query string == null && test uri . m query string == null ) || ( m query string != null && test uri . m query string != null && m query string . equals ( test uri . m query string ) ) ) && ( ( m fragment == null && test uri . m fragment == null ) || ( m fragment != null && test uri . m fragment != null && m fragment . equals ( test uri . m fragment ) ) ) ) { return bool ; } } return bool ; }	determines if the passed - in object is equivalent to this uri .
public sam region restriction ( region restriction restriction ) { super ( restriction . get sequence name ( ) , restriction . get start ( ) , restriction . get end ( ) ) ; }	restriction to named template sequence , accepts restrictions of the form name , name : start - end or name : start + length .
public void restore files from directory ( file directory ) throws io { log . debug ( str , directory . get absolute path ( ) ) ; copy backup set ( directory , get operations root ( ) ) ; }	restores a backup set from the given directory .
protected boolean is empty ( byte buffer bbuf ) { switch ( layer type ) { case none : case footprint : case viewshed : case derivative : break ; case elevation : case field : float buffer fbuf = bbuf . as float buffer ( ) ; int fl = fbuf . limit ( ) ; for ( int i = num ; i < fl ; ++ i ) { if ( ! float . is na n ( fbuf . get ( i ) ) ) { return ( bool ) ; } } break ; case colorimage : int buffer ibuf = bbuf . as int buffer ( ) ; int il = ibuf . limit ( ) ; for ( int i = num ; i < il ; ++ i ) { if ( ibuf . get ( i ) != num ) { return ( bool ) ; } } break ; case grayimage : int bl = bbuf . limit ( ) ; for ( int i = num ; i < bl ; ++ i ) { if ( bbuf . get ( i ) != num ) { return ( bool ) ; } } break ; } return ( bool ) ; }	determine if a tile is empty.
public void update results ( ) { m result list . clear ( ) ; int count = num ; for ( int x = num ; x < m searchable list . size ( ) ; x ++ ) { search result searchable = m searchable list . get ( x ) ; if ( m search filter . on filter ( searchable , get search text ( ) ) && count < num ) { add result ( searchable ) ; count ++ ; } } if ( m result list . size ( ) == num ) { m results list view . set visibility ( view . gone ) ; } else { m results list view . set visibility ( view . visible ) ; } }	force an update of the results.
com ( string comment ) { super ( jpeg . com ) ; data = comment . get bytes ( ) ; }	constructs a marker segment from a string.
@ override public dom item ( int index ) { final int length = get length ( ) ; if ( index >= num && index < length ) { return ( dom ) f implementations . get ( index ) ; } return null ; }	returns the indexth item in the collection .
private boolean has idle invokers ( ) { for ( async event listener invoker invoker : this . scheduled invokers ) { if ( invoker . is idle ( ) ) { return bool ; } } return bool ; }	determine whether this listener container currently has any idle instances among its scheduled invokers .
public void add message listener ( release message listener listener ) { if ( ! listeners . contains ( listener ) ) { listeners . add ( listener ) ; } }	add message listeners for release message.
public command builder with long switch if present ( map < string , object > properties , unary operator < string > switch name mapper , string ... keys ) { for ( string key : keys ) { with long switch if present ( properties , key , switch name mapper . apply ( key ) ) ; } return this ; }	if the given key ( s ) is present in the map , create a long switch ( - - switch ) with the given transformation to create the switch name from the key.
public void generate partition ( instances data ) throws exception { if ( m instanceof partition generator ) build classifier ( data ) ; else throw new exception ( str + get classifier spec ( ) + str ) ; }	builds the classifier to generate a partition .
protected object evaluate single ( structured content element , string expr ) { return null ; }	override this element to handle testing a predicate expression with no comparator .
private segment create mapped segment ( segment descriptor descriptor ) { file segment file = segment file . create segment file ( name , storage . directory ( ) , descriptor . id ( ) , descriptor . version ( ) ) ; buffer buffer = mapped buffer . allocate ( segment file , math . min ( default buffer size , descriptor . max segment size ( ) ) , integer . max value ) ; descriptor . copy to ( buffer ) ; segment segment = new segment ( new segment file ( segment file ) , buffer . slice ( ) , descriptor , create index ( descriptor ) , new offset predicate ( ) , serializer . clone ( ) , this ) ; logger . debug ( str , segment ) ; return segment ; }	creates a new segment .
private static int limited levenshtein ( final string str1 , final string str2 , int idx1 , int idx2 , final int limit ) { while ( bool ) { if ( idx1 == str1 . length ( ) ) { return str2 . length ( ) - idx2 ; } else if ( idx2 == str2 . length ( ) ) { return str1 . length ( ) - idx1 ; } else if ( str1 . char at ( idx1 ) != str2 . char at ( idx2 ) ) { if ( limit < num ) { return num ; } else { return num + best lim lev ( str1 , str2 , idx1 , idx2 , limit - num ) ; } } ++ idx1 ; ++ idx2 ; } }	calculate the levenshtein distance of two strings using index arithmetic given a maximum distance value to terminate calculation.
protected managed resource ( string resource id , solr resource loader loader , io storage io ) throws solr exception { this . resource id = resource id ; this . solr resource loader = loader ; this . storage = create storage ( storage io , loader ) ; }	initializes this managed resource , including setting up json - based storage using the provided storageio implementation , such as zk .
@ data provider public object [ ] [ ] create rename test data ( ) { return new object [ ] [ ] { { str , str , str , str } , { str , str , str , str } , { str , str , str , str } , { str , str , str , str } , { str , str , str , str } , { str , str , str , str } , { str , str , str , str } } ; }	test data for testlocalname tests .
private static comparable cast to comparable ( object obj ) { try { return ( comparable ) obj ; } catch ( class cast exception cce ) { throw new illegal argument exception ( str + obj . get class ( ) + str + storage type . object + str , cce ) ; } }	cast the object to comparable otherwise throws an illegalargumentexception exception.
private void read object ( final java . io . object input stream in ) throws io , class not found exception { use on off swith = in . read boolean ( ) ; marker colors = ( marker colors ) in . read object ( ) ; }	deserialize the state of the object .
public boolean read bool ( ) throws io { return dis . read byte ( ) > num ; }	read a boolean from the input stream .
protected boolean [ ] can handle missing ( attr types attr types , int class type , boolean attribute missing , boolean class missing , int missing level ) { if ( missing level == num ) { print ( str ) ; } print ( str ) ; if ( attribute missing ) { print ( str ) ; if ( class missing ) { print ( str ) ; } } if ( class missing ) { print ( str ) ; } print ( str ) ; print attribute summary ( attr types , class type ) ; print ( str ) ; array list < string > accepts = new array list < string > ( ) ; accepts . add ( str ) ; accepts . add ( str ) ; accepts . add ( str ) ; int num train = get num instances ( ) , num test = get num instances ( ) , num classes = num ; int num atts = num , attr index = num ; return run basic test ( attr types , num atts , attr index , class type , missing level , attribute missing , class missing , num train , num test , num classes , accepts ) ; }	checks basic missing value handling of the scheme.
@ override public synchronized int last index of ( object object ) { return last index of ( object , element count - num ) ; }	searches in this vector for the index of the specified object.
public colorful square ( float r , float g , float b , float a ) { byte buffer bb = byte buffer . allocate direct ( square coords . length * num ) ; bb . order ( byte order . native order ( ) ) ; vertex buffer = bb . as float buffer ( ) ; vertex buffer . put ( square coords ) ; vertex buffer . position ( num ) ; byte buffer dlb = byte buffer . allocate direct ( draw order . length * num ) ; dlb . order ( byte order . native order ( ) ) ; draw list buffer = dlb . as short buffer ( ) ; draw list buffer . put ( draw order ) ; draw list buffer . position ( num ) ; color = new float [ ] { r , g , b , a } ; }	sets up the drawing object data for use in an opengl es context .
public static list < string > names ( collection < ? extends data object rest rep > values ) { list < string > names = new array list < string > ( ) ; if ( values != null ) { for ( data object rest rep value : values ) { names . add ( value . get name ( ) ) ; } } return names ; }	gets the names of the data objects , null safe.
public void start ( ) throws startup exception { }	start the startup class.
public field declaration declaration of ( field binding field binding ) { if ( field binding != null && this . fields != null ) { for ( int i = num , max = this . fields . length ; i < max ; i ++ ) { field declaration field decl ; if ( ( field decl = this . fields [ i ] ) . binding == field binding ) return field decl ; } } return null ; }	find the matching parse node , answers null if nothing found.
public static string byte array to hex string ( byte in [ ] , int offset ) { if ( in == null || in . length <= num || offset >= in . length ) return null ; string buffer out = new string buffer ( in . length * num ) ; for ( int i = offset ; i < in . length ; i ++ ) { out . append ( byte to hex string ( in [ i ] ) ) ; out . append ( str ) ; } return out . to string ( ) ; }	converts the given byte array into a readable hexa - decimal formatted string , starting from given offset < br > this code was originally taken from jeff boyle ' s article on devx . com.
public static int calc column width ( j table , int col ) { int result ; table model data ; int row count ; int row ; int dec ; component c ; result = calc header width ( table , col ) ; if ( result == - num ) return result ; data = table . get model ( ) ; row count = data . get row count ( ) ; dec = ( int ) math . ceil ( ( double ) row count / ( double ) max rows ) ; try { for ( row = row count - num ; row >= num ; row -= dec ) { c = table . prepare renderer ( table . get cell renderer ( row , col ) , row , col ) ; result = math . max ( result , c . get preferred size ( ) . width + num ) ; } } catch ( exception e ) { e . print stack trace ( ) ; } return result ; }	calculates the optimal width for the column of the given table.
public void reply ( list < header > response headers , boolean out ) throws io { assert ( ! thread . holds lock ( framed stream . this ) ) ; boolean out finished = bool ; synchronized ( this ) { if ( response headers == null ) { throw new null pointer exception ( str ) ; } if ( this . response headers != null ) { throw new illegal state exception ( str ) ; } this . response headers = response headers ; if ( ! out ) { this . sink . finished = bool ; out finished = bool ; } } connection . write syn reply ( id , out finished , response headers ) ; if ( out finished ) { connection . flush ( ) ; } }	sends a reply to an incoming stream .
static boolean should reconfigure ( property change event e ) { if ( e . get property name ( ) == null ) { synchronized ( abstract action . class ) { if ( reconfigure on null == null ) { reconfigure on null = boolean . value of ( access controller . do privileged ( new get property action ( str , str ) ) ) ; } return reconfigure on null ; } } return bool ; }	whether or not to reconfigure all action properties from the specified event .
public static boolean is banned ( string ip ) { for ( ip ip ban : ban list ) { if ( ip ban . is active ( ) && network utils . check ip ( ip ban . get mask ( ) , ip ) ) { return bool ; } } return bool ; }	checks if ip ( or mask ) is banned.
@ override public list < alarm model descriptor > alarm models ( ) { list < alarm model descriptor > descriptors = new array list < alarm model descriptor > ( ) ; for ( service reference < alarm model > model : models ) { descriptors . add ( model . meta info ( alarm model descriptor . class ) ) ; } return descriptors ; }	returns all the alarmmodels that has been installed .
public static object string to value ( string string ) { double d ; if ( string . equals ( str ) ) { return string ; } if ( string . equals ignore case ( str ) ) { return boolean . true ; } if ( string . equals ignore case ( str ) ) { return boolean . false ; } if ( string . equals ignore case ( str ) ) { return json . null ; } char b = string . char at ( num ) ; if ( ( b >= str && b <= str ) || b == str ) { try { if ( string . index of ( str ) > - num || string . index of ( str ) > - num || string . index of ( str ) > - num ) { d = double . value of ( string ) ; if ( ! d . is infinite ( ) && ! d . is na n ( ) ) { return d ; } } else { long my long = new long ( string ) ; if ( string . equals ( my long . to string ( ) ) ) { if ( my long . long value ( ) == my long . int value ( ) ) { return new integer ( my long . int value ( ) ) ; } else { return my long ; } } } } catch ( exception ignore ) { } } return string ; }	try to convert a string into a number , boolean , or null.
public static byte [ ] read ( input stream in ) throws io { byte array output stream out = new byte array output stream ( ) ; int read = num ; byte [ ] buff = new byte [ num ] ; while ( ( read = in . read ( buff ) ) > num ) { out . write ( buff , num , read ) ; } in . close ( ) ; out . flush ( ) ; out . close ( ) ; return out . to byte array ( ) ; }	reads an input stream and writes it to a byte array.
public static string replace all ( string source , string pattern , string replace ) { string builder sb = new string builder ( ) ; int idx = num ; string working source = source ; idx = working source . index of ( pattern ) ; if ( idx == - num ) { return source ; } while ( idx != - num ) { sb . append ( working source . substring ( num , idx ) ) ; sb . append ( replace ) ; working source = working source . substring ( idx + pattern . length ( ) ) ; idx = working source . index of ( pattern ) ; } sb . append ( working source ) ; return sb . to string ( ) ; }	this method replaces all occurrences of the pattern with the replacement string.
public set < word token > nearest words ( final int distance , predicate < dependency > predicate , final word token ... start ) { return nearest words ( distance , predicate , arrays . as list ( start ) ) ; }	find the nearest neighbours within dependency distance links of the provided start dependencies .
private void add exclude class node ( document node inline document node , node component root ) { meta data node inline exclude node = new meta data node ( component root . get namespace ( ) , component root . get local part ( ) , num ) ; inline exclude node . image = component root . image ; cdata exclude text node = new cdata ( ) ; exclude text node . image = str ; inline exclude node . add child ( exclude text node ) ; inline document node . add child ( inline exclude node ) ; }	adds excludeclass metadata to inline_component nodes .
protected void delete sun xml key val files ( file dir handle ) throws sms { string builder sb = new string builder ( sms . attr xml keyval ) ; sb . append ( str ) ; filename filter filter = new filename filter ( sb . to string ( ) ) ; file [ ] delete files = dir handle . list files ( filter ) ; for ( int i = num ; delete files != null && i < delete files . length ; i ++ ) { file delete file = delete files [ i ] ; delete file . delete ( ) ; } }	delete sunxmlkeyvalue files under the given directory .
public static multi state animation from json resource ( context context , int resid ) { return multi state animation . from json resource ( context , null , resid ) ; }	create a multistateanimation from a json resource without a connected view .
show dialog ( j frame ) { inner frame = frame ; }	defining the dialog ' s owner jframe is highly recommended .
public void sort ( ) { arrays . sort ( data , num , count ) ; }	sorts the array in place .
private list < string > array to list ( string [ ] array ) { return arrays . as list ( array ) ; }	turns an array of strings into an list of strings .
public static void align ( byte buffer blob ) { blob . position ( align ( blob . position ( ) ) ) ; }	aligns the supplied bytebuffer position to the next four byte boundary.
private void open log file ( ) throws io { try { close ( ) ; } catch ( io e ) { } log name = version name ( logfile prefix ) ; log = new random access file ( log name , str ) ; log fd = log . get fd ( ) ; if ( log bytes == num ) { format = format padded ; write int ( log , magic ) ; write int ( log , format ) ; log bytes = ( int bytes + int bytes ) ; } else { log . seek ( log bytes ) ; } log . set length ( log bytes ) ; log . write ( zero buf ) ; log fd . sync ( ) ; }	opens the incremental update log file in read / write mode.
public void add ( string key , string value ) { keys . add ( key ) ; values . add ( value ) ; }	add a key / value pair.
public variable [ ] find arrays in current scope ( ) { list < variable > arrays = new array list < variable > ( ) ; for ( list iterator < variable > iterator = f local variables . list iterator ( f local variables . size ( ) ) ; iterator . has previous ( ) ; ) { variable local variable = iterator . previous ( ) ; if ( local variable . is array ( ) ) arrays . add ( local variable ) ; } for ( list iterator < variable > iterator = f fields . list iterator ( f fields . size ( ) ) ; iterator . has previous ( ) ; ) { variable field = iterator . previous ( ) ; if ( field . is array ( ) ) arrays . add ( field ) ; } return arrays . to array ( new variable [ arrays . size ( ) ] ) ; }	returns all arrays , visible in the current context ' s scope , in the order that they appear .
public void write line number table ( environment env , data output stream out , constant pool tab ) throws io { long ln = - num ; int count = num ; for ( instruction inst = first ; inst != null ; inst = inst . next ) { long n = ( inst . where > > whereoffsetbits ) ; if ( ( n > num ) && ( ln != n ) ) { ln = n ; count ++ ; } } ln = - num ; out . write short ( count ) ; for ( instruction inst = first ; inst != null ; inst = inst . next ) { long n = ( inst . where > > whereoffsetbits ) ; if ( ( n > num ) && ( ln != n ) ) { ln = n ; out . write short ( inst . pc ) ; out . write short ( ( int ) ln ) ; } } }	write the linenumber table.
public static string download string ( url url , proxy proxy , int read timeout , int socket timeout , string encoding , int tries count ) { io last exception = null ; for ( int i = num ; i < tries count ; i ++ ) { last exception = null ; url connection = null ; input stream input stream = null ; try { connection = ( url ) ( proxy == null ? url . open connection ( ) : url . open connection ( proxy ) ) ; connection . set read timeout ( read timeout ) ; connection . set connect timeout ( socket timeout ) ; connection . connect ( ) ; input stream = connection . get input stream ( ) ; return io . to string ( input stream , encoding ) ; } catch ( io ex ) { if ( log . is debug enabled ( ) ) { log . warn ( str , url , tries count , ex ) ; } else { log . warn ( str , url , tries count , ex . get message ( ) ) ; } last exception = ex ; } finally { io . close quietly ( input stream ) ; if ( connection != null ) { connection . disconnect ( ) ; } } } if ( last exception != null ) { log . error ( str + url , last exception ) ; } return null ; }	downloads content from the specified url using specified proxy ( or do not using it ) and timeouts.
private jaxb < error response > create xml ( input stream is , object factory obj factory , batch response batch response , string parser error message ) { error response error response = obj factory . create error response ( ) ; dsml content handler = new dsml ( ) ; try { final xml xml reader = create safe xml ( ) ; xml reader . set content handler ( content handler ) ; is . reset ( ) ; xml reader . parse ( new input source ( is ) ) ; } catch ( parser configuration exception | sax | io e ) { } if ( parser error message != null ) { error response . set message ( parser error message ) ; } batch response . set request id ( content handler . request id ) ; error response . set type ( malformed request ) ; return obj factory . create batch response error response ( error response ) ; }	returns an error response after a parsing error.
public static date convert date ( value value , calendar calendar ) { if ( value == value null . instance ) { return null ; } value date d = ( value date ) value . convert to ( value . date ) ; calendar cal = ( calendar ) calendar . clone ( ) ; cal . clear ( ) ; cal . set lenient ( bool ) ; long date value = d . get date value ( ) ; set calendar fields ( cal , year from date value ( date value ) , month from date value ( date value ) , day from date value ( date value ) , num , num , num , num ) ; long ms = cal . get time in millis ( ) ; return new date ( ms ) ; }	convert the date to the specified time zone .
private void query and compare uif ( object ... params ) throws exception { final query response expect = query ( params ) ; final object [ ] new params = arrays . copy of ( params , params . length + num ) ; new params [ new params . length - num ] = str ; new params [ new params . length - num ] = str ; final query response uif result = query ( new params ) ; compare responses ( expect , uif result ) ; }	comparing results with facet . method = uif.
protected date time data parse ( string str ) throws schema date time exception { date time data date = new date time data ( str , this ) ; int len = str . length ( ) ; date . year = year ; if ( str . char at ( num ) != str || str . char at ( num ) != str ) { throw new schema date time exception ( str + str ) ; } date . month = parse int ( str , num , num ) ; int start = num ; if ( str . char at ( start ++ ) != str ) { throw new schema date time exception ( str + str ) ; } date . day = parse int ( str , start , start + num ) ; if ( monthday size < len ) { if ( ! is next char utc ( str , monthday size , len ) ) { throw new schema date time exception ( str + str ) ; } else { get time zone ( str , date , monthday size , len ) ; } } validate date time ( date ) ; save unnormalized ( date ) ; if ( date . utc != num && date . utc != str ) { normalize ( date ) ; } date . position = num ; return date ; }	parses , validates and computes normalized version of gmonthday object.
void resume ( ) { paused . set ( bool ) ; synchronized ( pause lock ) { pause lock . notify all ( ) ; } }	resumes engine work . paused " load & display " tasks will continue its work .
private boolean is closure call ( object receiver , string method ) { return receiver instanceof closure && closure call method . equals ( method ) ; }	determines if this method call is a call to a closure ( anonymous method ) defined within the script itself .
public void update with clear ( list < gank > data ) { m gank list . clear ( ) ; update ( data ) ; }	before add data , it will remove history data.
private static byte find longest expansion ( string uri string , int pos ) { byte expansion = - num ; int expansion length = num ; for ( int i = num ; i < url codes . size ( ) ; i ++ ) { int key = url codes . key at ( i ) ; string value = url codes . value at ( i ) ; if ( value . length ( ) > expansion length && uri string . starts with ( value , pos ) ) { expansion = ( byte ) key ; expansion length = value . length ( ) ; } } return expansion ; }	finds the longest expansion from the uri at the current position .
public void remove table model listener ( table model listener l ) { listener . remove ( l ) ; }	removes a listener from the list that is notified each time a change to the data model occurs .
public void shutdown ( ) { logger . info ( str ) ; executor . shutdown ( ) ; }	shuts down the executor.
public static command of ( aggregate id aggregate id , stream timestamp command timestamp , versioned name command name , tuple parameters , type result type ) { check not null ( aggregate id , str ) ; check not null ( command timestamp , str ) ; check not null ( command name , str ) ; check not null ( parameters , str ) ; check not null ( result type , str ) ; return new command ( aggregate id , command timestamp , optional . empty ( ) , command name , parameters , result type ) ; }	create a new command with the specified properties .
public synchronized boolean remove ( file file ) { if ( value . remove ( file ) ) { set value ( value ) ; return bool ; } else { return bool ; } }	mutator for this setting .
private set < dtn > select tracked hosts ( list < dtn > all hosts ) { set < dtn > tracked hosts = new hash set < dtn > ( ) ; if ( this . nrof hosts > all hosts . size ( ) ) { throw new settings error ( str + str ) ; } for ( int i = num ; i < nrof hosts ; i ++ ) { dtn next host = all hosts . get ( rng . next int ( all hosts . size ( ) ) ) ; if ( tracked hosts . contains ( next host ) ) { i -- ; } else { tracked hosts . add ( next host ) ; } } return tracked hosts ; }	randomly selects the hosts to track.
public static string join gt ( boolean phased , int ... gt ) { final char sep = phased ? phased separator : unphased separator ; switch ( gt . length ) { case num : return missing field ; case num : return encode id ( gt [ num ] ) ; case num : return encode id ( gt [ num ] ) + sep + encode id ( gt [ num ] ) ; default : final string builder sb = new string builder ( ) ; for ( final int c : gt ) { if ( sb . length ( ) > num ) { sb . append ( sep ) ; } sb . append ( encode id ( c ) ) ; } return sb . to string ( ) ; } }	utility method for creating a vcf genotype subfield from an array of numeric allele identifiers .
private static boolean is in corner target zone ( float x , float y , float handle x , float handle y , float target radius ) { if ( math . abs ( x - handle x ) <= target radius && math . abs ( y - handle y ) <= target radius ) { return bool ; } return bool ; }	determines if the specified coordinate is in the target touch zone for a corner handle .
@ override public boolean equals ( object o ) { if ( this == o ) { return bool ; } if ( o == null ) { return bool ; } if ( ! ( o instanceof column ) ) { return bool ; } column column = ( column ) o ; return objects . equals ( name , column . name ) ; }	allows comparison based solely on the name between objects of the base class and / or any of the derived classes .
public void truncate ( final long position ) { final int index = index ( position ) ; final int offset = offset ( position ) ; final block block = blocks . get ( index ) ; this . index = index ; block . limit = offset ; current = block ; }	resets the write buffer to a particular point .
public static double min ( final double a , final double b ) { if ( a > b ) { return b ; } if ( a < b ) { return a ; } if ( a != b ) { return double . n ; } long bits = double . double to raw long bits ( a ) ; if ( bits == num ) { return a ; } return b ; }	compute the minimum of two values.
@ override public void add data source listener ( data source listener dsl ) { m data listeners . add ( dsl ) ; }	add a datasource listener.
public static void train epochs ( regression data set data set , updateable regressor to train , int epochs ) { if ( epochs < num ) throw new illegal argument exception ( str ) ; to train . set up ( data set . get categories ( ) , data set . get num numerical vars ( ) ) ; int list random order = new int list ( data set . get sample size ( ) ) ; list utils . add range ( random order , num , data set . get sample size ( ) , num ) ; for ( int epoch = num ; epoch < epochs ; epoch ++ ) { collections . shuffle ( random order ) ; for ( int i : random order ) to train . update ( data set . get data point ( i ) , data set . get target value ( i ) ) ; } }	performs training on an updateable classifier by going over the whole data set in random order one observation at a time , multiple times .
private static iterator < string > parse ( class < ? > service , url u , set < string > returned ) throws service configuration error { input stream in = null ; buffered reader r = null ; array list < string > names = new array list < > ( ) ; try { in = u . open stream ( ) ; r = new buffered reader ( new input stream reader ( in , str ) ) ; int lc = num ; while ( ( lc = parse line ( service , u , r , lc , names , returned ) ) >= num ) ; } catch ( io x ) { fail ( service , str + x ) ; } finally { try { if ( r != null ) r . close ( ) ; if ( in != null ) in . close ( ) ; } catch ( io y ) { fail ( service , str + y ) ; } } return names . iterator ( ) ; }	parse the content of the given url as a provider - configuration file .
private static string root test class name ( string original class name ) { int period index = original class name . last index of ( str ) ; if ( period index != - num ) { return original class name . substring ( num , period index ) + str + original class name . substring ( period index ) ; } else { return str ; } }	creates a unique test class name.
public void save favorites to settings ( settings settings ) { if ( ! loaded favorites from settings ) { logger . warning ( str ) ; return ; } list < list > entries to save = new array list < > ( ) ; for ( favorite f : favorites . key set ( ) ) { entries to save . add ( favorite to list ( f , bool ) ) ; } for ( favorite f : favorites not found . values ( ) ) { if ( f . not found count > num ) { logger . warning ( str + f + str ) ; } else { entries to save . add ( favorite to list ( f , bool ) ) ; } } settings . put list ( str , entries to save ) ; }	saves the favorites to the settings , discarding any favorites that haven ' t been found several times already .
private void complete scroll ( boolean post events ) { boolean need populate = scroll state == scroll state settling ; if ( need populate ) { scroller . abort animation ( ) ; int old x = get scroll x ( ) ; int old y = get scroll y ( ) ; int x = scroller . get curr x ( ) ; int y = scroller . get curr y ( ) ; if ( old x != x || old y != y ) { scroll to ( x , y ) ; if ( x != old x ) { page scrolled ( x ) ; } } } populate pending = bool ; for ( int i = num ; i < items . size ( ) ; i ++ ) { item info ii = items . get ( i ) ; if ( ii . scrolling ) { need populate = bool ; ii . scrolling = bool ; } } if ( need populate ) { if ( post events ) { view compat . post on animation ( this , end scroll runnable ) ; } else { end scroll runnable . run ( ) ; } } }	complete a scroll in progress .
private void update block mirror consistency group ( ) { log . info ( str ) ; db client db client = get db client ( ) ; list < uri > block mirror ur = db client . query by type ( block mirror . class , bool ) ; iterator < block mirror > block mirrors = db client . query iterative objects ( block mirror . class , block mirror ur ) ; list < block object > block objects = new array list < block object > ( ) ; while ( block mirrors . has next ( ) ) { block objects . add ( block mirrors . next ( ) ) ; } migrate ( block objects ) ; }	update the blockmirror object to migrate the old consistencygroup field into the new consistencygroup list field .
public void add ( string text ) { if ( errors == null ) { errors = new array list < string > ( ) ; } errors . add ( text ) ; }	add the error to the list.
public static void fill repo links ( final channel information channel , final list < menu entry > links , final string base name , final int base priority , final string prefix , final int priority offset , final function < string , link target > target function ) { objects . require non null ( channel , str ) ; objects . require non null ( links , str ) ; objects . require non null ( base name , str ) ; objects . require non null ( prefix , str ) ; objects . require non null ( target function , str ) ; links . add ( new menu entry ( base name , base priority , prefix + str , priority offset , target function . apply ( channel . get id ( ) ) , modifier . link , null ) ) ; int i = num ; for ( final string name : channel . get names ( ) ) { final link target target = target function . apply ( name ) ; if ( target != null ) { links . add ( new menu entry ( base name , base priority , string . format ( str , prefix , name ) , priority offset + i , target , modifier . link , null ) ) ; } i ++ ; } }	create a set of default repository links.
public static string elapsed time display ( date date start , date date end ) { long diff = date end . get time ( ) - date start . get time ( ) ; long diff minutes = diff / ( num * num ) % num ; long diff hours = diff / ( num * num * num ) ; string mins = long . to string ( diff minutes ) ; if ( mins . length ( ) == num ) { mins = str + mins ; } return long . to string ( diff hours ) + str + mins ; }	elapsedtimedisplay get the elapsed time between two dates in readable format.
public int total ( ) { return counter . int value ( ) ; }	get the total number of events that have been handled by this listener .
@ override public void flush ( ) throws io { synchronized ( lock ) { check not closed ( ) ; flush internal ( ) ; out . flush ( ) ; } }	flushes this writer . the contents of the buffer are committed to the target writer and it is then flushed .
public host multipath info logical unit policy create multipath policy ( string name ) { if ( string utils . equals ignore case ( name , vmw psp fixed ) ) { host multipath info fixed logical unit policy policy = new host multipath info fixed logical unit policy ( ) ; policy . set policy ( name ) ; policy . set prefer ( str ) ; return policy ; } else { host multipath info logical unit policy policy = new host multipath info logical unit policy ( ) ; policy . set policy ( name ) ; return policy ; } }	create a multipath policy based on the passed policy name.
public tracker operation create tracker operation ( string source , string description ) { preconditions . check argument ( ! strings . is null or empty ( source ) , source is empty msg ) ; preconditions . check not null ( ! strings . is null or empty ( description ) , str ) ; tracker operation impl po = new tracker operation impl ( source . to upper case ( ) , description , this ) ; if ( save tracker operation ( source , po ) ) { return po ; } return null ; }	creates tracker operation and save it to db.
injector ( final map < class < ? > , object > map ) { not null ( map ) ; this . map = map ; }	mapping of classes to be annotated and the corresponding injected object .
public static void write data source ( print stream writer , data source ds ) { writer . print ( str ) ; writer . print ( ds . get jndi location ( ) ) ; writer . print ( str ) ; writer . print ( ds . get id ( ) ) ; writer . println ( str ) ; writer . print ( str ) ; writer . print ( ds . get connection type ( ) ) ; writer . print ( str ) ; writer . print ( ds . get driver class ( ) ) ; writer . println ( str ) ; writer . print ( str ) ; string url = ds . get url ( ) ; if ( url != null ) { writer . print ( str ) ; writer . print ( ds . get url ( ) ) ; writer . print ( str ) ; } write properties ( writer , ds . get connection properties ( ) ) ; writer . println ( str ) ; string user = ds . get username ( ) ; string pass = ds . get password ( ) ; if ( user != null && pass != null ) { writer . print ( str ) ; writer . print ( user ) ; writer . print ( str ) ; writer . print ( pass ) ; writer . println ( str ) ; } writer . println ( str ) ; }	writes a datasource to the write .
void downcase ( string buffer text , int leng ) { for ( int i = num ; i < leng ; i ++ ) { if ( character . is upper case ( text . char at ( i ) ) ) { text . set char at ( i , character . to lower case ( text . char at ( i ) ) ) ; } } }	lowercase the characters up to the given length.
private action button create toolbar button ( action action ) { return new action button ( action , action manager , presentation factory . get presentation ( action ) , manager provider . get ( ) , toolbar resources ) ; }	creates a toolbar button .
public void rearrange children ( int item count ) { array list < view > views = get items in reading order ( ) ; m content . arrange children ( views , math . max ( item count , views . size ( ) ) ) ; m items invalidated = bool ; }	rearranges the children based on their rank .
@ suppress warnings ( str ) public < u > lazy future stream < u > from ( final iterator < u > iterator ) { return from stream ( stream support . stream ( spliterators . spliterator unknown size ( iterator , spliterator . ordered ) , bool ) ) ; }	start a reactive flow from a jdk iterator.
public void add specific damage ( string s ) { int ew spot = s . index of ( str ) ; if ( s . is empty ( ) || ( ew spot < num ) ) { return ; } int loc = integer . parse int ( s . substring ( num , ew spot ) ) ; int set to = integer . parse int ( s . substring ( ew spot + num ) ) ; boolean rear = ( s . char at ( num ) == str ) ; boolean internal = ( s . char at ( num ) == str ) ; specific dammage . add ( new spec dam ( loc , set to , rear , internal ) ) ; }	converts n2 : 1 to nornam hit to location 2 set armor to 1 !.
private byte [ ] [ ] extract i ( byte [ ] ip with submask1 , byte [ ] ip with submask2 ) { int ip length = ip with submask1 . length / num ; byte ip1 [ ] = new byte [ ip length ] ; byte subnetmask1 [ ] = new byte [ ip length ] ; system . arraycopy ( ip with submask1 , num , ip1 , num , ip length ) ; system . arraycopy ( ip with submask1 , ip length , subnetmask1 , num , ip length ) ; byte ip2 [ ] = new byte [ ip length ] ; byte subnetmask2 [ ] = new byte [ ip length ] ; system . arraycopy ( ip with submask2 , num , ip2 , num , ip length ) ; system . arraycopy ( ip with submask2 , ip length , subnetmask2 , num , ip length ) ; return new byte [ ] [ ] { ip1 , subnetmask1 , ip2 , subnetmask2 } ; }	splits the ip addresses and their subnet mask .
public string type ( ) { return type ; }	returns the high - level media type , such as " text " , " image " , " audio " , " video " , or " application " .
@ override public int on start command ( intent intent , int flags , int start id ) { oc . d ( tag , str + start id ) ; if ( action sync folder . equals ( intent . get action ( ) ) ) { if ( ! intent . has extra ( extra account ) || ! intent . has extra ( extra remote path ) ) { oc . e ( tag , str ) ; return start not sticky ; } account account = intent . get parcelable extra ( extra account ) ; string remote path = intent . get string extra ( extra remote path ) ; pair < account , string > item sync key = new pair < account , string > ( account , remote path ) ; pair < target , remote operation > item to queue = new operation ( intent ) ; if ( item to queue != null ) { m sync folder handler . add ( account , remote path , ( synchronize folder operation ) item to queue . second ) ; message msg = m sync folder handler . obtain message ( ) ; msg . arg1 = start id ; msg . obj = item sync key ; m sync folder handler . send message ( msg ) ; } } else { message msg = m operations handler . obtain message ( ) ; msg . arg1 = start id ; m operations handler . send message ( msg ) ; } return start not sticky ; }	entry point to add a new operation to the queue of operations.
private byte [ ] update no dictionary start and end key ( byte [ ] key ) { if ( key . length == num ) { return key ; } byte buffer buffer = byte buffer . wrap ( key , num , key . length - num ) ; byte buffer output = byte buffer . allocate ( key . length - num ) ; short number of byte to stor length = num ; for ( int i = num ; i < number of no dictionary column ; i ++ ) { output . put short ( ( short ) ( buffer . get short ( ) - number of byte to stor length ) ) ; } while ( buffer . has remaining ( ) ) { output . put ( buffer . get ( ) ) ; } output . rewind ( ) ; return output . array ( ) ; }	below method will be used to update the no dictionary start and end key.
public static void create tmp thumb ( final input stream stream , final file file , final string file name , final i conf ) throws io { buffered input stream buffered is = new buffered input stream ( stream ) ; buffered is . mark ( integer . max value ) ; buffered image image = io . read ( buffered is ) ; if ( image == null ) { throw new io ( str ) ; } dimension dimension = create thumb dimension ( image , conf . get img width ( ) , conf . get img height ( ) ) ; if ( image . get height ( ) == dimension . height && image . get width ( ) == dimension . width ) { buffered is . reset ( ) ; write untouched image ( buffered is , file ) ; } else { resize image ( image , dimension . width , dimension . height , conf . get img quality ( ) , file ) ; } stream . close ( ) ; }	uploads image and if the image size is larger than maximum allowed it resizes the image .
public static i create default class file reader ( input stream stream , int decoding flag ) { try { return new class file reader ( util . get input stream as byte array ( stream , - num ) , decoding flag ) ; } catch ( class format exception e ) { return null ; } catch ( io e ) { return null ; } }	create a default classfile reader , able to expose the internal representation of a given classfile according to the decoding flag used to initialize the reader.
public static string replace underscores ( string orig text ) { return orig text . replace all ( str , str ) ; }	replaces underscores with dashes ( many crawled news articles seem to have substituted em - or en - dashes with underscores ).
public static int abs ( number number ) { return math . abs ( number . int value ( ) ) ; }	get the absolute value.
public token ( token type type , token position position , int length , string data ) { super ( position ) ; if ( length < num ) throw new illegal argument exception ( str ) ; this . type = objects . require non null ( type ) ; this . length = length ; this . data = data ; }	creates a new token with the given parameters .
public boolean is auto reducible ( ) { boolean b = ( boolean ) get client property ( auto reducible property ) ; return ( b != null ) && b . boolean value ( ) ; }	is the combo box auto - reducible ?.
public dms ( int lat degrees , int lat minutes , double lat seconds , int lon degrees , int lon minutes , double lon seconds ) { this ( lat degrees < num , math . abs ( lat degrees ) , lat minutes , lat seconds , lon degrees < num , math . abs ( lon degrees ) , lon minutes , lon seconds ) ; }	create dmslatlonpoint where lat_degrees and lon_degrees are signed , negative for south and west .
public synchronized int init5 baud ( int address ) { int result = num ; set curr address ( address ) ; try { comm timer . stop ( ) ; set device name ( device name ) ; for ( int i = num ; i < baud rates . length ; i ++ ) { set prot stat ( prot status . connecting ) ; log . info ( string . format ( str , device name , address , baud rates [ i ] ) ) ; set custom baud rate ( baud rates [ i ] ) ; set curr baud rate ( baud rates [ i ] ) ; send5 baud ( address ) ; try { thread . sleep ( num ) ; } catch ( interrupted exception e ) { log . error ( str , e ) ; } if ( get prot stat ( ) != prot status . connecting ) { log . info ( string . format ( str , device name , address , baud rates [ i ] ) ) ; result = get curr baud rate ( ) ; comm timer . restart ( ) ; break ; } } if ( result == num ) { log . warn ( string . format ( str , device name , address ) ) ; close ( ) ; } } catch ( exception ex ) { log . error ( device name + str + ex . to string ( ) ) ; close ( ) ; set prot stat ( prot status . error ) ; result = num ; } set curr baud rate ( result ) ; return ( result ) ; }	initialize communication by sending specified ecu address with 5 baud.
protected void delete basis ( int selected basis ) { basis set . remove ( integer . value of ( selected basis ) ) ; alpha [ selected basis ] = - num ; }	delete a basis function from the model .
public void assert equals ( string assert id , collection expected , node list actual ) { collection actual list = new array list ( ) ; int actual len = actual . get length ( ) ; for ( int i = num ; i < actual len ; i ++ ) { actual list . add ( actual . item ( i ) ) ; } framework . assert equals ( this , assert id , expected , actual list ) ; }	asserts that each entry in actual exactly matches with an entry in expected.
public collection < string > list tables ( ) throws database exception { collection < string > result = new array list < string > ( ) ; result set rs = null ; try { database meta data dbm = connection . get meta data ( ) ; string types [ ] = { str } ; rs = dbm . get tables ( null , null , null , types ) ; while ( rs . next ( ) ) { string str = rs . get string ( str ) ; result . add ( str ) ; } } catch ( sql e ) { throw ( new database exception ( e ) ) ; } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( sql e ) { } } } return result ; }	get a list of all tables in the database .
public void test char sequence ( ) throws io { char sequence cs = mapper . read value ( str , char sequence . class ) ; assert equals ( string . class , cs . get class ( ) ) ; assert equals ( str , cs . to string ( ) ) ; }	test for [ jackson - 483 ] , allow handling of charsequence.
public namespaced properties ( string prefix ) { this ( prefix , system . get properties ( ) , bool ) ; }	create new instance backed by system properties ( properties instance obtained by system . getproperties ( ).
public void clear cache ( ) { if ( m memory cache != null ) { m memory cache . evict all ( ) ; if ( build config . debug ) { log . d ( tag , str ) ; } } synchronized ( m disk cache lock ) { m disk cache starting = bool ; if ( m disk lru cache != null && ! m disk lru cache . is closed ( ) ) { try { m disk lru cache . delete ( ) ; if ( build config . debug ) { log . d ( tag , str ) ; } } catch ( io e ) { log . e ( tag , str + e ) ; } m disk lru cache = null ; init disk cache ( ) ; } } }	clears both the memory and disk cache associated with this imagecache object.
public static final void write string array xml ( string [ ] val , string name , xml serializer out ) throws xml pull parser exception , io { if ( val == null ) { out . start tag ( null , str ) ; out . end tag ( null , str ) ; return ; } out . start tag ( null , str ) ; if ( name != null ) { out . attribute ( null , str , name ) ; } final int n = val . length ; out . attribute ( null , str , integer . to string ( n ) ) ; for ( int i = num ; i < n ; i ++ ) { out . start tag ( null , str ) ; out . attribute ( null , str , val [ i ] ) ; out . end tag ( null , str ) ; } out . end tag ( null , str ) ; }	flatten a string [ ] into an xmlserializer.
public void query function2 ( byte buffer bb , string builder high , string builder low ) { int base sec = ( int ) ( window id > > num ) ; bb . put int ( base sec ) ; short win id = ( short ) ( window id & num ) ; bb . put short ( win id ) ; integer oper id = operator id ; for ( int i = num ; i < num ; i ++ ) { byte num = ( byte ) ( oper id > > num * ( num - i ) ) ; bb . put ( num ) ; } byte buffer lowbb = bb . duplicate ( ) ; lowbb . put ( ( byte ) num ) ; lowbb . put ( ( byte ) num ) ; lowbb . put ( ( byte ) num ) ; for ( byte b : lowbb . array ( ) ) { low . append ( string . format ( str , b & num ) ) ; } byte buffer highbb = bb . duplicate ( ) ; highbb . put ( ( byte ) num ) ; highbb . put ( ( byte ) num ) ; highbb . put ( ( byte ) num ) ; for ( byte b : highbb . array ( ) ) { high . append ( string . format ( str , b & num ) ) ; } }	4b basesec | 2b windowid | 3b operatorid | 3b tupleid.
private static byte buffer generate wav header ( int sample count ) { final int num data bytes = sample count * num channels * bits per sample / num ; byte buffer buf = byte buffer . allocate ( num ) ; buf . order ( byte order . little endian ) ; buf . put int ( num ) ; buf . put int ( num + num data bytes ) ; buf . put int ( num ) ; buf . put int ( num ) ; buf . put int ( num ) ; buf . put short ( ( short ) num ) ; buf . put short ( ( short ) num channels ) ; buf . put int ( sample rate ) ; buf . put int ( sample rate * num channels * bits per sample / num ) ; buf . put short ( ( short ) ( num channels * bits per sample / num ) ) ; buf . put short ( ( short ) bits per sample ) ; buf . put int ( num ) ; buf . put int ( num data bytes ) ; buf . position ( num ) ; return buf ; }	generates the 44 - byte wav file header .
protected final boolean init ( ) throws ade exception { boolean initialized ; final properties prop = new properties ( ) ; try ( file input stream fis = new file input stream ( properties file name ) ) { prop . load ( fis ) ; initialized = bool ; } catch ( file not found exception e ) { throw new ade ext usage exception ( str + properties file name + str , e ) ; } catch ( io e ) { throw new ade ext usage exception ( str + properties file name + str , e ) ; } catch ( exception e ) { throw new ade ext usage exception ( str + properties file name + str , e ) ; } return initialized ; }	initializes the db configuration properties and diagnostics directory name for the exported db files .
public void print stack trace ( java . io . print stream ps ) { if ( root cause != null ) { string super string = super . to string ( ) ; synchronized ( ps ) { ps . print ( super string + ( super string . ends with ( str ) ? str : str ) + str ) ; root cause . print stack trace ( ps ) ; } } else { super . print stack trace ( ps ) ; } }	prints this exception ' s stack trace to a print stream.
public file data ( byte [ ] body hash , file file ) { m body file = file ; set body hash ( body hash ) ; set size ( ( int ) file . length ( ) ) ; }	create a new filedata .
public void simulate method ( soot method method , reference variable this var , reference variable return var , reference variable params [ ] ) { string sub signature = method . get sub signature ( ) ; if ( sub signature . equals ( str ) ) { java lang get system package0 ( method , this var , return var , params ) ; return ; } else if ( sub signature . equals ( str ) ) { java lang get system packages0 ( method , this var , return var , params ) ; return ; } else { default method ( method , this var , return var , params ) ; return ; } }	implements the abstract method simulatemethod.
void create edges ( integer [ ] v ) { graph . add edge ( new double ( math . random ( ) ) , v [ num ] , v [ num ] , edge type . directed ) ; graph . add edge ( new double ( math . random ( ) ) , v [ num ] , v [ num ] , edge type . directed ) ; graph . add edge ( new double ( math . random ( ) ) , v [ num ] , v [ num ] , edge type . directed ) ; graph . add edge ( new double ( math . random ( ) ) , v [ num ] , v [ num ] , edge type . directed ) ; graph . add edge ( new double ( math . random ( ) ) , v [ num ] , v [ num ] , edge type . directed ) ; graph . add edge ( new double ( math . random ( ) ) , v [ num ] , v [ num ] ) ; graph . add edge ( new double ( math . random ( ) ) , v [ num ] , v [ num ] ) ; }	create edges for this demo graph.
static void check internal name ( final string name , final string msg ) { if ( name == null || name . length ( ) == num ) { throw new illegal argument exception ( str + msg + str ) ; } if ( name . char at ( num ) == str ) { check desc ( name , bool ) ; } else { check internal name ( name , num , - num , msg ) ; } }	checks that the given string is a valid internal class name .
public static string clean path ( string path ) { if ( path == null ) { return null ; } string path to use = replace ( path , windows folder separator , folder separator ) ; int prefix index = path to use . index of ( str ) ; string prefix = str ; if ( prefix index != - num ) { prefix = path to use . substring ( num , prefix index + num ) ; if ( prefix . contains ( str ) ) { prefix = str ; } else { path to use = path to use . substring ( prefix index + num ) ; } } if ( path to use . starts with ( folder separator ) ) { prefix = prefix + folder separator ; path to use = path to use . substring ( num ) ; } string [ ] path array = delimited list to string array ( path to use , folder separator ) ; list < string > path elements = new linked list < string > ( ) ; int tops = num ; for ( int i = path array . length - num ; i >= num ; i -- ) { string element = path array [ i ] ; if ( current path . equals ( element ) ) { } else if ( top path . equals ( element ) ) { tops ++ ; } else { if ( tops > num ) { tops -- ; } else { path elements . add ( num , element ) ; } } } for ( int i = num ; i < tops ; i ++ ) { path elements . add ( num , top path ) ; } return prefix + collection to delimited string ( path elements , folder separator ) ; }	normalize the path by suppressing sequences like " path /.
public string encode body ( ) { return text != null ? integer . to string ( code ) + sp + agent + sp + double quote + text + double quote : integer . to string ( code ) + sp + agent ; }	encode the body of the header ( return the stuff following name : ) .
@ override protected void insert text ( final string text , final notification type type ) { final string builder sbuf = new string builder ( ) ; sbuf . append ( str ) ; sbuf . append ( type . get mnemonic ( ) ) ; sbuf . append ( str ) ; sbuf . append ( translate to html ( text ) ) ; sbuf . append ( str ) ; append string ( sbuf . to string ( ) ) ; }	insert the text portion of the line using a specified notification type for style .
private int count ( boolean [ ] array setted , byte [ ] [ ] array , byte [ ] value ) { if ( value != null ) { int counter = num ; for ( int i = num ; i < array . length ; i ++ ) { if ( array setted != null && array setted [ i ] && arrays . equals ( value , array [ i ] ) ) { counter ++ ; } } return counter ; } return num ; }	counts how many times ' value ' occurs in ' array '.
private void assert write little endian64 ( byte [ ] data , long value ) throws exception { byte array output stream raw output = new byte array output stream ( ) ; coded output stream output = coded output stream . new instance ( raw output ) ; output . write raw little endian64 ( value ) ; output . flush ( ) ; assert equal bytes ( data , raw output . to byte array ( ) ) ; for ( int block size = num ; block size <= num ; block size *= num ) { raw output = new byte array output stream ( ) ; output = coded output stream . new instance ( raw output , block size ) ; output . write raw little endian64 ( value ) ; output . flush ( ) ; assert equal bytes ( data , raw output . to byte array ( ) ) ; } }	parses the given bytes using writerawlittleendian64 ( ) and checks that the result matches the given value .
private void enable disable spacing fields ( ) { if ( manually set num columns . is selected ( ) ) { tf num columns . set enabled ( bool ) ; } else { tf num columns . set enabled ( bool ) ; } }	enable or disable spacing fields depending on whether the layout is in manual columns mode .
protected void draw x ( list < double > x labels , double [ ] x text label locations , canvas canvas , paint paint , int left , int top , int bottom , double x pixels per unit , double min x , double max x ) { int length = x labels . size ( ) ; boolean show labels = m renderer . is show labels ( ) ; boolean show grid y = m renderer . is show grid y ( ) ; boolean show tick marks = m renderer . is show tick marks ( ) ; for ( int i = num ; i < length ; i ++ ) { double label = x labels . get ( i ) ; float x label = ( float ) ( left + x pixels per unit * ( label - min x ) ) ; if ( show labels ) { paint . set color ( m renderer . get x ( ) ) ; if ( show tick marks ) { canvas . draw line ( x label , bottom , x label , bottom + m renderer . get labels text size ( ) / num , paint ) ; } draw text ( canvas , get label ( m renderer . get x ( ) , label ) , x label , bottom + m renderer . get labels text size ( ) * num / num + m renderer . get x ( ) , paint , m renderer . get x ( ) ) ; } if ( show grid y ) { paint . set color ( m renderer . get grid color ( num ) ) ; canvas . draw line ( x label , bottom , x label , top , paint ) ; } } draw x ( x text label locations , canvas , paint , show labels , left , top , bottom , x pixels per unit , min x , max x ) ; }	the graphical representation of the labels on the x axis .
static unix stream < string > echo ( final string input ) { objects . require non null ( input , str ) ; return new unix stream impl < > ( stream . of ( input ) ) ; }	create a new unixstream with the given input .
public aw ( url endpoint url , string http method , string service name , string region name ) { this . endpoint url = endpoint url ; this . http method = http method ; this . service name = service name ; this . region name = region name ; date time format = new simple date format ( is ) ; date time format . set time zone ( new simple time zone ( num , str ) ) ; date stamp format = new simple date format ( date string format ) ; date stamp format . set time zone ( new simple time zone ( num , str ) ) ; }	create a new aws v4 signer .
public d ( j parent , x509 ext extension ) throws asn1 exception , io { super ( res . get string ( str ) ) ; this . extension = extension ; init components ( ) ; }	creates new dviewasn1dump dialog where the parent is a dialog .
public long arg start ( ) { return long . parse long ( fields [ num ] ) ; }	( since linux 3.
public static string gen random string ( ) { return gen random string ( num ) ; }	generate a random string with fixed length.
static method find method ( class < ? > cls , string method name , int arg count ) { return find method ( cls , method name , arg count , null ) ; }	find a target methodname on a given class .
public task resource rep host vcenter unassign ( uri host id , uri event id ) { return host cluster change ( host id , null column value getter . get null uri ( ) , null column value getter . get null uri ( ) , bool , event id ) ; }	unassign host from a vcenter note : in order to maintain backwards compatibility , do not change the signature of this method .
public om ( ) { super ( ) ; set border ( border factory . create empty border ( ) ) ; debug = debug . debugging ( str ) ; selection support = new selection support ( this ) ; set attributes ( new graphic attributes ( ) ) ; set mouse mode ( create mouse mode ( ) ) ; undo stack = new undo stack ( ) ; undo trigger = new undo menu item stack trigger ( ) ; undo stack . add undo stack trigger ( undo trigger ) ; set use as tool ( bool ) ; }	create a openmap drawing tool .
public static string java encode ( string s ) { int length = s . length ( ) ; string builder buff = new string builder ( length ) ; for ( int i = num ; i < length ; i ++ ) { char c = s . char at ( i ) ; switch ( c ) { case str : buff . append ( str ) ; break ; case str : buff . append ( str ) ; break ; case str : buff . append ( str ) ; break ; case str : buff . append ( str ) ; break ; case str : buff . append ( str ) ; break ; case str : buff . append ( str ) ; break ; default : int ch = c & num ; if ( ch >= str && ( ch < num ) ) { buff . append ( c ) ; } else { buff . append ( str ) ; string hex = integer . to hex string ( ch ) ; for ( int len = hex . length ( ) ; len < num ; len ++ ) { buff . append ( str ) ; } buff . append ( hex ) ; } } } return buff . to string ( ) ; }	convert a string to a java literal using the correct escape sequences.
private void read external data ( externalizable obj , object stream class desc ) throws io { serial callback context old context = cur context ; if ( old context != null ) old context . check ( ) ; cur context = null ; try { boolean blocked = desc . has block external data ( ) ; if ( blocked ) { bin . set block data mode ( bool ) ; } if ( obj != null ) { try { obj . read external ( this ) ; } catch ( class not found exception ex ) { handles . mark exception ( pass handle , ex ) ; } } if ( blocked ) { skip custom data ( ) ; } } finally { if ( old context != null ) old context . check ( ) ; cur context = old context ; } }	if obj is non - null , reads externalizable data by invoking readexternal ( ) method of obj ; otherwise , attempts to skip over externalizable data.
@ nullable private string read attribute ( ixml elem , string attribute name , @ nullable string default value ) { if ( elem . has attribute ( attribute name , svg namespace ) ) { string value = elem . get attribute ( attribute name , svg namespace , null ) ; if ( value . equals ( str ) ) { return read attribute ( elem . get parent ( ) , attribute name , default value ) ; } else { return value ; } } else if ( elem . has attribute ( attribute name ) ) { string value = elem . get attribute ( attribute name , null ) ; if ( value . equals ( str ) ) { return read attribute ( elem . get parent ( ) , attribute name , default value ) ; } else { return value ; } } else { return default value ; } }	reads an attribute that is not inherited , unless its value is " inherit " .
public set < string > add incremental content ( independent distribution content , boolean follow previous ) { if ( ! paused ) { cur state . add to state incremental ( content . to discrete ( ) , follow previous ) ; return update ( ) ; } else { log . info ( str + content ) ; return collections . empty set ( ) ; } }	adds the incremental content ( expressed as a distribution over variables ) to the current dialogue state , and subsequently updates it.
private void show search view ( ) { if ( m search view != null && ! old query . is empty ( ) ) { m search view . set iconified ( bool ) ; m search view . set query ( old query , bool ) ; show search view = bool ; } }	sets searchview iconifed to false and sets oldquery as searchquery.
public static void check ( boolean cond , int value ) { if ( ! cond ) error ( string . value of ( value ) ) ; }	equivalent to assert cond : value ;.
public string print insts ( int start idx , int end idx ) { string buffer bf = new string buffer ( ) ; try { bf . append ( str ) ; for ( int i = start idx ; i <= end idx ; i ++ ) { if ( i == start idx ) { bf . append ( str + m [ i ] ) ; } else { bf . append ( str + m [ i ] ) ; } } } catch ( exception ex ) { ex . print stack trace ( ) ; } return bf . to string ( ) ; }	for printing indices in some given portion of the master index array .
public float compute distance to ( float x , float y ) { final f bounds = get click target bounds ( ) ; float dx = math . max ( bounds . left - x , x - bounds . right ) ; float dy = math . max ( bounds . top - y , y - bounds . bottom ) ; return math . max ( num , math . max ( dx , dy ) ) ; }	computes the manhattan - ish distance to the edge of the tab.
public static byte [ ] as bytes ( string basic string ) { final byte [ ] b = new byte [ basic string . length ( ) ] ; for ( int i = num ; i < b . length ; ++ i ) { b [ i ] = ( byte ) basic string . char at ( i ) ; } return b ; }	get the corresponding byte array for a basic string.
private double angle to ( d that ) { double dx = that . x - this . x ; double dy = that . y - this . y ; return math . atan2 ( dy , dx ) ; }	returns the angle between this point and that point .
private static list < string > cross catenate ( list < list < string > > all words list ) { list < string > cross list = new array list < string > ( all words list . get ( num ) ) ; for ( list < string > word list : all words list . sub list ( num , all words list . size ( ) ) ) { int prior cross list length = cross list . size ( ) ; cross list = replicate ( cross list , word list . size ( ) ) ; for ( int i = num ; i < word list . size ( ) ; i ++ ) { for ( int j = num ; j < prior cross list length ; j ++ ) { int index = i * prior cross list length + j ; cross list . set ( index , cross list . get ( index ) + str + word list . get ( i ) ) ; } } } return cross list ; }	function to perform a cross product concatenation of separate rewritten term lists for example if there are k lists : < l1 > , < l2 > , < l3 > ,.
public static < k , v > map < k , v > of ( k k1 , v v1 ) { map map = of ( ) ; map . put ( k1 , v1 ) ; return map ; }	returns map containing a single entry .
public void log ( final string id ) { if ( id . contains ( str ) ) { throw new illegal argument exception ( id ) ; } final string builder sb = new string builder ( ) ; local to string ( sb , id ) ; diagnostic . developer log ( sb . to string ( ) ) ; }	write the accumulated time and average time to the log .
public general path draw ( d g2 , d data area , value axis horizontal axis , value axis vertical axis ) { general path general path = generate clip path ( data area , horizontal axis , vertical axis ) ; if ( this . fill path || this . draw path ) { composite save composite = g2 . get composite ( ) ; paint save paint = g2 . get paint ( ) ; stroke save stroke = g2 . get stroke ( ) ; if ( this . fill paint != null ) { g2 . set paint ( this . fill paint ) ; } if ( this . composite != null ) { g2 . set composite ( this . composite ) ; } if ( this . fill path ) { g2 . fill ( general path ) ; } if ( this . draw stroke != null ) { g2 . set stroke ( this . draw stroke ) ; } if ( this . draw path ) { g2 . draw ( general path ) ; } g2 . set paint ( save paint ) ; g2 . set composite ( save composite ) ; g2 . set stroke ( save stroke ) ; } return general path ; }	draws the clip path .
private list < process change > update control tag information ( final configuration element element , final process process ) { list < process change > changes = new array list < process change > ( num ) ; long process id = process . get id ( ) ; control tag alive tag copy = control cache . get copy ( process . get alive tag id ( ) ) ; if ( alive tag copy != null ) { set process id ( ( control tag cache object ) alive tag copy , process id ) ; } else { throw new configuration exception ( configuration exception . invalid parameter value , string . format ( str , process . get alive tag id ( ) , process . get id ( ) , process . get name ( ) ) ) ; } control tag status tag copy = control cache . get copy ( process . get state tag id ( ) ) ; if ( status tag copy != null ) { set process id ( ( control tag cache object ) status tag copy , process id ) ; } else { throw new configuration exception ( configuration exception . invalid parameter value , string . format ( str , process . get state tag id ( ) , process . get id ( ) , process . get name ( ) ) ) ; } return changes ; }	ensures that the alive - , status - and commfault tags have appropriately the process id set .
@ override public xy initialise ( d g2 , d data area , xy plot , xy dataset , plot rendering info info ) { value axis axis = plot . get domain axis ( ) ; double x1 = axis . get lower bound ( ) ; double x2 = x1 + this . max candle width in milliseconds ; rectangle edge edge = plot . get domain axis edge ( ) ; double xx1 = axis . value to java2 d ( x1 , data area , edge ) ; double xx2 = axis . value to java2 d ( x2 , data area , edge ) ; this . max candle width = math . abs ( xx2 - xx1 ) ; if ( this . draw volume ) { ohlc high low dataset = ( ohlc ) dataset ; this . max volume = num ; for ( int series = num ; series < high low dataset . get series count ( ) ; series ++ ) { for ( int item = num ; item < high low dataset . get item count ( series ) ; item ++ ) { double volume = high low dataset . get volume value ( series , item ) ; if ( volume > this . max volume ) { this . max volume = volume ; } } } } return new xy ( info ) ; }	initialises the renderer then returns the number of ' passes ' through the data that the renderer will require ( usually just one ).
public static string key for image ( string image path ) { string key = null ; try { message digest message digest = message digest . get instance ( str ) ; message digest . update ( image path . get bytes ( ) ) ; key = byte to hex ( message digest . digest ( ) ) ; } catch ( no such algorithm exception e ) { e . print stack trace ( ) ; } return key ; }	generate md5 key for picture.
static boolean is available for connection ( ) { boolean available ; if ( connection in progress . get ( ) ) { available = bool ; } else { request receiver receiver = receiver ref . get ( ) ; boolean connected = bool ; if ( receiver != null ) { try { receiver . get receiver id ( ) ; connected = bool ; } catch ( remote exception e ) { } } available = ! connected ; } return available ; }	if this session of matlab is available to be connected to from an external java program.
public boolean add value ( value v ) { return values . add ( v ) ; }	add " hasvalue v " information .
public select < t > sort asc ( string ... columns ) { for ( string column : columns ) { m sorting order list . add ( column + str ) ; } return this ; }	sorts the specified columns in asc order.
public void error ( final string msg ) { try { m err . append ( msg ) ; m err . append ( ls ) ; } catch ( final io e ) { throw new runtime exception ( e ) ; } }	prints message to the specified error output .
public void cleanup ( boolean delete all ) { long current time = system . current time millis ( ) ; file file = new file ( get output directory string ( ) ) ; if ( file . is directory ( ) ) { file [ ] files = file . list files ( ) ; for ( int i = num ; i < files . length ; i ++ ) { file f = files [ i ] ; if ( ! delete all ) { try { long ft = get time for file name ( f . get name ( ) ) ; long tdiff = current time - ft ; if ( debug ) { debug . output ( str + f . get name ( ) + str + ft + str + current time + str + get cleanup interval ( ) + str + tdiff ) ; } if ( tdiff > get cleanup interval ( ) ) { if ( debug ) debug . output ( str ) ; f . delete ( ) ; } } catch ( number format exception nfe ) { } } else { f . delete ( ) ; } } } }	remove old files . checks the current time against the timestamps decoded by the names of files found in the output directory , and deletes them if the difference between those times is greater than the cleanupinterval .
public static boolean is empty or blanks ( string string ) { if ( string == null || string . length ( ) == num ) { return bool ; } for ( int i = num ; i < string . length ( ) ; i ++ ) { char c = string . char at ( i ) ; if ( ! character . is whitespace ( c ) ) { return bool ; } } return bool ; }	checks if the given string is null , empty or contains whitespace only.
@ override public void fill assigned keys ( set < string > keys ) { tree set < string > sub keys = new tree set < > ( ) ; for ( expr kraken expr : exprs ) { sub keys . clear ( ) ; expr . fill assigned keys ( sub keys ) ; keys . add all ( sub keys ) ; } }	returns all the keys assigned statically , e.
@ category ( flaky test . class ) @ test public void test missing member redundancy1 ( ) { host host = host . get host ( num ) ; vm vm0 = host . get vm ( num ) ; vm vm1 = host . get vm ( num ) ; vm vm2 = host . get vm ( num ) ; create pr ( vm0 , num ) ; create pr ( vm1 , num ) ; create data ( vm0 , num , num buckets , str ) ; set < integer > vm0 buckets = get bucket list ( vm0 ) ; set < integer > vm1 buckets = get bucket list ( vm1 ) ; close cache ( vm1 ) ; check data ( vm0 , num , num buckets , str ) ; remove data ( vm0 , num , num buckets / num ) ; create data ( vm0 , num buckets / num , num buckets , str ) ; create pr ( vm2 , num ) ; set < integer > vm2 buckets = get bucket list ( vm2 ) ; assert equals ( collections . empty set ( ) , vm2 buckets ) ; create pr ( vm1 , num ) ; check data ( vm1 , num , num buckets / num , null ) ; check data ( vm1 , num buckets / num , num buckets , str ) ; assert equals ( vm0 buckets , get bucket list ( vm0 ) ) ; assert equals ( vm1 buckets , get bucket list ( vm1 ) ) ; assert equals ( collections . empty set ( ) , get bucket list ( vm2 ) ) ; }	test the with redundancy 1 , we restore the same buckets when the missing member comes back online .
public tfs connect if necessary ( final i project ) { check . not null ( project , str ) ; wait for manager startup ( ) ; project repository data project data ; synchronized ( project data lock ) { project data = project data map . get ( project ) ; if ( project data == null ) { boolean should connect = should connect ( project ) ; if ( should connect == null ) { return null ; } project data = new project repository data ( ) ; project data map . put ( project , project data ) ; project closed set . remove ( project ) ; if ( should connect . equals ( boolean . false ) && is any project of status ( project repository status . online ) ) { should connect = boolean . true ; } else if ( should connect . equals ( boolean . true ) && is any project of status ( project repository status . offline ) ) { should connect = boolean . false ; } if ( should connect == boolean . false ) { project data . set status ( project repository status . offline ) ; return null ; } project data . set status ( project repository status . connecting ) ; } else { synchronized ( project data ) { if ( project data . get status ( ) == project repository status . initializing ) { return null ; } else if ( project data . get status ( ) != project repository status . connecting ) { return project data . get repository ( ) ; } } } } return connect internal ( project , bool , project data ) ; }	connects the given iproject to its team foundation server if and only if it is not marked offline.
public void load ( t entity , compound tag tag ) { if ( tag . is list ( str , tag type . double ) ) { entity . set velocity ( nbt serialization . list to vector ( tag . get list ( str , tag type . double ) ) ) ; } if ( tag . is float ( str ) ) { entity . set fall distance ( tag . get float ( str ) ) ; } if ( tag . is short ( str ) ) { entity . set fire ticks ( tag . get short ( str ) ) ; } if ( tag . is byte ( str ) ) { entity . set on ground ( tag . get bool ( str ) ) ; } if ( tag . is byte ( str ) ) { entity . set gravity ( ! tag . get bool ( str ) ) ; } if ( tag . is byte ( str ) ) { entity . set silent ( tag . get bool ( str ) ) ; } if ( tag . is long ( str ) && tag . is long ( str ) ) { uuid uuid = new uuid ( tag . get long ( str ) , tag . get long ( str ) ) ; entity . set unique id ( uuid ) ; } else if ( tag . is string ( str ) ) { uuid uuid = uuid . from string ( tag . get string ( str ) ) ; entity . set unique id ( uuid ) ; } }	load data into an existing entity of the appropriate type from the given compound tag .
public static string quote identifier ( string s ) { if ( s == null || s . length ( ) == num ) { return str ; } char c = s . char at ( num ) ; if ( ( ! character . is letter ( c ) && c != str ) || character . is lower case ( c ) ) { return string utils . quote identifier ( s ) ; } for ( int i = num , length = s . length ( ) ; i < length ; i ++ ) { c = s . char at ( i ) ; if ( ( ! character . is letter or digit ( c ) && c != str ) || character . is lower case ( c ) ) { return string utils . quote identifier ( s ) ; } } if ( is keyword ( s , bool ) ) { return string utils . quote identifier ( s ) ; } return s ; }	add double quotes around an identifier if required .
public static int count ( string string , string mark ) { if ( ! text utils . is empty ( string ) && ! text utils . is empty ( mark ) ) { int count = num ; int index = string . index of ( mark ) ; while ( index != - num ) { count ++ ; string = string . substring ( index + mark . length ( ) ) ; index = string . index of ( mark ) ; } return count ; } return num ; }	count how many marks existed in string .
final void put double ( int offset , double value ) { unsafe . put double ( offset + address , value ) ; }	writes a double at the specified offset from this native object ' s base address .
public double eval ( double i , double j ) { double eval kernel = math . exp ( - num * ( math . pow ( ( i - j ) , num ) / math . pow ( sigma , num ) ) ) ; return eval kernel ; }	evaluates the kernel at two given points.
public void remove all ( ) { recent searches . clear ( ) ; save ( ) ; fire change event ( ) ; }	remove all recent searches .
protected void re init ( ) { if ( is logging enabled ( ) ) stack logger . log debug ( str ) ; message processors = new array list < message processor > ( ) ; this . io handler = new io ( this ) ; pending transactions = new concurrent hash map < string , sip > ( ) ; client transaction table = new concurrent hash map < string , sip > ( ) ; server transaction table = new concurrent hash map < string , sip > ( ) ; retransmission alert transactions = new concurrent hash map < string , sip > ( ) ; merge table = new concurrent hash map < string , sip > ( ) ; this . dialog table = new concurrent hash map < string , sip > ( ) ; this . early dialog table = new concurrent hash map < string , sip > ( ) ; this . terminated server transactions pending ack = new concurrent hash map < string , sip > ( ) ; this . forked client transaction table = new concurrent hash map < string , sip > ( ) ; this . timer = new timer ( ) ; this . active client transaction count = new atomic integer ( num ) ; }	re initialize the stack instance .
public static boolean is enclosed between ( final string input , final string encloser ) { return is enclosed between ( input , encloser , encloser ) ; }	verifies whether string is enclosed by encloser.
public request params ( object ... keys and values ) { init ( ) ; int len = keys and values . length ; if ( len % num != num ) throw new illegal argument exception ( str ) ; for ( int i = num ; i < len ; i += num ) { string key = string . value of ( keys and values [ i ] ) ; string val = string . value of ( keys and values [ i + num ] ) ; put ( key , val ) ; } }	constructs a new requestparams instance and populate it with multiple initial key / value string param .
private void context menu ( logical visualization ex visualization , mouse event mouse event ) { j menu = new j ( ) ; j restore = new j ( str ) ; restore . add action listener ( null ) ; j collapse = new j ( str ) ; collapse . add action listener ( null ) ; j expand = new j ( str ) ; expand . add action listener ( null ) ; menu . add ( restore ) ; menu . add ( collapse ) ; menu . add ( expand ) ; get visibility menu items ( menu , visualization ) ; if ( menu instanceof j ) { j popup = ( j ) menu ; popup . set location ( mouse event . get location on screen ( ) ) ; popup . set invoker ( get display ( ) ) ; popup . set visible ( bool ) ; popup . request focus ( ) ; } }	creates and displays a context menu for the blank space on the graph .
public final void translate ( final char sequence input , final writer out ) throws io { if ( out == null ) { throw new illegal argument exception ( str ) ; } if ( input == null ) { return ; } int pos = num ; final int len = input . length ( ) ; while ( pos < len ) { final int consumed = translate ( input , pos , out ) ; if ( consumed == num ) { final char [ ] c = character . to chars ( character . code point at ( input , pos ) ) ; out . write ( c ) ; pos += c . length ; continue ; } for ( int pt = num ; pt < consumed ; pt ++ ) { pos += character . char count ( character . code point at ( input , pos ) ) ; } } }	translate an input onto a writer.
public void remove variable ( string var id ) { variables . remove ( var id ) ; discrete cache = null ; continuous cache = null ; for ( assignment s : samples ) { s . remove pair ( var id ) ; } }	removes a particular variable from the sampled assignments.
public static uuid parse string as uuid ( string in ) throws index parse field exception { try { return uuid . from string ( in ) ; } catch ( illegal argument exception e ) { throw new index parse field exception ( in , e ) ; } }	parses a string as a uuid .
public void add ( t object ) { if ( m original values != null ) { synchronized ( m lock ) { m original values . add ( object ) ; if ( m notify on change ) notify data set changed ( ) ; } } else { m objects . add ( object ) ; if ( m notify on change ) notify data set changed ( ) ; } }	adds the specified object at the end of the array .
public boolean is connected ( final synapse s ) { return ( fan in . contains ( s ) || fan out . get ( s . get target ( ) ) != null ) ; }	true if the synapse is connected to this neuron , false otherwise .
@ override public void reset learning ( ) { this . instances seen = num ; this . class instances = new hash map < > ( ) ; this . class prototypes = new hash map < > ( ) ; this . attribute observers = new hash map < > ( ) ; }	resets this classifier . it must be similar to starting a new classifier from scratch .
@ override public void put ( int index , byte [ ] value ) { system . arraycopy ( value , num , datastore , ( ( index ) * size of each element ) , size of each element ) ; }	this method will be used to insert key to store.
public final void init ( ir ir ) { live interval liveness information = ir . get liveness information ( ) ; this . reg alloc state = ir . mir . reg alloc state ; for ( enumeration < basic block > e = ir . get basic blocks ( ) ; e . has more elements ( ) ; ) { basic block b = e . next element ( ) ; process block ( b , liveness information ) ; } }	records all the register restrictions dictated by an ir.
private void install node selector tab ( string label , node selector part selector part ) { composite selection control = selector part . create control ( selector tab , swt . none , get editor ( ) ) ; selection control . set layout data ( new grid data ( swt . fill , swt . fill , bool , bool ) ) ; selector tab parts . add ( selector part ) ; tab item tab item = new tab item ( selector tab , swt . none ) ; tab item . set text ( label ) ; tab item . set control ( selection control ) ; }	install a new node selector part into the selectors tab .
protected boolean is inline alert message set ( ) { cc alert = ( cc ) get child ( ialert common ) ; string detail = alert . get detail ( ) ; return ( detail != null ) && ( detail . length ( ) > num ) ; }	returns true if inline alert message is set .
public j ( ) { super ( ) ; normal foreground = ui . get color ( str ) ; active foreground = ui . get color ( str ) ; visited foreground = ui . get color ( str ) ; set border painted ( bool ) ; set content area filled ( bool ) ; set foreground ( normal foreground ) ; set cursor ( cursor . get predefined cursor ( cursor . hand cursor ) ) ; set margin ( new insets ( num , num , num , num ) ) ; set action ( default browse action ) ; }	creates a new instance of jhyperlink.
public static string remove cross reference ( string text ) { if ( strings . is null or empty ( text ) ) { return str ; } pattern pattern = pattern . compile ( str + str ) ; matcher matcher = pattern . matcher ( text ) ; string buffer result = new string buffer ( ) ; while ( matcher . find ( ) ) { string replacement text = matcher . group ( str ) ; replacement text = matcher . quote replacement ( replacement text ) ; matcher . append replacement ( result , replacement text ) ; } matcher . append tail ( result ) ; return result . to string ( ) ; }	given a documentation string , replace the cross reference links with reference text .
@ guarded by ( str ) void drain write buffer ( ) { for ( int i = num ; i < write buffer drain threshold ; i ++ ) { final runnable task = write buffer . poll ( ) ; if ( task == null ) { break ; } task . run ( ) ; } }	drains the read buffer up to an amortized threshold .
private string pick lower or upper ( string input mode ) { int pos = get cursor position ( ) - num ; if ( pending commit ) { pos -- ; } string text = get text ( ) ; if ( pos >= text . length ( ) ) { pos = text . length ( ) - num ; } while ( pos > - num ) { if ( text . char at ( pos ) == str ) { return input mode . to upper case ( ) ; } if ( text . char at ( pos ) != str ) { return input mode . to lower case ( ) ; } pos -- ; } return input mode . to upper case ( ) ; }	used for the case of first sentence character should be upper case.
private static char handler parse simple codes ( string [ ] code strings ) { if ( code strings . length != num ) { throw new illegal state exception ( str + arrays . as list ( code strings ) ) ; } return new simple char handler ( codes to bytes ( code strings [ num ] , bool ) ) ; }	returns a simplecharhandler parsed from the given index code strings .
protected double calculate category size ( int category count , d area , rectangle edge edge ) { double result ; double available = num ; if ( ( edge == rectangle edge . top ) || ( edge == rectangle edge . bottom ) ) { available = area . get width ( ) ; } else if ( ( edge == rectangle edge . left ) || ( edge == rectangle edge . right ) ) { available = area . get height ( ) ; } if ( category count > num ) { result = available * ( num - get lower margin ( ) - get upper margin ( ) - get category margin ( ) ) ; result = result / category count ; } else { result = available * ( num - get lower margin ( ) - get upper margin ( ) ) ; } return result ; }	calculates the size ( width or height , depending on the location of the axis ) of a category .
@ override public void create buffers ( int num buffers , buffer capabilities caps ) throws awt { win32 graphics config gc = ( win32 graphics config ) get graphics configuration ( ) ; gc . assert operation supported ( ( component ) target , num buffers , caps ) ; try { replace surface data ( num buffers - num , caps ) ; } catch ( invalid pipe exception e ) { throw new awt ( e . get message ( ) ) ; } }	the following multibuffering - related methods delegate to our associated graphicsconfig ( win or wgl ) to handle the appropriate native windowing system specific actions .
public business object format create request create business object format create request ( string namespace code , string business object definition name , string business object format usage , string business object format file type , string partition key , string description , list < attribute > attributes , list < attribute definition > attribute definitions , schema schema ) { business object format create request business object format create request = new business object format create request ( ) ; business object format create request . set namespace ( namespace code ) ; business object format create request . set business object definition name ( business object definition name ) ; business object format create request . set business object format usage ( business object format usage ) ; business object format create request . set business object format file type ( business object format file type ) ; business object format create request . set partition key ( partition key ) ; business object format create request . set description ( description ) ; business object format create request . set attributes ( attributes ) ; business object format create request . set attribute definitions ( attribute definitions ) ; business object format create request . set schema ( schema ) ; return business object format create request ; }	creates a business object format create request .
public void remove observer ( final file alteration observer observer ) { if ( observer != null ) { while ( observers . remove ( observer ) ) { } } }	remove a file system observer from this monitor .
public void randomize weights ( random random ) { for ( int i = num ; i < weights . length ; i ++ ) weights [ i ] = random . next double ( ) * num ; }	generates a new weight.
private static method find overloaded method ( class base class , string method name , class [ ] types , boolean public only ) { if ( interpreter . debug ) interpreter . debug ( str + string util . method string ( method name , types ) + str + base class . get name ( ) + str ) ; method [ ] methods = get candidate methods ( base class , method name , types . length , public only ) ; if ( interpreter . debug ) interpreter . debug ( str + method name ) ; method method = find most specific method ( types , methods ) ; return method ; }	get the candidate methods by searching the class and interface graph of baseclass and resolve the most specific .
private id new service id ( ) { uuid uuid = service id generator . generate ( ) ; return new id ( uuid . get most significant bits ( ) , uuid . get least significant bits ( ) ) ; }	generate a new service id.
public void children added ( bean context membership event bcme ) { find and init ( bcme . iterator ( ) ) ; }	method for beancontextmembership interface .
public void test constr char int int math context exception1 ( ) { char value [ ] = { str , str , str , str , str , str , str , str , str , str , str , str , str , str , str , str } ; int offset = num ; int len = num ; int precision = num ; rounding mode rm = rounding mode . ceiling ; math context mc = new math context ( precision , rm ) ; try { new big decimal ( value , offset , len , mc ) ; fail ( str ) ; } catch ( number format exception e ) { } }	new bigdecimal ( char [ ] value , int offset , int len , mathcontext mc ) ;.
public void move to ( float x , float y ) { m points . add ( path point . move to ( x , y ) ) ; }	move from the current path point to the new one specified by x and y.
public do dtm ( dtm mgr , dom dom source , int dtm identity , dtmws white space filter , xml xstringfactory , boolean do indexing ) { super ( mgr , dom source , dtm identity , white space filter , xstringfactory , do indexing ) ; m pos = m root = dom source . get node ( ) ; m last parent = m last kid = null ; m last kid = add node ( m root , m last parent , m last kid , null ) ; if ( element node == m root . get node type ( ) ) { named node map attrs = m root . get attributes ( ) ; int attrsize = ( attrs == null ) ? num : attrs . get length ( ) ; if ( attrsize > num ) { int attr index = null ; for ( int i = num ; i < attrsize ; ++ i ) { attr index = add node ( attrs . item ( i ) , num , attr index , null ) ; m firstch . set element at ( dtm . null , attr index ) ; } m nextsib . set element at ( dtm . null , attr index ) ; } } m nodes are processed = bool ; }	construct a dom2dtm object from a dom node .
private void rebuild node ( ) { m realizer . regenerate ( ) ; m graph . update views ( ) ; }	regenerates the content of the node and updates the graph view .
public static long seconds since millis ( long time in millis ) { return ( system . current time millis ( ) - time in millis ) / num ; }	computes the number of seconds elapsed since the given time in milliseconds .
public final void test choose engine client alias ( ) { x509 extended key manager km = new my x509 extended key manager ( ) ; if ( km . choose engine client alias ( null , null , null ) != null ) { fail ( str ) ; } }	javax . net . ssl . x509extendedkeymanager # chooseengineclientalias ( java . lang . string [ ] , java . security . principal [ ] , javax . net . ssl . sslengine ).
public void print string ( char [ ] v , int offset , int length ) throws io { for ( int i = num ; i < length ; i ++ ) { char ch = v [ i + offset ] ; if ( ch < num ) os . write ( ch ) ; else if ( ch < num ) { os . write ( num + ( ( ch > > num ) & num ) ) ; os . write ( num + ( ch & num ) ) ; } else { os . write ( num + ( ( ch > > num ) & num ) ) ; os . write ( num + ( ( ch > > num ) & num ) ) ; os . write ( num + ( ch & num ) ) ; } } }	prints a string to the stream , encoded as utf - 8.
public static string trim leading tabs and spaces ( string line ) { int size = line . length ( ) ; int start = size ; for ( int i = num ; i < size ; i ++ ) { char c = line . char at ( i ) ; if ( ! indent manipulation . is indent char ( c ) ) { start = i ; break ; } } if ( start == num ) return line ; else if ( start == size ) return str ; else return line . substring ( start ) ; }	removes leading tabs and spaces from the given string.
public static object mimic array ( object array , class < ? > new type ) { int dims = num ; class < ? > array class = array . get class ( ) ; while ( array class != null && array class . is array ( ) ) { array class = array class . get component type ( ) ; dims += num ; } object mimic ; if ( dims > num ) { object [ ] xarray = ( object [ ] ) array ; int [ ] dimens = new int [ dims ] ; dimens [ num ] = xarray . length ; mimic = array funcs . new instance ( new type , dimens ) ; for ( int i = num ; i < xarray . length ; i += num ) { object temp = mimic array ( xarray [ i ] , new type ) ; ( ( object [ ] ) mimic ) [ i ] = temp ; } } else { mimic = array funcs . new instance ( new type , array . get length ( array ) ) ; } return mimic ; }	create an array of a type given by new type with the dimensionality given in array .
public concurrent skip list set ( sorted set < e > s ) { m = new concurrent skip list map < e , object > ( s . comparator ( ) ) ; add all ( s ) ; }	constructs a new set containing the same elements and using the same ordering as the specified sorted set .
protected abstract byte [ ] read optional bytes impl ( final string label ) ;	reads a byte array value ( allowing null values ) .
public static void deinitialize ( ) { instance . codename one running = bool ; synchronized ( lock ) { lock . notify all ( ) ; } }	closes down the edt and codename one , under normal conditions this method is completely unnecessary since exiting the application will shut down codename one.
public void init ( iterator iter , comparator c ) { m tuples . clear ( ) ; m cmp = c ; while ( iter . has next ( ) ) { tuple t = ( tuple ) iter . next ( ) ; m tuples . add ( t ) ; } collections . sort ( m tuples , m cmp ) ; m iter = m tuples . iterator ( ) ; }	initialize this iterator for the given source iterator and comparator .
@ override public void mouse clicked ( mouse event e ) { if ( swing utilities . is left mouse button ( e ) ) { if ( e . get click count ( ) == num ) { fixed hover entry = bool ; set fixed start at ( hover entry ) ; } else { long actual hover entry = find hover entry ( e . get point ( ) ) ; fixed hover entry = actual hover entry != - num ; if ( hover entry != actual hover entry ) { update hover entry ( e . get point ( ) ) ; } } } }	toggle displaying stuff on mouse - click . left - click : keep info displayed even when outside the component right - click : switch between 0 - max and min - max rendering.
public boolean is alter drop ( ) { return columns to drop . size ( ) > num ; }	true if the table has columns to remove .
public void distribute and update map objects in interval set ( ) { for ( internal map object map object : map objects ) { for ( interval interval : interval set . get intervals ( ) ) { if ( map object . get value ( ) >= interval . get value low ( ) && map object . get value ( ) <= interval . get value high ( ) ) { interval . add member ( map object ) ; map object . set interval ( interval ) ; break ; } } } }	distribute this map layer ' s map objects into the given interval set and update each map object with its interval .
public void delete rows ( int row , int length ) throws table exception { if ( row < num || length < num || row + length > this . nrow ) { throw new table exception ( str + row + str + length + str + this . nrow + str ) ; } if ( length == num ) { return ; } for ( int col = num ; col < this . arrays . length ; col += num ) { int sz = this . sizes [ col ] ; int new size = sz * ( this . nrow - length ) ; object new arr = array funcs . new instance ( this . bases [ col ] , new size ) ; system . arraycopy ( this . arrays [ col ] , num , new arr , num , row * sz ) ; system . arraycopy ( this . arrays [ col ] , ( row + length ) * sz , new arr , row * sz , ( this . nrow - row - length ) * sz ) ; this . arrays [ col ] = new arr ; } this . nrow -= length ; initialize pointers ( ) ; }	delete a contiguous set of rows from the table .
public file input reader ( string f ) throws io { if ( debug . debugging ( str ) ) { debug . output ( str + f ) ; } file file = new file ( f ) ; name = file . get name ( ) ; absolute path = file . get absolute path ( ) ; input file = init ( file ) ; }	constructs a new binaryfile with the specified file as the input.
public instances transform ( instances d ) throws exception { int l = d . class index ( ) ; d = d . num attributes ( ) - l ; int keep [ ] = a . append ( this . pa y , j ) ; arrays . sort ( keep ) ; int remv [ ] = a . invert ( keep , l ) ; arrays . sort ( remv ) ; map = new int [ l ] ; for ( int j = num ; j < l ; j ++ ) { map [ j ] = arrays . binary search ( keep , j ) ; } instances d = f . remove ( new instances ( d ) , remv , bool ) ; d . set class index ( map [ this . j ] ) ; return d ; }	transform - transform dataset d for this node.
public void test clear bit negative inside5 ( ) { string as = str ; string res = str ; int number = num ; big integer a number = new big integer ( as ) ; big integer result = a number . clear bit ( number ) ; assert equals ( res , result . to string ( ) ) ; }	clearbit ( 0 ) in the negative number of length 2 with all ones in bit representation.
public final void add ( v value ) { if ( gwt . is script ( ) ) { js array . add ( value ) ; } else { java array . add ( value ) ; } }	insert the given element at the end of the list .
public void test constructor sign bytes negative2 ( ) { byte a bytes [ ] = { - num , num , num , - num , - num , num , num , num , num , - num } ; int a sign = - num ; byte r bytes [ ] = { - num , num , - num , - num , num , num , - num , - num , - num , - num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = a number . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , - num , a number . signum ( ) ) ; }	create a negative number from a sign and an array of bytes.
public void write exif ( byte [ ] jpeg , string exif out file name ) throws file not found exception , io { if ( jpeg == null || exif out file name == null ) { throw new illegal argument exception ( null argument string ) ; } output stream s = null ; s = get exif writer stream ( exif out file name ) ; s . write ( jpeg , num , jpeg . length ) ; s . flush ( ) ; s . close ( ) ; }	writes the tags from this exifinterface object into a jpeg image , removing prior exif tags .
private void convert to array type ( char [ ] [ ] parameter types , int counter , int array dim ) { int length = parameter types [ counter ] . length ; char [ ] array type = new char [ length + array dim * num ] ; system . arraycopy ( parameter types [ counter ] , num , array type , num , length ) ; for ( int i = num ; i < array dim ; i ++ ) { array type [ length + ( i * num ) ] = str ; array type [ length + ( i * num ) + num ] = str ; } parameter types [ counter ] = array type ; }	for example : - int foo ( string [ ] ) is ( [ ljava / lang / string ; ) i = > java.
public type3 message ( type2 message type2 ) { set flags ( get default flags ( type2 ) ) ; set workstation ( get default workstation ( ) ) ; string domain = get default domain ( ) ; set domain ( domain ) ; string user = get default user ( ) ; set user ( user ) ; string password = get default password ( ) ; switch ( lm compatibility ) { case num : case num : set lm ( get lm ( type2 , password ) ) ; set nt ( get nt ( type2 , password ) ) ; break ; case num : byte [ ] nt = get nt ( type2 , password ) ; set lm ( nt ) ; set nt ( nt ) ; break ; case num : case num : case num : byte [ ] client challenge = new byte [ num ] ; random . next bytes ( client challenge ) ; set lm ( get l ( type2 , domain , user , password , client challenge ) ) ; break ; default : set lm ( get lm ( type2 , password ) ) ; set nt ( get nt ( type2 , password ) ) ; } }	creates a type - 3 message in response to the given type - 2 message using default values from the current environment .
public static value parse value ( string n triples value , value factory value factory ) throws illegal argument exception { if ( n triples value . starts with ( str ) ) { return parse uri ( n triples value , value factory ) ; } else if ( n triples value . starts with ( str ) ) { return parse b ( n triples value , value factory ) ; } else if ( n triples value . starts with ( str ) ) { return parse literal ( n triples value , value factory ) ; } else { throw new illegal argument exception ( str + n triples value ) ; } }	parses an n - triples value , creates an object for it using the supplied valuefactory and returns this object .
private pipe writer ( input stream in , output stream out , string tag , int n execs ) { this . in = in ; this . out = new print writer ( out ) ; buf out = new byte array output stream ( ) ; curr sep = new byte [ line separator length ] ; exec string = str + integer . to string ( n execs ) + str + tag + str ; }	create a new pipewriter object.
private void validate mask and place volumes ( storage system array , uri varray uri , map < uri , export mask > mask set , set < uri > invalid masks , export mask mask , export mask placement descriptor placement descriptor , map < uri , volume > volume map , string log msg ) { if ( ! is open stack ( array ) ) { log . info ( log msg ) ; if ( v . validate export mask ( varray uri , initiator port map , mask , invalid masks , director to initiator ids , id to initiator map , db client , coordinator , port wwn to cluster map ) ) { mask set . put ( mask . get id ( ) , mask ) ; placement descriptor . place volumes ( mask . get id ( ) , volume map ) ; } for ( uri invalid mask : invalid masks ) { placement descriptor . invalidate export mask ( invalid mask ) ; } } else { mask set . put ( mask . get id ( ) , mask ) ; placement descriptor . place volumes ( mask . get id ( ) , volume map ) ; } }	validate the mask for only non openstack storage systems now . for openstack , export mask will get validated later before the zoning step.
@ override public void emit tuple ( object tuple ) { output port . emit ( tuple ) ; }	emit the given tuple through the outputport.
protected void check params ( x params ) { if ( params == null ) { throw new illegal argument exception ( str ) ; } params . put if null ( parent window , long . value of ( x . get default root window ( ) ) ) ; params . put if null ( bounds , new rectangle ( def location , def location , min size , min size ) ) ; params . put if null ( depth , integer . value of ( ( int ) x . copy from parent ) ) ; params . put if null ( visual , long . value of ( x . copy from parent ) ) ; params . put if null ( visual class , integer . value of ( ( int ) x . input only ) ) ; params . put if null ( value mask , long . value of ( x . cw ) ) ; rectangle bounds = ( rectangle ) params . get ( bounds ) ; bounds . width = math . max ( min size , bounds . width ) ; bounds . height = math . max ( min size , bounds . height ) ; long event mask obj = ( long ) params . get ( event mask ) ; long event mask = event mask obj != null ? event mask obj . long value ( ) : num ; event mask |= x . property change mask | x . owner grab button mask ; params . put ( event mask , long . value of ( event mask ) ) ; }	verifies that all required parameters are set.
public static integer to integer ( object o , integer default value ) { if ( default value != null ) return integer . value of ( to int value ( o , default value . int value ( ) ) ) ; int res = to int value ( o , integer . min value ) ; if ( res == integer . min value ) return default value ; return integer . value of ( res ) ; }	casts a object to a integer.
protected boolean is index selected ( i selection , int index ) { if ( selection . is empty ( ) ) { return bool ; } iterator < ? > entries = selection . iterator ( ) ; list < i > list = get custom entries as list ( ) ; while ( entries . has next ( ) ) { object next = entries . next ( ) ; if ( list . index of ( next ) == index ) { return bool ; } } return bool ; }	returns whether the item at the given index in the list ( visually ) is selected .
private boolean is primal feasible ( ) { double [ ] x = row ( ) ; double sum = num ; for ( int j = num ; j < n ; j ++ ) { if ( x [ j ] < num ) { std out . println ( str ) ; std out . printf ( str , j , x [ j ] ) ; return bool ; } sum += x [ j ] ; } if ( math . abs ( sum - num ) > epsilon ) { std out . println ( str ) ; std out . println ( str + sum ) ; return bool ; } return bool ; }	the code below is solely for testing correctness of the data type .
public input stream download ( string artifact , string version ) throws io { path path = get artifact ( artifact , version ) ; if ( ! files . exists ( path ) ) { throw new artifact not found exception ( artifact , version ) ; } return new buffered input stream ( files . new input stream ( path ) ) ; }	downloads artifact from the repository .
public dml pop frame ( ) { if ( call stack . is empty ( ) ) return null ; return call stack . pop ( ) ; }	pop frame from stack as function call is done.
public static int last index of ignore case ( string src , char c , int start index , int end index ) { int total = src . length ( ) - num ; if ( total < num ) { return - num ; } if ( start index >= total ) { start index = total ; } if ( end index < num ) { end index = num ; } c = character . to lower case ( c ) ; for ( int i = start index ; i >= end index ; i -- ) { if ( character . to lower case ( src . char at ( i ) ) == c ) { return i ; } } return - num ; }	finds last index of a character in the given source string in specified range [ end , start ].
private void prepare for encoding ( ) { attribute msg int attr = remove attribute ( attribute . message integrity ) ; attribute fingerprint = remove attribute ( attribute . fingerprint ) ; string software = system . get property ( stack properties . software ) ; if ( get attribute ( attribute . software ) == null && software != null && software . length ( ) > num ) { put attribute ( attribute factory . create software attribute ( software . get bytes ( ) ) ) ; } if ( msg int attr != null ) { put attribute ( msg int attr ) ; } if ( fingerprint == null && boolean . get boolean ( stack properties . always sign ) ) { fingerprint = attribute factory . create fingerprint attribute ( ) ; } if ( fingerprint != null ) { put attribute ( fingerprint ) ; } }	adds attributes that have been requested vis configuration properties.
public static double quantile ( double x , double mu , double sigma , double skew ) { x = normal distribution . standard normal quantile ( x ) ; if ( math . abs ( skew ) > num ) { x = ( num - math . exp ( - skew * x ) ) / skew ; } return mu + sigma * x ; }	inverse cumulative probability density function ( probit ) of a normal distribution .
public static map < uuid , collection < cluster node > > neighbors ( collection < cluster node > top snapshot ) { map < string , collection < cluster node > > mac map = new hash map < > ( top snapshot . size ( ) , num ) ; for ( cluster node node : top snapshot ) { string macs = node . attribute ( ignite node attributes . attr macs ) ; collection < cluster node > nodes = mac map . get ( macs ) ; if ( nodes == null ) mac map . put ( macs , nodes = new hash set < > ( ) ) ; nodes . add ( node ) ; } map < uuid , collection < cluster node > > neighbors = new hash map < > ( top snapshot . size ( ) , num ) ; for ( collection < cluster node > group : mac map . values ( ) ) for ( cluster node node : group ) neighbors . put ( node . id ( ) , group ) ; return neighbors ; }	builds neighborhood map for all nodes in snapshot .
public void close ( ) { m socket . close ( ) ; }	closes the underlying socket .
public void test bug68763 ( ) throws exception { replication connection repl conn = null ; repl conn = ( replication connection ) get master slave replication connection ( ) ; repl conn . set read only ( bool ) ; assert false ( str , repl conn . is master connection ( ) ) ; repl conn . set read only ( bool ) ; assert true ( str , repl conn . is master connection ( ) ) ; }	tests fix for bug # 68763 , replicationconnection . ismasterconnection ( ) returns false always.
public boolean ends with ( java . lang . char sequence suffix ) { return starts with ( suffix , length ( ) - suffix . length ( ) ) ; }	indicates if this text ends with the specified suffix .
public boolean is fixed view ( view v ) { { array list < fixed view info > where = m header view infos ; int len = where . size ( ) ; for ( int i = num ; i < len ; ++ i ) { fixed view info info = where . get ( i ) ; if ( info . view == v ) { return bool ; } } } { array list < fixed view info > where = m footer view infos ; int len = where . size ( ) ; for ( int i = num ; i < len ; ++ i ) { fixed view info info = where . get ( i ) ; if ( info . view == v ) { return bool ; } } } return bool ; }	check this view is fixed view ( ex > header & footer ) or not .
@ override public void handle request ( request context rc ) throws cli { super . handle request ( rc ) ; ldap login ( ) ; get options ( rc ) ; validate options ( ) ; normalize options ( ) ; string spec = federation manager . get idff ( rc ) ; string [ ] params = { entity id , metadata , extended data , idp alias , sp alias , attra alias , attrq alias , authna alias , pdp alias , pep alias , affi alias , spec } ; write log ( log writer . log access , level . info , str , params ) ; try { if ( spec . equals ( federation manager . default specification ) ) { handle sam ( rc ) ; write log ( log writer . log access , level . info , str , params ) ; } else if ( spec . equals ( cli . idff specification ) ) { handle idff ( rc ) ; write log ( log writer . log access , level . info , str , params ) ; } else if ( spec . equals ( cli . wsfed specification ) ) { handle ws ( rc ) ; write log ( log writer . log access , level . info , str , params ) ; } else { throw new cli ( get resource string ( str ) , exit codes . request cannot be processed ) ; } } catch ( cli e ) { string [ ] args = { entity id , spec , e . get message ( ) } ; write log ( log writer . log error , level . info , str , args ) ; throw e ; } }	creates meta data template .
public void export ( string file name , int sample rate , short [ ] samples ) throws io { n bytes per sample = num ; buf = new byte [ samples . length * num ] ; for ( int i = num ; i < samples . length ; i ++ ) { buf [ num * i ] = ( byte ) ( ( samples [ i ] & num ) > > > num ) ; buf [ num * i + num ] = ( byte ) ( ( samples [ i ] & num ) ) ; } do write ( file name , sample rate ) ; }	export an array of shorts to a wav file .
public byte [ ] asn1 encode ( ) throws io { der output stream out = new der output stream ( ) ; out . put unaligned bit string ( bits ) ; return out . to byte array ( ) ; }	writes the encoded data .
public void lock row add ( array list < row > rows ) { if ( state == found ) { rows . add ( get ( ) ) ; } }	add the current row to the array , if there is a current row .
public static classification data set read c ( int classification target , path path , char delimiter , int lines to skip , char comment , set < integer > cat cols ) throws io { buffered reader br = files . new buffered reader ( path , charset . default charset ( ) ) ; classification data set ret = read c ( classification target , br , delimiter , lines to skip , comment , cat cols ) ; br . close ( ) ; return ret ; }	reads in a csv dataset as a classification dataset .
public pdf indirect reference add ( pdf indirect reference reference ) { if ( reference == null ) { return null ; } int obj nr = reference . get obj number ( ) ; this . count = math . max ( this . count , obj nr ) ; ensure count ( obj nr ) ; xref [ obj nr ] = reference ; return reference ; }	adds indirect reference to list of indirect objects .
public int do end tag ( ) throws jsp exception { string buffer results = new string buffer ( ) ; results . append ( str ) ; response utils . write ( page context , results . to string ( ) ) ; return ( eval page ) ; }	ignore the end of this tag .
public void test create attribute n ( ) throws throwable { string namespace uri = str ; string malformed name = str ; document doc ; doc = ( document ) load ( str , builder ) ; { boolean success = bool ; try { doc . create attribute ns ( namespace uri , malformed name ) ; } catch ( dom ex ) { success = ( ex . code == dom . namespace err ) ; } assert true ( str , success ) ; } }	runs the test case .
public void append bytes ( byte [ ] bs , int start , int len ) { elems = array utils . ensure capacity ( elems , length + len ) ; system . arraycopy ( bs , start , elems , length , len ) ; length += len ; }	append ` len ' bytes from byte array , starting at given ` start ' offset .
public static string primitive type label ( char type char ) { switch ( type char ) { case str : return str ; case str : return str ; case str : return str ; case str : return str ; case str : return str ; case str : return str ; case str : return str ; case str : return str ; case str : return str ; default : system . err . println ( str + type char ) ; assert bool ; return str ; } }	converts a single - character primitive type into its human - readable equivalent .
public void export as kml ( xml xml writer ) throws io , xml { }	export the record as kml.
public csv ( string matsim output directory ) { log . info ( str ) ; try { accessibility data writer = io . get buffered writer ( matsim output directory + str + accessibility indicators ) ; } catch ( exception ee ) { ee . print stack trace ( ) ; throw new runtime exception ( str ) ; } if ( accessibility data writer == null ) { throw new runtime exception ( str ) ; } try { accessibility data writer . write ( labels . zone id + str + labels . x coordinate + str + labels . y coordinate + str + labels . accessibility by freespeed + str + labels . accessibility by car + str + labels . accessibility by bike + str + labels . accessibility by walk + str + labels . accessibility by pt ) ; accessibility data writer . new line ( ) ; } catch ( io e ) { e . print stack trace ( ) ; throw new runtime exception ( str ) ; } log . info ( str ) ; }	writes the header of accessibility data csv file.
protected d . double constrain point ( d . double p , translation direction dir ) { d . double p0 = constrain point ( ( d . double ) p . clone ( ) ) ; switch ( dir ) { case north : case north west : case north east : if ( p0 . y < p . y ) { p . y = p0 . y ; } else if ( p0 . y > p . y ) { p . y = p0 . y - height ; } break ; case south : case south west : case south east : if ( p0 . y < p . y ) { p . y = p0 . y + height ; } else if ( p0 . y > p . y ) { p . y = p0 . y ; } break ; } switch ( dir ) { case west : case north west : case south west : if ( p0 . x < p . x ) { p . x = p0 . x ; } else if ( p0 . x > p . x ) { p . x = p0 . x - width ; } break ; case east : case north east : case south east : if ( p0 . x < p . x ) { p . x = p0 . x + width ; } else if ( p0 . x > p . x ) { p . x = p0 . x ; } break ; } return p ; }	constrains the placement of a point towards a direction.
protected boolean requires notification from pr ( partitioned region r ) { synchronized ( gem fire cache impl . class ) { boolean has serial senders = has serial senders ( r ) ; boolean result = has serial senders ; if ( ! result ) { iterator all cache servers iterator = all cache servers . iterator ( ) ; while ( all cache servers iterator . has next ( ) ) { cache server impl server = ( cache server impl ) all cache servers iterator . next ( ) ; if ( ! server . get notify by subscription ( ) ) { result = bool ; break ; } } } return result ; } }	check to see if any cache components require notification from a partitioned region . notification adds to the messaging a pr must do on each put / destroy / invalidate operation and should be kept to a minimum.
public graph request ( ) { this ( null , null , null , null , null ) ; }	constructs a request without an access token , graph path , or any other parameters .
public boolean is obscured recipient ( string player name ) { for ( int i = num ; i < obscured recipients . size ( ) ; i ++ ) { string s = obscured recipients . element at ( i ) ; if ( s . equals ( player name ) ) { return bool ; } } return bool ; }	internal method . not for typical use . < p > tests whether the given player name is on the report ' s list of players who received an obscured version of this report from the server at some time in the past .
private void clear exceptional completion ( ) { int h = system . identity hash code ( this ) ; final reentrant lock lock = exception table lock ; lock . lock ( ) ; try { exception node [ ] t = exception table ; int i = h & ( t . length - num ) ; exception node e = t [ i ] ; exception node pred = null ; while ( e != null ) { exception node next = e . next ; if ( e . get ( ) == this ) { if ( pred == null ) t [ i ] = next ; else pred . next = next ; break ; } pred = e ; e = next ; } expunge stale exceptions ( ) ; status = num ; } finally { lock . unlock ( ) ; } }	removes exception node and clears status .
public synchronized void create file ( jdbc file ) throws sql { try { connection . set auto commit ( bool ) ; create file . set string ( num , file . get file name ( ) ) ; create file . set string ( num , file . get extension ( ) ) ; create file . set bytes ( num , new byte [ num ] ) ; create file . execute update ( ) ; try ( result set keys = create file . get generated keys ( ) ) { keys . next ( ) ; file . set id ( keys . get int ( num ) ) ; } connection . commit ( ) ; } catch ( sql e ) { connection . rollback ( ) ; throw e ; } }	creates a new database row representing the supplied file .
public < t > t with feature ( final feature feature , final supplier < t > is set , final supplier < t > is not set ) { return has feature ( feature ) ? is set . get ( ) : is not set . get ( ) ; }	run the given operation if feature is set , or another operation if it is not .
public intent builder add email bcc ( string address ) { if ( m bcc addresses == null ) { m bcc addresses = new array list < string > ( ) ; } m bcc addresses . add ( address ) ; return this ; }	add an email address to be used in the " bcc " field of the final intent .
public void println ( object x ) { out . println ( x ) ; }	prints an object to this output stream and then terminates the line .
public void insert last focused ( string symbol , boolean append ) { if ( this . variable == last focused ) { set variable ( symbol , append ) ; } else { set expression ( symbol , append ) ; } }	inserts the given symbol into the last focused field , of if there isn ' t one the expression field .
@ override public void call ( ) throws exception { while ( ! processing complete || blocklet processing count . get ( ) > num ) { node holder node holder = null ; try { node holder = blocklet data holder . get ( ) ; if ( null != node holder ) { data writer . write blocklet data ( node holder ) ; } blocklet processing count . decrement and get ( ) ; } catch ( throwable throwable ) { if ( ! processing complete || blocklet processing count . get ( ) > num ) { producer executor service . shutdown now ( ) ; reset blocklet processing count ( ) ; throw new carbon data writer exception ( throwable . get message ( ) ) ; } } finally { semaphore . release ( ) ; } } return null ; }	computes a result , or throws an exception if unable to do so .
public lexer ( string s ) { init keywords ( ) ; tok = new stream tokenizer ( new string reader ( s ) ) ; tok . word chars ( str , str ) ; tok . ordinary char ( str ) ; tok . lower case mode ( bool ) ; next token ( ) ; }	creates a new lexical analyzer for the specified sql statement .
@ override public object remove ( object key ) { entry tab [ ] = table ; if ( key != null ) { int hash = system . identity hash code ( key ) ; int index = ( hash & num ) % tab . length ; for ( entry e = tab [ index ] , prev = null ; e != null ; prev = e , e = e . next ) { if ( ( e . hash == hash ) && key == e . key ) { mod count ++ ; if ( prev != null ) prev . next = e . next ; else tab [ index ] = e . next ; count -- ; object old value = e . value ; e . value = null ; return old value ; } } } else { for ( entry e = tab [ num ] , prev = null ; e != null ; prev = e , e = e . next ) { if ( e . key == null ) { mod count ++ ; if ( prev != null ) prev . next = e . next ; else tab [ num ] = e . next ; count -- ; object old value = e . value ; e . value = null ; return old value ; } } } return null ; }	removes the mapping for this key from this map if present .
public static object read ( input stream stream ) throws exception { class < ? > xstream class ; java . lang . reflect . constructor < ? > constructor ; object xstream ; class < ? > [ ] de serialize args classes = new class [ num ] ; object [ ] de serialize args = new object [ num ] ; java . lang . reflect . method method de serialize ; object result ; xstream class = class . for name ( str ) ; constructor = xstream class . get constructor ( ) ; xstream = constructor . new instance ( ) ; de serialize args classes [ num ] = input stream . class ; de serialize args [ num ] = stream ; method de serialize = xstream class . get method ( str , de serialize args classes ) ; try { result = method de serialize . invoke ( xstream , de serialize args ) ; } catch ( exception ex ) { ex . print stack trace ( ) ; result = null ; } return result ; }	reads the xml - serialized object from the given input stream.
private static boolean compare string case ( final string val , final int comparator , final string attr ) { final string value = comparator == approx ? strip whitespaces ( val ) : val ; final string attribute = comparator == approx ? strip whitespaces ( attr ) : attr ; switch ( comparator ) { case approx : case equals : return rf . string compare ( value . to char array ( ) , num , attribute . to char array ( ) , num ) == num ; case greater : return rf . string compare ( value . to char array ( ) , num , attribute . to char array ( ) , num ) <= num ; case less : return rf . string compare ( value . to char array ( ) , num , attribute . to char array ( ) , num ) >= num ; default : throw new illegal state exception ( str ) ; } }	compare a string . case sensitive.
protected string build cache key ( int x , int y , int z , string file ext ) { return build file path ( x , y , z , file ext ) ; }	creates a unique cache key for this tile based on zoom , x , y.
public int partition ( int left , int right , int pivot index ) { e pivot = ar [ pivot index ] ; e tmp = ar [ right ] ; ar [ right ] = ar [ pivot index ] ; ar [ pivot index ] = tmp ; int store = left ; for ( int idx = left ; idx < right ; idx ++ ) { if ( comparator . compare ( ar [ idx ] , pivot ) <= num ) { tmp = ar [ idx ] ; ar [ idx ] = ar [ store ] ; ar [ store ] = tmp ; store ++ ; } } tmp = ar [ right ] ; ar [ right ] = ar [ store ] ; ar [ store ] = tmp ; return store ; }	in linear time , group an array into two parts , those less than or equal to a certain value ( left ) , and those greater than a certain value ( right ) .
public static string reorder modifiers ( string text ) throws formatter exception { return reorder modifiers ( text , collections . singleton ( range . closed open ( num , text . length ( ) ) ) ) ; }	reorders all modifiers in the given text to be in jls order .
public void add files ( collection < string > files ) { check file names ( files ) ; for ( string f : files ) { set files . add ( named for this segment ( f ) ) ; } }	add these files to the set of files written for this segment .
public void test is weak ( ) { try { des . is weak ( null , num ) ; fail ( str + str ) ; } catch ( null pointer exception e ) { fail ( str ) ; } catch ( invalid key exception e ) { } byte [ ] key = { num , num , num , num , num , num , num , num } ; try { des . is weak ( key , num ) ; fail ( str + str ) ; } catch ( null pointer exception e ) { fail ( str ) ; } catch ( invalid key exception e ) { } for ( int i = num ; i < semiweaks . length ; i ++ ) { try { assert true ( str , des . is weak ( semiweaks [ i ] , num ) ) ; } catch ( invalid key exception e ) { fail ( str ) ; } } for ( int i = num ; i < notsemiweaks . length ; i ++ ) { try { assert false ( str , des . is weak ( notsemiweaks [ i ] , num ) ) ; } catch ( invalid key exception e ) { fail ( str ) ; } } }	isweak ( byte [ ] key , int offset ) method testing.
public response on command ( smtp session , request request ) { return not supported ; }	handler method called upon receipt of a expn command.
protected final void compute min max from tile ( data type data type , int n , int size ) { minimum = new double [ samples per pixel ] ; maximum = new double [ samples per pixel ] ; arrays . fill ( minimum , double . max value ) ; arrays . fill ( maximum , - double . max value ) ; byte buffer bbuf = byte buffer . allocate direct ( size ) ; bbuf . order ( byte order ) ; for ( int i = num ; i < n ; ++ i ) { bbuf . rewind ( ) ; long len = read tile ( i , bbuf , size ) ; if ( len == - num ) { throw new illegal state exception ( get tiff ( ) ) ; } bbuf . rewind ( ) ; compute min max ( bbuf ) ; thread . yield ( ) ; } }	compute the minimum and maximum of an entire file .
public synchronized void notify connected ( string title ) { connected server titles . add ( title ) ; update notification ( get string ( r . string . notification connected , title ) , null , bool , bool , bool ) ; }	notify the service of connection to a server ( updates the status bar notification ).
public static boolean is payment type ( generic value payment , string input type id ) throws generic entity exception { if ( payment == null ) { return bool ; } generic value payment type = payment . get related one ( str , bool ) ; if ( payment type == null ) { throw new generic entity exception ( str + payment . get string ( str ) ) ; } string payment type id = payment type . get string ( str ) ; if ( input type id . equals ( payment type id ) ) { return bool ; } return is payment type recurse ( payment type , input type id ) ; }	checks if a payment is of a specified paymenttype.
private list < string > missing fish ( final player player , final boolean hash ) { final list < string > result = new linked list < string > ( ) ; string done text = player . get quest ( quest slot ) ; if ( done text == null ) { done text = str ; } final list < string > done = arrays . as list ( done text . split ( str ) ) ; for ( final string fish : needed fish ) { if ( ! done . contains ( fish ) ) { if ( hash ) { result . add ( str + fish ) ; } else { result . add ( fish ) ; } } } return result ; }	returns a list of the names of all fish that the given player still has to bring to fulfill the quest .
static long read millis ( data input in ) throws io { int v = in . read unsigned byte ( ) ; switch ( v > > num ) { case num : default : v = ( v << ( num - num ) ) > > ( num - num ) ; return v * ( num * num ) ; case num : v = ( v << ( num - num ) ) > > ( num - num ) ; v |= ( in . read unsigned byte ( ) ) << num ; v |= ( in . read unsigned byte ( ) ) << num ; v |= ( in . read unsigned byte ( ) ) ; return v * num ; case num : long w = ( ( ( long ) v ) << ( num - num ) ) > > ( num - num ) ; w |= ( in . read unsigned byte ( ) ) << num ; w |= ( in . read unsigned byte ( ) ) << num ; w |= ( in . read unsigned byte ( ) ) << num ; w |= ( in . read unsigned byte ( ) ) ; return w * num ; case num : return in . read long ( ) ; } }	reads encoding generated by writemillis .
protected string drain inbound message buffer ( string builder builder ) { return drain inbound message buffer ( builder , builder . length ( ) ) ; }	removes all of the characters from inboundmessagebuffer and returns the string removed .
public void end fake drag ( ) { if ( ! m fake dragging ) { throw new illegal state exception ( str ) ; } final velocity tracker velocity tracker = m velocity tracker ; velocity tracker . compute current velocity ( num , m maximum velocity ) ; int initial velocity = ( int ) velocity tracker compat . get y ( velocity tracker , m active pointer id ) ; m populate pending = bool ; if ( ( math . abs ( initial velocity ) > m minimum velocity ) || math . abs ( m initial motion x - m last motion x ) >= ( get width ( ) / num ) ) { if ( m last motion x > m initial motion x ) { set current item internal ( m cur item - num , bool , bool ) ; } else { set current item internal ( m cur item + num , bool , bool ) ; } } else { set current item internal ( m cur item , bool , bool ) ; } end drag ( ) ; m fake dragging = bool ; }	end a fake drag of the pager .
public static string indent ( string str ) { cur indent [ indent depth + num ] = cur indent [ indent depth ] + str . length ( ) ; indent depth = indent depth + num ; return str ; }	there must be an easier way .
private static string load contents ( object file data ) throws io { string path = draft3 file value helper . get path ( file data ) ; input stream is = null ; try { file file = new file ( path ) ; is = new file input stream ( file ) ; byte [ ] buffer = new byte [ math . min ( contents number of bytes , ( int ) file . length ( ) ) ] ; is . read ( buffer ) ; return new string ( buffer , str ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( io e ) { } } } }	load first contents_number_of_bytes bytes from file.
@ override public void write to parcel ( parcel dest , int flags ) { dest . write string ( m name ) ; dest . write long ( m date ) ; dest . write long ( m cod ) ; final weather weather = m weathers . get ( num ) ; dest . write long ( weather . get id ( ) ) ; dest . write string ( weather . get main ( ) ) ; dest . write string ( weather . get description ( ) ) ; dest . write string ( weather . get icon ( ) ) ; dest . write long ( m sys . get sunrise ( ) ) ; dest . write long ( m sys . get sunset ( ) ) ; dest . write string ( m sys . get country ( ) ) ; dest . write double ( m main . get temp ( ) ) ; dest . write long ( m main . get humidity ( ) ) ; dest . write double ( m main . get pressure ( ) ) ; dest . write double ( m wind . get speed ( ) ) ; dest . write double ( m wind . get deg ( ) ) ; }	write this instance out to byte contiguous memory .
public static char [ ] de obfuscate ( string e password ) { if ( e password == null ) return null ; byte [ ] bytes = null ; try { bytes = simple base64 encoder . decode ( e password . substring ( xor tag . length ( ) ) ) ; } catch ( exception e ) { return null ; } for ( int i = num ; i < bytes . length ; i ++ ) { bytes [ i ] = ( byte ) ( ( bytes [ i ] ^ key [ i % key . length ] ) & num ) ; } return to char ( bytes ) ; }	the inverse operation of obfuscate : returns a cleartext password that was previously obfuscated using the xor scrambler .
public void add custom parameter ( custom parameter custom parameter ) { if ( custom parameter == null ) { throw new null pointer exception ( str ) ; } custom parameters . add ( custom parameter ) ; }	adds a new customparameter .
public static boolean valid system name config ( string system name , char type ) { if ( ! valid system name format ( system name , type ) ) { log . warn ( system name + str ) ; return bool ; } serial node node = get node from system name ( system name ) ; if ( node == null ) { log . warn ( system name + str ) ; return bool ; } int bit = get bit from system name ( system name ) ; if ( ( type == str ) || ( type == str ) ) { if ( ( bit <= num ) || ( bit > serial node . output bits [ node . node type ] ) ) { log . warn ( system name + str ) ; return bool ; } } else if ( type == str ) { if ( ( bit <= num ) || ( bit > serial node . input bits [ node . node type ] ) ) { log . warn ( system name + str ) ; return bool ; } } else { log . error ( str ) ; return bool ; } return bool ; }	public static method to validate system name for configuration returns ' true ' if system name has a valid meaning in current configuration , else returns ' false '.
public builder timeout ( long timeout , time unit time unit ) { this . timeout = time unit . to millis ( timeout ) ; return this ; }	set the maximal timeout for waiting until the command comes back with either a job or an empty result .
private void add vertex ( object start , set < dependency > set ) { vertices . put ( start , set ) ; edges . add all ( set ) ; }	add a vertex to the graph .
public void run ( ) throws serialization exception , sql { final string query = string . format ( str + str + str + str + str + str + str + str , table name ) ; map < string , map red stats > stats per stage = session state lite . get map red stats ( ) ; for ( string stage : stats per stage . key set ( ) ) { map red stats stats = stats per stage . get ( stage ) ; prepared statement ps = connection . prepare statement ( query ) ; int ps index = num ; ps . set long ( ps index ++ , audit log id ) ; ps . set string ( ps index ++ , stage ) ; ps . set long ( ps index ++ , stats . get num map ( ) ) ; ps . set long ( ps index ++ , stats . get num reduce ( ) ) ; ps . set long ( ps index ++ , stats . get cpu m ( ) ) ; ps . set string ( ps index , to json ( stats . get counters ( ) ) ) ; ps . execute update ( ) ; } }	runs the log module , writing the relevant audit data to the db .
public void add mapping ( matcher < request > request matcher , response source response source ) { mappings . add first ( new matcher response source pair ( request matcher , response source ) ) ; }	configure a response for matching requests.
private input stream do post ( ) throws io { boundary ( ) ; writeln ( str ) ; os . close ( ) ; return connection . get input stream ( ) ; }	posts the requests to the server , with all the cookies and parameters that were added.
public void wait for signal ( ) { synchronized ( m internal lock ) { if ( this . m trigger state ) { return ; } try { m internal lock . wait ( ) ; } catch ( final interrupted exception e ) { throw new runtime exception ( e ) ; } } }	blocking : waits for the signal to be triggered , or returns immediately if it has already been triggered .
private void uninstall ( string identifier ) { if ( vocabularies by id . contains key ( identifier ) ) { vocabulary to uninstall = vocabularies by id . get ( identifier ) ; file f = get vocab file ( to uninstall . get uri resolvable ( ) ) ; if ( f . exists ( ) ) { f . delete ( ) ; log . debug ( str + f . get absolute path ( ) ) ; } else { log . warn ( str + f . get absolute path ( ) ) ; } vocabularies by id . remove ( identifier ) ; } else { log . warn ( str + identifier ) ; } }	uninstall vocabulary by its unique identifier .
public void add conversation ( conversation conversation ) { conversations . add ( new conversation info ( conversation ) ) ; notify data set changed ( ) ; }	add a conversation to the adapter .
protected static string trim attribute name ( string att name ) { return att name . substring ( num , att name . length ( ) - num ) ; }	removes the last character of the input string and returns the trimmed name.
public synchronized void add object ( object obj ) { fifo . add element ( obj ) ; nb objects ++ ; notify all ( ) ; }	add an object in the buffer.
private void queue alarm ( alarm alarm , transaction builder builder , bluetooth gatt characteristic characteristic ) { calendar calendar = alarm . get alarm cal ( ) ; int days mask = num ; int max alarms = num ; if ( alarm . get index ( ) >= max alarms ) { if ( alarm . is enabled ( ) ) { gb . toast ( get context ( ) , str , toast . length long , gb . warn ) ; } return ; } if ( alarm . is enabled ( ) ) { days mask = alarm . get repetition mask ( ) ; } byte [ ] alarm message = new byte [ ] { ( byte ) num , ( byte ) ( num + alarm . get index ( ) ) , ( byte ) calendar . get ( calendar . hour of day ) , ( byte ) calendar . get ( calendar . minute ) , ( byte ) days mask } ; builder . write ( characteristic , alarm message ) ; }	convert an alarm from the gb internal structure to a mi band message and put on the specified builder queue as a write message for the passed characteristic.
output stream write channel ( int channel ) throws io { while ( os != null ) { boolean can write = bool ; synchronized ( write lock ) { if ( ! is write locked ) { is write locked = bool ; can write = bool ; } else { try { write lock . wait ( num ) ; } catch ( exception e ) { } } } if ( can write ) { os . write ( str ) ; os . write ( channel > > num ) ; os . write ( channel ) ; return os ; } } return null ; }	grabs the channel for writing .
public void reconfig zk ( list < string > observer nodes , list < string > read only nodes ) { log . info ( str + str ) ; try { boolean reconfig local = bool ; for ( string node : observer nodes ) { if ( node . equals ( coordinator ext . get my node id ( ) ) ) { reconfig local = bool ; continue ; } local repository local repository = local repository . get instance ( ) ; local repository . remote reconfig coordinator ( node , str ) ; local repository . remote restart coordinator ( node , str ) ; } for ( string node : read only nodes ) { if ( node . equals ( coordinator ext . get my node id ( ) ) ) { reconfig local = bool ; continue ; } local repository local repository = local repository . get instance ( ) ; local repository . remote reconfig coordinator ( node , str ) ; local repository . remote restart coordinator ( node , str ) ; } if ( reconfig local ) { coordinator ext . reconfig zk ( ) ; } } catch ( exception ex ) { log . warn ( str , ex . to string ( ) ) ; } }	reconfigure zookeeper to participant mode within the local site.
public soot method ( string name , list < type > parameter types , type return type ) { this ( name , parameter types , return type , num , collections . < soot class > empty list ( ) ) ; }	constructs a sootmethod with the given name , parameter types and return type .
public java class read from class path ( string class file ) throws io { thread thread = thread . current thread ( ) ; class loader loader = thread . get context class loader ( ) ; input stream is = loader . get resource as stream ( class file ) ; try { return parse ( is ) ; } finally { is . close ( ) ; } }	reads the class from the classpath .
private byte [ ] convert password to key ( byte [ ] password ) { try { message digest md = message digest . get instance ( str ) ; byte [ ] seed = md . digest ( password ) ; secure random random = secure random . get instance ( str ) ; random . set seed ( seed ) ; byte [ ] rawkey = new byte [ key length ] ; random . next bytes ( rawkey ) ; return rawkey ; } catch ( exception e ) { throw new runtime exception ( e ) ; } }	this method converts the specified password into a key in a deterministic manner.
public static string escape text ( string text ) { string result = text . replace ( str , str ) ; return str + result + str ; }	escapes a given string for use in a java.
private static boolean usable ( method m , class c , class base ) { int mods = m . get modifiers ( ) ; return ( m . get return type ( ) == proxy trust iterator . class && m . get exception types ( ) . length == num && ( mods & modifier . static ) == num && ( ( mods & ( modifier . public | modifier . protected ) ) != num || ( ( mods & modifier . private ) != num ? c == base : same package ( c , base ) ) ) ) ; }	returns true if the method returns proxytrustiterator , has no declared exceptions , and is a non - static member of the base class .
private void digits dash to words ( word relation word relation , item token item , string token val ) { int token length = token val . length ( ) ; int a = num ; for ( int p = num ; p <= token length ; p ++ ) { if ( p == token length || token val . char at ( p ) == str ) { string aaa = token val . substring ( a , p ) ; number expander . expand digits ( aaa , word relation , token item ) ; word relation . add break ( ) ; a = p + num ; } } }	convert the given digit token with dashes ( e.
private void check release ( ) { list < partition reader > to release = new array list < partition reader > ( ) ; for ( partition reader p : hold ) { if ( ! p . is taken ( ) ) { to release . add ( p ) ; finish ( p ) ; } } hold . remove all ( to release ) ; }	check whether to release the hold partitions.
public void test merge one servlet into empty document ( ) throws exception { string src xml = str ; web xml src web xml = web xml io . parse web xml ( new byte array input stream ( src xml . get bytes ( str ) ) , null ) ; string merge xml = str + str + str + str + str + str ; web xml merge web xml = web xml io . parse web xml ( new byte array input stream ( merge xml . get bytes ( str ) ) , null ) ; web xml merger merger = new web xml merger ( src web xml ) ; merger . merge ( merge web xml ) ; assert true ( web xml utils . has servlet ( src web xml , str ) ) ; }	tests whether a single servlet is correctly merged into an empty descriptor .
public string to string ( ) { return str + source + str ; }	returns a printable representation of the read stream .
protected string normalize version ( string version ) { pattern regex = pattern . compile ( str ) ; matcher m = regex . matcher ( version ) ; if ( m != null && m . looking at ( ) ) { string builder normal = new string builder ( ) ; for ( int i = num ; i <= num ; i ++ ) { int v = num ; if ( i == num && i < m . group count ( ) && m . group ( i ) == null && m . group ( i + num ) != null ) { i ++ ; } if ( m . group ( i ) != null ) { try { v = integer . parse int ( m . group ( i ) ) ; } catch ( exception ignore ) { } } if ( i > num ) { normal . append ( str ) ; } normal . append ( v ) ; } return normal . to string ( ) ; } throw new illegal argument exception ( str + version ) ; }	validate the supplied application version , and normalize the version .
public static boolean is extension ( string filename , string extension ) { if ( filename == null ) return bool ; if ( extension == null || extension . length ( ) == num ) return index of extension ( filename ) == - num ; string file ext = get extension ( filename ) ; return file ext . equals ( extension ) ; }	checks whether the extension of the filename is that specified.
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m evaluate thread != null && m evaluate thread . is alive ( ) ) { wait ( ) ; } } catch ( interrupted exception ex ) { } } else { notify all ( ) ; } }	function used to stop code that calls acceptclusterer.
public static boolean same week ( calendar cal , i week ) { return ( cal . get ( calendar . week of year ) == week . get week in year ( ) && cal . get ( calendar . year ) == week . get year ( ) ) ; }	check if calendar instance ' s date is in the same week , as the weekitem instance .
public static image icon create overlay icon ( final image icon base icon , final image icon overlay icon ) { if ( base icon == null ) { throw new illegal argument exception ( str ) ; } if ( overlay icon == null ) { throw new illegal argument exception ( str ) ; } buffered image buffered img = new buffered image ( base icon . get icon width ( ) , base icon . get icon height ( ) , buffered image . type int argb ) ; d g2 = ( d ) buffered img . get graphics ( ) ; g2 . set rendering hint ( rendering hints . key antialiasing , rendering hints . value antialias on ) ; affine transform identity at = new affine transform ( ) ; g2 . draw image ( base icon . get image ( ) , identity at , null ) ; g2 . set composite ( alpha composite . get instance ( alpha composite . src over , num ) ) ; g2 . draw image ( overlay icon . get image ( ) , identity at , null ) ; g2 . dispose ( ) ; return new image icon ( buffered img ) ; }	paints the given overlay icon over the base icon.
public list < estratigrafia > listar ( ) { list < estratigrafia > dados estratigrafia = new array list < > ( ) ; try { string sql = str ; stm = conector . prepare statement ( sql ) ; rs = stm . execute query ( sql ) ; while ( rs . next ( ) ) { estratigrafia estratigrafia = new estratigrafia ( rs . get int ( num ) , rs . get string ( num ) , rs . get string ( num ) , rs . get string ( num ) ) ; dados estratigrafia . add ( estratigrafia ) ; } stm . close ( ) ; rs . close ( ) ; } catch ( sql ex ) { mensagem . erro ( str + ex ) ; } return dados estratigrafia ; }	consultar todas estratigrafia cadastradas na base de dados.
public void run ( ) { int number of lines = highlighter . get number of lines ( ) ; cached line done = new boolean [ number of lines ] ; parser . clear cache ( number of lines ) ; boolean skipbreakpoint = bool ; if ( is break point ( data . get instruction pointer ( ) ) ) { skipbreakpoint = bool ; } int line number = data . get instruction pointer ( ) ; while ( ( line number < number of lines ) ) { if ( ! running ) { break ; } if ( is break point ( line number ) && ! skipbreakpoint ) { break ; } else if ( is break point ( line number ) && skipbreakpoint ) { skipbreakpoint = bool ; } if ( ( line number < number of lines ) ) { data . set instruction pointer ( line number + num ) ; try { execute line number ( line number , bool ) ; } catch ( exception ex ) { update execution mark ( ) ; scroll to execution mark ( ) ; error label . set text ( ex . to string ( ) + str ) ; ex . print stack trace ( ) ; break ; } } line number = data . get instruction pointer ( ) ; } data . update dirty ( ) ; running = bool ; thread . yield ( ) ; update all ( ) ; frame . check button states ( ) ; running thread = null ; }	this method is used to execute the assembler by the new thread .
public boolean equals ( object obj ) { if ( obj == null ) { return bool ; } if ( get class ( ) != obj . get class ( ) ) { return bool ; } final temporal point other = ( temporal point ) obj ; return other . time == time ; }	indicates whether some other object is " equal to " this comparator.
protected void assert starts with ( string text , string expected start ) { if ( ! text . starts with ( expected start ) ) { fail ( str + text + str + expected start + str ) ; } }	check that a text starts with the expected characters.
public static class signature to class signature ( string sig ) throws bad bytecode { try { return parse sig ( sig ) ; } catch ( index out of bounds exception e ) { throw error ( sig ) ; } }	parses the given signature string as a class signature .
public static string format distance between ( lat lng point1 , lat lng point2 ) { if ( point1 == null || point2 == null ) { return null ; } number format number format = number format . get number instance ( ) ; double distance = math . round ( spherical util . compute distance between ( point1 , point2 ) ) ; if ( distance >= num ) { number format . set maximum fraction digits ( num ) ; return number format . format ( distance / num ) + distance km postfix ; } return number format . format ( distance ) + distance m postfix ; }	calculate distance between two latlng points and format it nicely for display.
@ override public void mark ( int read ahead limit ) throws io { f input stream . mark ( read ahead limit ) ; }	mark the present position in the stream.
@ override protected void add convert ( convert metadata convert ) { if ( m converts == null ) { m converts = new array list < convert metadata > ( ) ; } m converts . add ( convert ) ; }	internal : subclasses that support key converts need to override this method .
public static block snapshot validate snapshot ( uri snapshot uri , uri info uri info , db client db client ) { arg validator . check uri ( snapshot uri ) ; block snapshot snapshot = db client . query object ( block snapshot . class , snapshot uri ) ; arg validator . check entity ( snapshot , snapshot uri , block service utils . is id embedded in url ( snapshot uri , uri info ) , bool ) ; return snapshot ; }	validate the blocksnapshot instance with the passed uri .
public boolean match ( uri uri ) { return match normalized ( uri . normalize ( ) ) ; }	returns true if the given uri matches the pattern.
public void add allowed ( class < ? > c , string display name ) { hash set < string > list ; list = m . get ( c ) ; if ( list == null ) { list = new hash set < string > ( ) ; m . put ( c , list ) ; } list . add ( display name ) ; }	adds the given property ( display name ) to the list of allowed properties for the specified class .
public properties find template tags ( ) { properties tags = new properties ( ) ; m error messages . set length ( num ) ; m missing keys . remove all elements ( ) ; while ( bool ) { next token result = get next token ( ) ; if ( ! result . finished parsing ( ) ) { if ( result . found token ( ) && ! begin for each . equals ( result . get key ( ) ) && ! end for each . equals ( result . get key ( ) ) ) { tags . put ( result . get key ( ) , result . get key ( ) ) ; } } else { break ; } } return ( tags ) ; }	this method parses the template substituting keys with values supplied in tags dictionary .
public static container stats calculate stats values ( string stats json ) { container stats state = new container stats ( ) ; if ( stats json == null || stats json . is empty ( ) ) { return state ; } map < string , json element > stats = parse stats ( stats json ) ; calculate cpu usage ( state , stats ) ; set memory usage ( state , stats ) ; set network usage ( state , stats ) ; set container stopped ( state , stats ) ; return state ; }	parse the json stats value and return containerstats state with the calculated values from the json field .
public boolean before writing ( ) { if ( file lock method != file lock . lock serialized ) { return bool ; } while ( checkpoint running ) { try { thread . sleep ( num + ( int ) ( math . random ( ) * num ) ) ; } catch ( exception e ) { } } synchronized ( reconnect sync ) { if ( reconnect modified ( bool ) ) { checkpoint allowed ++ ; if ( sys properties . check && checkpoint allowed > num ) { throw db exception . throw internal error ( ) ; } return bool ; } } reconnect check next = system . current time millis ( ) - num ; reconnect last lock = null ; return bool ; }	this method is called before writing to the transaction log .
private void start monitor thread ( ) { monitor thread = new thread ( new queue monitor ( resource manager ) ) ; monitor thread . start ( ) ; log . debug ( str ) ; }	start the publishing monitor thread itself .
public void center on point rel ( double xrel , double yrel ) { xrel = math . max ( num , xrel ) ; xrel = math . min ( num , xrel ) ; yrel = math . max ( num , yrel ) ; yrel = math . min ( num , yrel ) ; point p = new point ( ( int ) ( ( double ) board size . get width ( ) * xrel ) + hex w , ( int ) ( ( double ) board size . get height ( ) * yrel ) + hex h ) ; j vscroll = scrollpane . get vertical scroll bar ( ) ; vscroll . set value ( p . y - ( vscroll . get visible amount ( ) / num ) ) ; j hscroll = scrollpane . get horizontal scroll bar ( ) ; hscroll . set value ( p . x - ( hscroll . get visible amount ( ) / num ) ) ; repaint ( ) ; }	centers the board to a point.
public object pop ( ) { return stack . pop ( ) ; }	returns the latest element from the stack , removes it .
public boolean connection allowed ( event set descriptor esd ) { return connection allowed ( esd . get name ( ) ) ; }	returns true if , at this time , the object will accept a connection according to the supplied eventsetdescriptor.
protected void validate state ( state current ) { validation utils . validate state ( current ) ; check not null ( current . execution state , str ) ; check is positive number ( current . triggers success , str ) ; check is positive number ( current . triggers error , str ) ; }	validate the service state for coherence .
protected void assert equals ( float expected , float actual ) { if ( expected != actual ) { if ( float . is na n ( expected ) && float . is na n ( actual ) ) { } else { fail ( str + expected + str + actual ) ; } } }	check if two values are equal , and if not throw an exception .
protected static void add volume ( list < block object rest rep > block objects , volume rest rep volume , list < block snapshot rest rep > snapshots ) { block objects . add ( volume ) ; if ( collection utils . is not empty ( snapshots ) ) { iterator < block snapshot rest rep > snapshot iter = snapshots . iterator ( ) ; while ( snapshot iter . has next ( ) ) { block snapshot rest rep snap = snapshot iter . next ( ) ; if ( resource utils . id equals ( snap . get parent ( ) , volume ) ) { block objects . add ( snap ) ; snapshot iter . remove ( ) ; } } } }	add the volume and its snapshots to the ' blockobjects ' list.
private fixed allocator find allocator ( final int block ) { if ( block > c small slot ) { return null ; } final bucket stats = m storage stats . find bucket ( block ) ; if ( stats == null ) { return null ; } if ( stats . m allocators < c small slot waste check allocators ) { return null ; } final float slot waste = stats . slots unused ( ) ; if ( slot waste < c small slot high waste ) { return null ; } fixed allocator candidate = null ; int candidate free bits = c small slot threshold high waste ; for ( int i = num ; i < m allocs . size ( ) ; i ++ ) { final fixed allocator tst = m allocs . get ( i ) ; if ( tst . get block size ( ) == block ) { if ( tst . m free bits > candidate free bits ) { candidate = tst ; candidate free bits = candidate . m free bits ; } } } if ( candidate != null ) { candidate . m small slot high waste = bool ; if ( log . is debug enabled ( ) ) { log . debug ( str ) ; } } return candidate ; }	for a small slot size only , look for an existing allocator that has a sufficient percentage of free bits and add it to the free list.
public static byte [ ] build speex comment ( string comment ) { byte [ ] data = new byte [ comment . length ( ) + num ] ; write speex comment ( data , num , comment ) ; return data ; }	builds and returns a speex comment .
public void add edge ( final edge type edge ) { preconditions . check not null ( edge , str ) ; m edges . add ( edge ) ; update node to edge mapping ( edge ) ; }	adds an edge to the graph .
public collection < extension > build ( collection < string > urls ) { list < extension > extensions = new linked list < extension > ( ) ; for ( string url as string : urls ) { try { extension e = build ( url as string ) ; if ( e != null ) { extensions . add ( e ) ; } } catch ( io e ) { log . error ( str + url as string , e ) ; } catch ( sax e ) { log . error ( str + url as string , e ) ; } } return extensions ; }	builds extensions from the supplied strings which should be urls .
private void parse and add ( string line ) { string tokenizer tokenizer = new string tokenizer ( line , str ) ; try { string phoneme = tokenizer . next token ( ) ; string feature = tokenizer . next token ( ) ; string value = tokenizer . next token ( ) ; phoneset map . put ( get key ( phoneme , feature ) , value ) ; } catch ( no such element exception nse ) { throw new error ( str + line count ) ; } }	creates a word from the given input line and add it to the map .
public locale read ( string locale ) throws exception { string [ ] list = pattern . split ( locale ) ; if ( list . length < num ) { throw new invalid format exception ( str , locale ) ; } return read ( list ) ; }	this method is used to convert the string value given to an appropriate representation.
private string [ ] retrieve enumeration ( string schema table , string column ) throws sql { string [ ] enum elements = null ; string query = str + schema table + str + column + str ; statement st = null ; result set rs = null ; try { st = conn . create statement ( ) ; rs = st . execute query ( query ) ; if ( rs . next ( ) ) { string enum definition = rs . get string ( str ) ; if ( logger . is debug enabled ( ) ) logger . debug ( enum definition ) ; enum elements = parse list type ( enum definition ) ; } } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( sql e ) { } } if ( st != null ) { try { st . close ( ) ; } catch ( sql e ) { } } } return enum elements ; }	connects to the mysql database , executes show columns for a defined table and parses out allowed enum values to their corresponding string representations .
public void add data line ( string [ ] values ) { assert ( headers != null && ! headers . is empty ( ) && headers . size ( ) == values . length ) ; if ( data == null ) { data = new array list < > ( total lines ) ; time to data index = new hash map < > ( ) ; } map < string , string > data map = new hash map < > ( ) ; int num headers = headers . size ( ) ; int current data index = data . size ( ) ; for ( int index = num ; index < num headers ; index ++ ) { string header = headers . get ( index ) ; string value = values [ index ] ; if ( value . equals ( zero ) ) { value = zero ; } else if ( value . equals ( no data ) ) { value = no data ; } data map . put ( header , value ) ; if ( header . equals ( time utc ) ) { time to data index . put ( value , current data index ) ; } } data . add ( data map ) ; }	add the data values.
@ request mapping ( value = str , method = request method . delete , produces = media type . application json value ) @ timed @ secured ( authorities constants . admin ) public response entity < void > delete user ( @ path variable string login ) { }	delete user : login : delete the " login " user .
@ override public boolean equals ( object object ) { if ( this == object ) { return bool ; } if ( object instanceof set ) { set < ? > s = ( set < ? > ) object ; try { return size ( ) == s . size ( ) && contains all ( s ) ; } catch ( null pointer exception ignored ) { return bool ; } catch ( class cast exception ignored ) { return bool ; } } return bool ; }	compares the specified object to this set and returns true if they are equal.
@ override public double java2 d ( double java2 d , d data area , rectangle edge edge ) { range range = get range ( ) ; double vmax = range . get upper bound ( ) ; double vp = get cycle bound ( ) ; double jmin = num ; double jmax = num ; if ( rectangle edge . is top or bottom ( edge ) ) { jmin = data area . get min x ( ) ; jmax = data area . get max x ( ) ; } else if ( rectangle edge . is left or right ( edge ) ) { jmin = data area . get max y ( ) ; jmax = data area . get min y ( ) ; } if ( is inverted ( ) ) { double jbreak = jmax - ( vmax - vp ) * ( jmax - jmin ) / this . period ; if ( java2 d >= jbreak ) { return vp + ( jmax - java2 d ) * this . period / ( jmax - jmin ) ; } else { return vp - ( java2 d - jmin ) * this . period / ( jmax - jmin ) ; } } else { double jbreak = ( vmax - vp ) * ( jmax - jmin ) / this . period + jmin ; if ( java2 d <= jbreak ) { return vp + ( java2 d - jmin ) * this . period / ( jmax - jmin ) ; } else { return vp - ( jmax - java2 d ) * this . period / ( jmax - jmin ) ; } } }	converts a coordinate from java 2d space to data space .
static public document convert to cluster configuration ( document cluster xml , input stream cluster xsl ) throws io , transformer configuration exception , transformer exception , parser configuration exception , sax { document root doc = ( document ) xslt . transform do dom ( cluster xml , cluster xsl ) ; return root doc ; }	method which gets cluster xml dom element and cluster xsl schema input stream.
public static string find edit table ( string tables ) { if ( ! text utils . is empty ( tables ) ) { int spacepos = tables . index of ( str ) ; int commapos = tables . index of ( str ) ; if ( spacepos > num && ( spacepos < commapos || commapos < num ) ) { return tables . substring ( num , spacepos ) ; } else if ( commapos > num && ( commapos < spacepos || spacepos < num ) ) { return tables . substring ( num , commapos ) ; } return tables ; } else { throw new illegal state exception ( str ) ; } }	finds the name of the first table , which is editable .
public char buffer append ( double d ) { return append ( string . value of ( d ) ) ; }	add a double to the buffer .
void do connect ( ) throws io { int port = num ; if ( has more tokens ( ) ) { try { port = next int token ( ) ; } catch ( number format exception ex ) { err ( ex . get localized message ( ) ) ; } } else { port = d . debug connect port ; } if ( port > num ) { m connect port = string . value of ( port ) ; do run ( ) ; } }	fire up a session or await a connection from the socket if no uri was specified .
public void test remove named item n ( ) throws throwable { document doc ; node list element list ; node test address ; named node map attributes ; attr new attr ; node removed node ; doc = ( document ) load ( str , builder ) ; element list = doc . get elements by tag name ( str ) ; test address = element list . item ( num ) ; attributes = test address . get attributes ( ) ; removed node = attributes . remove named item ns ( str , str ) ; assert not null ( str , removed node ) ; new attr = ( attr ) attributes . get named item ( str ) ; assert null ( str , new attr ) ; }	runs the test case .
public static boolean is available ( ) { return s links . size ( ) != num ; }	is online help available .
public boolean connect ( final string address ) { if ( m bluetooth adapter == null || address == null ) { log . w ( tag , str ) ; return bool ; } if ( m bluetooth device address != null && address . equals ( m bluetooth device address ) && m bluetooth gatt != null ) { log . d ( tag , str ) ; if ( m bluetooth gatt . connect ( ) ) { m connection state = state connecting ; return bool ; } else { return bool ; } } final bluetooth device device = m bluetooth adapter . get remote device ( address ) ; if ( device == null ) { log . d ( tag , str ) ; return bool ; } m bluetooth gatt = device . connect gatt ( this , bool , m gatt callback ) ; log . d ( tag , str ) ; m bluetooth device address = address ; m connection state = state connecting ; return bool ; }	connects to the gatt server hosted on the bluetooth le device .
public void filled circle ( double x , double y , double r ) { if ( r < num ) throw new illegal argument exception ( str ) ; double xs = scale x ( x ) ; double ys = scale y ( y ) ; double ws = factor x ( num * r ) ; double hs = factor y ( num * r ) ; if ( ws <= num && hs <= num ) pixel ( x , y ) ; else offscreen . fill ( new d . double ( xs - ws / num , ys - hs / num , ws , hs ) ) ; draw ( ) ; }	draws a filled circle of radius r , centered on ( x , y ) .
public void recalculate path ( ) { if ( target vector != null ) { delta path x = target vector . x pos - start pos . x pos ; delta path y = target vector . y pos - start pos . y pos ; delta path z = target vector . z pos - start pos . z pos ; flat distance = vector2 . distance ( new vector2 ( start pos ) , new vector2 ( target vector ) ) ; max height = num + ( int ) ( flat distance * num ) ; missile flight time = ( float ) math . max ( num , num * flat distance ) - airborne ticks ; acceleration = ( float ) max height * num / ( missile flight time * missile flight time ) ; } }	recalculates required parabolic path for the missile registry.
private boolean has remaining comments ( ) { return last comment index < comments . size ( ) - num ; }	returns if there are comments in the input that we have not looked at yet.
public void register receiver ( broadcast receiver receiver , intent filter filter ) { synchronized ( m receivers ) { receiver record entry = new receiver record ( filter , receiver ) ; array list < intent filter > filters = m receivers . get ( receiver ) ; if ( filters == null ) { filters = new array list < intent filter > ( num ) ; m receivers . put ( receiver , filters ) ; } filters . add ( filter ) ; for ( int i = num ; i < filter . count actions ( ) ; i ++ ) { string action = filter . get action ( i ) ; array list < receiver record > entries = m actions . get ( action ) ; if ( entries == null ) { entries = new array list < receiver record > ( num ) ; m actions . put ( action , entries ) ; } entries . add ( entry ) ; } } }	register a receive for any local broadcasts that match the given intentfilter .
public boolean more ( ) { return pos < in . length ( ) ; }	returns true until the input has been exhausted .
public void save ( ) throws file not found exception { print stream p = new print stream ( file ) ; p . println ( comment prefix + str ) ; for ( pair < string , array list < string > > settings : store ) { p . println ( settings . first ) ; for ( string str : settings . second ) { p . println ( str ) ; } p . println ( ) ; } p . close ( ) ; }	save the current data to the given file .
public form show form ( string resource name , command source command ) { form f = ( form ) create container ( fetch resource file ( ) , resource name ) ; show form ( f , source command , null ) ; return f ; }	this method is equivalent to the internal navigation behavior , it adds functionality such as the back command into the given form resource and shows it.
public general names table model ( ) { column name = res . get string ( str ) ; data = new array list < general name > ( ) ; }	construct a new generalnamestablemodel .
private d calculate range marker text anchor point ( d g2 , plot orientation orientation , d data area , d marker area , rectangle insets marker offset , length adjustment type label offset for range , rectangle anchor anchor ) { d anchor rect = null ; if ( orientation == plot orientation . horizontal ) { anchor rect = marker offset . create adjusted rectangle ( marker area , label offset for range , length adjustment type . contract ) ; } else if ( orientation == plot orientation . vertical ) { anchor rect = marker offset . create adjusted rectangle ( marker area , length adjustment type . contract , label offset for range ) ; } return rectangle anchor . coordinates ( anchor rect , anchor ) ; }	calculates the ( x , y ) coordinates for drawing a marker label .
public string read file content ( file file ) { string builder file content builder = new string builder ( ) ; if ( file . exists ( ) ) { string string line ; try { file reader file reader = new file reader ( file ) ; buffered reader buffered reader = new buffered reader ( file reader ) ; boolean new line = bool ; while ( ( string line = buffered reader . read line ( ) ) != null ) { if ( new line ) { file content builder . append ( str ) ; } file content builder . append ( string line ) ; new line = bool ; } buffered reader . close ( ) ; file reader . close ( ) ; } catch ( file not found exception e ) { e . print stack trace ( ) ; } catch ( io e ) { e . print stack trace ( ) ; } } return file content builder . to string ( ) ; }	reads a content from a file.
public static word prepare word ( object object , offset offset ) { if ( vm . verify assertions ) vm . assert ( vm . not reached ) ; return word . max ( ) ; }	get contents of ( object + offset ) and begin conditional critical section .
protected void transform path ( path path ) { path . transform ( m matrix value to px ) ; path . transform ( m matrix touch ) ; path . transform ( m matrix offset ) ; }	transform a path with all the given matrices very important : keep order to value - touch - offset.
static private string int ( ) { long temp value = integer . max value + num ; return string . value of ( temp value ) ; }	get the max value plus one for an int.
public static byte [ ] decode ( string str ) throws coder exception { byte out [ ] = new byte [ str . length ( ) ] ; int len = num ; int offset = num ; byte b = num ; boolean stop = bool ; string character iterator it = new string character iterator ( str ) ; do { b = dec ( it . current ( ) ) ; it . next ( ) ; if ( b > num ) throw new coder exception ( str + str + str ) ; if ( b < num ) stop = bool ; len += b ; for ( ; b > num ; b -= num ) { decode chars ( it , out , offset ) ; offset += num ; } it . next ( ) ; } while ( ! stop ) ; byte rtn [ ] = new byte [ len ] ; for ( int i = num ; i < len ; i ++ ) rtn [ i ] = out [ i ] ; return rtn ; }	decodes back a string to a byte array.
void call stage3 ( p parameter , t object , c callback ) throws e ;	synchronous call , called multiple times , once per registered callback.
public void add all ( collection < ? extends t > collection ) { if ( m event delegate != null ) m event delegate . add data ( collection == null ? num : collection . size ( ) ) ; if ( collection != null && collection . size ( ) != num ) { synchronized ( m lock ) { m objects . add all ( collection ) ; } } int data count = collection == null ? num : collection . size ( ) ; if ( m observer != null ) m observer . on item range inserted ( get count ( ) - data count + num , data count ) ; if ( m notify on change ) notify item range inserted ( headers . size ( ) + get count ( ) - data count + num , data count ) ; log ( str + ( headers . size ( ) + get count ( ) - data count + num ) + str + ( data count ) ) ; }	adds the specified collection at the end of the array .
public void dump string ( final string builder sb long , final long start , final long end ) { sb long . append ( str ) ; sb long . append ( start ) ; sb long . append ( str ) ; for ( long i = start ; i < end ; i ++ ) { sb long . append ( str ) ; sb long . append ( format integer . to bits ( get ( i ) ) ) ; } sb long . append ( ls ) ; }	string representation on one line of part of the index .
private void merge ( final word alignment state state ) { if ( ! stack . is empty ( ) && state . is complete ( ) ) { final word alignment state parent state = stack . pop ( ) ; if ( parent state . is complete ( ) ) { throw new illegal state exception ( str ) ; } parent state . substitute in ( state ) ; merge ( parent state ) ; } else { stack . add ( state ) ; } }	merges a state with the top of the stack if applicable or places it on top of the stack .
protected void stop with error message ( string error , exception ex ) { stop ( ) ; if ( m log != null ) { m log . status message ( status message prefix ( ) + error + str ) ; m log . log message ( status message prefix ( ) + error + ( ex != null ? str + ex . get message ( ) : str ) ) ; } }	stops the step ( and upstream ones ) and then prints an error message and optional exception message.
public node parse text ( string text ) throws io , sax { return parse ( new string reader ( text ) ) ; }	a helper method to parse the given text as xml .
public void change view position ( view child , int new index ) { int current index = index of child ( child ) ; if ( child != null && child . get parent ( ) == this && current index != new index ) { m change position in progress = bool ; remove view ( child ) ; add view ( child , new index ) ; m change position in progress = bool ; if ( m is expanded && m animations enabled && child . get visibility ( ) != view . gone ) { m children changing positions . add ( child ) ; m needs animation = bool ; } } }	change the position of child to a new location.
public static < t > void write ( string file name , iterable < t > list , i < t , string > transformer ) throws io { buffered writer writer = new buffered writer ( new file writer ( file name ) ) ; for ( t object : list ) { writer . write ( transformer . transform ( object ) ) ; writer . new line ( ) ; } writer . close ( ) ; }	this function writes a list of objects into a file , one per line.
public xy ( time zone zone ) { this ( zone , locale . get default ( ) ) ; }	creates a new dataset with the given time zone .
public void skip to ( int desired position ) { desired position = math . max ( num , desired position ) ; for ( int i = num ; i < desired position ; i ++ ) skip ( ) ; }	this skips until the playlist is playing the specified track .
public static boolean is xm nc ( string nc name ) { int length = nc name . length ( ) ; if ( length == num ) return bool ; int i = num ; char ch = nc name . char at ( num ) ; if ( ! is xm nc ( ch ) ) { if ( length > num && is xm ( ch ) ) { char ch2 = nc name . char at ( num ) ; if ( ! xml . is low surrogate ( ch2 ) || ! is xm nc ( xml . supplemental ( ch , ch2 ) ) ) { return bool ; } i = num ; } else { return bool ; } } while ( i < length ) { ch = nc name . char at ( i ) ; if ( ! is xm nc ( ch ) ) { if ( ++ i < length && is xm ( ch ) ) { char ch2 = nc name . char at ( i ) ; if ( ! xml . is low surrogate ( ch2 ) || ! is xm nc ( xml . supplemental ( ch , ch2 ) ) ) { return bool ; } } else { return bool ; } } ++ i ; } return bool ; }	check to see if a string is a valid ncname according to [ 4 ] from the xml namespaces 1 . 1 recommendation.
public string consume to any ( string ... seq ) { int start = pos ; while ( ! is empty ( ) && ! matches any ( seq ) ) { pos ++ ; } return queue . substring ( start , pos ) ; }	consumes to the first sequence provided , or to the end of the queue.
protected void assert required dependent metric count ( string dictionary name , list < string > dependent metrics ) { int required count = get dependent metrics required ( ) ; int actual count = dependent metrics . size ( ) ; if ( actual count != required count ) { string message = string . format ( str , dictionary name , actual count , required count ) ; log . error ( message ) ; throw new illegal argument exception ( message ) ; } }	checks that we have the right number of metrics , and throws an exception if we don ' t .
private static boolean serialize field ( field f ) { int mod = f . get modifiers ( ) ; return ! modifier . is static ( mod ) && ! modifier . is transient ( mod ) ; }	whether the field must be serialized .
public component manager ( ) { gral components = new sequence collection ( ) ; gral seeds = collections . unmodifiable set ( collections . < sequence > empty set ( ) ) ; }	create an empty component manager , with an empty seed sequence set .
public boolean load properties ( url url , properties props ) { try { input stream props in = url . open stream ( ) ; props . load ( props in ) ; return bool ; } catch ( java . io . io e ) { return bool ; } }	loads properties from a java resource.
public static string format price ( double price ) { return price decimal format . format ( price ) ; }	formats a double representing a price into a string.
public kml ( final list < count sim comparison > count sim comp list , final network network , final coordinate transformation coord transform ) { super ( count sim comp list ) ; this . network = network ; this . counts = null ; this . coord transform = coord transform ; this . graphname = str ; }	sets the data to the fields of this class.
public boolean equals ( object obj ) { if ( this == obj ) return bool ; if ( ! ( obj instanceof ip ) ) return bool ; ip other name = ( ip ) obj ; byte [ ] other = other name . address ; if ( other . length != address . length ) return bool ; if ( address . length == num || address . length == num ) { int mask len = address . length / num ; for ( int i = num ; i < mask len ; i ++ ) { byte masked this = ( byte ) ( address [ i ] & address [ i + mask len ] ) ; byte masked other = ( byte ) ( other [ i ] & other [ i + mask len ] ) ; if ( masked this != masked other ) { return bool ; } } for ( int i = mask len ; i < address . length ; i ++ ) if ( address [ i ] != other [ i ] ) return bool ; return bool ; } else { return arrays . equals ( other , address ) ; } }	compares this name with another , for equality .
public owner impl ( principal impl owner ) { owner list = new vector < principal > ( ) ; owner list . add element ( owner ) ; }	constructs a list of owner with the specified principal as first element .
public final void write double ( double val ) throws io { write long ( double . double to long bits ( val ) ) ; }	writes a 64 - bit double to the target stream.
@ override protected void do get ( http servlet request request , http servlet response response ) throws servlet exception , io { string context path = request . get parameter ( str ) ; string war url = request . get parameter ( str ) ; string command = request . get servlet path ( ) ; if ( command . equals ( str ) ) { deploy ( response , context path , war url ) ; } else if ( command . equals ( str ) ) { undeploy ( response , context path ) ; } else { response . send error ( num , str + command + str ) ; } }	performs the http get method .
public int write class data ( class data class data ) { int off = data . position ( ) ; write uleb128 ( class data . static fields . length ) ; write uleb128 ( class data . instance fields . length ) ; write uleb128 ( class data . direct methods . length ) ; write uleb128 ( class data . virtual methods . length ) ; write fields ( class data . static fields ) ; write fields ( class data . instance fields ) ; write methods ( class data . direct methods ) ; write methods ( class data . virtual methods ) ; return off ; }	write classdata item into current section .
@ deprecated public url to url ( ) throws java . net . url { string name = get absolute name ( ) ; if ( ! name . starts with ( str ) ) { return new url ( str , str , - num , str + name , null ) ; } else if ( name . starts with ( str ) ) { return new url ( str + name ) ; } return new url ( str , str , - num , name , null ) ; }	returns a uniform resource locator for this file.
public byte [ ] generate mwk ( byte [ ] des bytes ) { if ( debug ) { debug . log info ( str + string util . to hex string ( des bytes ) + str + des bytes . length , module ) ; } secret key factory skf1 = null ; secret key mwk = null ; try { skf1 = secret key factory . get instance ( str ) ; } catch ( no such algorithm exception e ) { debug . log error ( e , module ) ; } de desede spec2 = null ; try { desede spec2 = new de ( des bytes ) ; } catch ( invalid key exception e ) { debug . log error ( e , module ) ; } if ( skf1 != null && desede spec2 != null ) { try { mwk = skf1 . generate secret ( desede spec2 ) ; } catch ( invalid key spec exception e ) { debug . log error ( e , module ) ; } } if ( mwk != null ) { return generate mwk ( mwk ) ; } else { return null ; } }	generate a new mwk.
@ override public boolean is pressed ( ) { boolean b = should act like button ( ) ? pressed : super . is pressed ( ) ; return b || ( pressed when popup visible && combo box . is popup visible ( ) ) ; }	indicates if the button is pressed .
public static int random int ( int lower than ) { return random . next int ( lower than ) ; }	get a pseudo random int value between 0 ( including and the given value ( excluding ).
public void save config ( ) { url combo box . get current text ( bool ) ; program properties . put ( str , url combo box . get items as string ( num , str ) ) ; }	save the current configuation.
public url ( string nuri ) throws uri { super ( nuri ) ; if ( uri . length ( ) == colon location + num ) throw new uri ( str , null ) ; if ( uri . char at ( colon location + num ) != str ) throw new uri ( str + uri + str , uri ) ; if ( ! uri . region matches ( num , str , num , colon location ) ) throw new uri ( str + uri + str , uri ) ; }	creates a " res : " url from the given string .
public void aggregate ( class loading information data other ) { count += other . count ; min loaded class count = math . min ( min loaded class count , other . min loaded class count ) ; max loaded class count = math . max ( max loaded class count , other . max loaded class count ) ; total loaded class count += other . total loaded class count ; min total loaded class count = math . min ( min total loaded class count , other . min total loaded class count ) ; max total loaded class count = math . max ( max total loaded class count , other . max total loaded class count ) ; total total loaded class count += other . total total loaded class count ; min unloaded class count = math . min ( min unloaded class count , other . min unloaded class count ) ; max unloaded class count = math . max ( max unloaded class count , other . max unloaded class count ) ; total unloaded class count += other . max unloaded class count ; }	aggregates other class loading object info this object .
private access request create access request ( ) throws no such algorithm exception { request authenticator ra = new request authenticator ( random , secret ) ; access request req = new access request ( get identifier ( ) , ra ) ; return req ; }	generates an access request packet .
public boolean is data flavor supported ( data flavor flavor ) { for ( data flavor flavor2 : flavors ) { if ( flavor2 . equals ( flavor ) ) { return bool ; } } return bool ; }	returns whether the requested flavor is supported by this transferable .
public void write ( rotate stream stream , byte [ ] buffer , int offset , int length ) throws io { try { queue . offer ( new log item binary ( stream , buffer , offset , length ) , num , time unit . seconds ) ; queue . wake ( ) ; } catch ( throwable e ) { e . print stack trace ( environment stream . get original system err ( ) ) ; } }	writes to the stream.
private void expand node ( final tree node node , final tree path path , final int level ) { if ( level <= num ) { return ; } tree . expand path ( path ) ; for ( int i = num ; i < node . get child count ( ) ; ++ i ) { final tree node child node = node . get child at ( i ) ; expand node ( child node , path . path by adding child ( child node ) , level - num ) ; } }	expand the given tree to the given level , starting from the given node and path .
public void add vm ( vm vmpa ) { string key = vmpa . get context reference ( ) ; if ( vmpa . is constant ( ) ) { localcontext . put ( key , vmpa . get object ( wrapped context ) ) ; } else { vmproxyhash . put ( key , vmpa ) ; } }	used to put vmproxyargs into this context . it separates the vmproxyargs into constant and non - constant types pulling out the value of the constant types so they can be modified w / o damaging the vmproxyarg , and leaving the dynamic ones , as they modify context rather than their own state.
public void add pinger ( pinger pinger ) { if ( ! m pingers . contains ( pinger ) ) { m pingers . add ( pinger ) ; notify data set changed ( ) ; } }	add a pinger to the list .
@ override public void on message ( message message ) { synchronized ( messages ) { messages . add ( message ) ; if ( verbose ) { log . info ( str + message ) ; } messages . notify all ( ) ; } }	method implemented from messagelistener interface .
public default independent distribution query prob ( b network , string query var ) { return query prob ( network , query var , new assignment ( ) ) ; }	computes the probability distribution for the query variable , assuming no additional evidence .
public static string encode non codes ( string string ) { matcher matcher = non codes . matcher ( string ) ; string buffer buf = new string buffer ( ) ; int idx = num ; while ( matcher . find ( idx ) ) { int start = matcher . start ( ) ; buf . append ( string . substring ( idx , start ) ) ; buf . append ( str ) ; idx = start + num ; } buf . append ( string . substring ( idx ) ) ; return buf . to string ( ) ; }	encode ' % ' if it is not an encoding sequence.
public void force leader ( int timeout ) { long start = system . current time millis ( ) ; while ( ! cmember . is leader ( ) ) { try { cmember . force leader ( ) ; if ( timeout >= num && system . current time millis ( ) - start > timeout ) { break ; } thread . sleep ( num ) ; } catch ( exception e ) { logger . error ( e . get message ( ) , e ) ; } } }	forces the local member of this shard to become the leader.
private synchronized void sync users ( ) { try { users . clear ( ) ; users . add all ( provider . load users ( ) ) ; } catch ( final couldnt load data exception exception ) { c . log exception ( exception ) ; } }	synchronizes the internal list of known users with the list of known users in the database .
public geometry function find ( string name , int arg count ) { for ( iterator i = functions . iterator ( ) ; i . has next ( ) ; ) { geometry function func = ( geometry function ) i . next ( ) ; string func name = func . get name ( ) ; if ( func name . equals ignore case ( name ) && func . get parameter types ( ) . length == arg count ) return func ; } return null ; }	finds the first function which matches the given name and argument count .
@ override public string to string ( ) { string buffer text = new string buffer ( ) ; if ( m train instances == null ) { text . append ( str ) ; } else { text . append ( str ) ; text . append ( str ) ; if ( m eval using training data ) { text . append ( str ) ; } else { text . append ( str + get folds ( ) + str + str ) ; } text . append ( str + get minimum bucket size ( ) ) ; } text . append ( str ) ; return text . to string ( ) ; }	return a description of the evaluator.
public input tab ( i controller , boolean editable ) { this . editable = editable ; gui container = new j ( ) ; source viewer = new ui ( ) ; source viewer . set listener ( listeners ) ; gui container . add tab ( str , source viewer ) ; raw editor = new ui ( callbacks , editable ) ; raw editor . set listener ( listeners ) ; gui container . add tab ( saml paramtername , raw editor . get component ( ) ) ; saml attacker = new uisaml ( ) ; saml attacker . set listeners ( listeners ) ; gui container . add tab ( str , saml attacker ) ; }	implementing the imessageeditortab . class with the ui components and the businesses logic .
private void marker with colored icon ( google map google map , lat lng lat lng , string public id , string hex color ) { marker options options = new marker options ( ) ; options . position ( lat lng ) ; int color = color . parse color ( hex color ) ; float [ ] hsv = new float [ num ] ; color . color to hsv ( color , hsv ) ; float hue = hsv [ num ] ; options . icon ( bitmap descriptor factory . default marker ( hue ) ) ; marker marker = google map . add marker ( options ) ; public marker ids . put ( marker . get id ( ) , public id ) ; }	places a colored default marker on the map at the required position .
public void run ( ) { string line ; try { while ( is connection open ) { line = in . read line ( ) ; if ( line == null ) break ; process line ( line ) ; } } catch ( io e ) { } finally { try { close ( ) ; } catch ( io e2 ) { } } debug . message ( str , str ) ; }	the running thread simply reads all the lines of input and hands each line off to be parsed .
public static void signal cache close ( ) { is cache closing = bool ; if ( proctor != null ) { proctor . interrupt ( ) ; } if ( watch dog != null ) { watch dog . interrupt ( ) ; } }	should be invoked when gemfire cache is closing or closed .
public synchronized int read from file ( jdbc file , byte buffer bytes ) throws sql { connection . set auto commit ( bool ) ; read large object . set int ( num , file . get id ( ) ) ; int read length = num ; try ( result set rs = read large object . execute query ( ) ) { if ( rs . next ( ) ) { blob blob = rs . get blob ( num ) ; read length = ( int ) calculate read length ( blob . length ( ) , bytes . remaining ( ) , file . position ( ) ) ; byte [ ] data = blob . get bytes ( file . position ( ) + num , read length ) ; bytes . put ( data ) ; } connection . commit ( ) ; return read length ; } catch ( throwable e ) { connection . rollback ( ) ; throw e ; } }	reads data from the file ( at file.
public static string [ ] split string ( string source , char delimeter ) { string [ ] result array = null ; int delimeter index = source . index of ( delimeter ) ; if ( delimeter index < num ) { result array = new string [ num ] ; result array [ num ] = source ; } else { string first str = source . substring ( num , delimeter index ) ; string second str = source . substring ( delimeter index + num ) ; result array = new string [ num ] ; result array [ num ] = first str ; result array [ num ] = second str ; } return result array ; }	returns pair of string objects ( packed in as string array ) that are deparated by one delimeter character in passed source string object.
public static char to char value ( string str ) throws page exception { if ( str . length ( ) > num ) return str . char at ( num ) ; throw new expression exception ( str ) ; }	cast a object to a char value ( primitive value type ).
public column entry ( int col , column column , column metadata metadata ) { this . colnum = col ; this . column = column ; this . metadata = metadata ; this . index = null ; }	create a new columnentry .
public static map parse advices xml ( string advices xml ) throws policy exception { if ( debug . message enabled ( ) ) { debug . message ( str + str + advices xml ) ; } map advices = null ; if ( advices xml != null ) { document document = xml . to dom ( advices xml , debug ) ; if ( document != null ) { node advices node = xml . get root node ( document , advices tag name ) ; if ( advices node != null ) { advices = xml . parse attribute value pair tags ( advices node ) ; } else { if ( debug . message enabled ( ) ) { debug . message ( str + str ) ; } } } else { if ( debug . message enabled ( ) ) { debug . message ( str + str ) ; } } } if ( debug . message enabled ( ) ) { debug . message ( str + str + advices ) ; } return advices ; }	parses an xml string representation of policy advices and returns a map of advices.
private void add unbuffered ( t elem ) { unbuffered elements . add ( elem ) ; if ( unbuffered elements . size ( ) == buffer size ) { collections . sort ( unbuffered elements , compare fn ) ; buffers . add ( new quantile buffer < t > ( unbuffered elements ) ) ; unbuffered elements = lists . new array list with capacity ( buffer size ) ; collapse if needed ( ) ; } }	add a new buffer to the unbuffered list , creating a new buffer and collapsing if needed .
public void add more datas ( list < m > datas ) { if ( datas != null ) { m datas . add all ( m datas . size ( ) , datas ) ; notify item range inserted ( m datas . size ( ) , datas . size ( ) ) ; } }	insert data to datas footer ( example weibo loadmore same newly data ).
public static d from radians2 ( double angle in rad , double magnitude ) { double x = magnitude * math . sin ( angle in rad ) ; double y = magnitude * math . cos ( angle in rad ) ; return new d ( x , y ) ; }	create a 2d vector from an angle relative to the positive y - axis and a magnitude.
public static document to dom ( input stream is , debug debug ) { document builder document builder = null ; try { document builder = get safe document builder ( validating ) ; } catch ( parser configuration exception pe ) { if ( debug != null ) { debug . error ( str , pe ) ; } } try { if ( document builder == null ) { if ( debug != null ) { debug . error ( str ) ; } return null ; } if ( debug != null && debug . warning enabled ( ) ) { document builder . set error handler ( new validation error handler ( debug ) ) ; } return document builder . parse ( is ) ; } catch ( exception e ) { if ( debug != null && debug . warning enabled ( ) ) { debug . warning ( str , e ) ; } return null ; } }	converts the xml document from an input stream to dom document format .
public int prune ( double [ ] alphas , double [ ] errors , instances test ) throws exception { vector < lmt > node list ; compare node comparator = new compare node ( ) ; tree errors ( ) ; calculate alphas ( ) ; node list = get nodes ( ) ; boolean prune = ( node list . size ( ) > num ) ; alphas [ num ] = num ; evaluation eval ; if ( errors != null ) { eval = new evaluation ( test ) ; eval . evaluate model ( this , test ) ; errors [ num ] = eval . error rate ( ) ; } int iteration = num ; while ( prune ) { iteration ++ ; lmt node to prune = collections . min ( node list , comparator ) ; node to prune . m is leaf = bool ; alphas [ iteration ] = node to prune . m alpha ; if ( errors != null ) { eval = new evaluation ( test ) ; eval . evaluate model ( this , test ) ; errors [ iteration ] = eval . error rate ( ) ; } tree errors ( ) ; calculate alphas ( ) ; node list = get nodes ( ) ; prune = ( node list . size ( ) > num ) ; } alphas [ iteration + num ] = num ; return iteration ; }	method for performing one fold in the cross - validation of the cost - complexity parameter.
public static < a > list < a > filter ( list < a > l , a elem ) { assert . check non null ( elem ) ; list < a > res = list . nil ( ) ; for ( a a : l ) { if ( a != null && ! a . equals ( elem ) ) { res = res . prepend ( a ) ; } } return res . reverse ( ) ; }	returns the list obtained from ' l ' after removing all elements ' elem '.
private void reload cache with new value ( final long new value ) { final long new value as primitive = new value == null ? get cache update period ( ) : new value ; log . debug ( str , cache update period listeners . size ( ) ) ; for ( final property change listener listener : cache update period listeners ) { final property change event event = new property change event ( this , str , get cache update period ( ) , new value as primitive ) ; listener . property change ( event ) ; } }	notify all listeners about cacheperiod property changed.
public lucene50 stored fields format ( mode mode ) { this . mode = objects . require non null ( mode ) ; }	stored fields format with specified mode.
private void reset redo ( string name , tungsten properties service props , map < string , string > progress ) { string cluster home ; try { cluster home = cluster configuration . get cluster home ( ) ; } catch ( configuration exception e ) { logger . error ( str , e ) ; return ; } string vmrr control script name = str + name ; file vmrr control script = new file ( cluster home , vmrr control script name ) ; if ( vmrr control script . can execute ( ) ) { logger . info ( str + vmrr control script . get absolute path ( ) ) ; try { redo reader manager vmrr mgr = new redo reader manager ( ) ; vmrr mgr . set vmrr control script ( vmrr control script . get absolute path ( ) ) ; vmrr mgr . set replicate apply name ( name ) ; vmrr mgr . initialize ( ) ; vmrr mgr . reset ( str ) ; } catch ( replicator exception e ) { logger . error ( str + e . get message ( ) , e ) ; } } }	resets the redo reader if it exists.
public boolean verify ( ) throws no such algorithm exception , no such provider exception , invalid key exception , signature exception { return verify ( bouncy castle provider . provider name ) ; }	verify the request using the bc provider .
public static crl load crl ( final input stream input stream ) { try { final crl crl = ( crl ) certificate factory . generate crl ( input stream ) ; return crl ; } catch ( crl e ) { throw new dss ( e ) ; } }	this method loads a crl from the given location .
private boolean copy master cc ( consistency check cc , string schema , string table , database slave db ) throws sql , consistency exception { table table slave = slave db . find table ( schema , table , bool ) ; consistency check cc slave = consistency check factory . create consistency check ( cc . get check id ( ) , table slave , cc . get row offset ( ) , cc . get row limit ( ) , get method ( ) , bool , bool ) ; string query = string . format ( str , consistency table . master crc column name , consistency table . master cnt column name , service schema , consistency table . table name , consistency table . id column name , cc . get check id ( ) ) ; statement st = null ; result set rs = null ; try { st = master db user . create statement ( ) ; rs = st . execute query ( query ) ; if ( rs . next ( ) ) { string master crc = rs . get string ( consistency table . master crc column name ) ; int master cnt = rs . get int ( consistency table . master cnt column name ) ; slave db . consistency check ( consistency table , cc slave , master crc , master cnt ) ; return bool ; } else { return bool ; } } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( sql e ) { } } if ( st != null ) { try { st . close ( ) ; } catch ( sql e ) { } } } }	reads result of the specified consistency check from the master and copies it over to the slave ( manually , without replication ) .
private boolean is merge point ( n target ) { if ( icfg . is start point ( target ) ) return bool ; list < n > preds = icfg . get preds of ( target ) ; int size = preds . size ( ) ; if ( size > num ) return bool ; if ( size > num ) for ( n pred : preds ) if ( icfg . is call stmt ( pred ) ) return bool ; return bool ; }	gets whether the given unit is a merge point in the icfg.
jc transform class parameter type ( parameter parameter ) { function or value decl = parameter . get model ( ) ; if ( ! ( decl . get container ( ) instanceof class ) ) { throw new bug exception ( str ) ; } jc type ; function or value attr = decl ; if ( ! decl . is transient ( attr ) ) { typed reference typed ref = get typed reference ( attr ) ; typed reference non widening typed ref = non widening type decl ( typed ref ) ; type param type = non widening type ( typed ref , non widening typed ref ) ; type = make java type ( non widening typed ref . get declaration ( ) , param type , num ) ; } else { type param type = decl . get type ( ) ; type = make java type ( decl , param type , num ) ; } return type ; }	transforms the type of the given class parameter.
public void update flowgraph settings ( final zy graph view settings settings ) { update graph settings ( flow graph settings , settings ) ; }	updates the default flow graph settings in the configuration file from graph settings .
public static boolean is mobile num ( string mobiles ) { pattern p = pattern . compile ( str ) ; matcher m = p . matcher ( mobiles ) ; return m . matches ( ) ; }	check whether mobile num is legal in mainland china.
private static void assert qual name ( string qual name ) throws xmp { if ( qual name == null || qual name . length ( ) == num ) { throw new xmp ( str , xmp . badxpath ) ; } }	parameterasserts that a qualifier name is set .
public void kill ( string pid ) { send ( string . format ( image server dialog properties . get string ( str ) , pid ) ) ; try { thread . sleep ( num ) ; } catch ( interrupted exception e ) { } }	kill process by pid .
public static map < graph node , d > translate nodes ( collection < graph node > move nodes , map < graph node , d > positions , translater translater ) { map < graph node , d > result = maps . new hash map with expected size ( move nodes . size ( ) ) ; for ( graph node node : move nodes ) { d location = translate node ( node , positions , translater ) ; if ( null == location ) { continue ; } result . put ( node , translater . translate ( location ) ) ; } return result ; }	compute positions of movenodes using the supplied translator.
public static color hex2 rgb ( string colour str ) { return new color ( integer . value of ( colour str . substring ( num , num ) , num ) , integer . value of ( colour str . substring ( num , num ) , num ) , integer . value of ( colour str . substring ( num , num ) , num ) ) ; }	convert colour encoded as hex to rgb .
public d ( j parent , byte [ ] encoded certificate , digest type fingerprint alg ) { super ( parent , dialog . modality type . document modal ) ; this . encoded certificate = encoded certificate ; this . fingerprint alg = fingerprint alg ; init components ( ) ; }	creates a new dviewcertificatefingerprint dialog .
private static ipc endpoint connect tcp endpoint ( string host , int port ) throws ignite checked exception { return new ipc client tcp endpoint ( host , port ) ; }	connects loopback ipc endpoint .
public static byte [ ] slurp ( input stream in ) throws io { if ( in == null ) throw new null pointer exception ( str ) ; try { int n read ; byte [ ] buffer = new byte [ num ] ; byte array output stream out = new byte array output stream ( ) ; while ( ( n read = in . read ( buffer , num , buffer . length ) ) != - num ) { out . write ( buffer , num , n read ) ; } return out . to byte array ( ) ; } finally { in . close ( ) ; } }	fully consume an inputstream into a byte array , and close the input .
public static index reader maybe wrap reader ( index reader r ) throws io { if ( rarely ( ) ) { r = wrap reader ( r ) ; } return r ; }	sometimes wrap the indexreader as slow , parallel or filter reader ( or combinations of that ).
public static sax new sax ( string schema language , boolean namespace aware , boolean validating , file schema ) throws sax , parser configuration exception { schema factory schema factory = schema factory . new instance ( schema language ) ; return new sax ( namespace aware , validating , schema factory . new schema ( schema ) ) ; }	factory method to create a saxparser configured to validate according to a particular schema language and a file containing the schema to validate against .
public enumeration < option > list options ( ) { vector < option > new vector = new vector < option > ( num ) ; new vector . add element ( new option ( str + str , str , num , str ) ) ; new vector . add element ( new option ( str + str , str , num , str ) ) ; new vector . add element ( new option ( str + str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add all ( collections . list ( super . list options ( ) ) ) ; return new vector . elements ( ) ; }	returns an enumeration describing the available options .
public void stop ( ) { try { scheduled executor service . shutdown ( ) ; scheduled executor service . await termination ( termination wait , time unit . milliseconds ) ; } catch ( interrupted exception ignore ) { } }	stops the associated reporting service provided by the given implementation .
public void prepend property ( string property , properties src ) { prepend property ( property , src . get property ( property , str ) ) ; }	prepend the given property into the current properties.
@ override public enumeration < option > list options ( ) { vector < option > new vector = new vector < option > ( num ) ; new vector . add element ( new option ( str + str + str + str , str , num , str ) ) ; return new vector . elements ( ) ; }	returns an enumeration describing the available options .
void generate barcode logic ( string msg , int error correction level ) throws writer exception { int error correction code words = pd . get error correction codeword count ( error correction level ) ; string high level = pd . encode high level ( msg , compaction ) ; int source code words = high level . length ( ) ; int [ ] dimension = determine dimensions ( source code words , error correction code words ) ; int cols = dimension [ num ] ; int rows = dimension [ num ] ; int pad = get number of pad codewords ( source code words , error correction code words , cols , rows ) ; if ( source code words + error correction code words + num > num ) { throw new writer exception ( str + msg . length ( ) + str ) ; } int n = source code words + pad + num ; string builder sb = new string builder ( n ) ; sb . append ( ( char ) n ) ; sb . append ( high level ) ; for ( int i = num ; i < pad ; i ++ ) { sb . append ( ( char ) num ) ; } string data codewords = sb . to string ( ) ; string ec = pd . generate error correction ( data codewords , error correction level ) ; string full codewords = data codewords + ec ; barcode matrix = new barcode matrix ( rows , cols ) ; encode low level ( full codewords , cols , rows , error correction level , barcode matrix ) ; }	generates the barcode logic .
protected key factory ( key factory spi key fac spi , provider provider , string algorithm ) { this . spi = key fac spi ; this . provider = provider ; this . algorithm = algorithm ; }	creates a keyfactory object .
public void rebuild classifier ( int new chain [ ] , instances d ) throws exception { }	rebuild - not yet implemented.
@ override public void draw series ( canvas canvas , paint paint , list < float > points , xy series renderer , float y axis value , int series index , int start index ) { int series nr = m dataset . get series count ( ) ; int length = points . size ( ) ; paint . set color ( series renderer . get color ( ) ) ; paint . set style ( style . fill ) ; float half diff x = get half diff x ( points , length , series nr ) ; int start = num ; if ( start index > num ) { start = num ; } for ( int i = start ; i < length ; i += num ) { if ( points . size ( ) > i + num ) { float x min = points . get ( i ) ; float y min = points . get ( i + num ) ; float x max = points . get ( i + num ) ; float y max = points . get ( i + num ) ; draw bar ( canvas , x min , y min , x max , y max , half diff x , series nr , series index , paint ) ; } } paint . set color ( series renderer . get color ( ) ) ; }	the graphical representation of a series .
public static void send email ( context context , final string receiver , final string subject , final string text ) { send email ( context , new string [ ] { receiver } , subject , text , null , null , null ) ; }	starts email intent with filled by given receiver , subject and text.
public string value ( int arr index ) throws exception { int index = locate index ( arr index ) ; if ( index >= num && ( m indices . get ( index ) == arr index ) ) { return m values . get ( index ) ; } else { return str ; } }	gets the value at index from the array .
private void update system icon ( ) { window window = get window ( ) ; if ( window == null ) { system icon = null ; return ; } java . util . list < image > icons = window . get icon images ( ) ; assert icons != null ; if ( icons . size ( ) == num ) { system icon = null ; } else if ( icons . size ( ) == num ) { system icon = icons . get ( num ) ; } else { system icon = sun toolkit . get scaled icon image ( icons , image width , image height ) ; } }	update the image used for the system icon.
public abstract void send message ( string message ) ;	used to send a message to the send - point we may want to do this - as a reply to an incoming request - at certain intervals - when certain criteria are met ( e.
public static sentence new conjunction ( sentence ... conjuncts ) { return new conjunction ( arrays . as list ( conjuncts ) ) ; }	create a conjunction of conjuncts .
public final synchronized void shutdown engine ( ) { if ( uci engine != null ) { engine monitor . interrupt ( ) ; engine monitor = null ; uci engine . shut down ( ) ; uci engine = null ; } engine state . set state ( main state . dead ) ; }	stop the engine process .
public static void shutdown forcely ( int status ) throws exception { class z = class . for name ( str ) ; method exit = z . get declared method ( str , int . class ) ; exit . set accessible ( bool ) ; exit . invoke ( z , status ) ; }	in order to fight against the permission manager by minecraft forge .
public boolean has badge ( @ id res final int item id ) { return map . contains ( item id ) ; }	returns if the menu item will require a badge.
private static string normalized url ( string host , int port , string path ) { if ( path == null || path . length ( ) == num ) { path = str ; } return str + host + str + port + path ; }	create a url out of the given parameters , translate an empty / null path to ' / '.
private void reset ( ) { m transmitted constellations . clear ( ) ; m new paths . clear ( ) ; m path metrics . reset ( ) ; m survivor paths . clear ( ) ; m survivor paths . add ( new path ( new node ( num , tribit . t0 , con . c0 ) ) ) ; }	resets the decoder before decoding a new data packet .
@ override public void accept test set ( test set event e ) { if ( m training set != null ) { try { if ( m state == idle ) { synchronized ( this ) { m state = clustering ; } m testing set = e . get test set ( ) ; if ( m training set . equal headers ( m testing set ) ) { batch clusterer event ce = new batch clusterer event ( this , m , new data set event ( this , e . get test set ( ) ) , e . get set number ( ) , e . get max set number ( ) , num ) ; notify batch clusterer listeners ( ce ) ; } m state = idle ; } } catch ( exception ex ) { stop ( ) ; if ( m log != null ) { m log . status message ( status message prefix ( ) + str ) ; m log . log message ( str + status message prefix ( ) + str + ex . get message ( ) ) ; } ex . print stack trace ( ) ; } } }	accepts a test set for a batch trained clusterer.
private static pair < byte [ ] , byte [ ] > create names for reverse prefix scan ( @ nonnull byte [ ] name ) { preconditions . check not null ( name , str ) ; preconditions . check argument ( name . length <= cell . max name length , str ) ; if ( name . length == num ) { return pair . create ( name , name ) ; } byte [ ] start name = new byte [ cell . max name length ] ; system . arraycopy ( name , num , start name , num , name . length ) ; for ( int i = name . length ; i < start name . length ; i ++ ) { start name [ i ] = ( byte ) num ; } byte [ ] end name = range requests . previous lexicographic name ( name ) ; return pair . create ( start name , end name ) ; }	this will return a start and end row that will exactly contain all rows for this prefix in reverse . < p > start will be on the left hand side and will be greater lexicographically.
public static fields find by thrift id ( int field id ) { switch ( field id ) { case num : return thing ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
public void test clear bit positive outside1 ( ) { byte a bytes [ ] = { num , - num , num , num , - num , - num , num , num , num , num , - num , num , num } ; int a sign = num ; int number = num ; byte r bytes [ ] = { num , - num , num , num , - num , - num , num , num , num , num , - num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer result = a number . clear bit ( number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	clearbit ( int n ) outside a positive number.
public void write data ( data output dout ) throws io { dout . write short ( reference ) ; dout . write short ( bit count ) ; }	writedata - copy the attribute values for this message to the output buffer .
string parse token ( boolean quoted ) throws jasper exception { string builder string buffer = new string builder ( ) ; skip spaces ( ) ; string buffer . set length ( num ) ; if ( ! has more input ( ) ) { return str ; } int ch = peek char ( ) ; if ( quoted ) { if ( ch == str || ch == str ) { char end quote = ch == str ? str : str ; ch = next char ( ) ; for ( ch = next char ( ) ; ch != - num && ch != end quote ; ch = next char ( ) ) { if ( ch == str ) ch = next char ( ) ; string buffer . append ( ( char ) ch ) ; } if ( ch == - num ) { err . jsp error ( mark ( ) , str ) ; } } else { err . jsp error ( mark ( ) , str ) ; } } else { if ( ! is delimiter ( ) ) { do { ch = next char ( ) ; if ( ch == str ) { if ( peek char ( ) == str || peek char ( ) == str || peek char ( ) == str || peek char ( ) == str ) ch = next char ( ) ; } string buffer . append ( ( char ) ch ) ; } while ( ! is delimiter ( ) ) ; } } return string buffer . to string ( ) ; }	parse a space delimited token.
protected final boolean parse line ( pattern pattern , int timestamp , int hostname , int comp , int pid , int msg , string line ) { final matcher matcher = pattern . matcher ( line ) ; if ( matcher . matches ( ) ) { try { final string msg time str = to string ( matcher , timestamp ) ; final string source255 chars = to string ( matcher , hostname ) ; if ( source255 chars . length ( ) > num ) { m source = source255 chars . substring ( num , num ) ; if ( ! is hostname truncation logged ) { logger . info ( str + source255 chars + str + str + source255 chars . length ( ) + str + m source . length ( ) + str + m source + str ) ; is hostname truncation logged = bool ; } } else { m source = source255 chars ; } m source = m source . to lower case ( ) ; m msg time = to date ( m source , msg time str ) ; m component = to string ( matcher , comp ) ; m pid = to string ( matcher , pid ) ; m text = to string ( matcher , msg ) ; return bool ; } catch ( illegal argument exception e ) { e . print stack trace ( ) ; return bool ; } } return bool ; }	parses a line based on a regex pattern.
public static < a > t < a > from stream ( final m < ? extends stream < a > > monads ) { return of ( monads . map ( null ) ) ; }	create a listt from an anym that wraps a monad containing a stream.
public named icon ( url p url , string p name ) { this ( p url . to string ( ) , p name ) ; }	create a named icon that includes an image to be loaded from a url .
final byte buffer [ ] map ( string resource description , file channel fc , long offset , long length ) throws io { if ( ( length > > > chunk size power ) >= integer . max value ) throw new illegal argument exception ( str + resource description ) ; final long chunk size = num << chunk size power ; final int nr buffers = ( int ) ( length > > > chunk size power ) + num ; byte buffer buffers [ ] = new byte buffer [ nr buffers ] ; long buffer start = num ; for ( int buf nr = num ; buf nr < nr buffers ; buf nr ++ ) { int buf size = ( int ) ( ( length > ( buffer start + chunk size ) ) ? chunk size : ( length - buffer start ) ) ; mapped byte buffer buffer ; try { buffer = fc . map ( map mode . read only , offset + buffer start , buf size ) ; } catch ( io ioe ) { throw convert map failed io ( ioe , resource description , buf size ) ; } if ( preload ) { buffer . load ( ) ; } buffers [ buf nr ] = buffer ; buffer start += buf size ; } return buffers ; }	maps a file into a set of buffers.
@ override public long skip ( long n ) throws io { return f input stream . skip ( n ) ; }	skip characters . this method will block until some characters are available , an i / o error occurs , or the end of the stream is reached .
public static int encode latitude ceil ( double latitude ) { geo utils . check latitude ( latitude ) ; if ( latitude == num ) { latitude = math . next down ( latitude ) ; } return ( int ) math . ceil ( latitude / lat decode ) ; }	quantizes double ( 64 bit ) latitude into 32 bits ( rounding up : in the direction of + 90 ).
protected storage pool check pool exists in db ( string native guid ) throws io { storage pool pool = null ; list < storage pool > pool in db = custom query utility . get active storage pool by native guid ( db client , native guid ) ; if ( pool in db != null && ! pool in db . is empty ( ) ) { pool = pool in db . get ( num ) ; } return pool ; }	check if pool exists in db .
protected void draw html text ( string text , int x , int y , int w , int h , map < string , object > style ) { mx lighweight label text renderer = mx lighweight label . get shared instance ( ) ; if ( text renderer != null && renderer pane != null ) { boolean horizontal = mx utils . is true ( style , mx constants . style horizontal , bool ) ; if ( g . hit clip ( x , y , w , h ) ) { affine transform at = g . get transform ( ) ; if ( ! horizontal ) { g . rotate ( - math . pi / num , x + w / num , y + h / num ) ; g . translate ( w / num - h / num , h / num - w / num ) ; int tmp = w ; w = h ; h = tmp ; } text renderer . set text ( mx utils . create html document ( style , text ) ) ; g . scale ( scale , scale ) ; renderer pane . paint component ( g , text renderer , renderer pane , ( int ) ( x / scale ) + mx constants . label inset , ( int ) ( y / scale ) + mx constants . label inset , ( int ) ( w / scale ) , ( int ) ( h / scale ) , bool ) ; g . set transform ( at ) ; } } }	draws the specified html markup .
public void test neg neg first longer ( ) { byte a bytes [ ] = { - num , num , num , num , - num , - num , num , num , num , num , - num , num , num , - num , num , num , - num , - num } ; byte b bytes [ ] = { - num , - num , - num , - num , num , num , num , num , num , num , num , num , num , num } ; int a sign = - num ; int b sign = - num ; byte r bytes [ ] = { - num , num , - num , - num , - num , num , num , num , num , - num , - num , num , - num , - num , num , - num , - num , num , num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . and ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , - num , result . signum ( ) ) ; }	and for two negative numbers ; the first is longer.
private int num coded units ( channel chan ) { chan . fill mode = br . read ( num ) ; if ( chan . fill mode == num ) { chan . num coded vals = ctx . num quant units ; } else { chan . num coded vals = br . read ( num ) ; if ( chan . num coded vals > ctx . num quant units ) { log . error ( string . format ( str ) ) ; return a p error ; } if ( chan . fill mode == num ) { chan . split point = br . read ( num ) + ( chan . ch num << num ) + num ; } } return num ; }	decode number of coded quantization units .
public defined default behavior provider ( string ... values ) { if ( values == null || values . length == num ) { throw new illegal argument exception ( str ) ; } this . values = arrays . as list ( values ) ; }	create a new defined default behavior provider associated with the specified list of values .
public static list < integer > create colors ( resources r , int [ ] colors ) { list < integer > result = new array list < > ( ) ; for ( int i : colors ) { result . add ( r . get color ( i ) ) ; } return result ; }	turn an array of resource - colors ( contains resource - id integers ) into an array list of actual color integers.
public static long sub address to long ( final string subaddress ) { preconditions . check not null ( subaddress , str ) ; if ( subaddress . contains ( str ) ) { final string [ ] parts = subaddress . split ( str ) ; preconditions . check argument ( parts . length == num , str ) ; final long first part = long . parse long ( parts [ num ] ) ; final long second part = long . parse long ( parts [ num ] ) ; return ( first part * num ) + second part ; } else { throw new illegal argument exception ( str ) ; } }	converts a string that contains a subaddress into a long value with the same offset as the string.
public list < page > relevant pages ( string query ) { list < page > relevant pages = new array list < page > ( ) ; for ( page p : p table . values ( ) ) { if ( matches ( query , p . get content ( ) ) ) { relevant pages . add ( p ) ; } } return relevant pages ; }	fetches and returns all pages that match the query.
public static string comparable qualifier ( string qualifier ) { int i = qualifiers . index of ( qualifier ) ; return i == - num ? ( qualifiers . size ( ) + str + qualifier ) : string . value of ( i ) ; }	returns a comparable value for a qualifier.
public void register success ( string url ) { m delay ms = min delay ; m last request ms = - num ; int bonus = num ; if ( text utils . equals ( m url , url ) ) { bonus = num ; m url = null ; } m score = math . min ( max score , m score + bonus ) ; shared preferences . editor editor = m shared preferences . edit ( ) ; update ban ( editor ) ; editor . apply ( ) ; }	signals that an incoming intent matched with a maylaunchurl ( ) call.
@ visible for testing protected state build patch ( task state . task stage stage , task state . sub stage sub stage ) { return build patch ( stage , sub stage , ( throwable ) null ) ; }	this method builds a patch state object which can be used to submit a self - patch .
private void write object ( java . io . object output stream s ) throws java . io . io { s . default write object ( ) ; s . write int ( values . size ( ) ) ; for ( int i = num ; i < values . size ( ) ; i ++ ) { s . write object ( values . element at ( i ) ) ; } }	overridden to avoid exposing implementation details.
public boolean remove ( object o ) { final reentrant lock lock = this . lock ; lock . lock ( ) ; try { return q . remove ( o ) ; } finally { lock . unlock ( ) ; } }	removes a single instance of the specified element from this queue , if it is present , whether or not it has expired .
public void send add entity ( entity entity ) { array list < entity > entities = new array list < entity > ( num ) ; entities . add ( entity ) ; send add entity ( entities ) ; }	sends an " add entity " packet with only one entity .
public void read bytes ( int position , int num , byte [ ] buf ) { if ( page . page size < position + num ) { throw new page exception ( str ) ; } if ( buf . length < num ) { throw new page exception ( str ) ; } page data . position ( position ) ; page data . get ( buf , num , num ) ; }	reads num bytes from offset position into buf .
public seq < c > take while ( predicate < c > condition ) { objects . require non null ( condition ) ; itr itr = new itr ( ) ; mutable seq < c > seq = seqs . new mutable seq ( ) ; while ( itr . has next ( ) ) { c candidate = itr . next ( ) ; if ( ! condition . test ( candidate ) ) { break ; } seq . append in place ( candidate ) ; } return seq ; }	get elements at the front of this range which satisfy the condition .
@ override public void write end document ( ) throws xml { log . log ( level . fine , str ) ; while ( current . get element ( ) != null ) { write end element ( ) ; } try { wb xml encoder encoder = new wb xml encoder ( stream , doc , encoder type ) ; encoder . encode ( ) ; encoded = bool ; } catch ( io e ) { throw new xml ( str , e ) ; } }	closes any start tags and writes corresponding end tags.
public static void write ( om line , link link , link properties props ) throws io { switch ( line . get render type ( ) ) { case om . rendertype latlon : double [ ] ll = line . get ll ( ) ; link line . write ( ( float ) ll [ num ] , ( float ) ll [ num ] , ( float ) ll [ num ] , ( float ) ll [ num ] , line . get line type ( ) , line . get num segs ( ) , props , link . dos ) ; break ; case om . rendertype xy : int [ ] pts = line . get pts ( ) ; link line . write ( pts [ num ] , pts [ num ] , pts [ num ] , pts [ num ] , props , link . dos ) ; break ; case om . rendertype offset : ll = line . get ll ( ) ; pts = line . get pts ( ) ; link line . write ( ( float ) ll [ num ] , ( float ) ll [ num ] , pts [ num ] , pts [ num ] , pts [ num ] , pts [ num ] , props , link . dos ) ; break ; default : debug . error ( str ) ; } }	write an omline to the link .
public static void show asset ( frame frame , int window no ) { info info = new info asset ( frame , bool , window no , num , str , bool , bool , str ) ; a . show center window ( frame , info ) ; }	show asset info ( non modal ).
public int max ( ) { if ( size ( ) == num ) { throw new illegal state exception ( str ) ; } int max = data [ pos - num ] ; for ( int i = pos - num ; i -- > num ; ) { max = math . max ( max , data [ pos ] ) ; } return max ; }	finds the maximum value in the list .
public static string random string ( string sampler , int length ) { string builder builder = new string builder ( length ) ; for ( int i = num ; i < length ; i ++ ) builder . append ( sampler . char at ( seeded random . next int ( sampler . length ( ) ) ) ) ; return builder . to string ( ) ; }	create a string that is a random sample ( with replacement ) from the given string.
public void add im ( im entity im ) { ims . add ( im ) ; }	adds a new im to this user.
public static string escape ( string string ) { if ( string == null || string . equals ( str ) ) { return string ; } string prefix = str ; if ( string . index of ( str ) != - num ) { prefix = string . substring ( num , string . index of ( str ) + num ) ; string = string . replace first ( prefix , str ) ; } string = string . replace all ( str , str ) ; if ( string . starts with ( str ) ) { string = str + string . replace all ( str , str ) ; } else { string = string . replace all ( str , str ) ; } return prefix . concat ( string ) ; }	escapes double slashes ( / / ) and replace all backslashes ( \ ) with slashes ( / ).
public service call < translation result > translate ( final list < string > texts , final string model id ) { validator . is true ( ( model id != null ) && ! model id . is empty ( ) , str ) ; return translate request ( texts , model id , null , null ) ; }	translate multiple texts using a given model .
public void generate snapshot ( ) { disable redo ( ) ; collection < undo object node > curr deleted objects list = new linked list < undo object node > ( ) ; deleted objects stack . add ( curr deleted objects list ) ; ++ stack level ; }	makes the current state of the list restorable by undo .
public static void print summary ( print stream out ) { print summary ( out , null ) ; print error summary ( out ) ; }	print the statistics report to specified stream.
public static boolean curl and extract package ( string working directory , string package uri , string package destination , boolean is delete package , boolean is verbose ) { log . log ( level . fine , str , package uri ) ; log . fine ( str ) ; if ( ! shell utils . curl package ( package uri , package destination , is verbose , bool ) ) { log . severe ( str ) ; return bool ; } log . log ( level . fine , str , package uri ) ; if ( ! shell utils . extract package ( package destination , working directory , is verbose , bool ) ) { log . severe ( str ) ; return bool ; } if ( is delete package && ! file utils . delete file ( package destination ) ) { log . warning ( str + package destination ) ; } return bool ; }	curl a package , extract it to working directory.
private string name without task id ( string object name ) { int index = object name . index of ( str + hadoop attempt ) ; if ( index > num ) { string attempt = object name . substring ( object name . last index of ( str ) + num ) ; try { id . for name ( attempt ) ; return object name . substring ( num , index ) ; } catch ( illegal argument exception e ) { return object name ; } } return object name ; }	accepts any object name.
public void add variable ( variable initializer v ) { assert not null ( v ) ; variables . add ( v ) ; v . set parent ( this ) ; }	adds a variable initializer node to the child list.
public static list < ? > clone list ( list < ? > source ) { param checks . null not permitted ( source , str ) ; list result = new array list ( ) ; for ( object obj : source ) { if ( obj != null ) { try { result . add ( object utilities . clone ( obj ) ) ; } catch ( clone not supported exception ex ) { throw new runtime exception ( ex ) ; } } else { result . add ( null ) ; } } return result ; }	returns a list containing cloned copies of the items in the source list .
public final list < string > execute string list query ( string sql ) throws ade exception { final list < string [ ] > temp = execute string list query2d ( sql ) ; final list < string > res = new array list < string > ( temp . size ( ) ) ; for ( int i = num ; i < temp . size ( ) ; ++ i ) { final string [ ] row = temp . get ( i ) ; if ( row . length != num ) { throw new ade internal exception ( str + ( i + num ) + str + sql + str + row . length + str ) ; } res . add ( row [ num ] ) ; } return res ; }	executes a given query , that is expected to return a list of strings .
public static int test monitor2 snippet ( ) { integer x = new integer ( num ) ; double y = new double ( num ) ; object z = new object ( ) ; synchronized ( x ) { synchronized ( y ) { synchronized ( z ) { not inlineable ( ) ; return x . int value ( ) ; } } } }	this test case differs from the last one in that it requires inlining within a synchronized region .
@ rpc method public void transfer image ( string image id , string source , string destination , server address destination host , async method callback < host . async client . copy image call > handler ) throws rpc exception { ensure client ( ) ; transfer image request transfer image request = new transfer image request ( ) ; transfer image request . set destination datastore id ( destination ) ; transfer image request . set destination host ( destination host ) ; transfer image request . set source datastore id ( source ) ; transfer image request . set source image id ( image id ) ; client proxy . set timeout ( transfer image timeout ms ) ; logger . info ( str , get host ip ( ) , transfer image request ) ; try { client proxy . transfer image ( transfer image request , handler ) ; } catch ( t e ) { throw new rpc exception ( e . get message ( ) ) ; } }	this method performs an asynchronous thrift call to copy an image from one host to another.
public static int parse rgb ( fxg node , string value , string name ) { matcher m ; m = rgb pattern . matcher ( value ) ; if ( ! m . matches ( ) ) { throw new fxg ( node . get start line ( ) , node . get start column ( ) , str , name , value ) ; } value = value . substring ( num ) ; int a = num ; int r = integer . parse int ( value . substring ( num , num ) , num ) & num ; int g = integer . parse int ( value . substring ( num , num ) , num ) & num ; int b = integer . parse int ( value . substring ( num , num ) , num ) & num ; return ( a << num ) | ( r << num ) | ( g << num ) | b ; }	convert an fxg hexadecimal color string to an int.
public boolean over point ( float lat , float lon ) { azimuth var az var = new azimuth var ( ) ; d pt = forward ( lat , lon , new d . float ( ) , az var ) ; if ( az var . invalid forward ) { return bool ; } if ( ( pt . get x ( ) < num ) || ( pt . get x ( ) > width ) || ( pt . get y ( ) < num ) || ( pt . get y ( ) > height ) ) { return bool ; } return bool ; }	checks if the point is visible on the screen .
public set < table id > read all table names ( string [ ] table types ) throws sql { return read table names ( null , null , null , table types ) ; }	get the identifiers of all available tables .
< t > t optional ( object obj , class < t > clazz , string part ) throws parse exception { if ( obj == null ) { return null ; } return expect ( obj , clazz , part ) ; }	abort with a parseexception if obj is not either null or of type clazz , returning obj otherwise .
@ override public void update ( graphics g ) { paint ( g ) ; }	updates the display area of the window .
private boolean serialize compact rdf ( xmp parent node , int indent ) throws io { boolean all are attrs = bool ; for ( iterator it = parent node . iterate children ( ) ; it . has next ( ) ; ) { xmp prop = ( xmp ) it . next ( ) ; if ( can be rdf ( prop ) ) { write newline ( ) ; write indent ( indent ) ; write ( prop . get name ( ) ) ; write ( str ) ; append node value ( prop . get value ( ) , bool ) ; write ( str ) ; } else { all are attrs = bool ; } } return all are attrs ; }	write each of the parent ' s simple unqualified properties as an attribute.
public void process invite ( request event request event , server transaction server transaction ) { sip provider sip provider = ( sip provider ) request event . get source ( ) ; request request = request event . get request ( ) ; try { server transaction = sip provider . get new server transaction ( request ) ; dialog = ( dialog ext ) sip provider . get new dialog ( server transaction ) ; dialog . disable sequence number validation ( ) ; } catch ( exception e ) { e . print stack trace ( ) ; } try { response ok response = message factory . create response ( response . ok , request ) ; from header from = ( from header ) ok response . get header ( from header . name ) ; from . remove parameter ( str ) ; address address = address factory . create address ( str + my address + str + my port + str ) ; contact header contact header = header factory . create contact header ( address ) ; to header to header = ( to header ) ok response . get header ( to header . name ) ; to header . set tag ( str ) ; from header from header = ( from header ) ok response . get header ( from header . name ) ; from header . set tag ( str ) ; ok response . add header ( contact header ) ; server transaction . send response ( ok response ) ; } catch ( exception ex ) { ex . print stack trace ( ) ; system . exit ( num ) ; } }	process the invite request .
private static pattern compile pattern ( final string s ) { string builder rc = new string builder ( ) ; for ( int i = num ; i < s . length ( ) ; i ++ ) { char ch = s . char at ( i ) ; switch ( ch ) { case str : rc . append ( str ) ; break ; case str : rc . append ( str ) ; break ; case str : rc . append ( str ) ; default : rc . append ( ch ) ; } } return pattern . compile ( rc . to string ( ) ) ; }	convert host pattern from glob format to regexp.
@ suppress warnings ( str ) public uniform generator ( vector < string > values ) { values = ( vector < string > ) values . clone ( ) ; laststring = null ; gen = new uniform integer generator ( num , values . size ( ) - num ) ; }	creates a generator that will return strings from the specified set uniformly randomly.
public void test direct sockets exception if port not open ( ) throws io { final inet socket address server addr1 = new inet socket address ( get port ( num ) ) ; final inet socket address server addr2 = new inet socket address ( get port ( num ) ) ; final server socket ss1 = new server socket ( ) ; try { ss1 . bind ( server addr1 ) ; assert true ( ss1 . get channel ( ) == null ) ; try { accept ( ss1 ) ; fail ( str ) ; } catch ( assertion failed error afe ) { } final socket channel cs1 = socket channel . open ( ) ; try { final boolean immediate1 = cs1 . connect ( server addr1 ) ; if ( ! immediate1 ) { if ( ! cs1 . finish connect ( ) ) { fail ( str ) ; } } } finally { cs1 . close ( ) ; } final socket channel cs2 = socket channel . open ( ) ; try { cs1 . connect ( server addr2 ) ; fail ( str + io . class ) ; } catch ( io ex ) { if ( log . is info enabled ( ) ) log . info ( str + ex ) ; } finally { cs2 . close ( ) ; } try { accept ( ss1 ) ; fail ( str ) ; } catch ( assertion failed error afe ) { } } finally { ss1 . close ( ) ; } }	simple test of connecting to a server socket and the failure to connect to a port not associated with a server socket .
public void connected ( ) { synchronized ( this ) { if ( idle reconnect future != null ) idle reconnect future . cancel ( bool ) ; schedule idle task ( idle timeout msec . get ( ) , bool ) ; } }	to be called when the connector has become connected .
public string escape attribute entities ( string str ) { string buffer buffer ; char ch ; string entity ; buffer = null ; for ( int i = num ; i < str . length ( ) ; i ++ ) { ch = str . char at ( i ) ; switch ( ch ) { case str : entity = str ; break ; case str : entity = str ; break ; case str : entity = str ; break ; case str : entity = str ; break ; case str : entity = str ; break ; case str : entity = str ; break ; case str : entity = str ; break ; default : entity = null ; break ; } if ( buffer == null ) { if ( entity != null ) { buffer = new string buffer ( str . length ( ) + num ) ; buffer . append ( str . substring ( num , i ) ) ; buffer . append ( entity ) ; } } else { if ( entity == null ) { buffer . append ( ch ) ; } else { buffer . append ( entity ) ; } } } return ( buffer == null ) ? str : buffer . to string ( ) ; }	this will take the pre - defined entities in xml 1.
private void await all ( ) throws interrupted exception , execution exception { if ( buffer . is open ( ) ) { throw new illegal state exception ( ) ; } will shutdown ( ) ; while ( bool ) { halted ( ) ; final e [ ] a ; lock . lock interruptibly ( ) ; try { a = redirect queue . poll ( ) ; if ( a == null ) { if ( finished subtask queue . is empty ( ) && sinks . is empty ( ) && redirect queue . is empty ( ) && nothing pending ( ) ) { if ( log . is info enabled ( ) ) log . info ( str + this ) ; return ; } if ( log . is debug enabled ( ) ) log . debug ( str + sinks . size ( ) + str + this ) ; drain futures ( ) ; if ( ! finished subtask queue . is empty ( ) ) { subtask done . await ( num , time unit . milliseconds ) ; } } } finally { lock . unlock ( ) ; } if ( a != null ) { handle chunk ( a , bool ) ; } } }	await the completion of the writes on each index partition.
public void invoke ( object receiver , string method name , string argument ) { util . throw if null ( receiver , method name , argument ) ; int size = invokers . size ( ) ; for ( int i = num ; i < size ; ++ i ) { final typed method invoker < ? > invoker = invokers . get ( i ) ; if ( invoker . invoke ( receiver , method name , argument ) ) { return ; } } log util . w ( str + method name + str ) ; }	tries to invoke a method on receiver with a single argument by trying out different types for arg until it finds one that matches ( or not ).
public long size ( ) { return is null ( ) ? num : this . end - this . start + num ; }	returns the size of this range ( the number of values within its bounds ) .
private void create plugin manifest ( int i , string p folder path ) throws io { file writer out = new file writer ( p folder path + file . separator + str ) ; string xml = str + str + str + i + str + i + str + str + str + str + str + str + str + str + str + str + str + str ; out . write ( xml ) ; out . flush ( ) ; out . close ( ) ; }	creates an plugin manifest file.
static void b2i big ( byte [ ] in , int in ofs , int [ ] out , int out ofs , int len ) { if ( ( in ofs < num ) || ( ( in . length - in ofs ) < len ) || ( out ofs < num ) || ( ( out . length - out ofs ) < len / num ) ) { throw new array index out of bounds exception ( ) ; } if ( little endian unaligned ) { in ofs += byte array ofs ; len += in ofs ; while ( in ofs < len ) { out [ out ofs ++ ] = reverse bytes ( unsafe . get int ( in , ( long ) in ofs ) ) ; in ofs += num ; } } else if ( big endian && ( ( in ofs & num ) == num ) ) { in ofs += byte array ofs ; len += in ofs ; while ( in ofs < len ) { out [ out ofs ++ ] = unsafe . get int ( in , ( long ) in ofs ) ; in ofs += num ; } } else { len += in ofs ; while ( in ofs < len ) { out [ out ofs ++ ] = ( ( in [ in ofs + num ] & num ) ) | ( ( in [ in ofs + num ] & num ) << num ) | ( ( in [ in ofs + num ] & num ) << num ) | ( ( in [ in ofs ] ) << num ) ; in ofs += num ; } } }	byte [ ] to int [ ] conversion , big endian byte order .
private static j create chart ( ) { xy series1 = new xy ( str ) ; series1 . add ( num , num ) ; series1 . add ( num , num ) ; series1 . add ( num , num ) ; xy dataset = new xy ( series1 ) ; return chart factory . create xy ( str , str , str , dataset ) ; }	create a chart for testing .
public void add intra pass ordering constraint ( detector ordering constraint constraint ) { intra pass constraint list . add ( constraint ) ; }	add an intra - pass detector ordering constraint .
public int connect timeout ( ) { return reader . get integer ( connect timeout , default connect timeout ) ; }	the connect timeout in milliseconds .
public static duration parse duration ( string s ) { return dt factory . new duration ( s ) ; }	parses the supplied xsd : duration value string and returns its value .
public static boolean is lower case ( final string value ) { validate ( value , null string predicate , null string msg supplier ) ; for ( int i = num ; i < value . length ( ) ; i ++ ) { if ( character . is upper case ( value . char at ( i ) ) ) { return bool ; } } return bool ; }	verifies if string is lower case.
private void score waypoint results ( collection < waypoint > waypoints , search query query , collection < scored result > output ) { for ( waypoint waypoint : waypoints ) { double score = score waypoint result ( query , waypoint ) ; output . add ( new scored result ( waypoint , score ) ) ; } }	scores a collection of waypoint results .
public d ( j parent , key store type key store type , key pair type key pair type , int key pair size ) { super ( parent , res . get string ( str ) , dialog . modality type . document modal ) ; this . key pair type = key pair type ; this . key pair size = key pair size ; this . key store type = key store type ; init components ( ) ; }	creates a new dgeneratekeypair dialog .
public update info ( string feature id ) { this . feature id = feature id ; }	constructs an object to hold update information for the given feature .
public boolean leaves zone ( final d shape ) { final double x = shape . get x ( ) ; final double y = shape . get y ( ) ; final double w = shape . get width ( ) ; final double h = shape . get height ( ) ; return ( x < num ) || ( x + w > width ) || ( y < num ) || ( y + h > height ) ; }	check if a rectangle is at least partially outside the map .
static int exclusive count ( int c ) { return c & exclusive mask ; }	returns the number of exclusive holds represented in count.
public static boolean is final ( final field field ) { return modifier . is final ( field . get modifiers ( ) ) ; }	checks if is final .
public void invalidate cache ( int start , int end ) { m valid . clear ( start , end + num ) ; }	invalidate a range of the cache .
@ override public state connection service ( ) throws io { try { connection protocol request = request or create ( ) ; if ( request == null ) { log . warning ( str + this ) ; return state connection . close ; } state connection next = request . service ( ) ; if ( next != state connection . close ) { return next ; } else { return on close read ( ) ; } } catch ( out of memory error e ) { string msg = str ; shutdown system . shutdown out of memory ( msg ) ; log . log ( level . warning , e . to string ( ) , e ) ; } catch ( throwable e ) { e . print stack trace ( ) ; log . log ( level . warning , e . to string ( ) , e ) ; } return state connection . close ; }	service a http request .
public boolean is auto archive ( ) { string aa = get auto archive ( ) ; return aa != null && ! aa . equals ( autoarchive ) ; }	is auto archive on.
private static int numeric compaction ( int [ ] codewords , int code index , string builder result ) throws format exception { int count = num ; boolean end = bool ; int [ ] numeric codewords = new int [ max numeric codewords ] ; while ( code index < codewords [ num ] && ! end ) { int code = codewords [ code index ++ ] ; if ( code index == codewords [ num ] ) { end = bool ; } if ( code < text compaction mode latch ) { numeric codewords [ count ] = code ; count ++ ; } else { if ( code == text compaction mode latch || code == byte compaction mode latch || code == byte compaction mode latch 6 || code == begin macro pd control block || code == begin macro pd optional field || code == macro pd terminator ) { code index -- ; end = bool ; } } if ( count % max numeric codewords == num || code == numeric compaction mode latch || end ) { if ( count > num ) { string s = decode base900to base10 ( numeric codewords , count ) ; result . append ( s ) ; count = num ; } } } return code index ; }	numeric compaction mode ( see 5.
private void check completion ( ) { for ( iterator < compute task future < integer > > iter = futures . iterator ( ) ; iter . has next ( ) ; ) { compute task future < integer > fut = iter . next ( ) ; if ( fut . is done ( ) ) { try { integer res = fut . get ( ) ; assert res == params . get jobs count ( ) : str + fut . get task session ( ) . get id ( ) + str + res + str ; ignite . log ( ) . info ( str + fut . get task session ( ) . get id ( ) ) ; } catch ( ignite future cancelled exception ignored ) { ignite . log ( ) . info ( str + fut . get task session ( ) . get id ( ) ) ; } catch ( ignite exception e ) { ignite . log ( ) . warning ( str + fut . get task session ( ) . get id ( ) , e ) ; } finally { iter . remove ( ) ; } } } }	finds completed tasks in the queue and removes them .
public void dup x2 ( ) { mv . visit insn ( opcodes . dup ) ; }	generates a dup_x2 instruction .
public change set add all to collection ( string path , serializable ... new items ) { return add all to collection ( path , arrays . as list ( new items ) ) ; }	adds the given items to a collection property.
public void add window drag listener ( window drag listener listener ) { drag listeners . add ( listener ) ; }	add a window drag listener.
static automaton reverse ( automaton a , set < integer > initial states ) { if ( operations . is empty ( a ) ) { return new automaton ( ) ; } int num states = a . get num states ( ) ; automaton . builder builder = new automaton . builder ( ) ; builder . create state ( ) ; for ( int s = num ; s < num states ; s ++ ) { builder . create state ( ) ; } builder . set accept ( num , bool ) ; transition t = new transition ( ) ; for ( int s = num ; s < num states ; s ++ ) { int num transitions = a . get num transitions ( s ) ; a . init transition ( s , t ) ; for ( int i = num ; i < num transitions ; i ++ ) { a . get next transition ( t ) ; builder . add transition ( t . dest + num , s + num , t . min , t . max ) ; } } automaton result = builder . finish ( ) ; int s = num ; bit set accept states = a . get accept states ( ) ; while ( s < num states && ( s = accept states . next set bit ( s ) ) != - num ) { result . add epsilon ( num , s + num ) ; if ( initial states != null ) { initial states . add ( s + num ) ; } s ++ ; } result . finish state ( ) ; return result ; }	reverses the automaton , returning the new initial states .
public boolean add rules ( list < rule > rule list ) { for ( int i = num ; i < rule list . size ( ) ; i ++ ) { if ( ! valid rule ( rule list . get ( i ) ) ) { return bool ; } } if ( ! validate rule probabilities ( rule list ) ) { return bool ; } this . rules = rule list ; update vars and terminals ( ) ; return bool ; }	add a rulelist as the grammar ' s rule list if all rules in it pass both the restrictions of the context - free grammar , and all rules or in chomsky - normal - form.
public static boolean is digit ( char c ) { return character . is digit ( c ) ; }	returns true if character c is a digit ( 0.
private static element add bean ( document doc , node parent , class < ? > cls ) { element elem = doc . create element ( str ) ; elem . set attribute ( str , cls . get name ( ) ) ; parent . append child ( elem ) ; return elem ; }	add bean to xml document .
public void test first position ( ) throws exception { break iterator expected = break iterator . get sentence instance ( locale . root ) ; break iterator actual = new whole break iterator ( ) ; assert same breaks ( str , num , num , num , expected , actual ) ; }	the current position must be ignored , initial position is always first ( ).
public void test get instance2 ( ) throws java . security . cert . certificate encoding exception , certificate encoding exception { boolean certificate exception = bool ; x509 certificate c = null ; if ( this . cert == null ) { return ; } try { c = x509 certificate . get instance ( cert . get encoded ( ) ) ; } catch ( java . security . cert . certificate encoding exception e ) { fail ( str ) ; } catch ( certificate exception e ) { certificate exception = bool ; } if ( ! certificate exception ) { assert not null ( c ) ; assert true ( arrays . equals ( c . get encoded ( ) , cert . get encoded ( ) ) ) ; } try { x509 certificate . get instance ( new byte [ ] { ( byte ) num } ) ; } catch ( certificate exception e ) { } try { x509 certificate . get instance ( ( byte [ ] ) null ) ; fail ( str ) ; } catch ( certificate exception e ) { } }	getinstance ( byte [ ] certdata ) method testing .
public static boolean matches ( mapped member mm , mapped member mm2 , boolean orig ) { return matches ( mm , orig ? mm2 . get original name ( ) : mm2 . get new name ( ) , mm2 . get desc ( ) , bool ) ; }	checks if two mapped members are the same .
public void add all ( collection < pdf object > c ) { list . add all ( c ) ; }	adds the collection of pdfobjects .
public boolean read from file ( ) { return read from file ( filename ) ; }	read save data from standard file loads the storage data from the default storage file note : lock is acquired in logic before this is called.
public static lng lat normalize lng lat ( lng lat p1 ) { if ( p1 . longitude < util . min lon || p1 . longitude > util . max lon ) { int wraps = ( int ) math . floor ( ( p1 . longitude - util . min lon ) / util . lon per world ) ; p1 . longitude -= wraps * util . lon per world ; } return p1 ; }	mapzens mapcontroller sometimes returns longitudes outside of - 180 / + 180 so we convert it to a normal value.
public final boolean cancel ( @ non null final string tag , final boolean may interrupt ) { final integer id = m tagged requests . get ( tag ) ; if ( id != null ) { return cancel ( id , may interrupt ) ; } else { return bool ; } }	cancels operation launch by its tag.
public void start ( ) { check ( numthreads , num , num ) ; go . count down ( ) ; }	fires the pistol ! go threads go.
public < t extends node > t jjt get child ( class < t > type ) { for ( node n : children ) { if ( type . is instance ( n ) ) { return ( t ) n ; } } return null ; }	gets the ( first ) child of this node that is of the specific type .
public static string url decode ( string text ) { if ( string utils . is empty ( text ) ) { return text ; } try { if ( text . contains ( str ) ) { return url . decode ( text , str ) ; } return url . decode ( text , str ) ; } catch ( exception ex ) { log . warn ( str + text , ex ) ; } return text ; }	tries to decode specified text ( also trying to autodetect encoding ).
protected void layout ( tree node node ) { if ( node != null ) { tree node child = node . child ; while ( child != null ) { layout ( child ) ; child = child . next ; } if ( node . child != null ) { attach parent ( node , join ( node ) ) ; } else { layout leaf ( node ) ; } } }	starts the actual compact tree layout algorithm at the given node .
of ref ( abstract pipeline < ? , t , ? > upstream , comparator < ? super t > comparator ) { super ( upstream , stream shape . reference , stream op flag . is ordered | stream op flag . not sorted ) ; this . is natural sort = bool ; this . comparator = objects . require non null ( comparator ) ; }	sort using the provided comparator .
private void check cyclic substitution ( final string var name , final list < string > prior variables ) { if ( prior variables . contains ( var name ) == bool ) { return ; } final str builder buf = new str builder ( num ) ; buf . append ( str ) ; buf . append ( prior variables . remove ( num ) ) ; buf . append ( str ) ; buf . append with separators ( prior variables , str ) ; throw new illegal state exception ( buf . to string ( ) ) ; }	checks if the specified variable is already in the stack ( list ) of variables .
public static boolean is very dangerous ( double d ) { return double . is infinite ( d ) || double . is na n ( d ) ; }	returns true if the argument is a " very dangerous " double to have around , namely one that is infinite or nan .
private void log min ( string type , string value , string arg , long amount ) { key key = new key ( type , value , arg + minimum indicator ) ; synchronized ( counts ) { long old min = counts . get ( key ) ; if ( old min == null ) { old min = amount ; } counts . put ( key , math . min ( old min , amount ) ) ; } }	logs the minimum amount that was logged for ( type , value , arg ) under ( type , value , arg_min ) .
public boolean append items ( string p button name , string p window title , java . util . collection < brd item > p items ) { java . util . collection < printable info > object list = new java . util . linked list < printable info > ( ) ; object list . add all ( p items ) ; return append objects ( p button name , p window title , object list ) ; }	appends a button for creating a new objectinfowindow with the information of p_items to the text pane.
private static dex class loader create instance ( configuration config ) { file file1 ; file file2 ; switch ( config ) { case one dex : file1 = dex file ; file2 = null ; break ; case one jar : file1 = jar file ; file2 = null ; break ; case two dex : file1 = dex file ; file2 = de file ; break ; case two jar : file1 = jar file ; file2 = ja file ; break ; default : throw new assertion error ( str ) ; } string path = file1 . get absolute path ( ) ; if ( file2 != null ) { path += file . path separator + file2 . get absolute path ( ) ; } return new dex class loader ( path , optimized dir . get absolute path ( ) , null , class loader . get system class loader ( ) ) ; }	helper to construct an instance to test .
public boolean is right ( ) { return ! is left ; }	returns whether or not this either represents a right value .
@ override public boolean close ( ) { if ( last opened time != - num ) { final long elapsed time open = system . current time millis ( ) - last opened time ; dialog settings helper . record dialog closed ( dialog settings key , elapsed time open ) ; last opened time = - num ; } dialog settings helper . persist shell geometry ( get shell ( ) , dialog settings key ) ; hook dialog about to close ( ) ; return super . close ( ) ; }	this base class overrides close ( ) to persist the dialog settings , record the elapsed open time for statistics , and to call a subclass hook .
public static void apply user settings ( environment env , map < string , object > context ) throws template exception { locale locale = ( locale ) context . get ( str ) ; if ( locale == null ) { locale = locale . get default ( ) ; } env . set locale ( locale ) ; time zone time zone = ( time zone ) context . get ( str ) ; if ( time zone == null ) { time zone = time zone . get default ( ) ; } env . set time zone ( time zone ) ; }	apply user settings to an environment instance .
synchronized public static void to file ( string context , string file name , boolean append ) throws io { print stream ps = new print stream ( new file output stream ( file name , append ) ) ; ps . println ( context ) ; ps . flush ( ) ; ps . close ( ) ; }	writes desired string data to appropriate file .
public void add bridge idle debug listener ( not thread safe bridge idle debug listener listener ) { m bridge idle listeners . add ( listener ) ; }	adds a idle listener for this catalyst instance.
private void next generation ( ) { trip . signal all ( ) ; count = parties ; generation = new generation ( ) ; }	updates state on barrier trip and wakes up everyone.
@ suppress warnings ( str ) public static < k extends throwable > void rewrap and throw if instance ( string new message , throwable t , class < k > clazz ) throws k { if ( ( t != null ) && clazz . is assignable from ( t . get class ( ) ) ) { k kt = ( k ) t ; k wrapped = throwables . rewrap ( new message , kt ) ; throw wrapped ; } }	if ( t instanceof k ) throw throwables.
public static void register tile codec ( int comp , xtiff codec ) { tile codecs . put ( new integer ( comp ) , codec ) ; }	register a new xtifftilecodec for encoding and decoding compressed tiff image data.
static final void help expunge stale exceptions ( ) { final reentrant lock lock = exception table lock ; if ( lock . try lock ( ) ) { try { expunge stale exceptions ( ) ; } finally { lock . unlock ( ) ; } } }	if lock is available , poll stale refs and remove them.
parse node parse expr ( entry in entry ) throws configuration exception , io { list nodes = new array list ( ) ; for ( ; ; ) { nodes . add ( parse sub expr ( in entry ) ) ; if ( st . next token ( ) != str ) { st . push back ( ) ; break ; } } if ( nodes . size ( ) == num ) { return ( parse node ) nodes . get ( num ) ; } else { return new string concatenation ( ( parse node [ ] ) nodes . to array ( new parse node [ nodes . size ( ) ] ) , st . lineno ( ) ) ; } }	parses a string concatenation.
public static object clone ( object array ) { class < ? > component type = get component type ( array . get class ( ) ) ; int dims [ ] = get array lengths ( array ) ; object [ ] elements = ( object [ ] ) mux array ( array , dims , component type ) ; return demux array ( elements , dims , component type ) ; }	clones the multi - dimension structure of an array but the not the individual elements.
public auth properties model impl ( http servlet request req , map map ) { super ( req , map ) ; current realm = ( string ) map . get ( am . current realm ) ; if ( current realm == null ) { current realm = str ; } }	creates a model instance for configuring the core auth properties .
private void read header fields ( final ciphertext headers ciphertext headers ) { final byte version = ciphertext headers . get version ( ) ; if ( version != version info . current ciphertext version ) { throw new bad ciphertext exception ( str ) ; } crypto algo = ciphertext headers . get crypto algo id ( ) ; final ciphertext type ciphertext type = ciphertext headers . get type ( ) ; if ( ciphertext type != ciphertext type . customer authenticated encrypted data ) { throw new bad ciphertext exception ( str ) ; } final byte [ ] message id = ciphertext headers . get message id ( ) ; encryption context = ciphertext headers . get encryption context map ( ) ; if ( crypto algo . get trailing signature length ( ) > num ) { try { trailing public key = deserialize trailing key from ec ( encryption context . get ( constants . ec public key field ) ) ; trailing sig = signature . get instance ( crypto algo . get trailing signature algo ( ) , str ) ; trailing sig . init verify ( trailing public key ) ; } catch ( final general security exception ex ) { throw new aws crypto exception ( ex ) ; } } else { trailing public key = null ; trailing sig = null ; } final content type content type = ciphertext headers . get content type ( ) ; final short nonce len = ciphertext headers . get nonce length ( ) ; final int frame len = ciphertext headers . get frame length ( ) ; data key = get data key ( ciphertext headers ) ; try { decryption key = crypto algo . get encryption key from data key ( data key . get key ( ) , ciphertext headers ) ; } catch ( final invalid key exception ex ) { throw new aws crypto exception ( ex ) ; } verify header integrity ( ciphertext headers ) ; switch ( content type ) { case frame : content crypto handler = new frame decryption handler ( decryption key , ( byte ) nonce len , crypto algo , message id , frame len ) ; break ; case singleblock : content crypto handler = new block decryption handler ( decryption key , ( byte ) nonce len , crypto algo , message id ) ; break ; default : break ; } }	read the fields in the ciphertext headers to populate the corresponding instance variables used during decryption .
public static void move end ( j pane ) { j bar = pane . get vertical scroll bar ( ) ; bar . set value ( bar . get maximum ( ) ) ; }	move the cursor to the end of scrollpane .
public void populate edit text ( array list < string > matches ) { toggle search ( ) ; string text = str ; for ( int x = num ; x < matches . size ( ) ; x ++ ) { text = text + matches . get ( x ) + str ; } text = text . trim ( ) ; set search string ( text ) ; search ( text ) ; }	populate the searchbox with words , in an arraylist . used by the voice input.
public candidate extend hypothesis ( ) { if ( ranks [ num ] < hypotheses . size ( ) - num ) { return new candidate ( feature functions , sentence , hypotheses , phrases , future delta , new int [ ] { ranks [ num ] + num , ranks [ num ] } ) ; } return null ; }	extends the cube pruning dot along the dimension of existing hypotheses .
public static bitmap resize bitmap ( bitmap bitmap , int req width , int req height , crop image view . request size options options ) { try { if ( req width > num && req height > num && ( options == crop image view . request size options . resize fit || options == crop image view . request size options . resize inside || options == crop image view . request size options . resize exact ) ) { bitmap resized = null ; if ( options == crop image view . request size options . resize exact ) { resized = bitmap . create scaled bitmap ( bitmap , req width , req height , bool ) ; } else { int width = bitmap . get width ( ) ; int height = bitmap . get height ( ) ; float scale = math . max ( width / ( float ) req width , height / ( float ) req height ) ; if ( scale > num || options == crop image view . request size options . resize fit ) { resized = bitmap . create scaled bitmap ( bitmap , ( int ) ( width / scale ) , ( int ) ( height / scale ) , bool ) ; } } if ( resized != null ) { if ( resized != bitmap ) { bitmap . recycle ( ) ; } return resized ; } } } catch ( exception e ) { log . w ( str , str , e ) ; } return bitmap ; }	resize the given bitmap to the given width / height by the given option . < br >.
protected boolean add new icon ( string name ) { if ( log . is debug enabled ( ) ) { log . debug ( str + icon map . size ( ) ) ; } if ( name == null || name . length ( ) == num ) { j . show message dialog ( parent . palette frame , bundle . get message ( str ) , bundle . get message ( str ) , j . warning message ) ; return bool ; } else if ( icon map . get ( name ) != null ) { j . show message dialog ( parent . palette frame , bundle . get message ( str , name ) , bundle . get message ( str ) , j . warning message ) ; return bool ; } string file name = str ; named icon icon = new jmri . jmrit . catalog . named icon ( file name , file name ) ; icon map . put ( name , icon ) ; return bool ; }	action item for makeaddiconbuttonpanel.
public void init ( mcmc options , likelihood likelihood , prior prior , operator schedule schedule , logger [ ] loggers , markov chain delegate [ ] delegates ) { mcmc criterion = new mcmc ( ) ; criterion . set temperature ( options . get temperature ( ) ) ; mc = new markov chain ( prior , likelihood , schedule , criterion , options . get full evaluation count ( ) , options . min operator count for full evaluation ( ) , options . get evaluation test threshold ( ) , options . use coercion ( ) ) ; this . options = options ; this . loggers = loggers ; this . schedule = schedule ; current state = num ; for ( markov chain delegate delegate : delegates ) { delegate . setup ( options , schedule , mc ) ; } this . delegates = delegates ; dump state file = system . get property ( load dump file ) ; if ( system . get property ( dump state ) != null ) { long debug write state = long . parse long ( system . get property ( dump state ) ) ; mc . add markov chain listener ( new debug chain listener ( this , debug write state , bool ) ) ; } if ( system . get property ( dump every ) != null ) { long debug write every = long . parse long ( system . get property ( dump every ) ) ; mc . add markov chain listener ( new debug chain listener ( this , debug write every , bool ) ) ; } }	must be called before calling chain .
private final boolean related moves ( move m1 , move m2 ) { if ( ( m1 . from == m1 . to ) || ( m2 . from == m2 . to ) ) return bool ; if ( ( m1 . to == m2 . from ) || ( m1 . from == m2 . to ) || ( ( bit board . squares between [ m2 . from ] [ m2 . to ] & ( num << m1 . from ) ) != num ) ) return bool ; return bool ; }	return true if move m2 was made possible by move m1 .
@ override public void write ( int b ) throws io { file stream . write ( b ) ; output stream . write ( b ) ; }	writes the specified byte to the specified output stream and copies it to the file .
@ safe varargs public final test subscriber < t > assert values with ( consumer < t > ... expectations ) { if ( ! values storage ) { throw new illegal state exception ( str ) ; } final int expected value count = expectations . length ; if ( expected value count != values . size ( ) ) { throw new assertion error ( str + expected value count + str + value count , null ) ; } for ( int i = num ; i < expected value count ; i ++ ) { consumer < t > consumer = expectations [ i ] ; t actual value = values . get ( i ) ; consumer . accept ( actual value ) ; } return this ; }	assert the specified values have been received in the declared order.
public static number multiply ( character left , number right ) { return number number multiply . multiply ( integer . value of ( left ) , right ) ; }	multiply a character by a number.
public void write ( byte [ ] b , int off , int len ) { if ( sys properties . check && ( len < num || len % constants . file block size != num ) ) { db exception . throw internal error ( str + name + str + len ) ; } check writing allowed ( ) ; check power off ( ) ; try { file utils . write fully ( file , byte buffer . wrap ( b , off , len ) ) ; } catch ( io e ) { close file silently ( ) ; throw db exception . convert io ( e , name ) ; } file pos += len ; file length = math . max ( file pos , file length ) ; }	write a number of bytes .
public void remove footer ( object footer ) { if ( m footers . contains ( footer ) ) { int position = m footers . index of ( footer ) ; m footers . remove ( position ) ; notify item removed ( m headers . size ( ) + m data . size ( ) + position ) ; } }	remove a footer from the adapter.
@ override public void refresh index ( string row id , dimension row dimension row , dimension row dimension row old ) { refresh index ( collections . singleton map ( row id , new pair < > ( dimension row , dimension row old ) ) ) ; }	refresh lucene index query the lucene indexes on key column to see if there are any existing indexes.
@ override public void export tree ( tree tree ) throws io { java . util . list < tree > trees = new array list < tree > ( ) ; trees . add ( tree ) ; export trees ( trees ) ; }	export a single tree.
public static external sortable [ ] read array of external sortable ( input stream in , external sortable ex ) throws io { vector a = new vector ( ) ; int i = num ; try { do { a . add element ( ex . read ( in ) ) ; i ++ ; } while ( bool ) ; } catch ( io e ) { } external sortable [ ] e a = new external sortable [ i ] ; for ( int j = num ; j < i ; j ++ ) e a [ j ] = ( external sortable ) a . element at ( j ) ; return e a ; }	reads in as many externalsortables as it can and returns an array corresponding to the externalsortables . input : in should contain some sequence of externalsortables , otherwise a runtimeexception is thrown.
public void post ( object event ) { list < object > event queue = current thread event queue . get ( ) ; event queue . add ( event ) ; boolean wrapper is posting = current thread is posting . get ( ) ; if ( is posting . value ) { return ; } else { boolean is main thread = looper . get main looper ( ) == looper . my looper ( ) ; is posting . value = bool ; try { while ( ! event queue . is empty ( ) ) { post single event ( event queue . remove ( num ) , is main thread ) ; } } finally { is posting . value = bool ; } } }	posts the given event to the event bus .
public static method symbol find method declaration in type ( types types , type symbol type symbol , string method name , method type method type ) { return find method declaration in type ( types , type symbol , method name , method type , bool ) ; }	finds the method in the given type that matches the given name and signature .
public string remainder ( ) { string builder accum = new string builder ( ) ; while ( ! is empty ( ) ) { accum . append ( consume ( ) ) ; } return accum . to string ( ) ; }	consume and return whatever is left on the queue .
private void first tuple ( object input event ) { if ( first tuple processed ) { return ; } first tuple processed = bool ; class < ? > clazz = input event . get class ( ) ; getters = gpo . build gpo ( field to getter , schema . get values descriptor ( ) , clazz ) ; }	a helper method which builds the getter methods for retrieving fields from pojos .
public void remove debugger ( final debugger template debugger ) throws couldnt save data exception { preconditions . check not null ( debugger , str ) ; preconditions . check argument ( m assigned debuggers . contains ( debugger ) , str ) ; m provider . remove debugger ( m project , debugger ) ; m assigned debuggers . remove ( debugger ) ; for ( final i listener : m listeners ) { try { listener . removed debugger ( m project , debugger ) ; } catch ( final exception exception ) { c . log exception ( exception ) ; } } update modification date ( ) ; }	removes an assigned debugger template from the project .
public void add layout ( loading layout layout ) { if ( null != layout ) { m loading layouts . add ( layout ) ; } }	this allows you to add extra loadinglayout instances to this proxy . this is only necessary if you keep your own instances , and want to have them included in any.
public void check ( ) throws erlang version exception { string erlang version ; try { erlang version = erlang shell . get erlang version ( ) ; logger . debug ( str , erlang version ) ; } catch ( erlang shell exception e ) { throw new erlang version exception ( str , e ) ; } if ( min erlang version == null ) { logger . debug ( str ) ; return ; } else { logger . debug ( str , min erlang version ) ; } double expected ; double actual ; try { expected = parse ( min erlang version ) ; actual = parse ( erlang version ) ; } catch ( runtime exception e ) { logger . warn ( str + min erlang version + str + erlang version + str ) ; return ; } if ( actual < expected ) { throw new erlang version exception ( string . format ( str , min erlang version , erlang version ) ) ; } }	retrieves the current system ' s erlang version to compare it to the minimum required version.
public static void decode path segment ( list < path segment > segments , string segment , boolean decode ) { int colon = segment . index of ( str ) ; if ( colon != - num ) { segments . add ( new path segment impl ( ( colon == num ) ? str : segment . substring ( num , colon ) , decode , decode matrix ( segment , decode ) ) ) ; } else { segments . add ( new path segment impl ( segment , decode ) ) ; } }	decode the path segment and add it to the list of path segments .
protected void parse and add ( map lexicon , string line ) { string tokenizer tokenizer = new string tokenizer ( line , str ) ; string phones = null ; string word and pos = tokenizer . next token ( ) ; string pos = word and pos . substring ( word and pos . length ( ) - num ) ; if ( ! parts of speech . contains ( pos ) ) { parts of speech . add ( pos ) ; } if ( tokenizer . has more tokens ( ) ) { phones = tokenizer . next token ( ) ; } if ( ( phones != null ) && ( tokenize on load ) ) { lexicon . put ( word and pos , get phones ( phones ) ) ; } else if ( phones == null ) { lexicon . put ( word and pos , no phones ) ; } else { lexicon . put ( word and pos , phones ) ; } }	creates a word from the given input line and add it to the lexicon .
public void from array ( int [ ] members ) { if ( this . members . length != members . length ) { throw new illegal argument exception ( str ) ; } member set . clear ( ) ; for ( int i = num ; i < members . length ; i ++ ) { this . members [ i ] = members [ i ] ; member set . add ( members [ i ] ) ; } validate ( ) ; }	populates this subset from an array .
private boolean start compact mode ( string type ) { long time passed = system . current time millis ( ) - compact mode start ; if ( time passed > max compactmode time ) { close compact mode ( ) ; } if ( ! type . equals ( compact mode ) ) { close compact mode ( ) ; } if ( compact mode == null ) { compact mode = type ; compact mode start = system . current time millis ( ) ; compact mode length = num ; return bool ; } return bool ; }	enters compact mode , closes it first if necessary .
public void close ( ) { logger . debug ( str ) ; set closed ( bool ) ; while ( ! is empty ( ) || is firing ( ) && ! checking thread . is daemon ( ) ) { try { thread . sleep ( min window size ) ; } catch ( exception e ) { logger . debug ( str ) ; } } }	close the buffer and deallocate resources.
void free write lock ( ) { synchronized ( write lock ) { is write locked = bool ; write lock . notify all ( ) ; } }	frees the channel for writing .
private void add mitre join ( coordinate p , line segment offset0 , line segment offset1 , double distance ) { boolean is mitre within limit = bool ; coordinate int pt = null ; try { int pt = h . intersection ( offset0 . p0 , offset0 . p1 , offset1 . p0 , offset1 . p1 ) ; double mitre ratio = distance <= num ? num : int pt . distance ( p ) / math . abs ( distance ) ; if ( mitre ratio > buf params . get mitre limit ( ) ) is mitre within limit = bool ; } catch ( not representable exception ex ) { int pt = new coordinate ( num , num ) ; is mitre within limit = bool ; } if ( is mitre within limit ) { seg list . add pt ( int pt ) ; } else { add limited mitre join ( offset0 , offset1 , distance , buf params . get mitre limit ( ) ) ; } }	adds a mitre join connecting the two reflex offset segments.
public void add listener ( am cdl ) { synchronized ( listeners ) { if ( ! listeners . contains ( cdl ) ) { listeners . add ( cdl ) ; } } }	register for listening to client data changes.
public static double rand ( ) { return rand . next double ( ) ; }	generates an equally distributed double precision random number . the upper boundary.
public void cancel throttle request ( int address , throttle listener l ) { boolean is long = bool ; if ( can be short address ( address ) ) { is long = bool ; } cancel throttle request ( address , is long , l ) ; }	cancel a request for a throttle.
private shape create thumb shape ( int width , int height , boolean upper ) { d path = new d . float ( ) ; if ( slider . get orientation ( ) == j . horizontal ) { float d = num * width ; path . move to ( d , num ) ; path . line to ( ( upper ? width : num ) , d ) ; path . line to ( ( upper ? width : num ) , height ) ; path . line to ( num * width , height ) ; } else { float d = num * height ; path . move to ( num , d ) ; path . line to ( d , ( upper ? height : num ) ) ; path . line to ( width , ( upper ? height : num ) ) ; path . line to ( height , num * height ) ; } path . close path ( ) ; return path ; }	returns a shape representing a thumb .
public final void open ( string page , string ref ) { if ( ref == null ) { ref = str ; } ref = ref . replace ( str , str ) ; if ( page == null ) { page = default page ; } if ( current page != null && current page . equals ( page ) ) { jump to ( ref ) ; } else { reference = ref ; } load page ( page ) ; history item location = new history item ( page , ref ) ; history . add if new ( location ) ; update history buttons ( ) ; current location . set text ( location . to string ( ) ) ; }	open a page and go to a position ( ref , which is an anchor in the html document ) on that page .
public void close ( ) throws io { if ( input != null ) { input . close ( ) ; input = null ; } }	closes this character stream , as well as the the reader it its iterating over .
protected void rehash ( int new capacity ) { int old capacity = set . length ; object old keys [ ] = set ; v old vals [ ] = values ; set = new object [ new capacity ] ; arrays . fill ( set , free ) ; values = ( v [ ] ) new object [ new capacity ] ; for ( int i = old capacity ; i -- > num ; ) { if ( old keys [ i ] != free && old keys [ i ] != removed ) { object o = old keys [ i ] ; int index = insertion index ( ( k ) o ) ; if ( index < num ) { throw object contract violation ( set [ ( - index - num ) ] , o ) ; } set [ index ] = o ; values [ index ] = old vals [ i ] ; } } }	rehashes the map to the new capacity .
@ override public void write end element ( ) throws xml { log . log ( level . fine , str ) ; calculate and next tag ( ) ; }	writes an end tag to the output relying on the internal state of the writer to determine the prefix and local name of the event.
private string next literal ( boolean assign offsets only ) throws io { string builder builder = null ; value pos = - num ; value length = num ; int i = num ; find non literal character : while ( bool ) { for ( ; pos + i < limit ; i ++ ) { switch ( buffer [ pos + i ] ) { case str : case str : case str : case str : case str : check lenient ( ) ; case str : case str : case str : case str : case str : case str : case str : case str : case str : case str : case str : break find non literal character ; } } if ( i < buffer . length ) { if ( fill buffer ( i + num ) ) { continue ; } else { buffer [ limit ] = str ; break ; } } if ( builder == null ) { builder = new string builder ( ) ; } builder . append ( buffer , pos , i ) ; value length += i ; pos += i ; i = num ; if ( ! fill buffer ( num ) ) { break ; } } string result ; if ( assign offsets only && builder == null ) { value pos = pos ; result = null ; } else if ( skipping ) { result = str ; } else if ( builder == null ) { result = string pool . get ( buffer , pos , i ) ; } else { builder . append ( buffer , pos , i ) ; result = builder . to string ( ) ; } value length += i ; pos += i ; return result ; }	reads the value up to but not including any delimiter characters.
protected void write column default value stmt ( table table , column column , string builder ddl ) { object parsed default = column . get parsed default value ( ) ; if ( parsed default != null ) { if ( ! database info . is default values for long types supported ( ) && ( ( column . get mapped type code ( ) == types . longvarbinary ) || ( column . get mapped type code ( ) == types . longvarchar ) ) ) { throw new model exception ( str ) ; } if ( is valid default value ( column . get default value ( ) , column . get mapped type code ( ) ) ) { ddl . append ( str ) ; write column default value ( table , column , ddl ) ; } } else if ( database info . is default value used for identity spec ( ) && column . is auto increment ( ) ) { ddl . append ( str ) ; write column default value ( table , column , ddl ) ; } else if ( ! string utils . is blank ( column . get default value ( ) ) ) { ddl . append ( str ) ; write column default value ( table , column , ddl ) ; } }	prints the default value stmt part for the column .
public synchronized byte [ ] read next part ( string username ) throws j { transfer object obj = user to download map . get ( username ) ; if ( obj == null ) { throw new j ( str , str , str ) ; } download timeout queue . remove ( obj ) ; byte [ ] data = obj . read next part ( ) ; if ( obj . get remaining bytes ( ) != num ) { obj . set timeout ( num ) ; download timeout queue . add ( obj ) ; } else { user to download map . remove ( username ) ; j . cancel submission ( obj . get struct ( ) ) ; } return data ; }	reads the next part of the download identified by the username . if it was the last part it unmarks the user and deletes the entry file.
public boolean is expired ( calendar from date ) { calendar end time = ( calendar ) from date . clone ( ) ; if ( window == null ) { end time . add ( calendar . hour of day , infinite window order execution timeout ) ; } else { end time . add ( get window length calendar field ( ) , window . get execution window length ( ) ) ; } calendar curr time = calendar . get instance ( ) ; log . debug ( str , curr time , end time ) ; return curr time . compare to ( end time ) > num ; }	check if order ' s scheduled time + schedule window already expire .
public void adjust static certificate ( certificate copy from ) { if ( this != unsigned && this != expired ) { throw new unsupported operation exception ( str ) ; } common name = copy from . common name ; organization = copy from . organization ; valid from = copy from . valid from ; valid to = copy from . valid to ; valid = bool ; }	copies the company information from a valid certificate to show on an invalid signature certificate .
private int detect type ( string file name ) throws io , ftp , ftp { int start = file name . last index of ( str ) + num ; int stop = file name . length ( ) ; if ( start > num && start < stop - num ) { string ext = file name . substring ( start , stop ) ; ext = ext . to lower case ( ) ; if ( textual extension recognizer . is textual ext ( ext ) ) { return type textual ; } else { return type binary ; } } else { return type binary ; } }	this method detects the type for a file transfer .
cut ( constant value , double diff ) { this . value = value ; this . diff = diff ; }	represents a cut at given value on a range.
public void add property change listener ( property change listener l ) { if ( listeners == null ) { listeners = new array list < property change listener > ( num ) ; } if ( ! listeners . contains ( l ) ) { listeners . add ( l ) ; } }	add an addresslistener . addresslisteners are notified when the user selects a new address and when a throttle is acquired for that address.
private void process response headers ( state state , inner state inner state , http response response ) throws stop request { if ( inner state . m continuing download ) { return ; } read response headers ( state , inner state , response ) ; try { state . m filename = m service . generate save file ( m info . m file name , m info . m total bytes ) ; } catch ( downloader service . generate save file error exc ) { throw new stop request ( exc . m status , exc . m message ) ; } try { state . m stream = new file output stream ( state . m filename ) ; } catch ( file not found exception exc ) { file path file = new file ( helpers . get save file path ( m service ) ) ; try { if ( path file . mkdirs ( ) ) { state . m stream = new file output stream ( state . m filename ) ; } } catch ( exception ex ) { throw new stop request ( downloader service . status file error , str + exc . to string ( ) , exc ) ; } } if ( constants . logv ) { log . v ( constants . tag , str + m info . m uri + str + state . m filename ) ; } update database from headers ( state , inner state ) ; check connectivity ( state ) ; }	read http response headers and take appropriate action , including setting up the destination file and updating the database .
@ override public void write ( byte [ ] buf , int off , int nbytes ) { digest . update ( buf , off , nbytes ) ; }	updates a digest with byte array .
@ override public double drift discretization ( final d sp , final double t0 , final double x0 , final double dt ) { return sp . drift ( t0 , x0 ) * dt ; }	returns an approximation of the drift defined as < p > \ mu ( t_0 , x_0 ) \ delta t.
private void do tree tag ( j jcas ) { try { if ( tt proc == null ) { tt proc = new tree tagger process ( ttprops . get tree tagging process ( ) ) ; } logger . print detail ( component , str + ttprops . par file name ) ; annotation index ai = jcas . get annotation index ( token . type ) ; list < string > token strings = new array list < > ( ) ; list < token > tokens = new array list < > ( ) ; for ( fs fsi = ai . iterator ( ) ; fsi . has next ( ) ; ) { token token = ( token ) fsi . next ( ) ; token strings . add ( token . get covered text ( ) ) ; tokens . add ( token ) ; } ttreader = new tree tagger reader ( tokens , tt proc . get stdout ( ) , jcas , annotate sentences ) ; ttwriter = new tree tagger writer ( token strings , tt proc . get stdin ( ) ) ; thread r thread = new thread ( ttreader ) ; thread w thread = new thread ( ttwriter ) ; r thread . start ( ) ; w thread . start ( ) ; r thread . join ( ) ; w thread . join ( ) ; } catch ( io | interrupted exception e ) { e . print stack trace ( ) ; } }	based on tokens from the jcas object , adds part of speech ( pos ) and sentence tags to the jcas object using the treetagger program .
public void terminate ( ) { this . terminated = bool ; executor service . shutdown ( ) ; boolean finished = bool ; boolean interrupted = bool ; while ( ! finished ) { try { log . warning ( str ) ; finished = executor service . await termination ( radius server constants . thread pool shutdown wait seconds , time unit . seconds ) ; } catch ( final interrupted exception e ) { log . warning ( str ) ; interrupted = bool ; } } final thread t = listener thread ; if ( t != null ) { t . interrupt ( ) ; while ( listener thread != null ) { log . warning ( str ) ; try { thread . sleep ( num ) ; } catch ( final interrupted exception e ) { } } } }	blocking call that terminates the thread pool , tells the listener to drop any new requests , waits until the thread pool is empty , and then interrupts the listener thread in case it is blocked waiting for new requests.
public static void write one block to xml ( block to serialize , output stream os ) throws blockly serializer exception { list < block > temp = new array list < > ( ) ; temp . add ( to serialize ) ; write to xml ( temp , os ) ; }	convenience function to serialize only one block .
private void render forms onto g2 with html ( final int page index , final map components to ignore ) { this . components to ignore = components to ignore ; form object form object ; for ( final form object next val : forms ordered [ page index ] ) { if ( next val != null ) { form object = next val ; check gui ( form object ) ; } } }	use swing to draw forms.
public builder add pattern ( string pattern ) { patterns . add ( pattern ) ; return this ; }	add a resource pattern that guides the resource for a policy .
protected static string add maven namespace ( string effective xml , boolean is pom ) { sax builder = new sax ( ) ; try { document document = builder . build ( new string reader ( effective xml ) ) ; element root element = document . get root element ( ) ; namespace pom namespace = namespace . get namespace ( str , str ) ; root element . set namespace ( pom namespace ) ; namespace xsi namespace = namespace . get namespace ( str , str ) ; root element . add namespace declaration ( xsi namespace ) ; if ( root element . get attribute ( str , xsi namespace ) == null ) { root element . set attribute ( str , str + ( is pom ? pom xsd url : settings xsd url ) , xsi namespace ) ; } element filter element filter = new element filter ( namespace . get namespace ( str ) ) ; for ( iterator < ? > i = root element . get descendants ( element filter ) ; i . has next ( ) ; ) { element e = ( element ) i . next ( ) ; e . set namespace ( pom namespace ) ; } string writer w = new string writer ( ) ; format format = format . get pretty format ( ) ; xml out = new xml ( format ) ; out . output ( document . get root element ( ) , w ) ; return w . to string ( ) ; } catch ( jdom e ) { return effective xml ; } catch ( io e ) { return effective xml ; } }	method from org . apache . maven . plugins . help . abstracteffectivemojo add a pom / settings namespaces to the effective xml content .
public void dispose ( ) { log debug ( str ) ; m setup done = bool ; log . e ( str , str ) ; if ( m service conn != null ) { log . e ( str , str ) ; log debug ( str ) ; if ( m context != null ) { log . e ( str , str ) ; m context . unbind service ( m service conn ) ; } } m disposed = bool ; m context = null ; m service conn = null ; m service = null ; m purchase listener = null ; }	dispose of object , releasing resources.
private static byte [ ] hex string to byte array ( string hex string ) { int len = hex string . length ( ) ; byte [ ] data = new byte [ len / num ] ; for ( int i = num ; i < len ; i += num ) { data [ i / num ] = ( byte ) ( ( character . digit ( hex string . char at ( i ) , num ) << num ) + character . digit ( hex string . char at ( i + num ) , num ) ) ; } return data ; }	converts hex values from strings to byte array.
public static generalized time current time ( ) { return value of ( calendar . get instance ( ) ) ; }	returns a generalized time whose value is the current time , using the default time zone and locale .
private void commit ( ) throws interrupted exception , replicator exception { applier . commit ( ) ; schedule . commit ( ) ; block event count = num ; last commit millis = system . current time millis ( ) ; }	utility routine to issue commit with appropriate transaction accounting .
private named list < object > process response ( xml parser ) { try { named list < object > response = null ; for ( int event = parser . next ( ) ; event != xml . end document ; event = parser . next ( ) ) { switch ( event ) { case xml . start element : if ( response != null ) { throw new exception ( str ) ; } string name = parser . get local name ( ) ; if ( name . equals ( str ) || name . equals ( str ) ) { response = read named list ( parser ) ; } else if ( name . equals ( str ) ) { return new simple ordered map < > ( ) ; } else { throw new exception ( str + str + parser . get local name ( ) ) ; } break ; } } return response ; } catch ( exception ex ) { throw new solr exception ( solr exception . error code . server error , str , ex ) ; } finally { try { parser . close ( ) ; } catch ( exception ex ) { } } }	parse the text into a named list.
public boolean is plural forms ( ) { return nouns != null ; }	if an attempt is made to convert set property names to their plural form .
object process avt qname ( stylesheet handler handler , string uri , string name , string raw name , string value , elem template element owner ) throws org . xml . sax . sax { avt avt = null ; try { avt = new avt ( handler , uri , name , raw name , value , owner ) ; if ( avt . is simple ( ) ) { int index of ns = value . index of ( str ) ; if ( index of ns >= num ) { string prefix = value . substring ( num , index of ns ) ; if ( ! xm . is xm nc ( prefix ) ) { handle error ( handler , xslt . invalid qname , new object [ ] { name , value } , null ) ; return null ; } } string local name = ( index of ns < num ) ? value : value . substring ( index of ns + num ) ; if ( ( local name == null ) || ( local name . length ( ) == num ) || ( ! xm . is xm nc ( local name ) ) ) { handle error ( handler , xslt . invalid qname , new object [ ] { name , value } , null ) ; return null ; } } } catch ( transformer exception te ) { throw new org . xml . sax . sax ( te ) ; } return avt ; }	process an attribute string of type t_qname into a qname value .
public boolean has mouse ( ) { return ( ( movable != null ) ) ; }	determine if this inputhandler is dragging an object.
private void trigger copy services ( set < string > target data store set , state current ) { if ( target data store set . is empty ( ) ) { service utils . log info ( this , str ) ; return ; } for ( string target data store : target data store set ) { trigger copy service ( current , target data store ) ; } }	this function creates a set of imagecopyservice instances parented to the current service instance .
public long to minutes ( ) { return time unit . to minutes ( length ) ; }	returns the duration in minutes .
private static void add variable if required ( data set data , string var ) { list < string > nodes = data . get variable names ( ) ; if ( ! nodes . contains ( var ) ) { data . add variable ( new continuous variable ( var ) ) ; } }	adds a column for the given varible if required .
public static m < integer > from range ( final int start , final int end ) { return m . from stream ( reactive seq . range ( start , end ) ) ; }	construct an anym instance that wraps a range from start ( inclusive ) to end ( exclusive ) provided the anym will contain a sequencem over the spefied range.
public string distance function tip text ( ) { return str + str ; }	returns the tip text for this property .
protected panel state find nearest panel state from height ( float desired panel height ) { panel state closest panel state = panel state . closed ; float smallest height diff = float . positive infinity ; for ( panel state state : panel state . values ( ) ) { if ( ! is valid state ( state ) ) { continue ; } if ( ! is fullscreen size panel ( ) && state == panel state . expanded ) { continue ; } float height = get panel height from state ( state ) ; float height diff = math . abs ( desired panel height - height ) ; if ( height diff < smallest height diff ) { closest panel state = state ; smallest height diff = height diff ; } } return closest panel state ; }	finds the state which has the nearest height compared to a given | desiredpanelheight | .
private static boolean are method args compatible ( class [ ] arg types , object [ ] args ) { for ( int i = num ; i < args . length ; i ++ ) { object arg = args [ i ] ; class arg type = wrap ( arg types [ i ] ) ; if ( arg != null && ! arg type . is assignable from ( arg . get class ( ) ) ) return bool ; } return bool ; }	determines whether specified method arguments are compatible with given method parameter definitions .
public static string remove quotation marks if needed ( string str ) { if ( str . starts with ( str ) && str . ends with ( str ) ) return str . substring ( num , str . length ( ) - num ) ; return str ; }	remove quotation marks at the beginning and end of the string if present .
public static byte buffer resize byte buffer ( byte buffer buf , long size ) { byte buffer ret = byte buffer . allocate direct ( ( int ) size ) ; if ( ret != null ) { if ( null != buf ) { ret . put ( buf ) ; ret . flip ( ) ; } } return ret ; }	resize a bytebuffer with a new instance.
public void remove all ( ) { io objects . clear ( ) ; }	removes all objects from this iocontainer .
public void clear ( ) { int index1 = delegate . size ( ) - num ; delegate . remove all elements ( ) ; if ( index1 >= num ) { fire interval removed ( this , num , index1 ) ; } }	removes all of the elements from this list.
protected void skip remaining tags in current ifd ( ) throws io , exif invalid format exception { int end of tags = m ifd start offset + offset size + tag size * m num of tag in ifd ; int offset = m tiff stream . get read byte count ( ) ; if ( offset > end of tags ) { return ; } if ( m need to parse offsets in current ifd ) { while ( offset < end of tags ) { m tag = read tag ( ) ; offset += tag size ; if ( m tag == null ) { continue ; } check offset or image tag ( m tag ) ; } } else { skip to ( end of tags ) ; } long ifd offset = read unsigned long ( ) ; if ( m ifd type == ifd id . type ifd 0 && ( is ifd requested ( ifd id . type ifd 1 ) || is thumbnail requested ( ) ) ) { if ( ifd offset > num ) { register ifd ( ifd id . type ifd 1 , ifd offset ) ; } } }	skips the tags area of current ifd , if the parser is not in the tag area , nothing will happen .
public static date parse date ( final string date value ) throws date parse exception { return parse date ( date value , null ) ; }	parses a date value.
public boolean is filled ( ) { return filled ; }	returns the filled boolean .
public void clear ( ) { m plottables . clear ( ) ; }	clears all plottables from this entity.
@ override public void send mail ( mime message message ) throws messaging exception { mail address sender = new mail address ( ( internet address ) message . get from ( ) [ num ] ) ; collection < mail address > recipients = new hash set < mail address > ( ) ; address addresses [ ] = message . get all recipients ( ) ; if ( addresses != null ) { for ( address address : addresses ) { if ( address instanceof internet address ) { recipients . add ( new mail address ( ( internet address ) address ) ) ; } } } send mail ( sender , recipients , message ) ; }	place a mail on the spool for processing.
private void send composed text ( ) { attributed string as = new attributed string ( buffer . to string ( ) ) ; as . add attribute ( text attribute . input method highlight , input method highlight . selected raw text highlight ) ; context . dispatch input method event ( input method event . input method text changed , as . get iterator ( ) , num , text hit info . leading ( insertion point ) , null ) ; }	send the composed text to the client .
public static db < ? > new default db ( string loc , enum < ? > e ) { return new default db ( loc , e . name ( ) ) ; }	creates a db for some enumeration.
public void remove addendum ( string word , string part of speech ) { addenda . remove ( word + fix part of speech ( part of speech ) ) ; }	removes a word from the addenda .
@ override public void close archive entry ( ) throws io { if ( finished ) { throw new io ( str ) ; } if ( entry == null ) { throw new io ( str ) ; } if ( ! entry . has written ) { write ( empty , num , num ) ; } flush deflater ( ) ; final zip64 mode effective mode = get effective zip64 mode ( entry . entry ) ; long bytes written = written - entry . data start ; long real crc = crc . get value ( ) ; crc . reset ( ) ; final boolean actually needs zip64 = handle sizes and crc ( bytes written , real crc , effective mode ) ; if ( raf != null ) { rewrite sizes and crc ( actually needs zip64 ) ; } write data descriptor ( entry . entry ) ; entry = null ; }	writes all necessary data for this entry .
private double pdf ( double x , int j ) { int from = arrays . binary search ( x , x - h * k . cut off ( ) ) ; int to = arrays . binary search ( x , x + h * k . cut off ( ) ) ; from = from < num ? - from - num : from ; to = to < num ? - to - num : to ; if ( weights . length == num && k instanceof kf ) return ( to - from ) * num / ( sum of * h ) ; double sum = num ; for ( int i = math . max ( num , from ) ; i < math . min ( x . length , to + num ) ; i ++ ) if ( i != j ) sum += k . k ( ( x - x [ i ] ) / h ) * get weight ( i ) ; return sum / ( sum of * h ) ; }	computes the leave one out pdf of the estimator.
public j ( frame owner ) { super ( owner ) ; init ( ) ; }	creates a new jsheet .
public string global info ( ) { return str + str + str + str + str + str + str + str + str + str + str + str + str ; }	returns a string describing this filter.
public static boolean parameter list contains parameter name ( list < i > parameter list , set < string > parameter names ) { boolean result = bool ; for ( i p : parameter list ) { if ( parameter names . contains ( p . get name ( ) ) ) { result = bool ; break ; } } return result ; }	search for the first appearance of a parameter in the list .
@ override protected void property change ( property change event evt ) { super . property change ( evt ) ; string name = evt . get property name ( ) ; if ( name . equals ( str ) ) { update foreground ( ( color ) evt . get new value ( ) ) ; } else if ( name . equals ( str ) ) { update font ( ( font ) evt . get new value ( ) ) ; } else if ( name . equals ( str ) ) { j comp = get component ( ) ; update foreground ( comp . get foreground ( ) ) ; update font ( comp . get font ( ) ) ; } }	this method gets called when a bound property is changed on the associated jtextcomponent.
public void put icon ( string extension , icon icon ) { icons . put ( extension , icon ) ; }	adds an icon based on the file type " dot " extension string , e.
public static @ dotted class name string extract package name ( @ dotted class name string class name ) { int i = class name . last index of ( str ) ; if ( i < num ) { return str ; } return class name . substring ( num , i ) ; }	extract the package name from a dotted class name.
public static byte [ ] to byte array ( final big integer value , final int num bytes ) { final byte [ ] output bytes = new byte [ num bytes ] ; final byte [ ] big integer bytes = value . to byte array ( ) ; int copy start index = ( num == big integer bytes [ num ] ) ? num : num ; int num bytes to copy = big integer bytes . length - copy start index ; if ( num bytes to copy > num bytes ) { copy start index += num bytes to copy - num bytes ; num bytes to copy = num bytes ; } for ( int i = num ; i < num bytes to copy ; ++ i ) { output bytes [ i ] = big integer bytes [ copy start index + num bytes to copy - i - num ] ; } return output bytes ; }	converts a biginteger to a little endian byte array .
public result filter only ( list < string > sources ) { result ret = new result ( ) ; for ( result entry l : this . log ) { if ( sources . contains ( l . get source ( ) ) ) { ret . add ( l ) ; } } return ret ; }	complementary operation to filteronly.
public long scheduled execution time ( ) { if ( expired ) { return - num ; } else { return time . get time ( ) ; } }	returns the time which this headtaskrunnable is scheduled .
public static void create dir ( file target ) throws ade usage exception { if ( ! target . exists ( ) && ! target . mkdir ( ) ) { throw new ade usage exception ( str + target . get path ( ) ) ; } }	create a directory if it does not already exist .
public void release ( ) { if ( h program >= num ) gle . gl delete program ( h program ) ; h program = - num ; }	terminatinng , this should be called in gl context.
private void write large data to file ( file file , int size ) throws file not found exception , io { file output stream fos = new file output stream ( file ) ; byte [ ] buf = new byte [ size ] ; try { fos . write ( buf ) ; } finally { fos . close ( ) ; } }	initializes large test file .
public notifications action ( action ... actions ) { this . actions = actions == null ? fx . < action > observable array list ( ) : fx . observable array list ( actions ) ; return this ; }	specify the actions that should be shown in the notification as buttons .
private static class node create usable class node from generics type ( final generics type generics type ) { class node value = generics type . get type ( ) ; if ( generics type . is placeholder ( ) ) { value = object type ; } class node lower bound = generics type . get lower bound ( ) ; if ( lower bound != null ) { value = lower bound ; } else { class node [ ] upper bounds = generics type . get upper bounds ( ) ; if ( upper bounds != null ) { value = widening categories . lowest upper bound ( arrays . as list ( upper bounds ) ) ; } } return value ; }	given a genericstype instance , returns a classnode which can be used as an inferred type .
public boolean is true ( string condition ) { boolean result = bool ; if ( condition != null && condition . length ( ) > num ) { string s = condition . substring ( num , num ) ; if ( s . equals ignore case ( str ) || s . equals ( str ) || s . equals ignore case ( str ) ) result = bool ; } return result ; }	convert string into boolean.
public flux map fuseable ( publisher < ? extends t > source , function < ? super t , ? extends r > mapper ) { super ( source ) ; this . mapper = objects . require non null ( mapper , str ) ; }	constructs a fluxmap instance with the given source and mapper .
public void create index hash ( environment env ) { index hash object = new hashtable ( ) ; index hash ascii = new hashtable ( ) ; for ( int i = num ; i < cpool . length ; i ++ ) { if ( types [ i ] == constant ut ) { index hash ascii . put ( cpool [ i ] , new integer ( i ) ) ; } else { try { index hash object . put ( get constant ( i , env ) , new integer ( i ) ) ; } catch ( class format error e ) { } } } }	create a hash table of all the items in the constant pool that could possibly be referenced from the outside .
public void test get date and time ( ) { crl selector = new crl ( ) ; assert null ( str , selector . get date and time ( ) ) ; date date = new date ( num ) ; selector . set date and time ( date ) ; assert true ( str , date . equals ( selector . get date and time ( ) ) ) ; }	getdateandtime ( ) method testing.
private double determine alpha min ( int n , double [ ] alpha min , hyper bounding box interval ) { double alpha n = extremum alpha n ( n , alpha min ) ; double lower = interval . get min ( n ) ; double upper = interval . get max ( n ) ; double [ ] alpha extreme = new double [ alpha min . length ] ; system . arraycopy ( alpha min , n , alpha extreme , n , alpha extreme . length - n ) ; alpha extreme [ n ] = alpha n ; extremum type type = extremum type ( n , alpha extreme , interval ) ; if ( type . equals ( extremum type . minimum ) || type . equals ( extremum type . constant ) ) { if ( lower <= alpha n && alpha n <= upper ) { return alpha n ; } else if ( alpha n < lower ) { return lower ; } else { if ( alpha n <= upper ) { throw new illegal state exception ( str ) ; } return upper ; } } else { if ( lower <= alpha n && alpha n <= upper ) { if ( alpha n - lower <= upper - alpha n ) { return upper ; } else { return lower ; } } else if ( alpha n < lower ) { return upper ; } else { if ( alpha n <= upper ) { throw new illegal state exception ( str ) ; } return lower ; } } }	determines the n - th alpha value where this function has a minimum in the specified interval .
public profiler start collecting ( ) { thread = new thread ( this , str ) ; thread . set daemon ( bool ) ; thread . start ( ) ; return this ; }	start collecting profiling data .
protected void check release ( ) { if ( ! is persistent object ( ) && listeners . is empty ( ) && ! is acquired ( ) ) { log . info ( str , name ) ; if ( storage != null ) { if ( ! storage . remove ( this ) ) { log . error ( str ) ; } } close ( ) ; } }	check if shared object must be released .
public stemmed string ( string orig , char sequence stemmed ) { str orig = orig ; str stemmed = stemmed . to string ( ) ; }	create a stemmedstring from one charsequence ( stemmed ) and one string ( original ).
void decode stats ( ) throws io { final int upto = ( int ) ord % interval ; final int old block ord = stats block ord ; stats block ord = ( int ) ord / interval ; if ( old block ord != stats block ord ) { refill stats ( ) ; } state . doc freq = doc freq [ upto ] ; state . total term freq = total term freq [ upto ] ; }	decodes stats data into term state.
public static integer zpvc ( number ... values ) { if ( values == null || values . length == num ) { throw new illegal argument exception ( str ) ; } int count = num ; for ( number value : values ) { if ( value != null && value . double value ( ) >= num ) { count ++ ; } } return count ; }	function which will return the count of zero or positive values among the given argument values .
public string to string ( ) { object [ ] elements = get array ( ) ; int max index = elements . length - num ; string buffer buf = new string buffer ( ) ; buf . append ( str ) ; for ( int i = num ; i <= max index ; i ++ ) { buf . append ( string . value of ( elements [ i ] ) ) ; if ( i < max index ) buf . append ( str ) ; } buf . append ( str ) ; return buf . to string ( ) ; }	returns a string representation of this list , containing the string representation of each element .
private boolean move to final scroller position ( scroller scroller ) { scroller . force finished ( bool ) ; int amount to scroll = scroller . get final y ( ) - scroller . get curr y ( ) ; int future scroll offset = ( m current scroll offset + amount to scroll ) % m selector element height ; int overshoot adjustment = m initial scroll offset - future scroll offset ; if ( overshoot adjustment != num ) { if ( math . abs ( overshoot adjustment ) > m selector element height / num ) { if ( overshoot adjustment > num ) { overshoot adjustment -= m selector element height ; } else { overshoot adjustment += m selector element height ; } } amount to scroll += overshoot adjustment ; scroll by ( num , amount to scroll ) ; return bool ; } return bool ; }	move to the final position of a scroller.
public void add graph ( final graph graph ) { if ( graph == null ) { throw new illegal argument exception ( str ) ; } graphs . add ( graph ) ; }	add a graph object to bukkitmetrics that represents data for the plugin that should be sent to the backend.
public boolean equals ( int ignore own element , sequence sequence , int ignore its element ) { int own index = num ; int its index = num ; iterator < item > own iterator = item iterator ( ) ; iterator < item > its iterator = sequence . item iterator ( ) ; while ( bool ) { if ( ignore own element == own index ) { own iterator . next ( ) ; own index ++ ; } if ( ignore its element == its index ) { its iterator . next ( ) ; its index ++ ; } if ( ! own iterator . has next ( ) || ! its iterator . has next ( ) ) { if ( ! own iterator . has next ( ) && ! its iterator . has next ( ) ) { return bool ; } return bool ; } item own item = own iterator . next ( ) ; item its item = its iterator . next ( ) ; own index ++ ; its index ++ ; if ( ! own item . equals ( its item ) ) { return bool ; } } }	this method implements an enhanced equals method where the specified elements of the sequences are treated as if not existent.
public void switch list mode ( ) { adapter . set list item size ( adapter . get list item size ( ) == adapter alerts . list item size . reduced ? adapter alerts . list item size . expanded : adapter alerts . list item size . reduced ) ; }	switch from flat to expanded list mode.
public void start ( int total seeds , int max nfe ) { this . total seeds = total seeds ; this . max nfe = max nfe ; last seed = num ; last nfe = num ; current seed = num ; current nfe = num ; statistics . clear ( ) ; start time = system . current time millis ( ) ; last time = start time ; }	prepares this progress helper for use.
public void append ( result entry entry ) throws io { number of entries ++ ; list < solution > feasible solutions = new array list < solution > ( ) ; for ( solution solution : entry . get population ( ) ) { if ( ! solution . violates constraints ( ) ) { feasible solutions . add ( solution ) ; } } properties properties = entry . get properties ( ) ; if ( feasible solutions . is empty ( ) && ( ( properties == null ) || ( properties . is empty ( ) ) ) ) { writer . println ( str ) ; } if ( ( properties != null ) && ! properties . is empty ( ) ) { print properties ( properties ) ; } if ( ! feasible solutions . is empty ( ) ) { for ( solution solution : feasible solutions ) { print solution ( solution ) ; } } writer . println ( str ) ; }	appends the decision variables , objectives and optional properties to the output file.
public void invalidate ( ) { net no = - num ; drill list . clear ( ) ; }	invalidates the drills of this page so that they are recalculated at the next call of get_drills ( ) .
public void add priority unit ( int id ) { priority unit targets . add ( id ) ; }	add an enemy unit to the priority list .
protected void write netscape ext ( ) throws io { out . write ( num ) ; out . write ( num ) ; out . write ( num ) ; write string ( str + str ) ; out . write ( num ) ; out . write ( num ) ; write short ( repeat ) ; out . write ( num ) ; }	writes netscape application extension to define repeat count .
public static boolean is char at equal ( string string , int index , char char to compare ) { if ( ( index < num ) || ( index >= string . length ( ) ) ) { return bool ; } return string . char at ( index ) == char to compare ; }	safely compares provided char with char on given location .
public synchronized void put quad tree ( string key , quad tree quad tree ) { quad tree . timestamp = system . current time millis ( ) ; quad tree map . put ( key , quad tree ) ; clean up cache ( ) ; }	place a quadtree in the cache update the timestamp.
public void queue ( string entity , string event , string key ) { if ( broadcast events == null ) return ; try { counter . increment and get ( ) ; broadcast events . put first ( new broadcast event ( entity , event , key ) ) ; } catch ( exception e ) { counter . decrement and get ( ) ; logger . error ( str , e ) ; } }	broadcast an event out.
public static string [ ] to string array ( object value ) { if ( value == null ) { return new string [ num ] ; } class < ? > type = value . get class ( ) ; if ( type . is array ( ) == bool ) { return new string [ ] { value . to string ( ) } ; } class component type = type . get component type ( ) ; if ( component type . is primitive ( ) ) { if ( component type == int . class ) { return arrays util . to string array ( ( int [ ] ) value ) ; } else if ( component type == long . class ) { return arrays util . to string array ( ( long [ ] ) value ) ; } else if ( component type == double . class ) { return arrays util . to string array ( ( double [ ] ) value ) ; } else if ( component type == float . class ) { return arrays util . to string array ( ( float [ ] ) value ) ; } else if ( component type == boolean . class ) { return arrays util . to string array ( ( boolean [ ] ) value ) ; } else if ( component type == short . class ) { return arrays util . to string array ( ( short [ ] ) value ) ; } else if ( component type == byte . class ) { return arrays util . to string array ( ( byte [ ] ) value ) ; } else { throw new illegal argument exception ( ) ; } } else { return arrays util . to string array ( ( object [ ] ) value ) ; } }	converts an array object to array of strings , where every element of input array is converted to a string.
public creation tool ( figure prototype ) { this ( prototype , null , null ) ; }	creates a new instance with the specified prototype but without an attribute set.
private void skip ( pattern pattern ) throws decode exception { matcher matcher = pattern . matcher ( gser value . substring ( pos , length ) ) ; if ( matcher . find ( ) && matcher . group count ( ) >= num ) { pos += matcher . end ( num ) ; } else { final localizable message msg = warn gser pattern no match . get ( pattern . pattern ( ) , gser value . substring ( pos , length ) ) ; throw decode exception . error ( msg ) ; } }	skips the input matched by the first capturing group .
public boolean is depreciated ( timestamp date ) { timestamp last action date = get last action date ( ) ; boolean is depr = ! date . after ( last action date ) ; log . fine ( str + last action date + str + date + str + is depr ) ; return is depr ; }	check if the asset is depreciated at the specified date.
public privileged boot ( final string class name , final string [ ] args ) { this . class name = class name ; this . args = args ; }	creates a privilagedboot object .
public static < t > t wrap throw ( callable < t > callable ) { try { return callable . call ( ) ; } catch ( runtime exception e ) { throw e ; } catch ( exception e ) { throw new runtime exception ( e ) ; } }	execute the callable wrapping checked exceptions inside a runtimeexception .
public string header ( string name ) { return ( string ) headers . get ( name . to lower case ( ) ) ; }	the headers are stored and fetched as lower case .
public boolean add all ( int index , collection < ? extends e > c ) { object [ ] cs = c . to array ( ) ; final reentrant lock lock = this . lock ; lock . lock ( ) ; try { object [ ] elements = get array ( ) ; int len = elements . length ; if ( index > len || index < num ) throw new index out of bounds exception ( str + index + str + len ) ; if ( cs . length == num ) return bool ; int num moved = len - index ; object [ ] new elements ; if ( num moved == num ) new elements = arrays . copy of ( elements , len + cs . length ) ; else { new elements = new object [ len + cs . length ] ; system . arraycopy ( elements , num , new elements , num , index ) ; system . arraycopy ( elements , index , new elements , index + cs . length , num moved ) ; } system . arraycopy ( cs , num , new elements , index , cs . length ) ; set array ( new elements ) ; return bool ; } finally { lock . unlock ( ) ; } }	inserts all of the elements in the specified collection into this list , starting at the specified position.
public void and with ( query predicate predicate ) { children . add ( predicate ) ; }	adds a query predicate that must be met by vertices .
public string object to string ( final long shop id , final string sku code , final big decimal quantity ) { string builder string builder = new string builder ( ) ; string builder . append ( id bridge . object to string ( new big decimal ( shop id ) ) ) ; string builder . append ( str ) ; string builder . append ( sku code ) ; string builder . append ( str ) ; string builder . append ( qty bridge . object to string ( quantity ) ) ; return string builder . to string ( ) ; }	create index value for given shop currency and price .
public static string read file contents ( file file ) { string builder script text = new string builder ( ) ; string new line = system . get property ( str ) ; scanner scanner = null ; try { scanner = new scanner ( new file input stream ( file ) ) ; while ( scanner . has next line ( ) ) { script text . append ( scanner . next line ( ) + new line ) ; } } catch ( file not found exception e ) { e . print stack trace ( ) ; } finally { scanner . close ( ) ; } return script text . to string ( ) ; }	returns the contents of a file as a string .
public config sets handler ( final core container core container ) { this . core container = core container ; }	overloaded ctor to inject corecontainer into the handler .
public boolean exists ( final string file ) { return exists ( file , bool ) ; }	use this to check whether or not a file exists on the filesystem .
public static string bytes to sequence inc cg ( final byte [ ] seq , final int start , final int length ) { final string builder sb = new string builder ( ) ; for ( int i = start ; i < start + length ; i ++ ) { if ( i < num || i >= seq . length ) { sb . append ( str ) ; } else if ( seq [ i ] != num ) { sb . append ( bases [ seq [ i ] ] ) ; } } return sb . to string ( ) ; }	convert a binary dna sequence to a human readable string using uppercase characters.
public void update ( int length , long rtpts ) throws io { m packet count += num ; m octet count += length ; set long ( m packet count , num , num ) ; set long ( m octet count , num , num ) ; now = system clock . elapsed realtime ( ) ; delta += oldnow != num ? now - oldnow : num ; oldnow = now ; if ( interval > num ) { if ( delta >= interval ) { send ( system . nano time ( ) , rtpts ) ; delta = num ; } } }	updates the number of packets sent , and the total amount of data sent .
private void active recycler view ( list my maps ) { recycler view . layout manager layout manager ; maps rv = ( recycler view ) find view by id ( r . id . my maps download recycler view ) ; default item animator animator = new default item animator ( ) ; animator . set add duration ( num ) ; animator . set remove duration ( num ) ; maps rv . set item animator ( animator ) ; maps rv . set has fixed size ( bool ) ; layout manager = new linear layout manager ( this ) ; maps rv . set layout manager ( layout manager ) ; my download adapter = new my download adapter ( my maps , this ) ; maps rv . set adapter ( my download adapter ) ; }	active directions , and directions view.
public int push ( int i ) { if ( ( m first free + num ) >= m map size ) { m map size += m blocksize ; int new map [ ] = new int [ m map size ] ; system . arraycopy ( m map , num , new map , num , m first free + num ) ; m map = new map ; } m map [ m first free ] = i ; m first free ++ ; return i ; }	pushes an item onto the top of this stack .
private static method find method ( object instance , string name , class < ? > ... parameter types ) throws no such method exception { for ( class < ? > clazz = instance . get class ( ) ; clazz != null ; clazz = clazz . get superclass ( ) ) { try { method method = clazz . get declared method ( name , parameter types ) ; if ( ! method . is accessible ( ) ) { method . set accessible ( bool ) ; } return method ; } catch ( no such method exception e ) { } } throw new no such method exception ( str + name + str + arrays . as list ( parameter types ) + str + instance . get class ( ) ) ; }	locates a given method anywhere in the class inheritance hierarchy .
private static double distance ( double [ ] p1 , double [ ] p2 ) { double sum = num ; for ( int i = num ; i < p1 . length ; i ++ ) { sum += math . pow ( p2 [ i ] - p1 [ i ] , num ) ; } return math . sqrt ( sum ) ; }	returns the euclidean distance between two points .
public boolean load spec ( string root external module name , errors errors ) throws abort exception { root parse unit = find or create parsed unit ( root external module name , errors , bool ) ; root module = root parse unit . get root module ( ) ; parse unit next extention or instantiation parse unit = null ; while ( find next unresolved extention ( root module ) || find next unresolved instantiation ( root module ) ) { if ( parse unit context . get ( next parse unit name ) == null ) { next extention or instantiation parse unit = find or create parsed unit ( next parse unit name , errors , bool ) ; } else { next extention or instantiation parse unit = ( parse unit ) parse unit context . get ( next parse unit name ) ; } parse unit extender or instancer parse unit = next extender or instancer module . get parse unit ( ) ; if ( extention found ) { extender or instancer parse unit . add extendee ( next extention or instantiation parse unit ) ; next extention or instantiation parse unit . add extended by ( extender or instancer parse unit ) ; } if ( instantiation found ) { extender or instancer parse unit . add instancee ( next extention or instantiation parse unit ) ; next extention or instantiation parse unit . add instanced by ( extender or instancer parse unit ) ; } non circularity test ( next extention or instantiation parse unit , errors ) ; if ( extention found ) { resolve names between spec and extention ( next extender or instancer module , next extention or instantiation parse unit ) ; } if ( instantiation found ) { resolve names between spec and instantiation ( next extender or instancer module , next extention or instantiation parse unit ) ; } } calculate dependencies ( root parse unit ) ; return bool ; }	this method " loads " an entire specification , starting with the top - level rootexternalmodule and followed by all of the external modules it references via extends and instance statements .
public void add ( node n ) { list . add ( n ) ; root = null ; }	appends a node to the list.
private int process error ( n e , string header message code , string debug message , object ... message parameters ) throws auth login exception { if ( null == e ) { return process error ( header message code , debug message , message parameters ) ; } string header message ; if ( null == header message code ) { header message = e . get l10 n ( get login locale ( ) ) ; } else { header message = bundle . get string ( header message code ) ; } if ( debug message != null ) { debug . error ( debug message , message parameters , e ) ; } substitute header ( state error , header message ) ; return state error ; }	writes out an error debug ( if a throwable and debug message are provided ) and returns a user - facing error page .
public static int clamp mono ( int value ) { return math . max ( math . min ( value , num ) , - num ) ; }	clamp a mono audio sample to a valid range [ - 0x8000.
unit type ( data input stream is ) throws io { this . name = utilities . get string ( is ) ; this . start = is . read int ( ) ; this . count = is . read int ( ) ; }	creates a unit type by reading it from the given input stream .
public void add response ( record response response ) { if ( response . get response size ( ) + get response size ( ) > num ) { throw new illegal argument exception ( ) ; } if ( records == null ) { records = new record response [ num ] ; } else { record response old [ ] = records ; records = new record response [ old . length + num ] ; system . arraycopy ( old , num , records , num , old . length ) ; } records [ records . length - num ] = response ; set data length ( get response size ( ) ) ; }	addresponse - - add a new record response .
public void flatten hierarchy ( constraint widget container root ) { array list < constraint widget container > containers = gather containers ( root ) ; while ( containers . size ( ) > num ) { for ( constraint widget container container : containers ) { remove container ( container ) ; } containers = gather containers ( root ) ; } }	flatten the hierachy - - remove all existing containers children of the given container.
@ override public boolean has ( pattern pattern ) { final matcher matcher = pattern . matcher ( rest ( ) ) ; return matcher . find ( ) && matcher . start ( ) == num ; }	this method will determine whether the indicated pattern can be found at this point in the document or not.
public int hash code ( ) { return arrays . hash code ( chars ) ; }	returns the hash code for this set of characters.
public static int patch fast ( file old file , file new file , file diff file , int ext len ) throws io { if ( old file == null || old file . length ( ) <= num ) { return return old file err ; } if ( new file == null ) { return return new file err ; } if ( diff file == null || diff file . length ( ) <= num ) { return return diff file err ; } input stream old input stream = new buffered input stream ( new file input stream ( old file ) ) ; byte [ ] diff bytes = new byte [ ( int ) diff file . length ( ) ] ; input stream diff input stream = new file input stream ( diff file ) ; try { bs . read from stream ( diff input stream , diff bytes , num , diff bytes . length ) ; } finally { diff input stream . close ( ) ; } byte [ ] new bytes = patch fast ( old input stream , ( int ) old file . length ( ) , diff bytes , ext len ) ; output stream new output stream = new file output stream ( new file ) ; try { new output stream . write ( new bytes ) ; } finally { new output stream . close ( ) ; } return return success ; }	this patch method is fast , but using more memory . memory size = oldbuf + diffbuf + newbuf.
public static double polynomial distance ( double [ ] coeffs1 , double [ ] coeffs2 ) { if ( coeffs1 == null || coeffs2 == null ) throw new null pointer exception ( str ) ; if ( coeffs1 . length != coeffs2 . length ) throw new illegal argument exception ( str ) ; double dist = num ; int order = coeffs1 . length - num ; for ( int i = num ; i <= order ; i ++ ) { dist += ( coeffs1 [ order - i ] - coeffs2 [ order - i ] ) / ( i + num ) ; } return math . abs ( dist ) ; }	compute the integrated distance between two polynomials of same order.
public ec ( elliptic curve curve , ec g , big integer n , int h ) { if ( curve == null ) { throw new null pointer exception ( str ) ; } if ( g == null ) { throw new null pointer exception ( str ) ; } if ( n == null ) { throw new null pointer exception ( str ) ; } if ( n . signum ( ) != num ) { throw new illegal argument exception ( str ) ; } if ( h <= num ) { throw new illegal argument exception ( str ) ; } this . curve = curve ; this . g = g ; this . n = n ; this . h = h ; }	creates elliptic curve domain parameters based on the specified values .
private boolean is instance modification event ( hashtable < string , string > notification ) { string event type = str ; boolean is instance modification event = boolean . false ; event type = notification . get ( cim . indication class tag ) ; if ( event type != null && event type . length ( ) > num && event type . contains ( cim . inst modification event ) ) { is instance modification event = boolean . true ; } return is instance modification event ; }	this method helps to identify whether the provided indication type is instance modification event or not .
protected int add child node ( node builder child ) { synchronized ( nodes ) { nodes . add ( child ) ; return nodes . size ( ) - num ; } }	this method adds the supplied node builder as a child of this node builder .
public static byte [ ] to unsigned byte array ( big integer bi ) { if ( bi == null ) { return null ; } byte [ ] bb = bi . to byte array ( ) ; if ( bb [ num ] == num ) { byte [ ] no zero = new byte [ bb . length - num ] ; system . arraycopy ( bb , num , no zero , num , no zero . length ) ; return no zero ; } else { return bb ; } }	remove first byte if 0.
private void check limits ( float temp , float year ) { if ( float . is na n ( overall max temp ) || temp > overall max temp ) overall max temp = temp ; if ( float . is na n ( overall min temp ) || temp < overall min temp ) overall min temp = temp ; if ( float . is na n ( overall max year ) || year > overall max year ) overall max year = year ; if ( float . is na n ( overall min year ) || year < overall min year ) overall min year = year ; }	see if these values for temp and year are outside of our current notion of how large our data space is . < p >.
private string create workflow step for relink native targets ( workflow workflow , block snapshot session tgt snap session , list < uri > snapshot ur , string wait for , workflow . method rollback method ) { uri parent system uri = tgt snap session . get storage controller ( ) ; storage system parent system = get data object ( storage system . class , parent system uri , db client ) ; workflow . method relink method = new workflow . method ( relink snapshot session targets method name , parent system uri , tgt snap session . get id ( ) , snapshot ur , boolean . false ) ; workflow . create step ( relink snapshot session target step , string . format ( str , snapshot ur , tgt snap session . get id ( ) ) , wait for , parent system uri , parent system . get system type ( ) , block device controller . class , relink method , rollback method , null ) ; log . info ( str , snapshot ur , tgt snap session . get id ( ) ) ; return relink snapshot session target step ; }	create a step in the passed workflow to call the block controller to natively relink the passed linked targets to the passed target snapshot session .
public void audit access message ( string resource , string action , sso token ) { init ( ) ; if ( access logger != null && msg provider != null ) { final log record record = msg provider . create log record ( str , new string [ ] { resource , action } , token ) ; if ( record != null ) { access logger . log ( record , access controller . do privileged ( admin token action . get instance ( ) ) ) ; } } }	audits an attempted rest request , indicating which resource was accessed using which method linked to the ssotoken of the accessing user .
public static void write ( om point , link link , link properties props ) throws io { props . set property ( link point . lpc point oval , point . is oval ( ) ? str : str ) ; switch ( point . get render type ( ) ) { case om . rendertype latlon : link point . write ( ( float ) point . get lat ( ) , ( float ) point . get lon ( ) , point . get radius ( ) , props , link . dos ) ; break ; case om . rendertype xy : link point . write ( point . get x ( ) , point . get y ( ) , point . get radius ( ) , props , link . dos ) ; break ; case om . rendertype offset : link point . write ( ( float ) point . get lat ( ) , ( float ) point . get lon ( ) , point . get x ( ) , point . get y ( ) , point . get radius ( ) , props , link . dos ) ; break ; default : debug . error ( str ) ; } }	write an ompoint to the link .
public static byte [ ] reverse dword bytes ( byte [ ] bytes , int trim length ) { check argument ( bytes . length % num == num ) ; check argument ( trim length < num || trim length % num == num ) ; byte [ ] rev = new byte [ trim length >= num && bytes . length > trim length ? trim length : bytes . length ] ; for ( int i = num ; i < rev . length ; i += num ) { system . arraycopy ( bytes , i , rev , i , num ) ; for ( int j = num ; j < num ; j ++ ) { rev [ i + j ] = bytes [ i + num - j ] ; } } return rev ; }	returns a copy of the given byte array with the bytes of each double - word ( 4 bytes ) reversed .
public v remove ( a arg ) { future < v > future = cache . remove ( arg ) ; v res = null ; if ( future != null ) { try { res = future . get ( ) ; } catch ( interrupted exception | execution exception ignore ) { } } return res ; }	removes the value to which the specified key is mapped , or null otherwise . note : this is a blocking call.
@ override public boolean test ( object receiver , string property , object [ ] args , object expected value ) { if ( is angula project property . equals ( property ) ) { return test is type script project ( receiver ) ; } return bool ; }	tests if the receiver object is a project is a angular2 project.
public player mined number of items condition ( int number , string ... items ) { item mined list = new array list < string > ( ) ; if ( items != null ) { for ( string item : items ) { item mined list . add ( item ) ; } } quantity = number ; }	create a new playerminednumberofitemscondition.
public static map < string , object > make valid context ( model service model , string mode , map < string , ? extends object > context ) throws generic service exception { map < string , object > new context ; int mode int = num ; if ( mode . equals ignore case ( str ) ) { mode int = num ; } else if ( mode . equals ignore case ( str ) ) { mode int = num ; } if ( model == null ) { throw new generic service exception ( str ) ; } else { switch ( mode int ) { case num : new context = model . make valid ( context , model service . out param , bool , null ) ; break ; case num : new context = model . make valid ( context , model service . in param , bool , null ) ; break ; default : throw new generic service exception ( str ) ; } return new context ; } }	uses an existing map of name value pairs and extracts the keys which are used in servicename note : this goes not guarantee the context will be 100 % valid , there may be missing fields.
public static void add ore weight ( string ore , int weight ) { ore weights . put ( ore , weight ) ; }	maps an ore ( ore dictionary key ) to it ' s weight on the world generation.
protected pair < class < ? extends page > , page parameters > determine cancel target ( boolean is checkout , final customer customer ) { return determine success target ( is checkout , customer ) ; }	extension hook to override classes for themes .
public void start element ( stylesheet handler handler , string uri , string local name , string raw name , attributes attributes ) throws org . xml . sax . sax { super . start element ( handler , uri , local name , raw name , attributes ) ; try { xslt def = get elem def ( ) ; class class object = def . get class object ( ) ; elem template element elem = null ; try { elem = ( elem template element ) class object . new instance ( ) ; elem . set dom ( handler . get originating node ( ) ) ; elem . set locater info ( handler . get locator ( ) ) ; elem . set prefixes ( handler . get namespace support ( ) ) ; } catch ( instantiation exception ie ) { handler . error ( xslt . er failed creating elemtmpl , null , ie ) ; } catch ( illegal access exception iae ) { handler . error ( xslt . er failed creating elemtmpl , null , iae ) ; } set properties from attributes ( handler , raw name , attributes , elem ) ; append and push ( handler , elem ) ; } catch ( transformer exception te ) { throw new org . xml . sax . sax ( te ) ; } }	receive notification of the start of an element .
private boolean check external storage and notify ( string filename , string full dir path , string external storage status ) { if ( full dir path == null ) { log . e ( tag , str ) ; alert download failure ( filename ) ; return bool ; } if ( ! external storage status . equals ( environment . media mounted ) ) { if ( external storage status . equals ( environment . media shared ) ) { log . e ( tag , str ) ; } else { log . e ( tag , str ) ; } alert download failure ( filename ) ; return bool ; } return bool ; }	check the external storage and notify user on error .
private void update storage ports for add initiators ( export mask add initiator completer task completer , storage system system , export mask export mask , list < com . emc . storageos . db . client . model . initiator > initiator list , list < com . emc . storageos . db . client . model . storage port > selected ports for mask , uri virtual array , export path params path params ) { list < uri > port uris = new array list < > ( ) ; for ( com . emc . storageos . db . client . model . storage port port : selected ports for mask ) { port uris . add ( port . get id ( ) ) ; } task completer . set target ur ( port uris ) ; list < uri > initiator uris = uri . to uris ( initiator list ) ; for ( uri initiator uri : initiator uris ) { export mask . remove zoning map entry ( initiator uri . to string ( ) ) ; } map < uri , list < uri > > assignments = block scheduler . assign selected storage ports ( system , selected ports for mask , virtual array , initiator list , path params , export mask . get zoning map ( ) ) ; export mask . add zoning map ( block storage scheduler . get zone map from assignments ( assignments ) ) ; db client . update object ( export mask ) ; }	this method updates storage ports in export masks for new initiators , based on array selected ports .
public static boolean use name suggestions ( set < string > used keys ) { return ! ( used keys . contains ( tags . key highway ) || used keys . contains ( tags . key waterway ) || used keys . contains ( tags . key landuse ) || used keys . contains ( tags . key natural ) || used keys . contains ( tags . key railway ) ) ; }	return true if the edited object could have a name in the name index.
public vn remove luns from lun group ( string lun group id , list < string > luns ) { lun group modify param param = new lun group modify param ( ) ; list < lun add param > lun removes = new array list < lun add param > ( ) ; for ( string lun id : luns ) { vn lun = new vn ( lun id ) ; lun add param lun add = new lun add param ( ) ; lun add . set lun ( lun ) ; lun removes . add ( lun add ) ; } param . set lun remove ( lun removes ) ; lun group requests req = new lun group requests ( kh client ) ; return req . modify lun group sync ( lun group id , param ) ; }	remove luns from the lun group.
public static boolean is invoice type ( generic value invoice , string input type id ) throws generic entity exception { if ( invoice == null ) { return bool ; } generic value invoice type = invoice . get related one ( str , bool ) ; if ( invoice type == null ) { throw new generic entity exception ( str + invoice . get string ( str ) ) ; } string invoice type id = invoice type . get string ( str ) ; if ( input type id . equals ( invoice type id ) ) { return bool ; } return is invoice type recurse ( invoice type , input type id ) ; }	checks if a invoice is of a specified invoicetype.
watch watch ( compilation request request ) { watch watch = request for thread . get ( ) ; if ( watch == null ) { watch = new watch ( ) ; synchronized ( requests ) { requests . put ( thread . current thread ( ) , watch ) ; } } watch . open ( request ) ; return watch ; }	opens a scope for watching the compilation of a given method .
public order by clause add ( string property , boolean is descending ) { order by expressions . add ( new order by element ( expressions . get prop expr ( property ) , is descending ) ) ; return this ; }	adds a property and flag .
public void add cancel listener ( action listener a ) { m cancel but . add action listener ( a ) ; }	this is used to hook an action listener to the cancel button .
@ deprecated protected final class < ? > define class ( byte [ ] class rep , int offset , int length ) throws class format error { return define class ( null , class rep , offset , length ) ; }	constructs a new class from an array of bytes containing a class definition in class file format .
public static void extract idat ( input stream is , output stream os , boolean strip filter byte , boolean check crc ) { try { chunk seq png raw pixels cr = new chunk seq png raw pixels ( is , os ) ; cr . set check crc ( check crc ) ; cr . set omit filter byte ( strip filter byte ) ; cr . read all ( ) ; is . close ( ) ; os . close ( ) ; } catch ( io e ) { throw new pngj exception ( e ) ; } }	reads a png and and writes the uncompressed unfiltered raw stream to os.
private void complete commits ( long previous commit index , long commit index ) { for ( long i = previous commit index + num ; i <= commit index ; i ++ ) { completable future < long > future = append futures . remove ( i ) ; if ( future != null ) { future . complete ( i ) ; } } }	completes append entries attempts up to the given index .
public concurrent skip list map ( sorted map < k , ? extends v > m ) { this . comparator = m . comparator ( ) ; initialize ( ) ; build from sorted ( m ) ; }	constructs a new map containing the same mappings and using the same ordering as the specified sorted map .
private void handle exception ( string message , exception exception ) { boolean unexpected = ! quitting ( ) ; if ( unexpected && ! ( exception instanceof cancel exception ) ) { logger . warn ( localized message . create ( localized strings . 0 1 2 , new object [ ] { this , message , exception } ) , exception ) ; } }	conditionally print a warning describing the failure < p > signals run thread to stop.
private void update media information lists ( movie movie ) { list < string > available codecs = new array list < > ( video codecs observable ) ; for ( media file mf : movie . get media files ( media file type . video ) ) { string codec = mf . get video codec ( ) ; boolean codec found = bool ; for ( string mf codec : available codecs ) { if ( mf codec . equals ( codec ) ) { codec found = bool ; break ; } } if ( ! codec found ) { add video codec ( codec ) ; } } available codecs = new array list < > ( audio codecs observable ) ; for ( media file mf : movie . get media files ( media file type . video ) ) { for ( media file audio stream audio : mf . get audio streams ( ) ) { string codec = audio . get codec ( ) ; boolean codec found = bool ; for ( string mf codec : available codecs ) { if ( mf codec . equals ( codec ) ) { codec found = bool ; break ; } } if ( ! codec found ) { add audio codec ( codec ) ; } } } }	update media information used in movies .
public collection relationship provider ( final connection factory connection factory , final resource path resource path , final schema field schema field , final activity logger activity logger , final managed object set service managed object sync service ) { super ( connection factory , resource path , schema field , activity logger , managed object sync service ) ; final router router = new router ( ) ; router . add route ( routing mode . starts with , uri template ( string . format ( str , param managed object id , schema field . get name ( ) ) ) , resources . new handler ( this ) ) ; this . request handler = router ; }	create a new relationship set for the given managed resource.
public static boolean should highlight methd ( string soot method signature ) { return methods to highlight . contains ( soot method signature ) ; }	return true if the soot method signature is in the list of methods to highlight .
private boolean auto reconnect ( int count ) { if ( ! is closed ( ) ) { return bool ; } if ( ! auto reconnect ) { return bool ; } if ( ! cluster && ! auto commit ) { return bool ; } if ( count > sys properties . max reconnect ) { return bool ; } last reconnect ++ ; while ( bool ) { try { embedded = connect embedded or server ( bool ) ; break ; } catch ( db exception e ) { if ( e . get error code ( ) != error code . database is in exclusive mode ) { throw e ; } try { thread . sleep ( num ) ; } catch ( exception e2 ) { } } } if ( embedded == this ) { embedded = null ; } else { connect embedded or server ( bool ) ; } recreate session state ( ) ; if ( event listener != null ) { event listener . set progress ( database event listener . state reconnected , database name , count , sys properties . max reconnect ) ; } return bool ; }	automatically re - connect if necessary and if configured to do so .
protected void finalize ( ) { synchronized ( stats map ) { stats map . remove ( stats name ) ; } synchronized ( this ) { if ( stats file == null ) { return ; } stats state = stats . off ; stats file . flush ( ) ; stats file . close ( ) ; stats file = null ; } }	flushes and then closes the stats file .
void declare ( string name , type type ) { if ( reserved words . contains ( name ) ) throw new runtime exception ( name + str ) ; if ( table . contains key ( name ) ) throw new runtime exception ( str + name + str ) ; symbol symbol = new symbol ( this , name , type ) ; table . put ( name , symbol ) ; stack map . add ( new declaration ( symbol ) ) ; }	declare a new variable.
protected void add xm ( xml component ) { if ( f xm . contains ( component ) ) { return ; } f xm . add ( component ) ; add recognized params and set defaults ( component ) ; }	adds an xml 1.
private set < string > wait for mac app quit ( string browser ) { set < string > running apps ; boolean app closed = bool ; final long start millis = system . current time millis ( ) ; final long wait millis = num ; do { running apps = running applications ( ) ; if ( running apps . contains ( browser ) ) { app closed = bool ; try { thread . sleep ( wait millis ) ; } catch ( interrupted exception e ) { return running apps ; } long current millis = system . current time millis ( ) ; if ( current millis - start millis >= max terminate wait millis ) break ; } else { app closed = bool ; } } while ( ! app closed ) ; return running apps ; }	utility function to wait for a mac application to quit.
public static void assert array equals ( string message , object [ ] expected , object [ ] actual ) { if ( expected == null ) { assert equals ( ( object ) null , actual ) ; return ; } if ( actual == null ) { throw new assertion failed error ( message + str + arrays . to string ( expected ) + str ) ; } assert equals ( message + str , expected . length , actual . length ) ; for ( int i = num ; i < expected . length ; i ++ ) { assert equals ( message , expected [ i ] , actual [ i ] ) ; } }	tests all objects in the array .
@ override public void remove ( ) { m src . remove ( ) ; }	delegates remove request to source iterator.
public static tc feature create ( class < ? extends resource > feature name , object ... parameters ) { string id = feature name . get simple name ( ) + system . nano time ( ) ; list < object > params = get parameter as string ( parameters ) ; params . add ( feature extractor resource impl base . param unique extractor name ) ; params . add ( id ) ; tc feature tc feature = new tc feature ( feature name , id , params . to array ( ) ) ; return tc feature ; }	creates a new instance of a tcfeature.
public void print ( object x ) { out . print ( x ) ; out . flush ( ) ; }	prints an object to this output stream and flushes this output stream .
public byte [ ] serialize ( ) { if ( current byte array index == num ) { return new byte [ num ] ; } final byte [ ] extracted serialized data = new byte [ current byte array index ] ; system . arraycopy ( serialized data , num , extracted serialized data , num , current byte array index ) ; return extracted serialized data ; }	finishes serialization , returning the object as a byte array .
public synchronized int length ( ) { return value . size ( ) ; }	returns the length of the array .
public static byte [ ] read all ( input stream in str ) throws io { byte array output stream buf = new byte array output stream ( ) ; pipe all ( in str , buf ) ; return buf . to byte array ( ) ; }	read stream fully , returning contents in a byte array .
public static list < list < file > > find java files per directory ( file parent , string ... dir names ) { list < list < file > > files per directory = new array list < > ( ) ; for ( string dir name : dir names ) { file dir = new file ( parent , dir name ) ; if ( dir . is directory ( ) ) { files per directory . add all ( find java test files in directory ( dir ) ) ; } } return files per directory ; }	returns a list where each item is a list of java files , excluding any skip tests , for each directory given by dirname and also a list for any subdirectory .
private byte buffer decode stream ( ) throws io { byte buffer out stream = null ; if ( decoded stream != null ) { out stream = ( byte buffer ) decoded stream . get ( ) ; } if ( out stream == null ) { stream . rewind ( ) ; out stream = pdf . decode stream ( this , stream ) ; decoded stream = new soft reference ( out stream ) ; } return out stream ; }	get the decoded stream value.
private boolean is all ports looped ( list < uri > ordered networks , map < uri , list < storage port > > allocatable ports , set < string > used ports ) { for ( uri network uri : ordered networks ) { for ( storage port port : allocatable ports . get ( network uri ) ) { if ( ! used ports . contains ( port . get port name ( ) ) ) { return bool ; } } } return bool ; }	checks if is all given ports have been processed or selected .
public static string to string ( int rank , int suit ) { string buffer sb = new string buffer ( ) ; switch ( rank ) { case ace : sb . append ( ac ) ; break ; case jack : sb . append ( jac ) ; break ; case queen : sb . append ( quee ) ; break ; case king : sb . append ( kin ) ; break ; default : if ( rank < num ) throw new illegal argument exception ( str ) ; if ( rank > num ) throw new illegal argument exception ( str ) ; sb . append ( rank ) ; } switch ( suit ) { case clubs : sb . append ( club ) ; break ; case diamonds : sb . append ( diamond ) ; break ; case hearts : sb . append ( heart ) ; break ; case spades : sb . append ( spade ) ; break ; default : throw new illegal argument exception ( str ) ; } return sb . to string ( ) ; }	static method for converting a specific rank / suit into its string representation . creation date : ( 10 / 1 / 01 8 : 53 : 13 pm ).
public h ( string table , string column family , boolean including all qualifiers , list < string > qualifiers ) { this . table = table ; this . column family = column family ; if ( qualifiers != null ) { this . output qualifiers = new byte [ qualifiers . size ( ) ] [ ] ; int i = num ; for ( string qualifier : qualifiers ) { this . output qualifiers [ i ++ ] = qualifier . get bytes ( ) ; } } this . including all qualifiers = including all qualifiers ; }	if includingallqualifiers is true , then the fourth argument outputqualifiers is ignored if includingallqualifiers is false , then need calculate based on the fourth argument outputqualifiers.
public void fade in all layers ( ) { m transition state = transition starting ; arrays . fill ( m is layer on , bool ) ; invalidate self ( ) ; }	starts fading in all layers .
private int strip source route ( string address , int pos ) { if ( pos < address . length ( ) ) { if ( address . char at ( pos ) == str ) { int i = address . index of ( str ) ; if ( i != - num ) { pos = i + num ; } } } return pos ; }	strips source routing . according to rfc - 2821 it is a valid approach to handle mails containing rfc - 821 source - route information .
public static boolean implements zero arg method ( class node class node , string method name ) { return implements method ( class node , method name , new class [ num ] ) ; }	tests whether the clasnode implements the specified method name.
public int parse ( char c , char [ ] ia , int ip , int il ) { assert ( ia [ ip ] == c ) ; if ( character . is high surrogate ( c ) ) { if ( il - ip < num ) { error = coder result . underflow ; return - num ; } char d = ia [ ip + num ] ; if ( character . is low surrogate ( d ) ) { character = character . to code point ( c , d ) ; is pair = bool ; error = null ; return character ; } error = coder result . malformed for length ( num ) ; return - num ; } if ( character . is low surrogate ( c ) ) { error = coder result . malformed for length ( num ) ; return - num ; } character = c ; is pair = bool ; error = null ; return character ; }	parses a ucs - 4 character from the given source buffer , handling surrogates .
public value read ( type type , node map node , map map ) throws exception { class actual = read value ( type , node ) ; class expect = type . get type ( ) ; if ( expect . is array ( ) ) { return read array ( actual , node ) ; } if ( expect != actual ) { return new object value ( actual ) ; } return null ; }	this is used to resolve and load a class for the given element.
public static o create o ( final string raw json ) throws twitter exception { try { final json json = new json ( raw json ) ; return oembed constructor . new instance ( json ) ; } catch ( final instantiation exception e ) { throw new twitter exception ( e ) ; } catch ( final illegal access exception e ) { throw new assertion error ( e ) ; } catch ( final invocation target exception e ) { throw new twitter exception ( e ) ; } catch ( final json e ) { throw new twitter exception ( e ) ; } }	constructs an oembed object from rawjson string .
private array list < cluster > define clusters random ( random random ) throws exception { array list < cluster > clusters = new array list < cluster > ( m ) ; double diff inst num = m - m ; double min inst num = m ; double diff radius = m - m ; cluster cluster ; for ( int i = num ; i < m ; i ++ ) { int inst num = ( int ) ( random . next double ( ) * diff inst num + min inst num ) ; double radius = ( random . next double ( ) * diff radius ) + m ; cluster = new cluster ( inst num , radius , random ) ; clusters . add ( cluster ) ; } return clusters ; }	defines the clusters if pattern is random.
public static synchronized fs instance ( ) { if ( instance == null ) { instance = new fs ( ) ; } return instance ; }	gets an instance of this class .
public static long pop xor ( long [ ] arr1 , long [ ] arr2 , int word offset , int num words ) { long pop count = num ; for ( int i = word offset , end = word offset + num words ; i < end ; ++ i ) { pop count += long . bit count ( arr1 [ i ] ^ arr2 [ i ] ) ; } return pop count ; }	returns the popcount or cardinality of a ^ b neither array is modified .
public db ( exception e , string sql , object [ ] params ) { this ( e ) ; m sql = sql ; if ( params != null ) m params = arrays . copy of ( params , params . length ) ; }	create a new dbexception based on a sqlexception and sql query.
public static < t > t first ( list < t > l ) { return l . get ( num ) ; }	get the first element from a list .
protected string [ ] remove blacklist ( string [ ] options ) { hashtable < string , option > pool ; option option ; enumeration < option > enm = list options ( ) ; pool = new hashtable < string , option > ( ) ; while ( enm . has more elements ( ) ) { option = enm . next element ( ) ; if ( is on blacklist ( option . name ( ) ) ) { pool . put ( option . name ( ) , option ) ; } } enumeration < string > enm2 = pool . keys ( ) ; while ( enm2 . has more elements ( ) ) { option = pool . get ( enm2 . next element ( ) ) ; try { if ( option . num arguments ( ) == num ) { utils . get flag ( option . name ( ) , options ) ; } else { utils . get option ( option . name ( ) , options ) ; } } catch ( exception e ) { e . print stack trace ( ) ; } } return options ; }	removes all the options from the options array that are blacklisted.
static public serial sensor manager instance ( ) { if ( instance == null ) { instance = new serial sensor manager ( ) ; } return instance ; }	static function returning the serialsensormanager instance to use .
@ override protected void on activity result ( int request code , int result code , intent data ) { if ( request code == get code ) { editable text = ( editable ) m results . get text ( ) ; if ( result code == result canceled ) { text . append ( str ) ; } else { text . append ( str ) ; text . append ( integer . to string ( result code ) ) ; text . append ( str ) ; if ( data != null ) { text . append ( data . get action ( ) ) ; } } text . append ( str ) ; } }	this method is called when the sending activity has finished , with the result it supplied .
private static void rdf ( xmp xmp , xmp xmp parent , node xml node , boolean is top level ) throws xmp { int node term = get rdf ( xml node ) ; if ( node term != rdfterm description && node term != rdfterm other ) { throw new xmp ( str , badrdf ) ; } else if ( is top level && node term == rdfterm other ) { throw new xmp ( str , badxmp ) ; } else { rdf ( xmp , xmp parent , xml node , is top level ) ; rdf ( xmp , xmp parent , xml node , is top level ) ; } }	7 . 2 . 5 nodeelementuris anyuri - ( coresyntaxterms | rdf : li | oldterms ) 7 . 2 . 11 nodeelement start - element ( uri = = nodeelementuris , attributes = = set ( ( idattr | nodeidattr | aboutattr ) ? , propertyattr * ) ) propertyeltlist end - element ( ) a node element uri is rdf : description or anything else that is not an rdf term .
public list to list ( ) { object [ ] copied elements = new object [ num elements ] ; system . arraycopy ( elements , num , copied elements , num , num elements ) ; return arrays . as list ( copied elements ) ; }	returns a unbacked list of elements in this set .
public void update vars and terminals ( ) { if ( rules == null ) { vars = new array list < string > ( ) ; terminals = new array list < string > ( ) ; return ; } for ( int i = num ; i < rules . size ( ) ; i ++ ) { rule r = rules . get ( i ) ; update vars and terminals ( r ) ; } }	whenever a new rule is added to the grammar , we want to update the list of variables and terminals with any new grammar symbols.
public void add items ( int how many ) { if ( how many > num ) { for ( int i = last inserted index + num ; i <= last inserted index + how many ; i ++ ) { items . add ( str + i ) ; notify item inserted ( items . size ( ) - num ) ; } last inserted index = last inserted index + how many ; } }	utility method to add some rows for testing purposes.
private void init resource bundle ( ui table ) { table . set default locale ( locale . get default ( ) ) ; table . add resource bundle ( str ) ; }	initialize the defaults table with the name of the resourcebundle used for getting localized defaults.
public boolean matches ( ) { return regex matcher . matches ( ) ; }	attempts to match the entire region against the pattern including grok predicates .
public static void put byte ( byte buffer bb , short value ) { bb . put ( ( byte ) ( value & num ) ) ; }	put a byte into the byte buffer unsigned .
public extended message format ( final string pattern ) { this ( pattern , locale . get default ( ) ) ; }	create a new extendedmessageformat for the default locale .
public void start element ( string namespace uri , string local name , string name , attributes atts ) throws org . xml . sax . sax { if ( m in entity ref ) return ; if ( m need to call start document ) { start document internal ( ) ; m need to call start document = bool ; m doc is empty = bool ; } else if ( m cdata tag open ) close cdata ( ) ; try { if ( m need to output doc type decl ) { if ( null != get doctype system ( ) ) { output doc type decl ( name , bool ) ; } m need to output doc type decl = bool ; } if ( m elem context . m start tag open ) { close start tag ( ) ; m elem context . m start tag open = bool ; } if ( namespace uri != null ) ensure prefix is declared ( namespace uri , name ) ; m ispreserve = bool ; if ( should indent ( ) && m start new line ) { indent ( ) ; } m start new line = bool ; final java . io . writer writer = m writer ; writer . write ( str ) ; writer . write ( name ) ; } catch ( io e ) { throw new sax ( e ) ; } if ( atts != null ) add attributes ( atts ) ; m elem context = m elem context . push ( namespace uri , local name , name ) ; m isprevtext = bool ; if ( m tracer != null ) fire pseudo attributes ( ) ; }	receive notification of the beginning of an element , although this is a sax method additional namespace or attribute information can occur before or after this call , that is associated with this element .
private static void do copy file ( file src file , file dest file , boolean preserve file date ) throws io { if ( dest file . exists ( ) && dest file . is directory ( ) ) { throw new io ( str + dest file + str ) ; } file input stream fis = null ; file output stream fos = null ; file channel input = null ; file channel output = null ; try { fis = new file input stream ( src file ) ; fos = new file output stream ( dest file ) ; input = fis . get channel ( ) ; output = fos . get channel ( ) ; long size = input . size ( ) ; long pos = num ; long count = num ; while ( pos < size ) { count = size - pos > file copy buffer size ? file copy buffer size : size - pos ; pos += output . transfer from ( input , pos , count ) ; } } finally { io . close quietly ( output ) ; io . close quietly ( fos ) ; io . close quietly ( input ) ; io . close quietly ( fis ) ; } if ( src file . length ( ) != dest file . length ( ) ) { throw new io ( str + src file + str + dest file + str ) ; } if ( preserve file date ) { dest file . set last modified ( src file . last modified ( ) ) ; } }	internal copy file method .
private void compute rotation time ( ) { key rotation interval in msecs = max life values holder . compute rotation time in m ( ) ; log . info ( str , key rotation interval in msecs ) ; }	initializes the rotation time based on the max token life value .
public void publish ( final string queue name , final string routing key , final string message ) { if ( ( m channel != null ) && m channel . is open ( ) ) { try { m channel . basic publish ( queue name , routing key , null , message . get bytes ( http . utf 8 ) ) ; } catch ( final unsupported encoding exception e ) { e . print stack trace ( ) ; } catch ( final io e ) { e . print stack trace ( ) ; } } }	publish a message to a queue.
private void translate header ( float of ) { float of calculated = of * m scroll multiplier ; if ( build . version . sdk int >= build . version codes . honeycomb && of < m header view . get height ( ) ) { m header view . set translation y ( of calculated ) ; } else if ( of < m header view . get height ( ) ) { translate animation anim = new translate animation ( num , num , of calculated , of calculated ) ; anim . set fill after ( bool ) ; anim . set duration ( num ) ; m header view . start animation ( anim ) ; } m header view . set clip y ( math . round ( of calculated ) ) ; if ( m parallax scroll listener != null ) { final recycler view . view holder holder = m recycler view . find view holder for adapter position ( num ) ; float left ; if ( holder != null ) { left = math . min ( num , ( ( of calculated ) / ( m header view . get height ( ) * m scroll multiplier ) ) ) ; } else { left = num ; } m parallax scroll listener . on parallax scroll ( left , of , m header view ) ; } }	translates the adapter in y.
public static boolean is valid subnet ( int hash ) { int bits = num ; while ( ( hash & num ) == num && bits < num ) { hash >>= num ; bits ++ ; } while ( ( hash & num ) == num && bits < num ) { hash >>= num ; bits ++ ; } return bits == num ; }	makes sure there are no high bits less significant than low bits .
protected final void add tools jar to classpath ( jvm launcher java ) throws file not found exception { if ( ! jdk utils . is osx ( ) && jvm major version < num ) { java . add classpath entries ( jdk utils . get tools jar ( get java home ( ) ) ) ; } }	adds the tools . jar to the classpath , except for mac osx and java 9 or above - as these jvms do not need the tools . jar .
public boolean move to next ( ) { try { return rs . next ( ) ; } catch ( sql e ) { log . warn ( str , e ) ; } return bool ; }	move the cursor to the next row.
private static remote stub create stub ( class < ? > remote class , remote ref ref ) throws stub not found exception { string stubname = remote class . get name ( ) + str ; try { class < ? > stubcl = class . for name ( stubname , bool , remote class . get class loader ( ) ) ; constructor < ? > cons = stubcl . get constructor ( stub cons param types ) ; return ( remote stub ) cons . new instance ( new object [ ] { ref } ) ; } catch ( class not found exception e ) { throw new stub not found exception ( str + stubname , e ) ; } catch ( no such method exception e ) { throw new stub not found exception ( str + stubname , e ) ; } catch ( instantiation exception e ) { throw new stub not found exception ( str + stubname , e ) ; } catch ( illegal access exception e ) { throw new stub not found exception ( str + stubname , e ) ; } catch ( invocation target exception e ) { throw new stub not found exception ( str + stubname , e ) ; } catch ( class cast exception e ) { throw new stub not found exception ( str + stubname , e ) ; } }	creates a remotestub instance for the specified class , constructed with the specified remoteref.
private boolean match domain ( string test domain , string tail domain ) { if ( ! test domain . ends with ( tail domain ) ) { return bool ; } if ( test domain . length ( ) == tail domain . length ( ) ) { return bool ; } if ( tail domain . char at ( num ) == str ) { return bool ; } return test domain . char at ( test domain . length ( ) - tail domain . length ( ) - num ) == str ; }	returns true if the full domain ' s final segments match the tail domain .
public static file add extension ( file file , string extension ) { if ( extension . starts with ( str ) ) { return new file ( file . get absolute path ( ) + extension ) ; } else { return new file ( file . get absolute path ( ) + str + extension ) ; } }	append an extension to a file . if extension does not contain a dot , it will be automatically added.
public boolean equals ( object obj ) { if ( obj instanceof object endpoint ) { object endpoint oe = ( object endpoint ) obj ; return id . equals ( oe . id ) && transport == oe . transport ; } else { return bool ; } }	compares the specified object with this object endpoint for equality.
public void clear all move vectors ( ) { movement sprites . clear ( ) ; }	clears out all movement vectors that were being drawn.
void engine update ( byte [ ] data , int offset , int length ) { count += length ; int datalen = data length ; int remainder ; while ( length >= ( remainder = datalen - buffered ) ) { system . arraycopy ( data , offset , buffer , buffered , remainder ) ; engine transform ( buffer ) ; length -= remainder ; offset += remainder ; buffered = num ; } if ( length > num ) { system . arraycopy ( data , offset , buffer , buffered , length ) ; buffered += length ; } }	updates the message digest with new data .
public void eat ( string s ) { string pn = peek n ( s . length ( ) ) ; if ( ! pn . equals ( s ) ) throw new runtime exception ( str + s + str + pn + str ) ; seek n ( s . length ( ) ) ; }	if the next characters are the same as those in s , seek over them.
public string to string ( ) { string buffer uri spec string = new string buffer ( ) ; if ( m scheme != null ) { uri spec string . append ( m scheme ) ; uri spec string . append ( str ) ; } uri spec string . append ( get scheme specific part ( ) ) ; return uri spec string . to string ( ) ; }	get the uri as a string specification.
private void basic remove ( disk region dr , disk entry entry ) throws io , interrupted exception { disk id id = entry . get disk id ( ) ; if ( entry bits . is needs value ( id . get user bits ( ) ) ) { long old offset = id . get offset in oplog ( ) ; if ( old offset != - num ) { id . set offset in oplog ( - num ) ; if ( rm live ( entry ) ) { if ( ! is compacting ( ) || called by compactor thread ( ) ) { handle no live values ( ) ; } } } } }	asif : a helper function which identifies whether to record a removal of entry in the current oplog or to make the switch to the next oplog.
public boolean include seconds ( ) { return preferences . get boolean ( resources . get string ( r . string . key include seconds ) , boolean . parse boolean ( resources . get string ( r . string . default include seconds ) ) ) ; }	include seconds in timestamps ?.
public string to string ( ) { string builder sb = new string builder ( ) ; sb . append ( super . to string ( ) ) ; sb . append ( str ) ; if ( is set ( num ) ) { sb . append ( str ) ; } if ( is set ( num ) ) { sb . append ( str ) ; } if ( is set ( num ) ) { sb . append ( str ) ; } if ( is set ( num ) ) { sb . append ( str ) ; } if ( is set ( num ) ) { sb . append ( str ) ; } if ( is set ( num ) ) { sb . append ( str ) ; } if ( is set ( num ) ) { sb . append ( str ) ; } sb . append ( str ) ; return sb . to string ( ) ; }	returns a printable representation of the netscapecerttype .
public static flickr photo match url ( string url , string text ) { matcher m = grouping pattern . matcher ( url ) ; if ( m . matches ( ) ) { return new flickr photo ( m . group ( num ) , null , m . group ( num ) , m . group ( num ) , text ) ; } m = url pattern . matcher ( url ) ; if ( m . matches ( ) ) { return new flickr photo ( m . group ( num ) , m . group ( num ) , null , null , text ) ; } else { return null ; } }	returns a flickrphoto object if the given url is to a photo or flickr user .
public void remove active line range listener ( active line range listener l ) { listener list . remove ( active line range listener . class , l ) ; }	removes an " active line range " listener from this text area .
void write external ( data output out ) throws io { out . write int ( standard transitions . length ) ; for ( long trans : standard transitions ) { ser . write epoch sec ( trans , out ) ; } for ( zone offset offset : standard offsets ) { ser . write offset ( offset , out ) ; } out . write int ( savings instant transitions . length ) ; for ( long trans : savings instant transitions ) { ser . write epoch sec ( trans , out ) ; } for ( zone offset offset : wall offsets ) { ser . write offset ( offset , out ) ; } out . write byte ( last rules . length ) ; for ( zone offset transition rule rule : last rules ) { rule . write external ( out ) ; } }	writes the state to the stream .
public fs ( http servlet request req , map map ) { super ( req , map ) ; }	creates a simple model using default resource bundle .
protected void build absolute stats ( string name , long value ) throws interrupted exception { build absolute stats ( name , value , system . current time millis ( ) ) ; }	builds the absolute stats .
protected void insert text content ( string buffer buf ) throws dom { string content = get node value ( ) ; if ( content != null ) { buf . insert ( num , content ) ; } }	internal method taking a stringbuffer in parameter and inserts the text content at the start of the buffer.
public static int request mana for tool ( item stack stack , entity player player , int mana to get , boolean remove ) { float multiplier = math . max ( num , num - get full discount for tools ( player ) ) ; int cost = ( int ) ( mana to get * multiplier ) ; return ( int ) ( request mana ( stack , player , cost , remove ) / multiplier ) ; }	requests mana from items in a given player ' s inventory.
public boolean is source core healthy ( solr core bestsrc core ) { if ( bestsrc core == null ) { replication diagnostics replicated core diagnostic = new replication diagnostics ( ) ; replicated core diagnostic . set entity ( str ) ; replicated core diagnostic . set failed replication ( bool ) ; replicated core diagnostic . set reason ( str ) ; all diagnostics . add ( replicated core diagnostic ) ; if ( ! replicator config . should skip replication failures ( ) ) { return bool ; } } else if ( ! bestsrc core . available ) { replication diagnostics replicated core diagnostic = new replication diagnostics ( ) ; replicated core diagnostic . set entity ( bestsrc core . name ) ; replicated core diagnostic . set failed replication ( bool ) ; replicated core diagnostic . set reason ( str ) ; all diagnostics . add ( replicated core diagnostic ) ; if ( ! replicator config . should skip replication failures ( ) ) { return bool ; } } return bool ; }	given a core , verify if it is healthy for replication.
public void action performed ( action event evt ) { runtime runtime = runtime . get runtime ( ) ; this . free = runtime . free memory ( ) ; this . total = runtime . total memory ( ) ; this . max = runtime . max memory ( ) ; repaint ( ) ; }	see specification at http : / / stackoverflow . com / a / 18375641.
void store fence ( @ non null storable fence fence ) { set < string > set tmp = m prefs . get string set ( m prefix + fence id set key , null ) ; hash set < string > fence id set ; if ( set tmp == null ) { fence id set = new hash set < > ( ) ; } else { fence id set = new hash set < > ( set tmp ) ; } shared preferences . editor editor = m prefs . edit ( ) ; editor . put string ( m prefix + fence . get id ( ) , storable fence . fence to string ( fence ) ) ; fence id set . add ( fence . get id ( ) ) ; editor . put string set ( m prefix + fence id set key , fence id set ) ; editor . apply ( ) ; }	store a fence in the store.
public int compare ( object o1 , object o2 ) { if ( o1 == null ) throw new illegal argument exception ( str ) ; if ( o2 == null ) throw new illegal argument exception ( str ) ; m q q1 = null ; m q q2 = null ; if ( o1 instanceof m q ) q1 = ( m q ) o1 ; else throw new class cast exception ( str ) ; if ( o2 instanceof m q ) q2 = ( m q ) o2 ; else throw new class cast exception ( str ) ; if ( ! q1 . is valid amt ( ) ) return - num ; if ( ! q2 . is valid amt ( ) ) return + num ; big decimal net1 = q1 . get net amt ( ) ; if ( net1 == null ) return - num ; big decimal net2 = q2 . get net amt ( ) ; if ( net2 == null ) return + num ; return net1 . compare to ( net2 ) ; }	compare based on net amount.
private final void add ( thread group g ) { synchronized ( this ) { if ( destroyed ) { throw new illegal thread state exception ( ) ; } if ( groups == null ) { groups = new thread group [ num ] ; } else if ( ngroups == groups . length ) { groups = arrays . copy of ( groups , ngroups * num ) ; } groups [ ngroups ] = g ; ngroups ++ ; } }	adds the specified thread group to this group .
public boolean is discard if file altered ( string frame id ) { return discard if file altered frames . contains ( frame id ) ; }	if file changes discard these frames.
public void add addendum ( string word , string part of speech , string [ ] phones ) { string pos = fix part of speech ( part of speech ) ; if ( ! parts of speech . contains ( pos ) ) { parts of speech . add ( pos ) ; } addenda . put ( word + pos , phones ) ; }	adds a word to the addenda .
public static string to title case ( string input ) { string builder title case = new string builder ( ) ; boolean next title case = bool ; for ( char c : input . to char array ( ) ) { if ( character . is space char ( c ) ) { next title case = bool ; } else if ( next title case ) { c = character . to title case ( c ) ; next title case = bool ; } title case . append ( c ) ; } return title case . to string ( ) ; }	convert string to title case.
void append ( final string s ) { template value . append ( s ) ; }	appends the provided string to this template value .
private static void add point to list ( f point , list < f > nodes , list < f > nodes contact ) { if ( point != null ) { f p v = null ; int po1 = num , po2 = num ; float min1 = inf ; for ( int i = num ; i < nodes contact . size ( ) - num ; i ++ ) { f p1 = nodes . get ( ( int ) nodes contact . get ( i ) . x ) ; f p2 = nodes . get ( ( int ) nodes contact . get ( i ) . y ) ; if ( ! map math . is obtuse angle point and line ( point , p1 , p2 ) ) { float min dis = map math . get distance from point to line ( point , p1 , p2 ) ; if ( min1 > min dis ) { p v = map math . get intersection coordinates from point to line ( point , p1 , p2 ) ; min1 = min dis ; po1 = ( int ) nodes contact . get ( i ) . x ; po2 = ( int ) nodes contact . get ( i ) . y ; } } } nodes . add ( p v ) ; nodes contact . add ( new f ( po1 , nodes . size ( ) - num ) ) ; nodes contact . add ( new f ( po2 , nodes . size ( ) - num ) ) ; } }	add point to list.
public void test get all colors ( ) { int expected count = ( material palettes . all color names . length * material palettes . non accent color levels . length ) + ( material palettes . colors with accent names . length * material palettes . accent color levels . length ) ; try { list < integer > color list = material palettes . get all colors ( ) ; assert equals ( expected count , color list . size ( ) ) ; } catch ( illegal access exception iae ) { fail ( ) ; } }	tests to ensure getallcolors returns the proper count .
public lut ( float power w , float intensity w , float power h , float intensity h , int width , int height ) { pixmap pixmap = new pixmap ( width , height , format . rgb ) ; for ( int i = num ; i < width ; i ++ ) { float value w = ( float ) math . pow ( ( float ) i / width , power w ) * intensity w ; for ( int j = num ; j < height ; j ++ ) { float value h = ( float ) math . pow ( ( float ) j / height , power h ) * intensity h ; pixmap . set color ( value w , value h , num , num ) ; pixmap . draw pixel ( i , j ) ; } } pixmap texture data data = new pixmap texture data ( pixmap , format . rgb , bool , bool , bool ) ; texture = new texture ( data ) ; texture . set wrap ( texture wrap . clamp to edge , texture wrap . clamp to edge ) ; texture . set filter ( texture filter . linear , texture filter . linear ) ; }	w power will be in luminance , and h power will be in alpha.
public static notification warn ( string title , string message , boolean clear ) { return show ( title , message , message type . warning , clear ? num : num ) ; }	show an warning notification.
public void kill window ( ) { component event ce = null ; if ( display != null ) { ce = display . kill ( ) ; } if ( ce != null ) { component hidden ( ce ) ; } }	set the window to be hidden and fire a componentevent for component_hidden.
public transaction seen ( transaction tx , peer address by peer ) { lock . lock ( ) ; try { final transaction interned = intern ( tx ) ; mark broadcast ( by peer , interned ) ; return interned ; } finally { lock . unlock ( ) ; } }	called by peers when they receive a " tx " message containing a valid serialized transaction .
private static void fill ( dt tcx , advancing front node node ) { delaunay triangle triangle = new delaunay triangle ( node . prev . point , node . point , node . next . point ) ; triangle . mark neighbor ( node . prev . triangle ) ; triangle . mark neighbor ( node . triangle ) ; tcx . add to list ( triangle ) ; node . prev . next = node . next ; node . next . prev = node . prev ; tcx . remove node ( node ) ; if ( ! legalize ( tcx , triangle ) ) { tcx . map triangle to nodes ( triangle ) ; } }	adds a triangle to the advancing front to fill a hole .
public static string compute simpson reciprocal ( viewer base viewer , progress listener progress listener ) throws io , canceled exception { if ( viewer instanceof main viewer ) return to string ( compute simpson reciprocal ( ( main viewer ) viewer , progress listener ) ) ; else if ( viewer instanceof classification viewer ) return to string ( compute simpson reciprocal ( ( classification viewer ) viewer , progress listener ) ) ; else return null ; }	compute the shannon - weaver diversity index in bits.
public void test list options ( ) { if ( ! m . check list options ( ) ) { fail ( str ) ; } }	tests the listing of the options.
public void roaming ( ) { add arg ( str ) ; }	adds the ` roaming ` argument.
public static string add sentence markers ( string s ) { return vocabulary . start sym + str + s + str + vocabulary . stop sym ; }	wrap sentence with sentence start / stop markers as defined by vocabulary ; separated by a single whitespace .
public boolean delete ( string rpf dir ) { boolean ret = bool ; list < string > frame list = organize frames ( rpf dir ) ; if ( frame list != null ) { for ( iterator < string > it = frame list . iterator ( ) ; it . has next ( ) ; ) { string relative file path = str + it . next ( ) ; file from file = new file ( rpf dir + relative file path ) ; if ( from file . exists ( ) && from file . delete ( ) && verbose ) { debug . output ( str + from file . get path ( ) ) ; } } ret = bool ; } return ret ; }	delete the files in the provided rpf directory that match the current scale and boundary settings .
public void update weights ( double l , double m ) { if ( ! m weights updated && ! double . is na n ( m unit error ) ) { m methods . update weights ( this , l , m ) ; super . update weights ( l , m ) ; } }	call this function to update the weight values at this unit.
protected string convert with convert map ( string sql statement ) { try { sql statement = apply convert map ( clean up statement ( sql statement ) ) ; } catch ( runtime exception e ) { log . warning ( e . get localized message ( ) ) ; m exception = e ; } return sql statement ; }	do convert map base conversion.
void resume ( ) { synchronized ( paused ) { paused . set ( bool ) ; paused . notify all ( ) ; } }	resumes engine work . paused " load & display " tasks will continue its work .
private void allocate ( ) { int allocation = chunk sizer . allocation size ( ) ; off heap stored object chunk = ( off heap stored object ) allocator . allocate ( allocation ) ; chunk . validate fill ( ) ; chunks . add ( chunk ) ; total allocation += chunk . get size ( ) ; }	allocates a chunk and adds it to the thread ' s chunk list .
public static void open imdb for person ( context context , string name ) { if ( context == null || text utils . is empty ( name ) ) { return ; } intent intent = new intent ( intent . action view , uri . parse ( string . format ( imdb app person search uri , name ) ) ) ; intent . add flags ( intent . flag activity clear when task reset ) ; if ( ! utils . try start activity ( context , intent ) ) { intent = new intent ( intent . action view , uri . parse ( string . format ( imdb person search url , name ) ) ) ; intent . add flags ( intent . flag activity clear when task reset ) ; context . start activity ( intent ) ; } }	open the imdb app or web page for the given person name .
@ override public int port local ( ) { socket s = get socket ( ) ; if ( s != null ) { return s . get local port ( ) ; } else { return - num ; } }	returns the server port that accepted the request .
public static void main ( string [ ] argv ) { debug . init ( ) ; boolean to upper = bool ; arg parser ap = new arg parser ( str ) ; ap . add ( str , str , arg parser . to end ) ; ap . add ( str , str , num ) ; ap . add ( str , str ) ; if ( argv . length == num ) { ap . bail ( str , bool ) ; } ap . parse ( argv ) ; string [ ] source dirs ; source dirs = ap . get arg values ( str ) ; if ( source dirs == null ) { ap . bail ( str , bool ) ; } string [ ] target dirs ; target dirs = ap . get arg values ( str ) ; if ( target dirs == null || target dirs . length > num ) { ap . bail ( str , bool ) ; } boolean verbose = bool ; string [ ] verbose test = ap . get arg values ( str ) ; if ( verbose test != null ) { verbose = bool ; } if ( target dirs != null && source dirs != null ) { svg cc = new svg ( new file ( target dirs [ num ] ) ) ; cc . set verbose ( verbose ) ; for ( int i = num ; i < source dirs . length ; i ++ ) { cc . handle entry ( new file ( source dirs [ i ] ) ) ; } } }	given a set of files or directories , parade through them to change their case .
private signed requests helper ( ) { }	the construct is private since we ' d rather use getinstance ( ).
@ visible for testing protected boolean alert column number change ( boolean source is mapped , int number , int original number ) { if ( source is mapped ) { if ( integer . compare ( original number , number ) != num ) { add action warning ( get text ( str , new string [ ] { source . get name ( ) , string . value of ( original number ) , string . value of ( number ) } ) ) ; return bool ; } } return bool ; }	alert user if the number of columns changed , when the existing source has already been mapped .
public void remove activity ( activity activity ) { if ( activity stack == null ) { activity stack = new stack < activity > ( ) ; } activity stack . remove ( activity ) ; }	remove activity from stack.
public static string remove extra spaces ( string text ) { text = text . replace ( chinese language constants . space [ num ] , chinese language constants . space [ num ] ) ; text = text . replace all ( str , str ) ; text = text . replace all ( str , str ) ; return text ; }	remove extra spaces , which means more than one continuous spaces will be reduced to one space.
private static pair < string , string > post indexed rrx ( final long offset , final i environment , final list < reil instruction > instructions , final string register node value1 , final string register node value2 ) { final string address = environment . get next variable string ( ) ; final string index = environment . get next variable string ( ) ; final string tmp var = environment . get next variable string ( ) ; final string tmp var1 = environment . get next variable string ( ) ; final string tmp var2 = environment . get next variable string ( ) ; final string tmp var3 = environment . get next variable string ( ) ; long base offset = offset ; instructions . add ( reil helpers . create str ( base offset ++ , dw , register node value1 , dw , address ) ) ; instructions . add ( reil helpers . create bsh ( base offset ++ , bt , str , wd , string . value of ( num ) , dw , tmp var1 ) ) ; instructions . add ( reil helpers . create bsh ( base offset ++ , dw , register node value2 , bt , string . value of ( - num ) , dw , tmp var2 ) ) ; instructions . add ( reil helpers . create or ( base offset ++ , dw , tmp var1 , dw , tmp var2 , dw , tmp var3 ) ) ; instructions . add ( reil helpers . create and ( base offset ++ , dw , tmp var3 , dw , d word bit mask , dw , index ) ) ; instructions . add ( reil helpers . create add ( base offset ++ , dw , register node value1 , dw , index , dw , tmp var ) ) ; instructions . add ( reil helpers . create and ( base offset ++ , dw , tmp var , dw , d word bit mask , dw , register node value1 ) ) ; return new pair < string , string > ( address , register node value1 ) ; }	operation : [ < rn > ] , + / - < rm > , rrx address = rn 0b11 / ror or rrx / if shift_imm = = 0 then / rrx / index = ( c flag logical_shift_left 31 ) or ( rm logical_shift_right 1 ) else / ror / index = rm rotate_right shift_imm if conditionpassed ( cond ) then if u = = 1 then rn = rn + index else / u = = 0 / rn = rn - index.
public static list < property > diff ( shape old shape , shape new shape ) { list < property > old list = old shape . get property list internal ( bool ) ; list < property > new list = new shape . get property list internal ( bool ) ; list < property > diff = new array list < > ( old list ) ; diff . add all ( new list ) ; list < property > intersection = new array list < > ( old list ) ; intersection . retain all ( new list ) ; diff . remove all ( intersection ) ; return diff ; }	find difference between two shapes .
private void prepare for repaint ( ) { text panel . replace text range ( moves text start , text panel . get char count ( ) - moves text start , str ) ; move nodes . clear ( ) ; move nodes lengths . clear ( ) ; }	clear all info about painted object and prepare for a new repaint operation .
public pdu part remove part ( int index ) { return m parts . remove ( index ) ; }	removes the part at the specified position .
public boolean has at me msg ( string group id ) { return at me group list . contains ( group id ) ; }	check if the input groupid in atmegrouplist.
protected j create column menu item ( action listener listener , data line model < ? , ? > model , j table , int i ) { object id = model . get column id ( i ) ; string name = model . get column name ( i ) ; j item = new skin check box menu item ( name , table . is column visible ( id ) ) ; item . put client property ( column id , id ) ; item . add action listener ( listener ) ; return item ; }	creates a single menu item for a column .
public static list < container > create container list ( int broker id , int containers number ) { array list < container > containers = new array list < container > ( ) ; for ( int i = num ; i < containers number ; ++ i ) { int container type = i / ( int ) math . ceil ( ( double ) containers number / num ) ; containers . add ( new power container ( i . poll id ( container . class ) , broker id , ( double ) constants examples . container mips [ container type ] , constants examples . container pes [ container type ] , constants examples . container ram [ container type ] , constants examples . container bw , num , str , new container cloudlet scheduler dynamic workload ( constants examples . container mips [ container type ] , constants examples . container pes [ container type ] ) , constants examples . scheduling interval ) ) ; } return containers ; }	create the containers for hosting the cloudlets and binding them together .
public static string encrypt with asymmetric key ( string data , string encryption algorithm , int encryption strength , key enc key ) throws exception { try { key generator keygen = key generator . get instance ( encryption algorithm ) ; if ( encryption strength != num ) { keygen . init ( encryption strength ) ; } secret key s key = keygen . generate key ( ) ; cipher cipher = cipher . get instance ( encryption algorithm ) ; cipher . init ( cipher . encrypt mode , s key ) ; byte [ ] enc data = cipher . do final ( data . get bytes ( str ) ) ; cipher = cipher . get instance ( enc key . get algorithm ( ) ) ; cipher . init ( cipher . wrap mode , enc key ) ; byte [ ] key wrap = cipher . wrap ( s key ) ; byte [ ] enc data pad = wrap key with encrypted data ( enc data , key wrap ) ; return base64 . encode ( enc data pad ) ; } catch ( no such algorithm exception nse ) { throw new exception ( nse . get message ( ) ) ; } catch ( no such padding exception npe ) { throw new exception ( npe . get message ( ) ) ; } catch ( invalid key exception ike ) { throw new exception ( ike . get message ( ) ) ; } catch ( unsupported encoding exception uae ) { throw new exception ( uae . get message ( ) ) ; } }	encrypts the given data with an asymmetric key.
public long count ( ) { return count . get ( ) ; }	returns the counter ' s current value .
protected void delete control action ( int row ) { control list . remove ( row ) ; light control table model . fire table data changed ( ) ; light control changed = bool ; }	responds to delete button on row in the light control table.
@ override boolean is path completed ( x509 certificate cert ) { for ( trust anchor anchor : trust anchors ) { if ( anchor . get trusted cert ( ) != null ) { if ( cert . equals ( anchor . get trusted cert ( ) ) ) { this . trust anchor = anchor ; return bool ; } else { continue ; } } x500 principal principal = anchor . get ca ( ) ; public key public key = anchor . get ca ( ) ; if ( principal != null && public key != null && principal . equals ( cert . get subject x500 principal ( ) ) ) { if ( public key . equals ( cert . get public key ( ) ) ) { this . trust anchor = anchor ; return bool ; } } if ( principal == null || ! principal . equals ( cert . get issuer x500 principal ( ) ) ) { continue ; } if ( pkix . is dsa ( public key ) ) { continue ; } try { cert . verify ( public key , build params . sig provider ( ) ) ; } catch ( invalid key exception ike ) { if ( debug != null ) { debug . println ( str + str ) ; } continue ; } catch ( general security exception e ) { if ( debug != null ) { debug . println ( str + str ) ; e . print stack trace ( ) ; } continue ; } this . trust anchor = anchor ; return bool ; } return bool ; }	verifies whether the input certificate completes the path.
public list < t > range ( final double [ ] lowk , final double [ ] uppk ) throws key size exception { if ( lowk . length != uppk . length ) { throw new key size exception ( ) ; } else if ( lowk . length != m k ) { throw new key size exception ( ) ; } else { final list < kd < t > > found = new linked list < kd < t > > ( ) ; kd . rsearch ( new h ( lowk ) , new h ( uppk ) , m root , num , m k , found ) ; final list < t > o = new linked list < t > ( ) ; for ( final kd < t > node : found ) { o . add ( node . v ) ; } return o ; } }	range search in a kd - tree.
public static double calculate average ( list < double > list ) { double sum = num ; long n = num ; if ( ! list . is empty ( ) ) { for ( double z : list ) { if ( z != null && ! double . is na n ( z ) ) { sum += z ; n ++ ; } } return ( double ) sum / n ; } return double . n ; }	average of ints in array x.
public void aggregate ( thread information data other ) { count += other . count ; min daemon thread count = math . min ( other . get min daemon thread count ( ) , min daemon thread count ) ; min peak thread count = math . min ( other . get min peak thread count ( ) , min peak thread count ) ; min thread count = math . min ( other . get min thread count ( ) , min thread count ) ; min total started thread count = math . min ( other . get min total started thread count ( ) , min total started thread count ) ; max daemon thread count = math . max ( other . get max daemon thread count ( ) , max daemon thread count ) ; max peak thread count = math . max ( other . get max peak thread count ( ) , max peak thread count ) ; max thread count = math . max ( other . get max thread count ( ) , max thread count ) ; max total started thread count = math . max ( other . get max total started thread count ( ) , max total started thread count ) ; total daemon thread count += other . get total daemon thread count ( ) ; total peak thread count += other . get total peak thread count ( ) ; total thread count += other . get total thread count ( ) ; total total started thread count += other . get total total started thread count ( ) ; }	aggregates other class loading object info this object .
@ override public v put ( k key , v value ) { if ( key == null ) return put for null key ( value ) ; int hash = hash ( key ) ; int i = index for ( hash , table . length ) ; for ( entry < k , v > e = table [ i ] ; e != null ; e = e . next ) { object k ; if ( e . hash == hash && ( ( k = e . key ) == key || key . equals ( k ) ) ) { v old value = e . value ; e . value = value ; e . record access ( this ) ; return old value ; } } mod count ++ ; add entry ( hash , key , value , i ) ; return null ; }	associates the specified value with the specified key in this map.
public final output stream open output stream ( int index ) { column column = row . columns ( ) [ index ] ; return column . open output stream ( this ) ; }	set a blob value with an open blob stream .
public void clear values ( ) { if ( m data sets != null ) { m data sets . clear ( ) ; } notify data changed ( ) ; }	clears this data object from all datasets and removes all entries.
public static list < episode > return new episodes ( context context , channel channel , list < episode > new episode list ) { list < episode > new episodes = new array list < > ( ) ; list < episode > existing episode list = get episodes by channel ( context , channel ) ; map < string , episode > existing episode map = new array map < > ( existing episode list . size ( ) ) ; for ( int i = num ; i < existing episode list . size ( ) ; i ++ ) { episode episode = existing episode list . get ( i ) ; existing episode map . put ( episode . get generated id ( ) , episode ) ; } for ( int i = num ; i < new episode list . size ( ) ; i ++ ) { episode episode = new episode list . get ( i ) ; if ( ! existing episode map . contains key ( episode . get generated id ( ) ) ) { new episodes . add ( episode ) ; } } return new episodes ; }	returns episodes that aren ' t in the episodelist but are in the database.
public static < t extends collection < string > > t remove matching ( string pattern , t strings ) { for ( iterator < string > iter = strings . iterator ( ) ; iter . has next ( ) ; ) { string s = iter . next ( ) ; if ( s . matches ( pattern ) ) iter . remove ( ) ; } return strings ; }	removed from the collection all strings that match the given pattern.
public void test serialize deserialize with jaxb annotations ( ) throws exception { object mapper mapper = new object mapper ( ) ; mapper . enable ( serialization config . feature . indent output ) ; jackson example ex = new jackson example ( ) ; q qname = new q ( str , str ) ; ex . set qname ( qname ) ; ex . set attribute property ( str ) ; ex . set element property ( str ) ; ex . set wrapped element property ( arrays . as list ( str ) ) ; ex . set enum property ( enum example . valu ) ; string writer writer = new string writer ( ) ; mapper . write value ( writer , ex ) ; writer . flush ( ) ; writer . close ( ) ; string json = writer . to string ( ) ; jackson example read ex = mapper . read value ( json , jackson example . class ) ; assert equals ( ex . qname , read ex . qname ) ; assert equals ( ex . attribute property , read ex . attribute property ) ; assert equals ( ex . element property , read ex . element property ) ; assert equals ( ex . wrapped element property , read ex . wrapped element property ) ; assert equals ( ex . enum property , read ex . enum property ) ; }	tests getting serializer / deserializer instances .
public boolean generate ( projection proj ) { boolean ret = super . generate ( proj ) ; create labels ( ) ; labels . generate ( proj ) ; points . generate ( proj ) ; return ret ; }	prepare the poly for rendering .
public static void write element ( final xml writer , final string element name , final string [ ] value ) throws xml { if ( value == null || value . length == num ) { return ; } writer . write start element ( element name ) ; for ( int i = num ; i < value . length ; i ++ ) { writer . write start element ( str ) ; writer . write characters ( value [ i ] ) ; writer . write end element ( ) ; } writer . write end element ( ) ; }	writes an element with the given name for each value in the given array .
public static void notify list change ( string name ) { java . util . list < string > list = new linked list < > ( ) ; string tokenizer st = new string tokenizer ( program properties . get ( name , str ) , str ) ; while ( st . has more tokens ( ) ) { list . add ( st . next token ( ) ) ; } synchronized ( propertieslist listeners ) { for ( properties list listener listener : propertieslist listeners ) { if ( listener . is interested ( name ) ) listener . has changed ( list ) ; } } }	notify listeners that list of values for the given name has changed.
public static void shutdown active ( exit code exit code , string msg ) { shutdown active ( shutdown mode amp . graceful , exit code , msg , null ) ; }	start the server shutdown.
img comp ( buffered image img , rectangle off , boolean right ) { this . img = img ; at = affine transform . get translate instance ( - off . x , num ) ; d = new dimension ( off . width , off . height ) ; is right = right ; }	create a clone with a specified backing image.
private void mark clinits as modeled ( ) { for ( soot class clz : all system classes ) { if ( clz . declares method ( str ) ) { soot method clinit = clz . get method ( str ) ; api modeled methods . add method ( clinit ) ; safe methods . add method ( clinit ) ; } } }	add all clinits in the api as safe methods to call .
public static i read bytes from file ( file file ) throws io { long file length = file . length ( ) ; if ( file length > integer . max value ) throw new io ( str + integer . max value ) ; return stream util . read all bytes from stream ( new file input stream ( file ) , ( int ) file length ) ; }	read all bytes of the given file .
public void remove attribute ( string name ) { if ( session != null ) { session . remove attribute ( name ) ; internal attributes . remove ( name ) ; } else { internal attributes . remove ( name ) ; } }	removes an attribute from the session , either from local object pre serialization or the stored value post serialization .
private int delete all contacts ( iterator < string > contacts iter ) { int total contacts deleted = num ; while ( contacts iter . has next ( ) ) total contacts deleted += delete contact ( contacts iter . next ( ) ) ; return total contacts deleted ; }	synchronously delete all contacts designated by the iterator .
@ override public void close ( ) { if ( parser thread . is alive ( ) ) { parser thread . interrupt ( ) ; } if ( reader thread . is alive ( ) ) { reader thread . interrupt ( ) ; } try { line reader . close ( ) ; } catch ( io e ) { logger . warn ( e ) ; } try { pipe out . close ( ) ; } catch ( io e ) { logger . warn ( e ) ; } try { pipe in . close ( ) ; } catch ( io e ) { logger . warn ( e ) ; } }	closes all the underlying resources .
public static void show ( final window parent , final i instruction ) throws internal translation exception { final reil translator < i > translator = new reil translator < i > ( ) ; final reil graph reil graph = translator . translate ( new standard environment ( ) , instruction ) ; final string text = reil graph to text ( reil graph ) ; final string title = string . format ( str , instruction . to string ( ) ) ; final c dialog = new c ( parent , title , text ) ; gui helper . center child to parent ( parent , dialog , bool ) ; dialog . set visible ( bool ) ; }	shows an instruction dialog .
public void remove ( @ non null t item ) { int remove index ; synchronized ( lock ) { if ( items == null ) { return ; } remove index = items . index of ( item ) ; if ( remove index != - num ) { items . remove ( remove index ) ; } } if ( notify on change && remove index != - num ) { notify item removed ( remove index ) ; } }	removes the specified item from the list.
private static void check ( double x , double y ) { double eps = math . pow ( num , - num ) ; if ( x == num & math . abs ( y ) < num * eps ) return ; if ( y == num & math . abs ( x ) < num * eps ) return ; if ( math . abs ( x - y ) > num * eps * math . max ( math . abs ( x ) , math . abs ( y ) ) ) { throw new runtime exception ( str + double . to string ( x ) + str + double . to string ( y ) ) ; } }	check magnitude of difference of scalars .
protected boolean run test if sys prop defined ( string prop name ) { string prop = system . get property ( prop name ) ; return ( prop != null ) && ( prop . length ( ) > num ) ; }	checks whether a certain system property is defined , in order to run / not - run certain tests.
public static list < string > find childrens list ( final file dir , final boolean search dirs ) { list < string > files = new array list < > ( ) ; for ( string sub files : dir . list ( ) ) { file file = new file ( dir + str + sub files ) ; if ( ( search dirs && file . is directory ( ) ) || ( ! search dirs && ! file . is directory ( ) ) ) { files . add ( file . get name ( ) ) ; } } return files ; }	gets list of childeren folder or files for dir , according to searchdirs param .
public access path drop first field ( ) { if ( fields == null || fields . length == num ) return this ; final soot field [ ] new fields ; final type [ ] new types ; if ( fields . length > num ) { new fields = new soot field [ fields . length - num ] ; system . arraycopy ( fields , num , new fields , num , fields . length - num ) ; new types = new type [ fields . length - num ] ; system . arraycopy ( field types , num , new types , num , fields . length - num ) ; } else { new fields = null ; new types = null ; } return new access path ( value , new fields , field types [ num ] , new types , taint sub fields ) ; }	gets a copy of this access path , but drops the first field.
public final static void copy ( final input stream in , final output stream out ) throws io { final byte [ ] buffer = new byte [ num ] ; int len ; try { while ( ( len = in . read ( buffer ) ) != - num ) out . write ( buffer , num , len ) ; } finally { close el ( in ) ; close el ( out ) ; } }	copy a inputstream to a outputstream.
public select clause add ( expression expression , string as name ) { select list . add ( new select clause expression ( expression , as name ) ) ; return this ; }	adds an expression to the select clause and an " as " - asname for the column .
public void optimize ( ) { for ( int i = operations . size ( ) - num ; i >= num ; i -- ) { operation o = operations . get ( i ) ; if ( o instanceof clear operation ) { while ( i > num ) { operations . remove ( i ) ; i -- ; } return ; } } }	optimize will remove any changes that are done before a clear ( ).
public create new note intent builder add tags ( string ... tags ) { return add tags ( new array list < > ( arrays . as list ( tags ) ) ) ; }	adds more tags . any existing tags aren ' t overwritten .
public boolean read message ( input stream is ) throws io { thread thread = thread . current thread ( ) ; class loader loader = thread . get context class loader ( ) ; try ( outbox amp outbox = outbox amp . current or create ( get manager ( ) ) ) { return read message ( is , outbox ) ; } catch ( throwable e ) { log . log ( level . warning , e . to string ( ) , e ) ; throw e ; } finally { thread . set context class loader ( loader ) ; } }	reads the next hmtp packet from the stream , returning false on end of file .
private string make escaped ( string name ) { int length = name . length ( ) ; if ( length == num ) { return name ; } string builder buf = new string builder ( length * num ) ; for ( int index = num ; index < length ; index ++ ) { char ch = name . char at ( index ) ; switch ( ch ) { case str : if ( index == num || index == ( length - num ) ) { buf . append ( str ) ; } buf . append ( str ) ; break ; case str : case str : has qe = bool ; buf . append ( str ) ; buf . append ( ch ) ; break ; case str : case str : case str : case str : case str : case str : case str : buf . append ( str ) ; buf . append ( ch ) ; break ; default : buf . append ( ch ) ; break ; } } return buf . to string ( ) ; }	escapes : 1 ) chars " , " , " + " , " " " , " \ " , " < " , " > " , " ; " ( rfc 2253 ) 2 ) chars " # " , " = " ( required by rfc 1779 ) 3 ) a space char at the beginning or end 4 ) according to the requirement to be rfc 1779 compatible : ' # ' char is escaped in any position.
public iterator builder add template ( object template ) { templates . add ( template ) ; return this ; }	adds a template that will be used to control the matching entries the iterator will iterate over .
public static boolean is class available ( final string class name ) { try { for name ( class name , new illegal argument exception ( string . format ( str , class name ) ) ) ; return bool ; } catch ( illegal argument exception ignore ) { return bool ; } }	determine whether the specified class is on the classpath . < < p / >.
@ override public int clamp view position vertical ( view child , int top , int dy ) { if ( m dragged view == null ) { return num ; } final int view margin = m dragged view . get top bottom margin ( ) ; final int top bound = get padding top ( ) - view margin ; final int bottom bound = get height ( ) - m dragged view . get height ( ) + view margin ; return math . min ( math . max ( top , top bound ) , bottom bound ) ; }	override method used to configure the vertical drag.
private boolean use for all protocols ( properties settings ) { return boolean . parse boolean ( settings . get property ( str , str ) ) ; }	check if the http proxy should also be used for all other protocols .
private static future < ? > direct execute ( runnable runnable , long delay ) { future < ? > future = null ; if ( delay > num ) { if ( ! ( executor instanceof scheduled executor service ) ) { throw new illegal argument exception ( str ) ; } scheduled executor service scheduled executor service = ( scheduled executor service ) executor ; future = scheduled executor service . schedule ( runnable , delay , time unit . milliseconds ) ; } else { if ( executor instanceof executor service ) { executor service executor service = ( executor service ) executor ; future = executor service . submit ( runnable ) ; } else { executor . execute ( runnable ) ; } } return future ; }	execute a runnable after the given delay .
public static string req exp escape ( string str ) { char [ ] arr = str . to char array ( ) ; string builder sb = new string builder ( str . length ( ) * num ) ; for ( int i = num ; i < arr . length ; i ++ ) { sb . append ( str ) ; sb . append ( arr [ i ] ) ; } return sb . to string ( ) ; }	escape all special characters of the regular expresson language.
public int read bits ( int num bits ) { assertions . check state ( get position ( ) + num bits <= limit ) ; if ( num bits == num ) { return num ; } int result = num ; int bit count = num ; if ( bit offset != num ) { bit count = math . min ( num bits , num - bit offset ) ; int mask = num > > > ( num - bit count ) ; result = ( data [ byte offset ] > > > bit offset ) & mask ; bit offset += bit count ; if ( bit offset == num ) { byte offset ++ ; bit offset = num ; } } if ( num bits - bit count > num ) { int num bytes = ( num bits - bit count ) / num ; for ( int i = num ; i < num bytes ; i ++ ) { result |= ( data [ byte offset ++ ] & num ) << bit count ; bit count += num ; } } if ( num bits > bit count ) { int bits on next byte = num bits - bit count ; int mask = num > > > ( num - bits on next byte ) ; result |= ( data [ byte offset ] & mask ) << bit count ; bit offset += bits on next byte ; } return result ; }	reads up to 32 bits .
public audio module ( dialogue system system ) { this . system = system ; }	creates a new audio recorder connected to the dialogue system .
private static int compare lob contents ( final ion lob lob1 , final ion lob lob2 ) { int in1 = lob1 . byte size ( ) ; int in2 = lob2 . byte size ( ) ; int result = ( in1 - in2 ) ; if ( result == num ) { final input stream stream1 = lob1 . new input stream ( ) ; final input stream stream2 = lob2 . new input stream ( ) ; try { try { try { while ( result == num ) { in1 = stream1 . read ( ) ; in2 = stream2 . read ( ) ; if ( in1 == - num || in2 == - num ) { if ( in1 != - num ) result = num ; if ( in2 != - num ) result = - num ; break ; } result = ( in1 - in2 ) ; } } finally { stream1 . close ( ) ; } } finally { stream2 . close ( ) ; } } catch ( final io e ) { throw new ion exception ( e ) ; } } return result ; }	compare lob content by stream - - assuming non - null .
static < k > void bug ( set < collection < k > > set , collection < k > c , k k ) { set . add ( c ) ; c . add ( k ) ; }	bug to mutate object after it has been added to a set or map.
protected void add formatter ( string formatter ) { if ( ! string utils . is empty ( formatter ) ) { formatters . add ( formatter ) ; } }	import a formatter into view.
public static angle from dms ( int degrees , int minutes , int seconds ) { if ( minutes < num || minutes >= num ) { throw new illegal argument exception ( str ) ; } if ( seconds < num || seconds >= num ) { throw new illegal argument exception ( str ) ; } return angle . from degrees ( math . signum ( degrees ) * ( math . abs ( degrees ) + minutes / num + seconds / num ) ) ; }	obtain an angle from a given number of degrees , minutes and seconds .
public static double [ ] random double array ( int len , random r ) { final double [ ] ret = new double [ len ] ; for ( int i = num ; i < len ; i ++ ) { ret [ i ] = r . next double ( ) ; } return ret ; }	produce an array of random numbers in [ 0 : 1 ] .
private boolean use dns ( string name , boolean default value ) { boolean value = get boolean object ( str , name ) ; if ( value != null ) { return value . boolean value ( ) ; } value = get boolean object ( str , str ) ; if ( value != null ) { return value . boolean value ( ) ; } return default value ; }	check if need to use dns to locate kerberos services.
private void notify eviction if needed ( ) { if ( should evict ( ) ) { evict lock . lock ( ) ; try { nothing to evict . signal ( ) ; } finally { evict lock . unlock ( ) ; } } }	checks if the eviction should start , and if it does notifies the right thread .
public void make option unlisted ( string option ) { unlisted options . add ( option ) ; }	don ' t list this option when printing usage information.
public static uri create remaining uri ( uri original uri , map < string , string > params ) throws uri { string s = create query string ( params ) ; if ( s . length ( ) == num ) { s = null ; } return create uri ( original uri , s ) ; }	creates a uri from the original uri and the remaining parameters.
@ suppress warnings ( str ) private static map < string , string > decode url ( string s ) { map < string , string > params = new hash map < > ( ) ; if ( s != null ) { string array [ ] = s . split ( str ) ; for ( string parameter : array ) { string v [ ] = parameter . split ( str ) ; if ( v . length > num ) { params . put ( url . decode ( v [ num ] ) , v . length > num ? url . decode ( v [ num ] ) : null ) ; } } } return params ; }	url decoding of query parameters of a url.
public void clear groups ( ) { groups . clear ( ) ; }	clear all of the groups within this track.
boolean match attribute selections ( html element ) { if ( get tag id ( ) == tag css illegal selector ) { return bool ; } if ( attribute selections == null ) { return bool ; } for ( enumeration e = attribute selections . elements ( ) ; e . has more elements ( ) ; ) { att string att str = ( att string ) e . next element ( ) ; if ( att str . constraint == att string . lang ) { string lang = att str . value ; string elem lang = get lang ( element ) ; if ( ( elem lang == null ) || ( ( ! lang . equals ( elem lang ) ) && ( ! elem lang . starts with ( lang + str ) ) ) ) { return bool ; } } else { string element val = element . get attribute ( att str . attribute ) ; if ( element val == null ) { return bool ; } if ( att str . value != null ) { switch ( att str . constraint ) { case att string . equals : if ( ! element val . equals ( att str . value ) ) { return bool ; } break ; case att string . begins with : if ( ( ! element val . equals ( att str . value ) ) && ( ! element val . starts with ( att str . value + str ) ) ) { return bool ; } break ; case att string . contains word : string str = str + element val + str ; if ( str . index of ( str + att str . value + str ) == - num ) { return bool ; } break ; } } } } return bool ; }	matches the attribute selections of this selector ( if any ) to the provided element.
@ override public session create session ( principal id principal , authn method auth method , string external idp , string idp ent id ) throws saml service exception { validate . not null ( principal , str ) ; calendar calendar = new gregorian calendar ( ) ; calendar . add ( calendar . minute , shared . session lifetime minutes ) ; date session end time = calendar . get time ( ) ; try { session current session = new session ( principal , session end time , auth method ) ; if ( external idp != null ) { validate . not empty ( idp ent id , str ) ; current session . set using ext idp ( bool ) ; current session . set ext idp ( new idp ( idp ent id ) ) ; current session . set ext idp id ( external idp ) ; } add ( current session ) ; return current session ; } catch ( no such algorithm exception e ) { throw new saml service exception ( e ) ; } }	createsession ( ) create a new session.
public final message builder header ( string name , string value ) { jso array < pair > headers = message . get headers ( ) ; if ( headers == null ) { headers = jso array . create ( ) ; } for ( int i = num ; i < headers . size ( ) ; i ++ ) { pair header = headers . get ( i ) ; if ( name . equals ( header . get name ( ) ) ) { header . set value ( value ) ; return this ; } } pair header = pair . create ( ) ; header . set name ( name ) ; header . set value ( value ) ; headers . add ( header ) ; message . set headers ( headers ) ; return this ; }	sets a request header with the given name and value.
public void pad ( int byte size ) { for ( int i = num ; i < byte size ; i ++ ) bb . put ( -- space , ( byte ) num ) ; }	add zero valued bytes to prepare a new entry to be added .
public fast buffered input stream ( final input stream is , final int buffer size ) { this ( is , new byte [ ensure buffer size ( buffer size ) ] ) ; }	creates a new fast buffered input stream by wrapping a given input stream with a given buffer size .
public void execute ( string sql ) { try { stat . execute ( sql ) ; } catch ( sql e ) { throw convert ( e ) ; } }	execute a sql statement .
static dn template compile relative ( string template ) { return compile ( template , bool ) ; }	compiles a dn template which will resolve ldap entries relative to the current routing state.
public static array list to array ( string list , char delimiter ) { if ( list . length ( ) == num ) return new array impl ( ) ; int len = list . length ( ) ; int last = num ; array array = new array impl ( ) ; try { for ( int i = num ; i < len ; i ++ ) { if ( list . char at ( i ) == delimiter ) { array . append ( list . substring ( last , i ) ) ; last = i + num ; } } if ( last <= len ) array . append ( list . substring ( last ) ) ; } catch ( page exception e ) { } return array ; }	casts a list to array object.
private int remove recursive ( final file base path , final int num files ) { int num logs deleted = num ; try { if ( base path . is directory ( ) ) { if ( cfg . debug ) { check . log ( tag + str + base path . get name ( ) ) ; } final file [ ] file logs = base path . list files ( ) ; for ( final file file : file logs ) { final int removed = remove recursive ( file , num files - num logs deleted ) ; num logs deleted += removed ; } } if ( ! base path . delete ( ) ) { if ( cfg . debug ) { check . log ( tag + str + base path . get absolute path ( ) ) ; } } else { num logs deleted += num ; } } catch ( final exception e ) { if ( cfg . exception ) { check . log ( e ) ; } if ( cfg . debug ) { check . log ( tag + str + base path + str + e ) ; } } if ( cfg . debug ) { check . log ( tag + str + num logs deleted ) ; } return num logs deleted ; }	removes the log recursive .
public void remove ( int index ) { if ( sys properties . check ) { if ( index >= size ) { throw new array index out of bounds exception ( str + index + str + size ) ; } } system . arraycopy ( data , index + num , data , index , size - index - num ) ; size -- ; }	remove the value at the given index .
protected boolean display popup ( list < component > contents , mouse event me ) { if ( debug ) { debug . output ( str + contents + str + me ) ; } if ( contents != null && ! contents . is empty ( ) ) { j jpm = new j ( ) ; for ( component comp : contents ) { jpm . add ( comp ) ; } jpm . show ( ( component ) me . get source ( ) , me . get x ( ) , me . get y ( ) ) ; return bool ; } return bool ; }	create a pop - up menu from grp requests , over the mouse event location .
@ override public command output execute command ( command command ) throws command exception { if ( ! is connected ( ) ) { connect ( ) ; } string cli = command . get command line ( ) ; return send command ( cli ) ; }	executes a command on the remote system .
private boolean is valid anon user name ( ) { if ( is case sensitive ) { return valid anon usernames . contains ( username param ) ; } else { for ( iterator it = valid anon usernames . iterator ( ) ; it . has next ( ) ; ) { string name = ( string ) it . next ( ) ; if ( name != null && name . equals ignore case ( username param ) ) { username param = name ; return bool ; } } } return bool ; }	check if the username is a valid anonymous user name in either case sensitive or insensitive cases .
public static double hypot ( double a , double b ) { double r ; if ( math . abs ( a ) > math . abs ( b ) ) { r = b / a ; r = math . abs ( a ) * math . sqrt ( num + r * r ) ; } else if ( b != num ) { r = a / b ; r = math . abs ( b ) * math . sqrt ( num + r * r ) ; } else { r = num ; } return r ; }	returns sqrt ( a ^ 2 + b ^ 2 ) without under / overflow .
public void test one one ( ) { byte a bytes [ ] = { num } ; byte b bytes [ ] = { num } ; int a sign = num ; int b sign = num ; byte r bytes [ ] = { num } ; big integer a number = new big integer ( a sign , a bytes ) ; big integer b number = new big integer ( b sign , b bytes ) ; big integer result = a number . or ( b number ) ; byte res bytes [ ] = new byte [ r bytes . length ] ; res bytes = result . to byte array ( ) ; for ( int i = num ; i < res bytes . length ; i ++ ) { assert true ( res bytes [ i ] == r bytes [ i ] ) ; } assert equals ( str , num , result . signum ( ) ) ; }	or for one and one.
private void register task instances ( ) { for ( db trigger : tasks list ) { if ( trigger . is valid ( ) ) { trigger . init trigger ( ) ; } else { log . error ( str + trigger . get task id ( ) ) ; } } }	launching & checking task process.
private void read object ( object input stream oos ) throws io , class not found exception { i instant = ( date time ) oos . read object ( ) ; date time field type type = ( date time field type ) oos . read object ( ) ; i field = type . get field ( i instant . get chronology ( ) ) ; }	reads the property from a safe serialization format .
private j create asm field ( ) { final j asm field = new j ( num , num ) ; asm field . set font ( gui helper . monospaced font ) ; asm field . set editable ( bool ) ; return asm field ; }	creates a text field that can be used to display assembler code .
public void remove drawer listener ( @ non null drawer listener listener ) { if ( listener == null ) { return ; } if ( m listeners == null ) { return ; } m listeners . remove ( listener ) ; }	removes the specified listener from the list of listeners that will be notified of drawer events .
public void validate meta alias for new entity ( string realm , list < string > new meta aliases ) throws ws { if ( null != new meta aliases && ! new meta aliases . is empty ( ) ) { if ( new meta aliases . size ( ) > num ) { set check for duplicates = new hash set < string > ( new meta aliases ) ; if ( check for duplicates . size ( ) < new meta aliases . size ( ) ) { debug . error ( str + str + new meta aliases ) ; string [ ] data = { new meta aliases . to string ( ) } ; throw new ws ( str , data ) ; } } list < string > all realm meta aliaes = get all hosted meta aliases by realm ( realm ) ; if ( ! all realm meta aliaes . is empty ( ) ) { list < string > duplicate meta aliases = new array list < string > ( ) ; for ( string meta alias : new meta aliases ) { if ( all realm meta aliaes . contains ( meta alias ) ) { duplicate meta aliases . add ( meta alias ) ; } } if ( ! duplicate meta aliases . is empty ( ) ) { string builder sb = new string builder ( ) ; for ( string value : duplicate meta aliases ) { sb . append ( value ) ; sb . append ( str ) ; } debug . error ( str + sb . to string ( ) + str + realm ) ; string [ ] data = { sb . to string ( ) , realm } ; throw new ws ( str , data ) ; } } } }	checks that the provided metaaliases are valid for a new hosted entity in the specified realm.
public static set < string > assert valid cipher suites ( set < string > expected , string [ ] cipher suites ) { assert not null ( cipher suites ) ; assert true ( cipher suites . length != num ) ; set remaining cipher suites = new hash set < string > ( expected ) ; set unknown cipher suites = new hash set < string > ( ) ; for ( string cipher suite : cipher suites ) { boolean removed = remaining cipher suites . remove ( cipher suite ) ; if ( ! removed ) { unknown cipher suites . add ( cipher suite ) ; } } assert equals ( str , collections . empty set , unknown cipher suites ) ; return remaining cipher suites ; }	asserts that the cipher suites array is non - null and that it all of its contents are cipher suites known to this implementation.
public void move ( double x , double y ) { move move = new move ( x , y ) ; if ( x < min x ) { min x = x ; } if ( y < min y ) { min y = y ; } if ( x > max x ) { max x = x ; } if ( y > max y ) { max y = y ; } elements . add ( move ) ; }	move the pen without drawing any line.
public keyword search tuple set ( ) { m lucene = new lucene searcher ( ) ; }	creates a new keywordsearchfocusset using an in - memory search index .
private static string substitute properties ( string str ) { str = str . trim ( ) ; matcher matcher = prop regex . matcher ( str ) ; string buffer buf = new string buffer ( ) ; while ( matcher . find ( ) ) { string match = matcher . group ( ) ; if ( match . length ( ) >= num ) { string key = match . substring ( num , match . length ( ) - num ) ; string val = system . getenv ( key ) ; if ( val == null ) val = system . get property ( key ) ; if ( val != null ) { match = val . replace all ( str , str ) ; } else if ( match . starts with ( str ) ) match = match . replace ( str , str ) ; } matcher . append replacement ( buf , match ) ; } matcher . append tail ( buf ) ; return buf . to string ( ) ; }	substitutes environmental or system properties in the given string .
private queued request sender ( builder builder ) { this . message store = builder . message store ; this . client registry = builder . client registry ; this . observation registry = builder . observation registry ; this . delegate sender = builder . delegate sender ; this . client status tracker = new client status tracker ( ) ; this . queue mode client registry listener = new queue mode client registry listener ( ) ; client registry . add listener ( queue mode client registry listener ) ; this . queue mode observation registry listener = new queue mode observation registry listener ( ) ; observation registry . add listener ( queue mode observation registry listener ) ; delegate sender . add response listener ( create response listener ( ) ) ; }	creates a new queuerequestsender using given builder .
public void start ( int conditions ) throws io { super . start ( conditions ) ; int ptr = ( int ) tagout . get bytes written ( ) ; int offset = ptr - last ptr ; offsets . add ( new int [ ] { last ptr , offset } ) ; last ptr = ptr ; tagout . write u ( num ) ; tagout . write u ( conditions ) ; }	description of the method.
public synchronized int write to file ( jdbc file , byte [ ] data ) throws sql { try { connection . set auto commit ( bool ) ; append to large object . set bytes ( num , data ) ; append to large object . set int ( num , file . get id ( ) ) ; append to large object . execute update ( ) ; connection . commit ( ) ; return data . length ; } catch ( sql e ) { connection . rollback ( ) ; throw e ; } }	persists data to this files associated database mapping .
private void close ( ) { db . close ( m rs , m pstmt ) ; m rs = null ; m pstmt = null ; }	close resultset and statement.
public boolean equal signature ( assignment obj ) { if ( this == obj ) return bool ; if ( obj == null ) return bool ; if ( label == null ) { if ( obj . label != null ) return bool ; } else if ( ! label . equals ( obj . label ) ) return bool ; return ( params . length == obj . params . length ) ; }	compares if the signature ( label and the number of parameters matches ).
public mp create parameter ( int seq no , string parameter name , object value ) { mp ip = new mp ( this , seq no ) ; if ( value == null ) { ip . set parameter ( parameter name , ( string ) null ) ; } else if ( value instanceof big decimal ) { ip . set parameter ( parameter name , ( big decimal ) value ) ; } else if ( value instanceof integer ) { ip . set parameter ( parameter name , ( integer ) value ) ; } else if ( value instanceof timestamp ) { ip . set parameter ( parameter name , ( timestamp ) value ) ; } else if ( value instanceof boolean ) { ip . set parameter ( parameter name , ( boolean ) value ) ; } else { ip . set parameter ( parameter name , value . to string ( ) ) ; } ip . save ex ( ) ; return ip ; }	create process instance parameter and save to database.
public void test adding a ( ) { element a = document . create element ( str ) ; element b = document . create element ( str ) ; element c = document . create element ( str ) ; document fragment fragment = document . create document fragment ( ) ; fragment . append child ( a ) ; fragment . append child ( b ) ; fragment . append child ( c ) ; node returned = menu . append child ( fragment ) ; assert same ( fragment , returned ) ; node list children = menu . get child nodes ( ) ; assert equals ( num , children . get length ( ) ) ; assert true ( children . item ( num ) instanceof text ) ; assert equals ( item , children . item ( num ) ) ; assert true ( children . item ( num ) instanceof text ) ; assert equals ( a , children . item ( num ) ) ; assert equals ( b , children . item ( num ) ) ; assert equals ( c , children . item ( num ) ) ; }	documents shouldn ' t contain document fragments.
public void add ( t graphic ) { synchronized ( m lock ) { m graphics . add ( graphic ) ; if ( m first graphic == null ) { m first graphic = graphic ; } } post invalidate ( ) ; }	adds a graphic to the overlay .
@ override public string to string ( ) { try { string buffer text = new string buffer ( ) ; text . append ( m attr . name ( ) + str ) ; for ( int v = num ; v < m classifications . length ; v ++ ) { text . append ( str ) ; if ( m attr . is nominal ( ) ) { text . append ( m attr . value ( v ) ) ; } else if ( v < m breakpoints . length ) { text . append ( str + m breakpoints [ v ] ) ; } else if ( v > num ) { text . append ( str + m breakpoints [ v - num ] ) ; } else { text . append ( str ) ; } text . append ( str + m class . value ( m classifications [ v ] ) + str ) ; } if ( m missing value class != - num ) { text . append ( str + m class . value ( m missing value class ) + str ) ; } text . append ( str + m correct + str + m num inst + str ) ; return text . to string ( ) ; } catch ( exception e ) { return str ; } }	returns a description of the rule .
protected int parse int ( ) throws io { int sign = num ; int value = num ; int ch = skip whitespace ( ) ; if ( ch == str ) ch = read ( ) ; else if ( ch == str ) { sign = - num ; ch = read ( ) ; } for ( ; ch >= str && ch <= str ; ch = read ( ) ) value = num * value + ch - str ; peek = ch ; return sign * value ; }	parses an integer value from the stream .
private list < byte [ ] > convert string list to byte array ( list < string > value list ) { list < byte [ ] > byte array list = new array list < > ( value list . size ( ) ) ; for ( string value : value list ) { byte array list . add ( value . get bytes ( charset . for name ( carbon common constants . default charset ) ) ) ; } return byte array list ; }	this method will convert list of string to list of byte array.
private void add object if not found ( object obj , vector v ) { int n = v . size ( ) ; boolean add it = bool ; for ( int i = num ; i < n ; i ++ ) { if ( v . element at ( i ) == obj ) { add it = bool ; break ; } } if ( add it ) { v . add element ( obj ) ; } }	add object to vector if not already there .
public void put ( final long key ) { key list . add ( key ) ; }	add the key to the task , prior to execution .
@ post @ produces ( { media type . application xml , media type . application json } ) @ path ( str ) @ check permission ( roles = { role . tenant admin } ) public task resource rep create vcenter cluster ( @ path param ( str ) uri id , vcenter cluster param vcenter cluster param ) { return create or update vcenter cluster ( bool , id , vcenter cluster param . get id ( ) , null , null ) ; }	create a new vcenter cluster with all hosts and datastores.
public void add server ( inet socket address addr ) { server addresses . add ( addr . get host name ( ) + str + addr . get port ( ) ) ; }	adds a server address.
public static int utf8 length ( string string ) { character iterator iter = new string character iterator ( string ) ; char ch = iter . first ( ) ; int size = num ; while ( ch != character iterator . done ) { if ( ( ch >= num ) && ( ch < num ) ) { char trail = iter . next ( ) ; if ( ( trail > num ) && ( trail < num ) ) { size += num ; } else { size += num ; iter . previous ( ) ; } } else if ( ch < num ) { size ++ ; } else if ( ch < num ) { size += num ; } else { size += num ; } ch = iter . next ( ) ; } return size ; }	for the given string , returns the number of utf - 8 bytes required to encode the string .
public static void un register client app ( context context ) throws app catalog exception { string server ip = preference . get string ( context , constants . preference flag . ip ) ; if ( server ip != null && ! server ip . is empty ( ) ) { string application name = preference . get string ( context , constants . client name ) ; string consumer key = preference . get string ( context , constants . client id ) ; string user id = preference . get string ( context , constants . username ) ; if ( application name != null && ! application name . is empty ( ) && consumer key != null && ! consumer key . is empty ( ) && user id != null && ! user id . is empty ( ) ) { unregister profile profile = new unregister profile ( ) ; profile . set application name ( application name ) ; profile . set consumer key ( consumer key ) ; profile . set user id ( user id ) ; server config utils = new server config ( ) ; utils . set server ip ( server ip ) ; dynamic client manager dynamic client manager = new dynamic client manager ( ) ; boolean is unregistered = dynamic client manager . unregister client ( profile , utils , context ) ; if ( ! is unregistered ) { log . e ( tag , str ) ; } } else { log . e ( tag , str ) ; } } else { log . e ( tag , str ) ; } }	this method is used to initiate the oauth client app unregister process .
protected byte [ ] ftp get ( final string url string ) { input stream input stream = null ; try { final url url = new url ( url string ) ; input stream = url . open stream ( ) ; return dss . to byte array ( input stream ) ; } catch ( exception e ) { log . warn ( e . get message ( ) ) ; } finally { io . close quietly ( input stream ) ; } return null ; }	this method retrieves data using ftp protocol .
public void test set bit negative inside3 ( ) { string as = str ; string res = str ; int number = num ; big integer a number = new big integer ( as ) ; big integer result = a number . set bit ( number ) ; assert equals ( res , result . to string ( ) ) ; }	setbit ( int n ) inside a negative number with all ones in bit representation.
private static double gnorm ( double a , double x ) { double sx ; if ( ( x <= num ) || ( a <= num ) ) { return num ; } else { sx = math . sqrt ( a ) * num * ( math . pow ( x / a , num / num ) + num / ( a * num ) - num ) ; return normal cdf ( sx ) ; } }	compute gamma cdf by a normal approximation.
public object create parameter ( final class < ? > c ) { if ( c == integer . type ) { return integer . value of ( random . next int ( ) ) ; } else if ( c == double . type ) { return double . value of ( random . next double ( ) ) ; } else if ( c == double [ ] . class ) { final double [ ] v = new double [ dim ] ; for ( int i = num ; i < dim ; i ++ ) { v [ i ] = random . next double ( ) ; } return v ; } else if ( c . is assignable from ( real vector . class ) ) { return create vector ( ) ; } else if ( c . is assignable from ( univariate function . class ) ) { return new sin ( ) ; } else { throw new illegal argument exception ( str + c ) ; } }	creates a new random object of the specified type .
@ override public void clear ( ) { entry tab [ ] = table ; mod count ++ ; for ( int index = tab . length ; -- index >= num ; ) tab [ index ] = null ; count = num ; }	removes all mappings from this map .
public void show list ( list < item chooser row > list ) { m progress bar . set visibility ( view . gone ) ; if ( ! list . is empty ( ) ) { m item adapter . add all ( list ) ; } set state ( state . progress update available ) ; }	add items to show in the dialog .
protected ie create single element description ( t existing member ) { return e . create ( existing member . get name ( ) , existing member ) ; }	creates a description for a successfully found element.
public list < i > choose resources ( ) { if ( open ( ) == window . ok ) { list < i > resources = new array list < i > ( ) ; for ( object obj : get result ( ) ) { resources . add ( ( i ) obj ) ; } return resources ; } return null ; }	return the selected resource ( s ) as a list of iresource objects .
@ override public void emit ( alert stream event event ) { try { queue . put ( event ) ; } catch ( interrupted exception e ) { log . error ( e . get message ( ) , e ) ; } }	emit method can be called in multi - thread .
public static tungsten properties load from json ( string json ) throws json parse exception , json mapping exception , io { object mapper mapper = new object mapper ( ) ; tungsten properties tungsten prop = mapper . read value ( json , tungsten properties . class ) ; return tungsten prop ; }	load values from a json serialized string.
public < t > string make string value ( t value ) { return value . to string ( ) ; }	scipio : makes an escaped freemarker string value without enclosing double - quotes , as intended for a regular ( non - raw ) string.
public void test available ( ) throws exception { byte [ ] data = new byte [ ] { - num , - num , - num , - num , - num , num , num , num , num , num } ; test input stream tis = new test input stream ( data ) ; cipher input stream cis = new cipher input stream ( tis , new null cipher ( ) ) ; assert equals ( str + str , cis . available ( ) , num ) ; }	available ( ) method testing.
private void encode full revision uncompressed ( final diff part part ) throws unsupported encoding exception , encoding exception { data . write bit ( num ) ; data . write bit ( num ) ; data . write bit ( num ) ; string text = part . get text ( ) ; byte [ ] b text = text . get bytes ( wikipedia encoding ) ; data . write value ( codec data . get blocksize l ( ) , b text . length ) ; data . write ( b text ) ; }	encodes a fullrevision operation .
public static string to bits ( final long x ) { final string builder sb = new string builder ( ) ; long t = x ; boolean first = bool ; for ( int i = num ; i < num ; i ++ ) { if ( t < num ) { sb . append ( str ) ; first = bool ; } else if ( first ) { sb . append ( str ) ; } t = t << num ; } assert t == num ; return sb . to string ( ) ; }	convert a number into a bit string .
private void hideable label ( j label , string text ) { if ( text . is empty ( ) ) { label . set foreground ( label invisible ) ; } else { label . set foreground ( label visible ) ; label . set text ( text ) ; } }	changes the text on the given label , making it invisible if the text is empty or visible again otherwise .
public static string join ( collection < ? > c , string delim ) { string builder retval = new string builder ( ) ; iterator < ? > itr = c . iterator ( ) ; if ( itr . has next ( ) ) retval . append ( itr . next ( ) ) ; else return str ; while ( itr . has next ( ) ) { retval . append ( delim ) ; retval . append ( itr . next ( ) ) ; } return retval . to string ( ) ; }	similar to perl ' s join ( ) method on lists , but works with all collections .
public void end document ( ) throws sax { write ( str ) ; super . end document ( ) ; try { flush ( ) ; } catch ( io e ) { throw new sax ( e ) ; } }	write a newline at the end of the document.
protected boolean is stopped ( ) { return this . is stopped ; }	returns whether the dispatcher is stopped.
public string scm revision ( ) { return properties . get property ( str ) ; }	returns the revision number of the source repository on which this build is based .
public void ask permissions ( ) { m permissions to ask = get not granted permissions ( ) ; if ( m permissions to ask . size ( ) > num && build . version . sdk int >= build . version codes . m ) { request permissions ( m permissions to ask . to array ( new string [ m permissions to ask . size ( ) ] ) , my permission request all ) ; } else { send response ( bool ) ; } }	main function to ask permissions.
public greater equal constraint ( double constraint value ) { super ( double . value of ( constraint value ) ) ; }	creates a greater - equal parameter constraint.
public void test get owner document1 ( ) throws throwable { document doc ; document owner doc ; dom dom impl ; document type doc type ; string null id = null ; doc = ( document ) load ( str , builder ) ; dom impl = doc . get implementation ( ) ; doc type = dom impl . create document type ( str , null id , null id ) ; owner doc = doc type . get owner document ( ) ; assert null ( str , owner doc ) ; }	runs the test case .
private void add action ( string label , int id , int type ) { card action card action = new card action ( ) ; card action . label = label ; card action . id = id ; card action . type = type ; m card actions . add ( card action ) ; }	adds an action to this card during build time .
private date backoff time ( date start time ) { if ( start time . before ( date utils . add minutes ( new date ( ) , - num ) ) ) { return date utils . add seconds ( start time , - num ) ; } return date utils . add seconds ( start time , - backoff time ) ; }	adds backoff time to start time.
public static final int binary search ( object [ ] a , object key , comparator cp , int begin , int end ) { int x1 = begin ; int x2 = end ; int i = x1 + ( x2 - x1 ) / num , c ; while ( x1 < x2 ) { c = cp . compare ( a [ i ] , key ) ; if ( c == num ) { return i ; } else if ( c < num ) { x1 = i + num ; } else { x2 = i ; } i = x1 + ( x2 - x1 ) / num ; } return - num * ( i + num ) ; }	perform a binary search over a sorted range of an array for the given key .
private void post init view pager ( ) { try { class < ? > viewpager = view pager . class ; field scroller = viewpager . get declared field ( str ) ; scroller . set accessible ( bool ) ; field interpolator = viewpager . get declared field ( str ) ; interpolator . set accessible ( bool ) ; m scroller = new custom duration scroller ( get context ( ) , ( interpolator ) interpolator . get ( null ) ) ; double duration = num ; m scroller . set scroll duration factor ( duration ) ; scroller . set ( this , m scroller ) ; } catch ( no such field exception e ) { } catch ( illegal argument exception e ) { } catch ( illegal access exception e ) { } }	override the scroller instance with our own class so we can change the duration.
public i prepare update ( final string update str ) throws exception { return prepare update ( update str , uuid . random uuid ( ) ) ; }	prepare a sparql update request .
private void handle certificate request ( certificate request request ) { if ( request . get renew ( ) ) { val certificate response = request handler . request certificate ( request . get domains ( ) ) ; secret manager . update certificate ( namespace , request . get secret name ( ) , certificate response ) ; } else { val certificate response = request handler . request certificate ( request . get domains ( ) ) ; secret manager . insert certificate ( namespace , request . get secret name ( ) , certificate response ) ; } }	this function performs a certificate request as determined by preparecertificaterequest ( ).
private final void send chunk to ( byte buffer in , socket channel sc , byte buffer out ) throws io { int bytes sent = in . remaining ( ) ; if ( in . is direct ( ) ) { flush buffer ( sc , out ) ; while ( in . remaining ( ) > num ) { sc . write ( in ) ; } } else { int out max = out . remaining ( ) ; if ( bytes sent <= out max ) { out . put ( in ) ; } else { final byte [ ] bytes = in . array ( ) ; int off = in . array offset ( ) + in . position ( ) ; int len = bytes sent ; while ( len > num ) { int bytes this time = len ; if ( bytes this time > out max ) { bytes this time = out max ; } out . put ( bytes , off , bytes this time ) ; off += bytes this time ; len -= bytes this time ; flush buffer ( sc , out ) ; out max = out . remaining ( ) ; } in . position ( in . limit ( ) ) ; } } this . size -= bytes sent ; }	sends the data from " in " by writing it to " sc " through " out " ( out is used to chunk to data and is probably a direct memory buffer ) .
public void clear last login time ( ) { operations . add ( password policy state operation type . clear last login time ) ; }	clears the last login time .
public boolean copy ( string to rpf dir ) { file to dir = new file ( to rpf dir ) ; boolean ret = bool ; string source rpf dir = get rpf dir ( ) ; if ( ( to dir . exists ( ) || to dir . mkdirs ( ) ) && frame list != null ) { if ( verbose ) { debug . output ( str + source rpf dir + str + to rpf dir + str ) ; } for ( iterator < string > it = frame list . iterator ( ) ; it . has next ( ) ; ) { string relative file path = str + it . next ( ) ; file from file = new file ( source rpf dir + relative file path ) ; file to file = new file ( to rpf dir + relative file path ) ; file to parent = to file . get parent file ( ) ; if ( ! to parent . exists ( ) ) { to parent . mkdirs ( ) ; } if ( verbose ) { debug . output ( str + relative file path ) ; } try { file utils . copy ( from file , to file , num ) ; } catch ( io ioe ) { debug . error ( str + ioe . get message ( ) ) ; return bool ; } } ret = bool ; } return ret ; }	copy the frame files currently set on the framelist to the provided rpf directory .
protected void stop reset expired jobs thread ( ) { if ( reset expired job thread != null ) { try { reset expired job thread . join ( ) ; } catch ( interrupted exception e ) { log . warn ( str , e ) ; } reset expired job thread = null ; } }	stops the reset expired jobs thread.
@ suppress warnings ( { str , str } ) private list filter resources for lookup ( iterable resources , resource field field ) { list results = new array list ( ) ; iterator iterator = resources . iterator ( ) ; while ( iterator . has next ( ) ) { object resource = iterator . next ( ) ; object property = property utils . get property ( resource , field . get underlying name ( ) ) ; lookup include behavior lookup include behavior = field . get lookup include automatically ( ) ; if ( lookup include behavior == lookup include behavior . automatically always || ( property == null && lookup include behavior == lookup include behavior . automatically when null ) ) { results . add ( resource ) ; } } return results ; }	filter by resources that need lookup based on incusion behavior .
public void clear node map ( ) { node loc . clear ( ) ; }	clears node local map .
public static < t > t check not null ( t reference , object error message ) { if ( exo player library info . assertions enabled && reference == null ) { throw new null pointer exception ( string . value of ( error message ) ) ; } return reference ; }	ensures that an object reference is not null .
public synchronized void rollback ( ) throws replicator exception { assert writable ( ) ; }	rollback transactions stored in the log .
private synchronized void update thread panel ( boolean force update ) { if ( ! force update && ! is visible ( ) ) { return ; } thread panel . remove all ( ) ; grid bag constraints gbc = new grid bag constraints ( ) ; gbc . gridx = num ; gbc . gridy = num ; gbc . weightx = num ; gbc . weighty = num ; gbc . fill = grid bag constraints . horizontal ; gbc . ipady = num ; for ( progress thread current thread : progress thread . get current threads ( ) ) { progress thread display pg panel = new progress thread display ( current thread , bool ) ; thread panel . add ( pg panel , gbc ) ; mapping pg to ui . put ( current thread , pg panel ) ; update progress message ( current thread ) ; update progress ( current thread ) ; gbc . gridy += num ; } for ( progress thread queued thread : progress thread . get queued threads ( ) ) { progress thread display pg panel = new progress thread display ( queued thread , bool ) ; thread panel . add ( pg panel , gbc ) ; mapping pg to ui . put ( queued thread , pg panel ) ; gbc . gridy += num ; } gbc . gridy += num ; gbc . weighty = num ; gbc . fill = grid bag constraints . both ; thread panel . add ( new j ( ) , gbc ) ; thread panel . revalidate ( ) ; thread panel . repaint ( ) ; }	updates the thread display panel which shows running / queued threads .
private boolean is implicit import ( string name ) { boolean yes = implicit imports . get ( name ) ; if ( yes != null ) { return yes ; } try { class . for name ( str + name ) ; yes = bool ; } catch ( exception e ) { yes = bool ; } implicit imports . put ( name , yes ) ; return yes ; }	checks whether the simple type name is implicitly imported from java.
public void add banned mac ( final string mac ) { add banned mac ( mac , null ) ; }	ban the mac permanently.
@ override public void accept ( int value ) { ++ count ; sum += value ; min = math . min ( min , value ) ; max = math . max ( max , value ) ; }	records a new value into the summary information.
public void mouse entered ( mouse event e ) { j c = ( j ) e . get source ( ) ; c . set cursor ( cursor ) ; }	show a special cursor while the mouse is inside the window.
private void print pool recommendations ( list < recommendation > pool recommendations ) { string buffer buf = new string buffer ( ) ; buf . append ( string . format ( str ) ) ; for ( recommendation pool rec : pool recommendations ) { storage pool pool = db client . query object ( storage pool . class , pool rec . get source storage pool ( ) ) ; buf . append ( string . format ( str , pool . get label ( ) , pool . get free capacity ( ) ) ) ; } buf . append ( string . format ( str ) ) ; log . info ( buf . to string ( ) ) ; }	display storage pool information from recommendation.
private tuple < message , connection > try other messages ( ) { list < tuple < message , connection > > messages = new array list < tuple < message , connection > > ( ) ; collection < message > msg collection = get message collection ( ) ; for ( connection con : get connections ( ) ) { dtn other = con . get other node ( get host ( ) ) ; prophet router oth router = ( prophet router ) other . get router ( ) ; if ( oth router . is transferring ( ) ) { continue ; } for ( message m : msg collection ) { if ( oth router . has message ( m . get id ( ) ) ) { continue ; } if ( oth router . get pred for ( m . get to ( ) ) > get pred for ( m . get to ( ) ) ) { messages . add ( new tuple < message , connection > ( m , con ) ) ; } } } if ( messages . size ( ) == num ) { return null ; } collections . sort ( messages , new tuple comparator ( ) ) ; return try messages for connected ( messages ) ; }	tries to send all other messages to all connected hosts ordered by their delivery probability.
public static string to string ( object value ) { if ( value == null ) { return null ; } return value . to string ( ) ; }	converts safely an object to a string .
static boolean less than unsigned ( long x1 , long x2 ) { return ( x1 + long . min value ) < ( x2 + long . min value ) ; }	returns true if x1 is less than x2 , when both values are treated as unsigned .
@ override public boolean remove ( object object ) { return remove element ( object ) ; }	removes the first occurrence , starting at the beginning and moving towards the end , of the specified object from this vector.
public static int find end of string ( string str , int loc , int line ) throws parse algorithm exception { int pos = loc + num ; boolean found = bool ; while ( ( ! found ) && ( pos < str . length ( ) ) ) { char c = str . char at ( pos ) ; if ( c == str ) { found = bool ; } else if ( c == str && ( pos < str . length ( ) - num ) ) { pos ++ ; } pos ++ ; } if ( ! found ) { throw new parse algorithm exception ( str + str + ( line + num ) + str + ( loc + num ) ) ; } return pos ; }	this method assumes that str is a string whose character at position loc is a quote ( " ).
public string to verbose string ( ) { string buffer result = new string buffer ( ) ; result . append ( str ) ; result . append ( get name ( ) ) ; result . append ( str ) ; result . append ( get java name ( ) ) ; result . append ( str ) ; result . append ( get mapped type ( ) ) ; result . append ( str ) ; result . append ( get mapped type code ( ) ) ; result . append ( str ) ; result . append ( get size ( ) ) ; result . append ( str ) ; result . append ( is required ( ) ) ; result . append ( str ) ; result . append ( is primary key ( ) ) ; result . append ( str ) ; result . append ( is auto increment ( ) ) ; result . append ( str ) ; result . append ( get default value ( ) ) ; result . append ( str ) ; result . append ( get precision radix ( ) ) ; result . append ( str ) ; result . append ( get scale ( ) ) ; result . append ( str ) ; return result . to string ( ) ; }	returns a verbose string representation of this column .
private void simulate block ( ssa basic block block ) { for ( ssa insn insn : block . get insns ( ) ) { if ( insn instanceof phi insn ) { simulate phi ( ( phi insn ) insn ) ; } else { simulate stmt ( insn ) ; } } }	simulate a block and note the results in the lattice .
public static big decimal round off ( final big decimal amount ) { return amount . set scale ( decimals , rounding mode ) ; }	this method is a utility method , which takes a bigdecimal and rounds that to 0 places .
public fits ( ) { }	create an empty fits object which is not associated with an input stream .
@ deprecated public void correctly spends ( transaction tx containing this , long script sig index , script script pub key ) throws script exception { correctly spends ( tx containing this , script sig index , script pub key , all verify flags ) ; }	verifies that this script ( interpreted as a scriptsig ) correctly spends the given scriptpubkey , enabling all validation rules .
public void done ( ) { output . println ( ) ; }	description of the method.
protected void process initiators ( export group export group , collection < initiator > initiators , collection < string > port names , map < string , uri > port name to initiator uri , collection < uri > host ur , list multimap < string , string > compute resource to port names ) { for ( initiator initiator : initiators ) { string normalized name = initiator . normalize port ( initiator . get initiator port ( ) ) ; port names . add ( normalized name ) ; port name to initiator uri . put ( normalized name , initiator . get id ( ) ) ; if ( host ur != null ) { if ( ! null column value getter . is null uri ( initiator . get host ( ) ) && ! host ur . contains ( initiator . get host ( ) ) ) { host ur . add ( initiator . get host ( ) ) ; } } if ( compute resource to port names != null ) { string compute resource id ; if ( export group != null && export group . for cluster ( ) ) { compute resource id = initiator . get cluster name ( ) ; } else { uri host uri = initiator . get host ( ) ; if ( host uri == null ) { host uri = null column value getter . get null uri ( ) ; } compute resource id = host uri . to string ( ) ; } compute resource to port names . put ( compute resource id , normalized name ) ; } } }	a utility for processing initiators and updating data structures.
public void write as serialized byte array ( object v ) throws io { if ( this . ignore writes ) return ; check if writable ( ) ; ensure capacity ( num ) ; if ( v instanceof heap data output stream ) { heap data output stream other = ( heap data output stream ) v ; other . finish writing ( ) ; internal data serializer . write array length ( other . size ( ) , this ) ; if ( this . do not copy ) { if ( other . chunks != null ) { for ( byte buffer bb : other . chunks ) { write ( bb ) ; } } write ( other . buffer ) ; } else { other . send to ( ( byte buffer writer ) this ) ; other . rewind ( ) ; } } else { byte buffer size buf = this . buffer ; int size pos = size buf . position ( ) ; size buf . position ( size pos + num ) ; final int pre array size = size ( ) ; data serializer . write object ( v , this ) ; int array size = size ( ) - pre array size ; size buf . put ( size pos , internal data serializer . int array len ) ; size buf . put int ( size pos + num , array size ) ; } }	writes the given object to this stream as a byte array.
private boolean is closed ( ) { if ( ! verify reader ) { return bool ; } try { br . mark ( num ) ; int next byte = br . read ( ) ; br . reset ( ) ; return next byte == - num ; } catch ( io e ) { return bool ; } }	checks to see if the file is closed .
public static void append file to file ( final file file1 , final file file2 ) { if ( ! is readable ( file1 ) || ! is readable ( file2 ) || ! is writable ( file1 ) ) { return ; } try { file input stream input stream = new file input stream ( file2 ) ; file output stream output stream = new file output stream ( file1 , bool ) ; int count ; final int buffer size = num ; byte [ ] bytes = new byte [ buffer size ] ; while ( ( count = input stream . read ( bytes , num , buffer size ) ) > num ) output stream . write ( bytes , num , count ) ; file utils . sync ( output stream ) ; output stream . close ( ) ; input stream . close ( ) ; } catch ( file not found exception e ) { e . print stack trace ( ) ; } catch ( io e ) { e . print stack trace ( ) ; } }	appends one file to another .
public static double distance ( lat lng point a , lat lng point b ) { double lat = math . to radians ( point a . latitude ) ; double lat2 = math . to radians ( point b . latitude ) ; double dif lat = math . to radians ( point b . latitude - point a . latitude ) ; double dif long = math . to radians ( point b . longitude - point a . longitude ) ; double a = ( math . pow ( math . sin ( dif lat / num ) , num ) ) + ( math . cos ( lat ) * math . cos ( lat2 ) * math . pow ( math . sin ( dif long / num ) , num ) ) ; double c = num * math . atan2 ( math . sqrt ( a ) , math . sqrt ( num - a ) ) ; return earth * c ; }	returns the distance from ' this ' point to destination point ( using haversine formula ) .
public final boolean is clearance compensation used ( ) { return compensated clearance class no > num ; }	if for the shapes stored in this tree clearance compensation is used .
private long try dec reader overflow ( long s ) { if ( ( s & abits ) == rfull ) { if ( u . compare and swap long ( this , state , s , s | rbits ) ) { int r ; long next ; if ( ( r = reader overflow ) > num ) { reader overflow = r - num ; next = s ; } else next = s - runit ; u . put long volatile ( this , state , next ) ; return next ; } } else if ( ( next secondary seed ( ) & overflow yield rate ) == num ) thread . yield ( ) ; return num ; }	tries to decrement readeroverflow .
public static string signature class ( string sig ) { int pos = sig . index of ( str ) ; return sig . substring ( num , pos ) ; }	given a method signature , returns a substring denoting the class name .
protected list < power host > extract host list from migration map ( list < map < string , object > > migration map ) { list < power host > hosts = new linked list < power host > ( ) ; for ( map < string , object > map : migration map ) { hosts . add ( ( power host ) map . get ( str ) ) ; } return hosts ; }	extracts the host list from a migration map .
protected boolean include ( iterable < string > path , string name ) throws io , lexer exception { for ( string dir : path ) { virtual file file = filesystem . get file ( dir , name ) ; if ( include ( file ) ) return bool ; } virtual file file = filesystem . get file ( name ) ; if ( include ( file ) ) return bool ; return bool ; }	includes a file from an include path , by name .
public static string format station ( int station ) { float frequency = ( float ) station / convert rate ; string result = string . format ( locale . english , str , float . value of ( frequency ) ) ; return result ; }	according station to get frequency string.
public void remove priority unit ( string id ) { if ( ! string util . is positive integer ( id ) ) { return ; } remove priority unit ( integer . parse int ( id ) ) ; }	remove a unit from the priority target list .
public void commit changes ( synapse group synapse group ) { double percent excitatory = utils . double parsable ( e ratio ) / num ; if ( ! double . is na n ( percent excitatory ) ) synapse group . set excitatory ratio ( percent excitatory ) ; excitatory randomizer panel . commit changes ( ) ; inhibitory randomizer panel . commit changes ( ) ; synapse group . set excitatory randomizer ( ex randomizer ) ; synapse group . set inhibitory randomizer ( in randomizer ) ; }	commits changes to a synapse group .
private void return buffer ( byte buffer buf ) { if ( buf != null ) { buf . clear ( ) ; buffer pool . add ( buf ) ; } }	returns direct buffer to pool .
public void write ( char buf [ ] ) { write ( buf , num , buf . length ) ; }	writes an array of characters.
public void insert child ( node [ ] nodes , int index ) { for ( node node : nodes ) { node . detach from parent ( ) ; node . parent node = this ; try { init child nodes ( node ) ; child nodes . add ( index , node ) ; index ++ ; } catch ( index out of bounds exception ignore ) { throw new dom ( str + index ) ; } } reindex children ( ) ; }	inserts several nodes at ones.
public properties load properties ( string artifact , string version ) throws io { properties props = new properties ( ) ; path properties file = get properties file ( artifact , version ) ; if ( ! files . exists ( properties file ) ) { throw new artifact not found exception ( artifact , version ) ; } try ( input stream in = new buffered input stream ( files . new input stream ( properties file ) ) ) { props . load ( in ) ; } return props ; }	loads the properties of the artifact .
protected array list < float [ ] > forward poly ( float [ ] rawllpts , int ltype , int nsegs , boolean is filled ) { double [ ] drawllpts = new double [ rawllpts . length ] ; system . arraycopy ( drawllpts , num , rawllpts , num , rawllpts . length ) ; return forward poly ( drawllpts , ltype , nsegs , is filled ) ; }	forward project a lat / lon poly . remember to specify vertices in radians !.
@ override public enumeration < option > list options ( ) { vector < option > result = enum to vector ( super . list options ( ) ) ; result . add element ( new option ( str + default num examples ( ) + str , str , num , str ) ) ; return result . elements ( ) ; }	returns an enumeration describing the available options .
public static fields find by thrift id ( int field id ) { switch ( field id ) { case num : return id ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
static replay promise < void > all replay ( final duration timeout , final promise < ? > ... promises ) { return all replay ( timeout , system . current time millis ( ) , promises ) ; }	all promises must complete .
private void import zielobjekte ( final i monitor ) { activator . inherit verinice context state ( ) ; import task import task = new import task ( dialog . is bausteine ( ) , dialog . is massnahmen personen ( ) , dialog . is ziel objekte zielobjekte ( ) , dialog . is schutzbedarf ( ) , dialog . is rollen ( ) , dialog . is kosten ( ) , dialog . is umsetzung ( ) , dialog . is baustein personen ( ) ) ; long import task start = system . current time millis ( ) ; import task . execute ( import task . type sqlserver , new eclipse progress monitor delegator ( monitor ) ) ; if ( log . is debug enabled ( ) ) { log . debug ( str + string . value of ( ( system . current time millis ( ) - import task start ) / num ) + str ) ; } source id = import task . get source id ( ) ; }	imports zielobjekte from gstool bausteine , gefaehrdungen , massnahmen und relations between these objects are also imported if selected in configuration dialog .
private static double [ ] compute labels ( final double start , final double end , final int approx num labels ) { if ( math . abs ( start - end ) < num ) { return new double [ ] { start , start , num } ; } double s = start ; double e = end ; boolean switched = bool ; if ( s > e ) { switched = bool ; double tmp = s ; s = e ; e = tmp ; } double x step = round up ( math . abs ( s - e ) / approx num labels ) ; double x start = x step * math . ceil ( s / x step ) ; double x end = x step * math . floor ( e / x step ) ; if ( switched ) { return new double [ ] { x end , x start , - num * x step } ; } return new double [ ] { x start , x end , x step } ; }	computes a reasonable number of labels for a data range .
public void add transform ( data transform transform ) { transform source . add ( transform ) ; }	adds a transform to the list of transforms.
socket creator ( final ssl ssl config ) { this . ssl config = ssl config ; initialize ( ) ; }	constructs new socketcreator instance .
public static boolean is absolute uri ( string system id ) { if ( is windows absolute path ( system id ) ) { return bool ; } final int fragment index = system id . index of ( str ) ; final int query index = system id . index of ( str ) ; final int slash index = system id . index of ( str ) ; final int colon index = system id . index of ( str ) ; int index = system id . length ( ) - num ; if ( fragment index > num ) index = fragment index ; if ( ( query index > num ) && ( query index < index ) ) index = query index ; if ( ( slash index > num ) && ( slash index < index ) ) index = slash index ; return ( ( colon index > num ) && ( colon index < index ) ) ; }	return true if the systemid denotes an absolute uri .
public default http method retry handler ( final int retry count , final boolean request sent retry enabled ) { super ( ) ; this . retry count = retry count ; this . request sent retry enabled = request sent retry enabled ; }	creates a new defaulthttpmethodretryhandler .
private static void check for koml ( ) { try { class . for name ( str ) ; m = bool ; } catch ( exception e ) { m = bool ; } }	checks whether the koml is present in the class path.
@ override public synchronized void add instance listener ( instance listener dsl ) { m listeners . add ( dsl ) ; }	add an instance listener.
public type name ( string full name , string nickname , string parent type name ) { this . top level alias = type alias . create ( full name , nickname , parent type name ) ; this . pattern = null ; this . inner type names = arrays . as list ( ) ; }	creates a type alias for a static inner type with the given fullname and nickname .
@ override public void remove property change listener ( string name , property change listener pcl ) { m bc support . remove property change listener ( name , pcl ) ; }	remove a property change listener from this bean.
@ override public void run ( ) { if ( ! lifecycle . to active ( ) ) { log . fine ( this + str ) ; return ; } try { run impl ( ) ; } finally { } }	running process accepting connections .
public static string create html document ( map < string , object > style , string text , double scale ) { string buffer css = new string buffer ( ) ; css . append ( str + get string ( style , mx constants . style fontfamily , mx constants . default fontfamilies ) + str ) ; css . append ( str + ( int ) ( get int ( style , mx constants . style fontsize , mx constants . default fontsize ) * scale ) + str ) ; string color = mx utils . get string ( style , mx constants . style fontcolor ) ; if ( color != null ) { css . append ( str + color + str ) ; } int font style = mx utils . get int ( style , mx constants . style fontstyle ) ; if ( ( font style & mx constants . font bold ) == mx constants . font bold ) { css . append ( str ) ; } if ( ( font style & mx constants . font italic ) == mx constants . font italic ) { css . append ( str ) ; } if ( ( font style & mx constants . font underline ) == mx constants . font underline ) { css . append ( str ) ; } string align = get string ( style , mx constants . style align , mx constants . align left ) ; if ( align . equals ( mx constants . align center ) ) { css . append ( str ) ; } else if ( align . equals ( mx constants . align right ) ) { css . append ( str ) ; } return str + css . to string ( ) + str + text + str ; }	returns a new , empty dom document .
public void start log cleaning process ( file access log directory ) { logger . info ( str , access log directory . get absolute path ( ) ) ; timer timer = new timer ( is daemon ) ; access log cleaner task tomcat access log cleaner = new access log cleaner task ( access log directory ) ; logger . info ( str ) ; timer . schedule at fixed rate ( tomcat access log cleaner , num , timer task delay in millis ) ; }	perform clean up of the tomcat access log files.
public boolean is known repository ( string location , boolean require exact match ) { set < string > keys = repositories . key set ( ) ; for ( string check location : keys ) { if ( ! require exact match && location . index of ( check location ) != - num ) { return bool ; } if ( location . equals ( check location ) ) return bool ; } return bool ; }	answer whether the provided repository location is known by the provider or not . the location string corresponds to the strin returned by isvnrepositorylocation # getlocation ( ).
public static int index header length ( string codec , string suffix ) { return header length ( codec ) + string helper . id length + num + suffix . length ( ) ; }	computes the length of an index header .
private int test in range ( long actual , long expected , long epsilon ) { long min = expected - epsilon ; long max = expected + epsilon ; return actual < min ? - num : actual > max ? num : num ; }	returns - 1 , 0 , 1 if actual is less than , equal to , or greater than expected w / in epsilon .
public void remove method ( soot method method ) { methods . remove ( method ) ; }	remove method from list .
public void add stats ( long [ ] msg1 unique msg id stats , long [ ] msg1 total stats , long [ ] msg2 unique msg id stats , long [ ] msg2 total stats ) { m number of intervals += msg1 unique msg id stats . length ; for ( int i = num ; i < msg1 unique msg id stats . length ; i ++ ) { final long msg1 unique msg id stat = msg1 unique msg id stats [ i ] ; final long msg1 total stat = msg1 total stats [ i ] ; final long msg2 unique msg id stat = msg2 unique msg id stats [ i ] ; final long msg2 total stat = msg2 total stats [ i ] ; if ( msg1 unique msg id stat == num ) { m interval with zero counts ++ ; } else { m min msg1 unique msg id count = math . min ( m min msg1 unique msg id count , msg1 unique msg id stat ) ; } m max msg1 unique msg id count = math . max ( m max msg1 unique msg id count , msg1 unique msg id stat ) ; m sum of msg1 unique msg id count += msg1 unique msg id stat ; m sum of msg2 unique msg id count += msg2 unique msg id stat ; m sum of msg1 unique msg id count square += msg1 unique msg id stat * msg1 unique msg id stat ; m msg1 total count += msg1 total stat ; m msg2 total count += msg2 total stat ; } }	add an array of stats.
@ patch public void patch objects ( list < api < string > > patches ) throws guacamole exception { for ( api < string > patch : patches ) { if ( patch . get op ( ) != api . operation . remove ) throw new guacamole unsupported exception ( str + str ) ; string path = patch . get path ( ) ; if ( ! path . starts with ( str ) ) throw new guacamole client exception ( str ) ; directory . remove ( path . substring ( num ) ) ; } }	applies the given object patches , updating the underlying directory accordingly.
public void add dimension key name ( string key ) { dimension key names . add ( key ) ; }	add the key that should be treated as one of the dimensions . the key must be in the input map.
private static boolean is in vertical target zone ( float x , float y , float handle x , float handle y , float handle y , float target radius ) { if ( math . abs ( x - handle x ) <= target radius && y > handle y && y < handle y ) { return bool ; } return bool ; }	determines if the specified coordinate is in the target touch zone for a vertical bar handle .
public static int count occurrences of ( string str , string sub ) { if ( str == null || sub == null || str . length ( ) == num || sub . length ( ) == num ) { return num ; } int count = num ; int pos = num ; int idx ; while ( ( idx = str . index of ( sub , pos ) ) != - num ) { ++ count ; pos = idx + sub . length ( ) ; } return count ; }	count the occurrences of the substring in string s .
public void add fileset ( file set set ) { filesets . add element ( set ) ; }	adds a set of files ( nested fileset attribute ) .
private void put with validation ( string key , object value ) throws uri { if ( parameter map . contains key ( key ) ) { throw new uri ( string . format ( str , key ) ) ; } else { parameter map . put ( key , value ) ; } }	put the value against the key in the map checking for duplication.
public boolean is identical ( final double x , final double y , final double z ) { return math . abs ( this . x - x ) < minimum resolution && math . abs ( this . y - y ) < minimum resolution && math . abs ( this . z - z ) < minimum resolution ; }	compute whether point matches another .
@ override protected string translate ( final string name ) { return str + name + str ; }	translate a resource name into it ' s sprite image path .
public account header builder add profiles ( @ non null i ... profiles ) { if ( this . m profiles == null ) { this . m profiles = new array list < > ( ) ; } collections . add all ( this . m profiles , id distributor . check ids ( profiles ) ) ; return this ; }	add single ore more draweritems to the drawer.
private boolean overloaded ( method symbol m , type symbol c , types types ) { for ( com . redhat . ceylon . langtools . tools . javac . util . list < type > is = types . interfaces ( c . type ) ; is . non empty ( ) ; is = is . tail ) { type symbol i = is . head . tsym ; if ( overloaded in ( m , i , types ) ) return bool ; if ( overloaded ( m , i , types ) ) return bool ; } return bool ; }	copied from methodsymbol . implemented and adapted for overloading.
private boolean has nodes in context ( site node node ) { @ suppress warnings ( str ) enumeration < site node > en = node . children ( ) ; while ( en . has more elements ( ) ) { site node sn = en . next element ( ) ; if ( is in context ( sn ) ) { return bool ; } if ( has nodes in context ( sn ) ) { return bool ; } } return bool ; }	tells whether or not there ' s at least one node from the sites tree in context.
public gzip configurable output stream ( output stream out , int size , int compression ) throws io { super ( out , new deflater ( compression , bool ) , size ) ; write header ( ) ; crc . reset ( ) ; }	creates a new output stream with the specified buffer size .
private void add aux class path entries ( string argument ) { string tokenizer tok = new string tokenizer ( argument , file . path separator ) ; while ( tok . has more tokens ( ) ) { project . add aux classpath entry ( tok . next token ( ) ) ; } }	parse the argument as auxclasspath entries and add them.
public boolean qualify ( final node that , final declaration d ) { string path = qualified path ( that , d ) ; if ( path . length ( ) > num ) { out ( path , d instanceof constructor ? names . constructor separator ( d ) : str ) ; } return path . length ( ) > num ; }	outputs the module name for the specified declaration.
public sided plane ( final vector p , final vector a , final vector b ) { super ( a , b ) ; sig num = math . signum ( evaluate ( p ) ) ; if ( sig num == num ) throw new illegal argument exception ( str ) ; }	construct a sided plane from a pair of vectors describing points , and including origin , plus a point p which describes the side .
public static string encode ( string source ) { string buffer dest = new string buffer ( ) ; int source len = source . length ( ) ; for ( int i = num ; i < source len ; i ++ ) { int run length = num ; final char current char = source . char at ( i ) ; while ( i + num < source len && current char == source . char at ( i + num ) ) { run length ++ ; i ++ ; } dest . append ( run length ) ; dest . append ( current char ) ; } return dest . to string ( ) ; }	returns encoded string . for example , converts " wwwwwwwwwwwwbwwwwwwwwwwwwbbb " to " 12w1b12w3b ".
public void add primer ( string module filename , string extended module name ) { tla buffer . append ( resource helper . get extending module content ( module filename , extended module name ) ) ; }	add file header , which consists of the module - beginning - - - - - module.
public boolean is unique ( ) { return class id . equals ( stem ) ; }	is this spec unique or is it a class pattern ?.
public void test example keystore path ( ) { assert not null ( str + str + str , ssl . test keystore ) ; }	a trivial test that verifies the example keystore used for ssl testing can be found using the base class.
@ visible for testing protected void add oma ( string oma info ) { set < string > oma downloads = get stored download info ( pending oma downloads ) ; oma downloads . add ( oma info ) ; store download info ( pending oma downloads , oma downloads ) ; }	add oma download info to sharedprefs .
final boolean is running or shutdown ( boolean shutdown ok ) { int rs = run state of ( ctl . get ( ) ) ; return rs == running || ( rs == shutdown && shutdown ok ) ; }	state check needed by scheduledthreadpoolexecutor to enable running tasks during shutdown .
public void wait for id to unlock ( final id id , final long timeout ) { if ( timeout <= num ) { throw new illegal argument exception ( str ) ; } final long start time = system . current time millis ( ) ; long left to wait = timeout ; while ( left to wait > num && ! is unlocked ( id ) ) { synchronized ( m wait for lock ) { if ( is unlocked ( id ) ) { return ; } try { m wait for lock . wait ( left to wait ) ; } catch ( final interrupted exception e ) { } left to wait = start time + timeout - system . current time millis ( ) ; } } }	wait until the given id is unlocked.
static string format debug time ( long unix time , long now ) { time time = new time ( ) ; time . set ( unix time ) ; long delta = unix time - now ; if ( delta > date utils . minute in millis ) { delta /= date utils . minute in millis ; return string . format ( str , unix time , time . format ( str ) , delta ) ; } else { delta /= date utils . second in millis ; return string . format ( str , unix time , time . format ( str ) , delta ) ; } }	format given time for debugging output .
public static file ensure log directory exists ( ) { if ( m log directory == null ) { return null ; } if ( ! m log directory . exists ( ) ) { m log directory . mkdirs ( ) ; } return m log directory ; }	check if the log directory exists . create it if it s not created.
protected void require arguments ( string ... names ) { string builder missing = new string builder ( ) ; for ( string name : names ) { if ( ! has argument ( name ) ) { if ( missing . length ( ) > num ) { missing . append ( str ) ; } missing . append ( name ) ; } } if ( missing . length ( ) > num ) { throw new command exception ( str + missing ) ; } }	requires that the specified arguments are present .
public void action performed ( action event e ) { j target = get text component ( e ) ; if ( target != null ) { int selected index ; rectangle visible = new rectangle ( ) ; target . compute visible rect ( visible ) ; if ( left ) { visible . x = math . max ( num , visible . x - visible . width ) ; } else { visible . x += visible . width ; } selected index = target . get caret position ( ) ; if ( selected index != - num ) { if ( left ) { selected index = target . view to model ( new point ( visible . x , visible . y ) ) ; } else { selected index = target . view to model ( new point ( visible . x + visible . width - num , visible . y + visible . height - num ) ) ; } document doc = target . get document ( ) ; if ( ( selected index != num ) && ( selected index > ( doc . get length ( ) - num ) ) ) { selected index = doc . get length ( ) - num ; } else if ( selected index < num ) { selected index = num ; } if ( select ) target . move caret position ( selected index ) ; else target . set caret position ( selected index ) ; } } }	the operation to perform when this action is triggered .
public static void click button by label ( string text ) { if ( verbose ) { log ( str + text + str ) ; } button b = ( button ) find label text ( text ) ; wait for ( num ) ; b . pressed ( ) ; wait for ( num ) ; b . released ( ) ; wait for ( num ) ; }	clicks the button with the given label.
private int parse fuzziness ( state state ) { char slop text [ ] = new char [ state . length ] ; int slop length = num ; if ( state . data [ state . index ] == str ) { while ( state . index < state . length ) { state . index ++ ; if ( state . index < state . length ) { if ( token finished ( state ) ) { break ; } slop text [ slop length ] = state . data [ state . index ] ; slop length ++ ; } } int fuzziness = num ; try { fuzziness = integer . parse int ( new string ( slop text , num , slop length ) ) ; } catch ( number format exception e ) { } if ( fuzziness < num ) { fuzziness = num ; } return fuzziness ; } return num ; }	helper parsing fuzziness from parsing state.
public double pdf ( double x ) { double diff = x - mean ; return sqrt inv * math . exp ( - ( diff * diff ) / ( num * variance ) ) ; }	returns the probability distribution function .
public void repaint panel ( ) { remove all ( ) ; initialize layout ( ) ; repaint ( ) ; }	called to repaint the panel based on changes in the to the selected synapse type .
private string format boolean value ( boolean val ) { return string . value of ( val ? num : num ) ; }	formats boolean value into a string one .
public void clear image ( ) { clear image int ( ) ; m crop overlay view . set initial crop window rect ( null ) ; }	clear the current image set for cropping .
public static string remove dot from file extension ( string file ext ) { string tem file ext = file ext ; if ( file ext . char at ( num ) == str ) { tem file ext = file ext . substring ( num , file ext . length ( ) ) ; } return tem file ext ; }	removes the leading '.
private void bcopy ( int cidx , int bidx ) { int length = m ch idx - cidx ; if ( ( bidx + length + num ) >= m buff . length ) { char buff [ ] = new char [ m buff . length + length ] ; system . arraycopy ( m buff , num , buff , num , m buff . length ) ; m buff = buff ; } system . arraycopy ( m chars , cidx , m buff , bidx , length ) ; m buff idx += length ; }	appends ( mchidx - cidx ) characters from character buffer ( mchars ) to parser ' s buffer ( mbuff ) .
public void save ( @ not null progress indicator progress ) { if ( is sources modified ( ) ) { repository source provider user source provider = get user source provider ( ) ; assert user source provider != null ; user source provider . save ( new repo progress indicator adapter ( progress ) ) ; reset ( ) ; } }	save any changes the user has made .
public synchronized result remove ( int index ) { result result ; date date ; date = m . remove ( index ) ; m . remove ( date ) ; m . remove ( date ) ; result = m . remove ( date ) ; return result ; }	removes the specified entry .
public boolean has trace exit restrictions ( ) { for ( int index = first layer ( ) ; index <= last layer ( ) ; ++ index ) { collection < brd trace exit restriction > curr exit restrictions = get trace exit restrictions ( index ) ; if ( curr exit restrictions . size ( ) > num ) return bool ; } return bool ; }	returns true , if this pin has exit restrictions on some kayer .
public static string format time ( string millis ) { string result ; try { long time = long . value of ( millis ) ; result = format time ( time ) ; } catch ( number format exception e ) { throw new illegal argument exception ( str + millis ) ; } return result ; }	convert the time it took to compute these results into a label to add to the scorecard .
@ override public boolean add ( e o ) { return offer ( o ) ; }	adds the specified object to the priority queue .
private void select clicked ( mouse event e , boolean only outside ) { int index = location to index ( e . get point ( ) ) ; rectangle bounds = get cell bounds ( index , index ) ; if ( bounds != null && bounds . contains ( e . get point ( ) ) ) { if ( ! only outside ) { if ( is selected index ( index ) ) { add selection interval ( index , index ) ; } else { set selected index ( index ) ; } } } else { clear selection ( ) ; } }	adds selection of the clicked element , or removes selection if no element was clicked .
public double full path distance ( final distance style distance style ) { synchronized ( full distance cache ) { double dist = full distance cache . get ( distance style ) ; if ( dist == null ) { dist = new double ( distance style . compute distance ( start , end . x , end . y , end . z ) ) ; full distance cache . put ( distance style , dist ) ; } return dist . double value ( ) ; } }	compute the full distance along this path segment .
public player visited zones condition ( string ... zones ) { this . zone names = new linked list < string > ( ) ; for ( string zone : zones ) { zone names . add ( zone ) ; } }	creates a new playervisitedzonescondition.
public groovy class loader ( class loader loader ) { this ( loader , null ) ; }	creates a groovyclassloader using the given classloader as parent.
@ override public void window deactivated ( window event e ) { }	invoked when a window is deactivated.
public void add sprite ( odor world entity sprite ) { sprites . add ( sprite ) ; }	adds a odorworldentity object to this map .
public void free use count ( ) { if ( indirect source != null ) { indirect source . free use count ( ) ; } else if ( use count != null ) { if ( use count . decrement and get ( ) < num ) { close self ( ) ; } } }	frees a use - counter , so getinputstream can be called multiple times .
public void close jdbc ( statement stmt ) { try { if ( stmt != null ) { stmt . close ( ) ; } } catch ( sql sqle ) { subclass log wrapper ( str ) ; } }	closes database statement and logs if an error is encountered.
public void test negate positive ( ) { string a = str ; int a scale = num ; string c = str ; int c scale = num ; big decimal a number = new big decimal ( new big integer ( a ) , a scale ) ; big decimal c number = new big decimal ( new big integer ( c ) , c scale ) ; assert equals ( str , c number , a number . negate ( ) ) ; }	negate ( ) for a positive bigdecimal.
public string statement to code string ( int i ) { string builder one statement = new string builder ( ) ; sequence . append code ( one statement , i ) ; return one statement . to string ( ) ; }	return the code representation of the i ' th statement .
private byte skip tag forward ( ) { int initial char index = char index ; while ( char index < length ) { last char = text . char at ( char index ++ ) ; if ( last char == str ) { return character . directionality whitespace ; } if ( last char == str || last char == str ) { char quote = last char ; while ( char index < length && ( last char = text . char at ( char index ++ ) ) != quote ) { } } } char index = initial char index ; last char = str ; return character . directionality other neutrals ; }	advances charindex forward through an html tag ( after the opening & lt ; has already been read ) and returns character.
public session info refresh ( session session , boolean reset ) throws session exception { id session id = session . get id ( ) ; if ( debug . message enabled ( ) ) { debug . message ( message format . format ( str + str , session id . to string ( ) , reset ) ) ; } return get session info ( session id , reset ) ; }	fetches the sessioninfo from the sessionservice .
public void next group ( ) { release ( ) ; }	move to a new sl that represents a new group of same - values - used in fifo group scanning.
public void assert not equals ( string assert id , string expected , string actual ) { framework . assert not equals ( this , assert id , expected , actual ) ; }	asserts that values of expected and actual are not equal .
protected void duplicate class ( diagnostic position pos , class symbol c ) { log . error ( pos , str , c . fullname ) ; }	complain about a duplicate class .
public static string create name identifier ( ) { string handle = null ; try { byte [ ] handle bytes = new byte [ num ] ; random generator . next bytes ( handle bytes ) ; handle = base64 . encode ( handle bytes ) ; if ( debug . message enabled ( ) ) { debug . message ( str + handle ) ; } } catch ( exception e ) { debug . message ( str + str + e . get message ( ) ) ; } return handle ; }	returns a name identifier.
public static long calculate server fee reverse ( long amount ) { long a = constants . server fee flat ; long b = amount + a ; long c = ( long ) ( ( b / ( num - constants . server fee percentage ) ) - b ) ; return math . min ( constants . server fee max , math . max ( constants . server fee min , c + a ) ) ; }	calculate server fee reverse .
private static void load extension bundles ( config server impl cs , config impl config , document doc , log log ) { element parent = get child by name ( doc . get document element ( ) , str ) ; element [ ] children = get children ( parent , str ) ; string str bundles ; map < string , bundle definition > extension bundles = new hash map < string , bundle definition > ( ) ; list < rh > extensions = new array list < rh > ( ) ; for ( element child : children ) { rh rhe ; try { rhe = new rh ( config , child ) ; if ( rhe . get start bundles ( ) ) rhe . deploy bundles ( ) ; extensions . add ( rhe ) ; } catch ( exception e ) { log . error ( str , e ) ; continue ; } bundle info [ ] bfs = rhe . get bundles ( ) ; bundle info bf ; bundle definition bd ; for ( int i = num ; i < bfs . length ; i ++ ) { bf = bfs [ i ] ; extension bundles . put ( bf . get symbolic name ( ) + str + bf . get version as string ( ) , bd = bf . to bundle definition ( ) ) ; try { if ( rhe . get start bundles ( ) ) { bundle b = bd . get bundle ( config ) ; os . start if necessary ( b ) ; } } catch ( bundle exception e ) { log . error ( str , e ) ; } } } config . set extensions ( extensions . to array ( new rh [ extensions . size ( ) ] ) ) ; config . set extension bundle defintions ( extension bundles ) ; }	loads the bundles defined in the extensions.
public static string string to8859 1 ( string str ) throws unsupported encoding exception { if ( str == null ) { return str ; } return new string ( str . get bytes ( str ) , str ) ; }	used to convert username - value , passwd or realm to 8859_1 encoding if all chars in string are within the 8859_1 ( latin 1 ) encoding range .
public boolean is debugging finer ( ) { return logger . is loggable ( level . finer ) ; }	test whether to log ' debug ' at ' finer ' level.
public static void select nodes with string ( final zy graph graph , final string search string ) { preconditions . check not null ( graph , str ) ; preconditions . check not null ( search string , str ) ; final graph searcher searcher = new graph searcher ( ) ; searcher . search ( graph helpers . get nodes ( graph ) , new array list < navi edge > ( ) , search string ) ; final list < search result > results = searcher . get results ( ) ; final list < navi node > result nodes = new array list < navi node > ( ) ; for ( final search result search result : results ) { result nodes . add ( ( navi node ) search result . get object ( ) ) ; } graph . select nodes ( result nodes , bool ) ; searcher . dispose ( ) ; }	selects all nodes of a graph that contain a given search string .
private void add block listeners ( tracker tracker ) { list < o > range = tracker . get range ( ) ; if ( log . is debug enabled ( ) ) { log . debug ( str + tracker . get train name ( ) + str + range . size ( ) + str ) ; } iterator < o > iter = range . iterator ( ) ; while ( iter . has next ( ) ) { add block listener ( iter . next ( ) , tracker ) ; } }	adds listeners to all blocks in the range of a tracker.
public synchronized void open write ( ) throws replicator exception , interrupted exception { if ( ! file . exists ( ) ) { throw new thl ( str + file . get name ( ) ) ; } try { buffered file data input bfdi = new buffered file data input ( file , buffer size ) ; check file header ( bfdi ) ; bfdi . close ( ) ; data output = new buffered file data output ( file , buffer size ) ; } catch ( io e ) { throw new thl ( str + file . get name ( ) , e ) ; } mode = access mode . write ; if ( log flush task != null ) log flush task . add log file ( this ) ; }	prepare the log file for writing.
public static boolean verify volumes in cg ( list < volume > volumes , block consistency group cg , db client db client ) { list < volume > cg volumes = block consistency group utils . get active vplex volumes in cg ( cg , db client , null ) ; return verify volumes in cg ( volumes , cg volumes , db client ) ; }	verifies if the passed volumes are all the volumes in the same backend arrays in the passed consistency group .
private void clean up streams ( exception inflight ) { if ( stream != null ) { try { stream . close ( ) ; stream = null ; } catch ( io close exception ) { inflight . add suppressed ( close exception ) ; } } if ( connection != null ) { byte [ ] buf = new byte [ num * num ] ; input stream es = connection . get error stream ( ) ; if ( es != null ) { try { try { while ( es . read ( buf ) > num ) { } } finally { es . close ( ) ; } } catch ( io error stream error ) { inflight . add suppressed ( error stream error ) ; } } } }	according to https : / / docs.
public void do filter ( final servlet request request , final servlet response response , final filter chain chain ) throws io , servlet exception { url rewriter url rewriter = get url rewriter ( request , response , chain ) ; final http servlet request hs request = ( http servlet request ) request ; final http servlet response hs response = ( http servlet response ) response ; url rewrite wrapped response url rewrite wrapped response = new url rewrite wrapped response ( hs response , hs request , url rewriter ) ; if ( status enabled && status server name matcher . is match ( request . get server name ( ) ) ) { string uri = hs request . get request uri ( ) ; if ( log . is debug enabled ( ) ) { log . debug ( str + uri ) ; } string context path = hs request . get context path ( ) ; if ( uri != null && uri . starts with ( context path + status path ) ) { show status ( hs request , url rewrite wrapped response ) ; return ; } } boolean request rewritten = bool ; if ( url rewriter != null ) { request rewritten = url rewriter . process request ( hs request , url rewrite wrapped response , chain ) ; } else { if ( log . is debug enabled ( ) ) { log . debug ( str ) ; } } if ( ! request rewritten ) { chain . do filter ( hs request , url rewrite wrapped response ) ; } }	the main method called for each request that this filter is mapped for .
@ override public string to string ( ) { string str = str ; for ( basic effect e : subeffects ) { str += e . to string ( ) + str ; } return ( ! subeffects . is empty ( ) ) ? str . substring ( num , str . length ( ) - num ) : str ; }	returns a string representation for the effect.
private e create using static create method ( ) throws checked analysis exception { method create method ; try { create method = database class . get method ( str , new class [ num ] ) ; } catch ( no such method exception e ) { return null ; } if ( ! modifier . is static ( create method . get modifiers ( ) ) ) { return null ; } if ( create method . get return type ( ) != database class ) { return null ; } try { return database class . cast ( create method . invoke ( null , new object [ num ] ) ) ; } catch ( invocation target exception e ) { throw new checked analysis exception ( str + database class . get name ( ) , e ) ; } catch ( illegal access exception e ) { throw new checked analysis exception ( str + database class . get name ( ) , e ) ; } }	try to create the database using a static create ( ) method .
public void test negate math context positive ( ) { string a = str ; int a scale = num ; int precision = num ; rounding mode rm = rounding mode . floor ; math context mc = new math context ( precision , rm ) ; string c = str ; int c scale = num ; big decimal a number = new big decimal ( new big integer ( a ) , a scale ) ; big decimal res = a number . negate ( mc ) ; assert equals ( str , c , res . to string ( ) ) ; assert equals ( str , c scale , res . scale ( ) ) ; }	negate ( mathcontext ) for a positive bigdecimal.
public static void flag document as corrected ( element element ) { document doc = element . get owner document ( ) ; if ( doc != null ) { doc . set user data ( str , str , null ) ; } }	flags a mini - language xml document as corrected .
protected void paint origin label ( d origin pnt , graphics graphics , map bean the map ) { if ( the map != null && origin pnt != null ) { om text = new om ( origin pnt . get y ( ) , origin pnt . get x ( ) , get origin label ( ) , om . justify center ) ; text . set baseline ( om . baseline bottom ) ; text . put attribute ( om . no rotate , boolean . true ) ; prepare label ( text ) ; text . generate ( the map . get rotated projection ( ) ) ; text . render ( graphics ) ; } }	paints the origin label of the range rings on the given graphics .
public static void clear log filters ( ) { if ( filters == null || filters . is empty ( ) ) { return ; } filters . clear ( ) ; }	remove all the log filters which have been added before .
public coder result unmappable result ( ) { assert ( error == null ) ; return coder result . unmappable for length ( is pair ? num : num ) ; }	returns an unmappable - input result object , with the appropriate input length , for the previously - parsed character .
public static boolean seek for v1 or v11 tag ( byte buffer byte buffer ) { byte [ ] buffer = new byte [ field tagid length ] ; byte buffer . get ( buffer , num , field tagid length ) ; return ( arrays . equals ( buffer , tag id ) ) ; }	does a v1tag or a v11tag exist.
private void setup ui ( ) { content pane = new j ( ) ; content pane . set layout ( new border layout ( num , num ) ) ; split pane = new j ( ) ; content pane . add ( split pane , border layout . center ) ; final j scroll pane1 = new j ( ) ; split pane . set left component ( scroll pane1 ) ; method list = new j ( ) ; scroll pane1 . set viewport view ( method list ) ; final j scroll pane2 = new j ( ) ; split pane . set right component ( scroll pane2 ) ; method detail table = new j ( ) ; scroll pane2 . set viewport view ( method detail table ) ; }	method generated by intellij idea gui designer > > > important ! ! < < < do not edit this method or call it in your code !.
public void remove ( int index ) { entries . remove ( index ) ; }	removes the entry at the specified position in the table .
public string build activiti id string ( string namespace cd , string job name ) { map < string , string > path to token value map = new hash map < > ( ) ; path to token value map . put ( get namespace token ( ) , namespace cd ) ; path to token value map . put ( get job name token ( ) , job name ) ; string activiti id = get activiti job definition template ( ) ; for ( map . entry < string , string > map entry : path to token value map . entry set ( ) ) { activiti id = activiti id . replace all ( map entry . get key ( ) , map entry . get value ( ) ) ; } return activiti id ; }	returns activiti id constructed according to the template defined .
public string ruby type name ( type ref type ref ) { switch ( type ref . get kind ( ) ) { case type message : return ruby type name for proto element ( type ref . get message type ( ) ) ; case type enum : return ruby type name for proto element ( type ref . get enum type ( ) ) ; default : { string name = primitive type names . get ( type ref . get kind ( ) ) ; if ( ! strings . is null or empty ( name ) ) { return name ; } throw new illegal argument exception ( str + type ref . get kind ( ) ) ; } } }	returns the name of ruby class for the given typeref .
private v find virtual volume after device migration ( string original volume name , v migration info , list < v > cluster info list ) { v virtual volume info = null ; v discovery mgr = vplex api client . get discovery manager ( ) ; for ( v cluster info : cluster info list ) { string cluster name = cluster info . get name ( ) ; virtual volume info = discovery mgr . find virtual volume ( cluster name , original volume name , bool ) ; if ( virtual volume info != null ) { s logger . info ( str , original volume name , cluster name ) ; break ; } else { string virtual volume name = migration info . get target ( ) ; virtual volume info = discovery mgr . find virtual volume ( cluster name , virtual volume name , bool ) ; if ( virtual volume info != null ) { s logger . info ( str , virtual volume name , cluster name ) ; break ; } else { virtual volume name += v . virtual volume suffix ; virtual volume info = discovery mgr . find virtual volume ( cluster info . get name ( ) , virtual volume name , bool ) ; if ( virtual volume info != null ) { s logger . info ( str , virtual volume name , cluster name ) ; break ; } } } } return virtual volume info ; }	finds the virtual volume after a device migration .
private static final boolean is supplementary ( int ch ) { return ch >= character . min supplementary code point || character . is surrogate ( ( char ) ch ) ; }	determines if the specified code point is a supplementary character or unpaired surrogate .
public builder add service ( action service service ) { if ( service == null ) { throw new illegal argument exception ( str ) ; } if ( service . get supported annotation type ( ) == null ) { throw new illegal argument exception ( str ) ; } services . add ( service ) ; return this ; }	add an service for action processing.
protected boolean compute children ( openable element info info , file underlying resource ) throws java model exception { hashtable of array to object raw package info = new hashtable of array to object ( ) ; i [ ] children ; zip file jar = null ; try { string compliance = compiler options . version 1 8 ; jar = get jar ( ) ; raw package info . put ( char operation . no strings , new array list [ ] { empty list , empty list } ) ; for ( enumeration e = jar . entries ( ) ; e . has more elements ( ) ; ) { zip entry member = ( zip entry ) e . next element ( ) ; init raw package info ( raw package info , member . get name ( ) , member . is directory ( ) , compliance ) ; } children = new i [ raw package info . size ( ) ] ; int index = num ; for ( int i = num , length = raw package info . key table . length ; i < length ; i ++ ) { string [ ] pkg name = ( string [ ] ) raw package info . key table [ i ] ; if ( pkg name == null ) continue ; children [ index ++ ] = get package fragment ( pkg name ) ; } } catch ( core exception e ) { if ( e . get cause ( ) instanceof zip exception ) { util . log ( i . error , str + to string with ancestors ( ) ) ; children = no elements ; } else if ( e instanceof java model exception ) { throw ( java model exception ) e ; } else { throw new java model exception ( e ) ; } } finally { manager . close zip file ( jar ) ; } info . set children ( children ) ; ( ( jar package fragment root info ) info ) . raw package info = raw package info ; return bool ; }	compute the package fragment children of this package fragment root.
@ override public string filter ( string value , string previous value ) { if ( previous value != null && value . length ( ) > previous value . length ( ) ) return value ; return value . equals ( str ) || value . equals ( str ) ? str : value ; }	the default filter removes the display of ' 0 ' or ' 0.
private void free ( ) { off heap stored object chunk = chunks . remove ( random . next int ( chunks . size ( ) ) ) ; total allocation -= chunk . get size ( ) ; chunk . release ( ) ; }	frees a random chunk from the chunk list .
public sql ( throwable the cause ) { this ( the cause == null ? null : the cause . to string ( ) , null , num , the cause ) ; }	creates an sqlexception object.
private boolean is numeric string ( final string s ) { int i = num ; if ( s . length ( ) == num ) { return bool ; } final char [ ] chars = s . to char array ( ) ; boolean seen dot = bool ; if ( chars [ num ] == str || chars [ num ] == str ) { i ++ ; } while ( i < s . length ( ) ) { if ( chars [ i ] == str ) { if ( seen dot ) { return bool ; } seen dot = bool ; } else if ( chars [ i ] < str || chars [ i ] > str ) { return bool ; } i ++ ; } return bool ; }	check whether the string is a decimal numeric string .
public void test a b ( ) throws exception { bridge brokers ( str , str ) ; bridge brokers ( str , str ) ; start all brokers ( ) ; wait for bridge formation ( ) ; destination dest = create destination ( str , bool ) ; message consumer client c = create consumer ( str , dest ) ; send messages ( str , dest , message count ) ; thread . sleep ( num ) ; message id list msgs c = get consumer messages ( str , client c ) ; assert equals ( num , msgs c . get message count ( ) ) ; }	brokera - > brokerb - > brokerc.
@ override protected final void close no lock ( string reason ) { if ( is closed . compare and set ( bool , bool ) ) { assert rwl . is write locked by current thread ( ) || fail engine lock . is held by current thread ( ) : str ; try { this . version map . clear ( ) ; try { io . close ( searcher manager ) ; } catch ( throwable t ) { logger . warn ( str , t ) ; } try { io . close ( translog ) ; } catch ( throwable t ) { logger . warn ( str , t ) ; } logger . trace ( str ) ; try { index writer . rollback ( ) ; } catch ( already closed exception e ) { } logger . trace ( str ) ; } catch ( throwable e ) { logger . warn ( str , e ) ; } finally { store . dec ref ( ) ; logger . debug ( str , reason ) ; } } }	closes the engine without acquiring the write lock.
private list < object > execute group by ( profile measurement m ) { list < object > groups = new array list < > ( ) ; if ( ! is empty ( m . get group by ( ) ) ) { try { bean map measure as map = new bean map ( m ) ; for ( string expr : m . get group by ( ) ) { object result = executor . execute ( expr , measure as map , object . class ) ; groups . add ( result ) ; } } catch ( throwable e ) { string msg = format ( str , e . get message ( ) , m . get profile name ( ) , m . get entity ( ) ) ; throw new parse exception ( msg , e ) ; } } return groups ; }	executes each of the ' groupby ' expressions.
public static void safe close ( input stream in ) { try { if ( in != null ) in . close ( ) ; } catch ( io e ) { } }	closes a stream and ignores any resulting exception .
public static string expand line ( char sequence self , int tab stop ) { string s = self . to string ( ) ; int index ; while ( ( index = s . index of ( str ) ) != - num ) { string builder builder = new string builder ( s ) ; int count = tab stop - index % tab stop ; builder . delete char at ( index ) ; for ( int i = num ; i < count ; i ++ ) builder . insert ( index , str ) ; s = builder . to string ( ) ; } return s ; }	expands all tabs into spaces.
private bsh method [ ] flatten method collection ( enumeration e ) { vector v = new vector ( ) ; while ( e . has more elements ( ) ) { object o = e . next element ( ) ; if ( o instanceof bsh method ) v . add element ( o ) ; else { vector ov = ( vector ) o ; for ( int i = num ; i < ov . size ( ) ; i ++ ) v . add element ( ov . element at ( i ) ) ; } } bsh method [ ] bma = new bsh method [ v . size ( ) ] ; v . copy into ( bma ) ; return bma ; }	flatten the vectors of overloaded methods to a single array .
public static string print line ( string a , int num ) { string builder builder = new string builder ( ) ; for ( int i = num ; i < num ; i ++ ) { builder . append ( a ) ; } return builder . to string ( ) ; }	below method will create string like " * * * * * * * * * * * ".
public connection connect ( ) throws sql { properties p = new properties ( ) ; if ( is sybase ( ) ) { p . set property ( str , str ) ; p . set property ( str , str ) ; } p . set property ( str , user ) ; p . set property ( str , password ) ; return driver . connect ( uri , p ) ; }	connect to the database and return the connection .
public void remove on tag select listener ( tags select listener listener ) { if ( select listeners != null ) { select listeners . remove ( listener ) ; } }	removing selection items listener.
private static void create and show gui ( ) { j frame = new j ( str ) ; frame . set default close operation ( j . exit on close ) ; add components to pane ( frame . get content pane ( ) ) ; frame . pack ( ) ; frame . set visible ( bool ) ; }	create the gui and show it.
public int next ( ) { tree node n = stack . pop ( ) ; push all ( n . right ) ; return n . val ; }	to get the next smallest value.
public publisher merge < t > merge additional source ( publisher < ? extends t > source , int function < supplier < ? extends queue < t > > > new queue supplier ) { int n = sources . length ; @ suppress warnings ( str ) publisher < ? extends t > [ ] new array = new publisher [ n + num ] ; system . arraycopy ( sources , num , new array , num , n ) ; new array [ n ] = source ; supplier < ? extends queue < t > > new main queue ; int mc = max concurrency ; if ( mc != integer . max value ) { mc ++ ; new main queue = new queue supplier . apply ( mc ) ; } else { new main queue = main queue supplier ; } return new publisher merge < > ( new array , delay error , mc , new main queue , prefetch , inner queue supplier ) ; }	returns a new instance which has the additional source to be merged together with the current array of sources.
@ target api ( lollipop ) private bonjour event new bonjour event ( bonjour event . type type , nsd service info service info ) { bonjour service . builder service builder = new bonjour service . builder ( service info . get service name ( ) , service info . get service type ( ) ) ; if ( build . version . sdk int >= lollipop ) { map < string , byte [ ] > attributes = service info . get attributes ( ) ; for ( string key : attributes . key set ( ) ) { service builder . add txt record ( key , new string ( attributes . get ( key ) , charset . for name ( str ) ) ) ; } } service builder . add address ( service info . get host ( ) ) ; service builder . set port ( service info . get port ( ) ) ; return new bonjour event ( type , service builder . build ( ) ) ; }	creates a new bonjourevent instance from an nsd service info object .
static private string short ( ) { short temp value = short . max value ; return string . value of ( temp value ) ; }	get the max value for a short.
public void append ( final char c ) { builder . append ( c ) ; }	directly append the given character .
@ suppress warnings ( str ) public boolean add telegram writer ( telegram writer new writer ) { return ( telegram writers . add ( new writer ) ) ; }	add a new writer to be notified about new telegrams.
private resource pack icon ( int dpi , bitmap icon ) { resource res = new resource ( ) ; res . dpi = dpi ; byte array output stream os = new byte array output stream ( ) ; if ( icon . compress ( image format , image compression quality , os ) ) { res . data = os . to byte array ( ) ; } return res ; }	serialize an icon resource for persistence , including a checksum wrapper .
public void retain ( ) { bbl list . add ( this ) ; }	ensure that this blockbosslogic object is available for later retrieval.
public enumeration < option > list options ( ) { vector < option > new vector = new vector < option > ( ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str + str , str , num , str ) ) ; new vector . add element ( new option ( str + str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str + str + str + str + str + str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add element ( new option ( str , str , num , str ) ) ; new vector . add all ( collections . list ( super . list options ( ) ) ) ; return new vector . elements ( ) ; }	returns an enumeration describing the available options .
bcrsa ( rsa spec ) { this . modulus = spec . get modulus ( ) ; this . public exponent = spec . get public exponent ( ) ; this . private exponent = spec . get private exponent ( ) ; this . prime p = spec . get prime p ( ) ; this . prime q = spec . get prime q ( ) ; this . prime exponent p = spec . get prime exponent p ( ) ; this . prime exponent q = spec . get prime exponent q ( ) ; this . crt coefficient = spec . get crt coefficient ( ) ; }	construct a private key from an rsaprivatecrtkeyspec.
private void morph ( hg instance handle , hg old type , hg new type ) { hg [ ] layout = store . get link ( instance handle ) ; object old instance = raw make ( layout , old type , instance handle ) ; type utils . release value ( this , old type , layout [ num ] ) ; index by value . remove entry ( layout [ num ] , instance handle ) ; layout [ num ] = type utils . store value ( this , old instance , new type ) ; index by value . add entry ( layout [ num ] , instance handle ) ; store . store ( instance handle , layout ) ; object new instance = raw make ( layout , new type , instance handle ) ; hg instance live handle = cache . get ( instance handle ) ; if ( instance live handle != null && instance live handle . get ref ( ) != null ) cache . atom refresh ( instance live handle , new instance , bool ) ; if ( old instance instanceof hg ) { hg < hg > rs = null ; try { rs = index by type . find ( instance handle ) ; if ( rs . has next ( ) && ! ( new instance instanceof hg ) ) throw new hg ( str + instance handle + str ) ; old type = ( hg ) old instance ; new type = ( hg ) new instance ; while ( rs . has next ( ) ) { morph ( ( hg ) rs . next ( ) , old type , new type ) ; } } finally { if ( rs != null ) rs . close ( ) ; } } }	change the type value of an atom value.
private addressing mode two generator ( ) { }	the addressingmodegenerator class takes the addressing_mode operand of an arm instruction and provides the result of the computation within the operand to the caller.
public static d from radians ( double angle in rad , double magnitude ) { double x = magnitude * math . cos ( angle in rad ) ; double y = magnitude * math . sin ( angle in rad ) ; return new d ( x , y ) ; }	create a 2d vector from an angle relative to the positive x - axis and a magnitude.
protected void elemental to semantic ( ) { if ( ! is sparse ) { logger . warning ( str + str ) ; return ; } voting record = new array list < fixed bit set > ( ) ; voting record . add ( ( fixed bit set ) bit set . clone ( ) ) ; total number of votes . set ( num ) ; temp set = new fixed bit set ( dimension ) ; is sparse = bool ; }	automatically translate elemental vector ( no storage capacity ) into semantic vector ( storage capacity initialized , this will occupy ram ).
public void write state ( data output stream stream ) throws io { int len = mt . length ; for ( int x = num ; x < len ; x ++ ) stream . write int ( mt [ x ] ) ; len = mag01 . length ; for ( int x = num ; x < len ; x ++ ) stream . write int ( mag01 [ x ] ) ; stream . write int ( mti ) ; stream . write double ( next next gaussian ) ; stream . write boolean ( have next next gaussian ) ; }	writes the entire state of the mersennetwister rng to the stream.
final byte [ ] compute ( byte type , byte buf [ ] , int offset , int len , boolean is simulated ) { if ( mac alg . size == num ) { return null mac ; } if ( ! is simulated ) { byte [ ] additional = acquire authentication bytes ( type , len ) ; mac . update ( additional ) ; } mac . update ( buf , offset , len ) ; return mac . do final ( ) ; }	computes and returns the mac for the data in this byte array .
protected object visit ( binary logic operator filter , object extra data ) { logger . finer ( str ) ; final list < filter builder > filter list = new array list < > ( ) ; for ( final filter child : filter . get children ( ) ) { child . accept ( this , extra data ) ; filter list . add ( filter builder ) ; } final filter builder [ ] filters ; filters = filter list . to array ( new filter builder [ filter list . size ( ) ] ) ; if ( extra data . equals ( str ) ) { filter builder = filter builders . and filter ( filters ) ; } else { filter builder = filter builders . or filter ( filters ) ; } return extra data ; }	common implementation for binarylogicoperator filters.
@ safe varargs public static < t > set < t > as set ( final t ... array ) { set < t > array set = new hash set < t > ( array . length ) ; collections . add all ( array set , array ) ; return array set ; }	returns the specified array as a set of elements . < p / >.
private map < string , set < string > > find missing classes ( map < string , set < string > > deps , set < string > zip classes ) { map < string , set < string > > missing = new tree map < string , set < string > > ( ) ; for ( entry < string , set < string > > entry : deps . entry set ( ) ) { string name = entry . get key ( ) ; for ( string dep : entry . get value ( ) ) { if ( ! zip classes . contains ( dep ) ) { set < string > set = missing . get ( dep ) ; if ( set == null ) { set = new tree set < string > ( ) ; missing . put ( dep , set ) ; } set . add ( name ) ; } } } return missing ; }	computes which classes fqcn were found as dependencies that are not listed in the original jar classes .
private static url file to url ( file file ) { string name ; try { name = file . get canonical path ( ) ; } catch ( io e ) { name = file . get absolute path ( ) ; } name = name . replace ( file . separator char , str ) ; if ( ! name . starts with ( str ) ) { name = str + name ; } if ( ! file . is file ( ) ) { name = name + str ; } try { return new url ( str , str , name ) ; } catch ( url e ) { throw new illegal argument exception ( str ) ; } }	returns the directory or jar file url corresponding to the specified local file name .
public element select element matching x ( string xpath , element to search ) { list < element > results = select elements matching x ( xpath , to search ) ; if ( results . is empty ( ) ) { throw new element not found exception ( xpath , to search ) ; } element match = results . get ( num ) ; return match ; }	the following will search the given element for the specified xpath and return any node that matches .
public byte order mark ( string charset name , int ... bytes ) { if ( charset name == null || charset name . length ( ) == num ) { throw new illegal argument exception ( str ) ; } if ( bytes == null || bytes . length == num ) { throw new illegal argument exception ( str ) ; } this . charset name = charset name ; this . bytes = new int [ bytes . length ] ; system . arraycopy ( bytes , num , this . bytes , num , bytes . length ) ; }	construct a new bom .
public void failover copy cancel ( rp copy to failover to ) throws recover point exception { recover point image management utils image manager = new recover point image management utils ( ) ; image manager . disable copy image ( functional api , copy to failover to ) ; }	cancel a failover operation , usually a failover after a failover without a swap .
public static boolean is jwt ( string data ) { string [ ] base64 = data . split ( str ) ; boolean val = bool ; try { val = is base64 encoded ( base64 [ num ] ) && is base64 encoded ( base64 [ num ] ) && is base64 encoded ( base64 [ num ] ) ; } catch ( index out of bounds exception e ) { return bool ; } return val ; }	check if the input is a json web token ( jwt ).
public static boolean is configured ( ) { return system . get property ( str ) != null ; }	checks if logger is already configured within this vm or not .
public int read ( byte [ ] buffer , int offset , int length ) throws io { return file . read ( buffer , offset , length ) ; }	reads a block starting from the current file pointer .
public static boolean is mac ( ) { return ( os . index of ( str ) >= num ) ; }	checks if is mac .
private void validate blocklet size ( ) { string blocklet size str = carbon properties . get property ( carbon common constants . blocklet size , carbon common constants . blocklet size default val ) ; try { int blocklet size = integer . parse int ( blocklet size str ) ; if ( blocklet size < carbon common constants . blocklet size min val || blocklet size > carbon common constants . blocklet size max val ) { logger . info ( str + blocklet size str + str + carbon common constants . blocklet size default val ) ; carbon properties . set property ( carbon common constants . blocklet size , carbon common constants . blocklet size default val ) ; } } catch ( number format exception e ) { logger . info ( str + blocklet size str + str + carbon common constants . blocklet size default val ) ; carbon properties . set property ( carbon common constants . blocklet size , carbon common constants . blocklet size default val ) ; } }	this method validates the blocklet size.
java source from string ( @ not null string name , string code ) { super ( uri . create ( str + name . replace ( str , str ) + kind . source . extension ) , kind . source ) ; this . code = code ; }	constructs a new javasourcefromstring .
public < e , d > void add mapped entity class ( class < e > entity class , class < d > dto class , jpa mapper < e , d > mapper ) { check not initialized ( ) ; if ( mappings . contains key ( dto class ) ) { throw new illegal argument exception ( dto class . get name ( ) + str ) ; } mappings . put ( dto class , new mapped registration < > ( entity class , dto class , mapper ) ) ; }	adds the given entity class which is mapped to a dto with the provided mapper .
public string to dot ( ) { string builder b = new string builder ( ) ; b . append ( str ) ; b . append ( str ) ; final int num states = get num states ( ) ; if ( num states > num ) { b . append ( str ) ; b . append ( str ) ; } transition t = new transition ( ) ; for ( int state = num ; state < num states ; state ++ ) { b . append ( str ) ; b . append ( state ) ; if ( is accept ( state ) ) { b . append ( str + state + str ) ; } else { b . append ( str + state + str ) ; } int num transitions = init transition ( state , t ) ; for ( int i = num ; i < num transitions ; i ++ ) { get next transition ( t ) ; assert t . max >= t . min ; b . append ( str ) ; b . append ( state ) ; b . append ( str ) ; b . append ( t . dest ) ; b . append ( str ) ; append char string ( t . min , b ) ; if ( t . max != t . min ) { b . append ( str ) ; append char string ( t . max , b ) ; } b . append ( str ) ; } } b . append ( str ) ; return b . to string ( ) ; }	returns the dot ( graphviz ) representation of this automaton.
public static void validate ( string topic string , boolean wildcard allowed ) throws illegal state exception , illegal argument exception { int topic len = num ; try { topic len = topic string . get bytes ( str ) . length ; } catch ( unsupported encoding exception e ) { throw new illegal state exception ( e ) ; } if ( topic len < min topic len || topic len > max topic len ) { throw new illegal argument exception ( string . format ( str , new object [ ] { new integer ( min topic len ) , new integer ( max topic len ) } ) ) ; } if ( wildcard allowed ) { if ( strings . equals any ( topic string , new string [ ] { multi level wildcard , single level wildcard } ) ) { return ; } if ( strings . count matches ( topic string , multi level wildcard ) > num || ( topic string . contains ( multi level wildcard ) && ! topic string . ends with ( multi level wildcard pattern ) ) ) { throw new illegal argument exception ( str + topic string ) ; } validate single level wildcard ( topic string ) ; return ; } if ( strings . contains any ( topic string , topic wildcards ) ) { throw new illegal argument exception ( str ) ; } }	validate the topic name or topic filter.
public boolean is attacked by ( final i attacker ) { return attackers . contains ( attacker ) ; }	check if a specific entity is attacking this rpentity .
public int view to model ( float fx , float fy , shape a , position . bias [ ] bias ) { bias [ num ] = position . bias . forward ; rectangle alloc = a . get bounds ( ) ; r doc = ( r ) get document ( ) ; int x = ( int ) fx ; int y = ( int ) fy ; if ( y < alloc . y ) { return get start offset ( ) ; } else if ( y > alloc . y + alloc . height ) { return get end offset ( ) - num ; } else { element map = doc . get default root element ( ) ; int line index = math . abs ( ( y - alloc . y ) / line height ) ; if ( line index >= map . get element count ( ) ) return get end offset ( ) - num ; element line = map . get element ( line index ) ; if ( x < alloc . x ) return line . get start offset ( ) ; else if ( x > alloc . x + alloc . width ) return line . get end offset ( ) - num ; else { int p0 = line . get start offset ( ) ; token token list = doc . get token list for line ( line index ) ; tab base = alloc . x ; int offs = token list . get list offset ( ( r ) get container ( ) , this , tab base , x ) ; return offs != - num ? offs : p0 ; } } }	provides a mapping from the view coordinate space to the logical coordinate space of the model .
public void test max unequal2 ( ) { string a = str ; int a scale = num ; string b = str ; int b scale = num ; string c = str ; int c scale = num ; big decimal a number = new big decimal ( new big integer ( a ) , a scale ) ; big decimal b number = new big decimal ( new big integer ( b ) , b scale ) ; big decimal c number = new big decimal ( new big integer ( c ) , c scale ) ; assert equals ( str , c number , a number . max ( b number ) ) ; }	max ( ) for unequal bigdecimals.
public void remove pause listener ( animator pause listener listener ) { if ( m pause listeners == null ) { return ; } m pause listeners . remove ( listener ) ; if ( m pause listeners . size ( ) == num ) { m pause listeners = null ; } }	removes a pause listener from the set listening to this animation .
public void show error ( drawable error image drawable , string error text title , string error text content , string error button text , view . on click listener on click listener ) { switch state ( error , error image drawable , error text title , error text content , error button text , on click listener , collections . < integer > empty list ( ) ) ; }	show error view with a button when something goes wrong and prompting the user to try again.
public boolean column ( int nrows , int capacity , boolean default value ) { super ( boolean . class , new boolean ( default value ) ) ; if ( capacity < nrows ) { throw new illegal argument exception ( str ) ; } m bits = new bit set ( capacity ) ; m bits . set ( num , capacity , default value ) ; m size = nrows ; }	create a new booleancolumn .
public x509 cert path impl ( list certs ) throws certificate exception { super ( str ) ; int size = certs . size ( ) ; certificates = new array list ( size ) ; for ( int i = num ; i < size ; i ++ ) { object cert = certs . get ( i ) ; if ( ! ( cert instanceof x509 certificate ) ) { throw new certificate exception ( str ) ; } certificates . add ( cert ) ; } }	creates an instance of x.
public void add tree model listener ( tree model listener l ) { tree model listeners . add element ( l ) ; }	adds a listener for the treemodelevent posted after the tree changes .
public int right x value ( int p y ) { int result = math . min ( oct rx , oct urx - p y ) ; return math . min ( result , oct lrx + p y ) ; }	computes the x value of the right boundary of this octagon at p_y.
public static string rjust ( string str , int column width ) { return string . format ( str + column width + str , str ) ; }	this should not be in this class , move to a dedicated ascii - art class when appropriate.
public void parse package ( dynamic apk manager dpkg , context context , file apk file ) { if ( is apk file ( apk file ) ) { parse base package ( dpkg , context , apk file ) ; } else if ( apk file . is directory ( ) ) { file [ ] apk files = apk file . list files ( ) ; if ( apk files != null && apk files . length > num ) { for ( file file : apk files ) { parse package ( dpkg , context , file ) ; } } } }	parse the given apk file , treating it as as a single monolithic package . < p >.
int append slot ( int w0 , int w1 , int w2 , int w3 ) { { final int slotsize = num ; int newoffset = ( last used + num ) * slotsize ; int chunkpos = newoffset > > lowbits ; int slotpos = ( newoffset & lowmask ) ; if ( chunkpos > chunks . size ( ) - num ) chunks . add element ( new int [ chunkalloc ] ) ; int [ ] chunk = chunks . element at ( chunkpos ) ; chunk [ slotpos ] = w0 ; chunk [ slotpos + num ] = w1 ; chunk [ slotpos + num ] = w2 ; chunk [ slotpos + num ] = w3 ; return ++ last used ; } }	append a 4 - integer record to the cia , starting with record 1.
public string next token ( ) { string result = null ; synchronized ( this ) { if ( is empty ( ) ) { return null ; } else { if ( is eating blocks of delimiters ) { trim starting delimiters ( ) ; } int nearest delimeter = - num ; for ( int i = num ; i < delimiters . length ( ) ; i ++ ) { int delimiter = source . index of ( delimiters . char at ( i ) , current index ) ; if ( nearest delimeter == - num || delimiter != - num && delimiter < nearest delimeter ) { nearest delimeter = delimiter ; } } if ( nearest delimeter == - num ) { result = source . substring ( current index ) ; current index = source . length ( ) ; } else { result = source . substring ( current index , nearest delimeter ) ; current index = nearest delimeter + num ; if ( is eating blocks of delimiters ) { trim starting delimiters ( ) ; } } } } return result ; }	returns null if there is nothing left .
public static only branch coverage test fitness create only branch coverage test fitness ( control dependency cd ) { return create only branch coverage test fitness ( cd . get branch ( ) , cd . get branch expression value ( ) ) ; }	create a fitness function for branch coverage aimed at executing the given controldependency .
private set < emoticon > parse emoticons ( string json ) { set < emoticon > result = new hash set < > ( ) ; if ( json == null ) { return null ; } json parser = new json ( ) ; int errors = num ; try { json root = ( json ) parser . parse ( json ) ; json emoticons = ( json ) root . get ( str ) ; for ( object obj : emoticons ) { if ( obj instanceof json ) { json emote json = ( json ) obj ; emoticon emote = parse emoticon ( emote json ) ; if ( emote == null ) { if ( errors < num ) { logger . warning ( str + emote json ) ; } errors ++ ; } else { result . add ( emote ) ; } } } if ( errors > num ) { logger . warning ( errors + str ) ; } if ( errors > num ) { return null ; } return result ; } catch ( parse exception | null pointer exception | class cast exception ex ) { logger . warning ( str + ex ) ; return null ; } }	parses the list of emoticons from the twitch api .
private string copy ( final char [ ] array , final int start , final int end ) { string builder text = new string builder ( ) ; for ( int j = start ; j < end ; j ++ ) { text . append ( array [ j ] ) ; } return text . to string ( ) ; }	copies the specified interval of characters for the array .
public void redirect method call ( string old method name , ct method new method ) throws cannot compile exception { transformers = new transform call ( transformers , old method name , new method ) ; }	correct invocations to a method that has been renamed.
private string read line ( input stream input stream ) throws io { string buffer retval = new string buffer ( str ) ; while ( bool ) { char ch ; int i = input stream . read ( ) ; if ( i == - num ) { throw new io ( str ) ; } else ch = ( char ) i ; if ( this . max message size > num ) { this . size counter -- ; if ( this . size counter <= num ) throw new io ( str ) ; } if ( ch != str ) retval . append ( ch ) ; if ( ch == str ) { break ; } } return retval . to string ( ) ; }	read a line of input ( i cannot use buffered reader because we may need to switch encodings mid - stream !.
public void show error ( drawable error image drawable , string error text title , string error text content , string error button text , on click listener on click listener ) { switch state ( error , error image drawable , error text title , error text content , error button text , on click listener , collections . < integer > empty list ( ) ) ; }	show error view with a button when something goes wrong and prompting the user to try again.
void notify change ( ) { notify change ( inferencevars . diff ( restvars ( ) ) ) ; }	mark the inference context as complete and trigger evaluation of all deferred checks .
public boolean contains one category ( list categories ) { for ( iterator iter = categories . iterator ( ) ; iter . has next ( ) ; ) { group category category = ( group category ) iter . next ( ) ; if ( contains ( category ) ) return bool ; } return bool ; }	returns whether one of the given categories is contained in this set of group categories.
public static document read document ( input stream in , string encoding ) throws io , xml { try { input stream reader reader = new input stream reader ( in , encoding ) ; input source source = new input source ( new buffered reader ( reader ) ) ; document document ; try { document = document builder . parse ( source ) ; } catch ( sax e ) { throw new xml ( str , e ) ; } return document ; } finally { in . close ( ) ; } }	creates a document instance from a reader reading an xml input stream .
public static string tick to string ( string builder clslbls , long timestamp , long location , long elevation , object value ) { try { string builder sb = new string builder ( ) ; sb . append ( timestamp ) ; sb . append ( str ) ; if ( geo time serie . no location != location ) { double [ ] latlon = xp . from geo xp ( location ) ; sb . append ( latlon [ num ] ) ; sb . append ( str ) ; sb . append ( latlon [ num ] ) ; } sb . append ( str ) ; if ( geo time serie . no elevation != elevation ) { sb . append ( elevation ) ; } sb . append ( str ) ; if ( null != clslbls && clslbls . length ( ) > num ) { sb . append ( clslbls ) ; sb . append ( str ) ; } encode value ( sb , value ) ; return sb . to string ( ) ; } catch ( exception e ) { e . print stack trace ( ) ; } return null ; }	return a string representation of a gts measurement at ' tick '.
public static color hex to color ( string hex string ) { int decimal color ; decimal color = integer . parse int ( hex string , num ) ; return new color ( decimal color ) ; }	convert a hex string to a color object.
public static x509 cert impl to impl ( x509 certificate cert ) throws certificate exception { if ( cert instanceof x509 cert impl ) { return ( x509 cert impl ) cert ; } else { return x509 factory . intern ( cert ) ; } }	utility method to convert an arbitrary instance of x509certificate to a x509certimpl.
public nasip ( inet address ip ) { super ( nasip . to octets ( ip ) ) ; this . ip = ip ; }	construct an instance from the ip address of the nas originating the request .
private static int generate push param ( class file writer cfw , int param offset , class < ? > param type ) { if ( ! param type . is primitive ( ) ) { cfw . add a ( param offset ) ; return num ; } 