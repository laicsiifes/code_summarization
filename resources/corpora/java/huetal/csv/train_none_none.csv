code	desc
@ override public int runcommand ( boolean mergeerrorintooutput , string ... commands ) throws ioexception , interruptedexception { return runcommand ( mergeerrorintooutput , new arraylist < string > ( arrays . aslist ( commands ) ) ) ; }	runs a command on the command line synchronously .
private int findplv ( int m_pricelist_id ) { timestamp pricedate = null ; string datestr = env . getcontext ( env . getctx ( ) , p_windowno , _str ) ; if ( datestr != null && datestr . length ( ) > _num ) pricedate = env . getcontextasdate ( env . getctx ( ) , p_windowno , _str ) ; else { datestr = env . getcontext ( env . getctx ( ) , p_windowno , _str ) ; if ( datestr != null && datestr . length ( ) > _num ) pricedate = env . getcontextasdate ( env . getctx ( ) , p_windowno , _str ) ; } if ( pricedate == null ) pricedate = new timestamp ( system . currenttimemillis ( ) ) ; log . config ( _str + m_pricelist_id + _str + pricedate ) ; int retvalue = _num ; string sql = _str + _str + _str + _str + _str + _str ; try { preparedstatement pstmt = db . preparestatement ( sql , null ) ; pstmt . setint ( _num , m_pricelist_id ) ; resultset rs = pstmt . executequery ( ) ; while ( rs . next ( ) && retvalue == _num ) { timestamp pldate = rs . gettimestamp ( _num ) ; if ( ! pricedate . before ( pldate ) ) retvalue = rs . getint ( _num ) ; } rs . close ( ) ; pstmt . close ( ) ; } catch ( sqlexception e ) { log . log ( level . severe , sql , e ) ; } env . setcontext ( env . getctx ( ) , p_windowno , _str , retvalue ) ; return retvalue ; }	find price list version and update context.
public static boolean memoryislow ( ) { return availablememory ( ) * _num < runtime . totalmemory ( ) * _num ; }	returns true if less then 5 % of the available memory is free .
public string describeattributes ( ) { stringbuilder sb = new stringbuilder ( ) ; sb . append ( _str ) ; boolean first = _bool ; for ( object key : attributes . keyset ( ) ) { if ( first ) { first = _bool ; } else { sb . append ( _str ) ; } sb . append ( key ) ; sb . append ( _str ) ; sb . append ( attributes . get ( key ) ) ; } sb . append ( _str ) ; return sb . tostring ( ) ; }	returns a string representation of the object ' s current attributes.
public static byte [ ] nextbytes ( byte [ ] buffer ) { srandom . nextbytes ( buffer ) ; return buffer ; }	fill the given buffer with random bytes .
public void removeallfromdamaged ( final collection < unit > damagedunits ) { for ( final unit u : damagedunits ) { while ( m_damaged . contains ( u ) ) { m_damaged . remove ( u ) ; } } }	can have multiple of the same unit , to show multiple hits to that unit .
private ijavaelement [ ] computechildren ( arraylist nameswithoutextension ) { int size = nameswithoutextension . size ( ) ; if ( size == _num ) return no_elements ; ijavaelement [ ] children = new ijavaelement [ size ] ; for ( int i = _num ; i < size ; i ++ ) { string namewithoutextension = ( string ) nameswithoutextension . get ( i ) ; children [ i ] = new classfile ( this , manager , namewithoutextension ) ; } return children ; }	compute the children of this package fragment.
public object [ ] toarray ( ) { object [ ] result = new object [ size ] ; system . arraycopy ( elementdata , _num , result , _num , size ) ; return result ; }	returns an array containing all of the elements in this list in the correct order .
@ override protected void ondeletecomplete ( int token , object cookie , int result ) { if ( token == mdeletetoken ) { synchronized ( sdeletingthreadslock ) { sdeletingthreads = _bool ; if ( deletedebug ) { log . v ( tag , _str + sdeletingthreads ) ; } sdeletingthreadslock . notifyall ( ) ; } unreadbadgeservice . update ( mcontext ) ; notificationmanager . create ( mcontext ) ; } }	always call this super method from your overridden ondeletecomplete function .
private static ilaunchconfiguration createnewlaunchconfiguration ( iproject project ) throws coreexception , operationcanceledexception { string initialname = calculatelaunchconfigname ( project ) ; ilaunchconfiguration launchconfig = gwtsuperdevmodecodeserverlaunchutil . createlaunchconfig ( initialname , project ) ; return launchconfig ; }	create a new launch configuration .
protected long parsedate ( ) throws ioexception { if ( _utccalendar == null ) _utccalendar = calendar . getinstance ( timezone . gettimezone ( _str ) ) ; return parsedate ( _utccalendar ) ; }	parses a date value from the stream .
@ override public request < list < builderstatus > > builds ( projectreference projectreference ) { list < dummybuilderstatus > current = currentbuilderstatuses . get ( projectreference . name ( ) ) ; list < builderstatus > update = new arraylist < > ( ) ; if ( current != null ) { for ( dummybuilderstatus dummybuilderstatus : current ) { update . add ( dummybuilderstatus ) ; } } return new dummyrequest < > ( update ) ; }	gets the project builds for the given project.
public string lookahead ( ) { if ( buf != null ) { return new string ( buf , bufpos , buf . length - bufpos ) ; } else { return text . substring ( pos . getindex ( ) ) ; } }	returns a string containing the remainder of the characters to be returned by this iterator , without any option processing.
protected int entityindex ( entity entity ) { return arrays . binarysearch ( entities , entity ) ; }	check whether the device contains the specified entity.
public void runtest ( ) throws throwable { document doc ; nodelist elementlist ; node namenode ; characterdata child ; doc = ( document ) load ( _str , _bool ) ; elementlist = doc . getelementsbytagname ( _str ) ; namenode = elementlist . item ( _num ) ; child = ( characterdata ) namenode . getfirstchild ( ) ; { boolean success = _bool ; try { child . insertdata ( - _num , _str ) ; } catch ( domexception ex ) { success = ( ex . code == domexception . index_size_err ) ; } asserttrue ( _str , success ) ; } }	runs the test case .
public abstract boolean isloggable ( level level ) ;	" logger like " api to be used by rmi implementation.
public string replacetokens ( string querystring , string replacement , string ... nonreplacementtokenprefixes ) { matcher matcher = tokenpattern . matcher ( querystring ) ; stringbuffer buf = new stringbuffer ( ) ; while ( matcher . find ( ) ) { string origtoken = matcher . group ( _num ) ; if ( origtoken != null ) { matcher . appendreplacement ( buf , _str ) ; if ( tokenstartswithprefix ( origtoken , nonreplacementtokenprefixes ) ) { buf . append ( _str + origtoken + _str ) ; } else { buf . append ( replacement ) ; } } } matcher . appendtail ( buf ) ; return buf . tostring ( ) ; }	replaces a query string with tokens of format $ { token - name } with the specified replacement string for all tokens .
public boolean isplural ( ) { return typestring . contains ( suffix_plural ) ; }	determine if the expression is in plural form .
public void insert ( forceitem item ) { try { insert ( item , root , xmin , ymin , xmax , ymax ) ; } catch ( stackoverflowerror e ) { e . printstacktrace ( ) ; } }	inserts an item into the quadtree .
private void handlehovering ( int x , int y ) { handlecellhover ( x , y ) ; if ( columnheadersvisible ) { handlehoveroncolumnheader ( x , y ) ; } }	handles the assignment of the correct values to the hover * field variables that let the painting code now what to paint as hovered .
public static void drawcircledtext ( graphics2d g , font font , string text , int x , int y ) { graphics2d g2 = ( graphics2d ) g . create ( ) ; g2 . setfont ( font ) ; fontmetrics fm = g2 . getfontmetrics ( ) ; int padding = _num ; rectangle2d bounds = fm . getstringbounds ( text , g2 ) ; double th = bounds . getheight ( ) ; double tw = bounds . getwidth ( ) ; float radius = ( float ) ( math . max ( th , tw ) / _num + padding ) ; ellipse2d . float circle = new ellipse2d . float ( x - radius , y - radius , _num * radius + _num , _num * radius + _num ) ; g2 . fill ( circle ) ; g2 . setcolor ( color . black ) ; g2 . drawstring ( text , ( int ) ( x - tw / _num ) , ( y + fm . getascent ( ) / _num ) ) ; if ( debug ) { g2 . setcolor ( color . red ) ; g2 . drawline ( x - _num , y , x + _num , y ) ; g2 . drawline ( x , y - _num , x , y + _num ) ; } g2 . dispose ( ) ; }	utility function to draw a circle text centered at coordinates ( x , y ).
private void registerend ( final string prefixsingular , final string prefixplural , final string endstring ) { prefixendlist . add ( new prefixentry ( endstring , prefixsingular , prefixplural ) ) ; registerprefix ( prefixsingular , prefixplural ) ; }	define the singular and plural prefix strings for an item name to be matched at the end , for example " bottle of.
public void addobserver ( observer observer ) { observers . add ( observer ) ; }	sets the observer , which will observe the iterator returned in the next call to iterator ( ) method.
public string tostring ( ) { return _str + subjectpublickeyinfo . tostring ( ) + _str + subject + _str + _str + _str + attributeset . tostring ( ) + _str ; }	provides a short description of this request .
public systempropertiestablemodel ( ) { columnnames = new string [ _num ] ; columnnames [ _num ] = res . getstring ( _str ) ; columnnames [ _num ] = res . getstring ( _str ) ; data = new object [ _num ] [ _num ] ; }	construct a new systempropertiestablemodel .
public boolean canceljob ( long id , boolean ispersistent ) { jobholder holder ; synchronized ( getnextjoblock ) { if ( jobconsumerexecutor . isrunning ( id , ispersistent ) ) return _bool ; if ( ispersistent ) { synchronized ( persistentjobqueue ) { holder = persistentjobqueue . findjobbyid ( id ) ; if ( holder == null ) return _bool ; persistentjobqueue . remove ( holder ) ; } } else { synchronized ( nonpersistentjobqueue ) { holder = nonpersistentjobqueue . findjobbyid ( id ) ; if ( holder == null ) return _bool ; nonpersistentjobqueue . remove ( holder ) ; } } } basejob basejob = holder . getbasejob ( ) ; if ( dependencyinjector != null ) { dependencyinjector . inject ( basejob ) ; } basejob . oncancel ( ) ; return _bool ; }	cancels job which is waiting to be run .
public static boolean issimplematchpattern ( string str ) { return str . indexof ( _str ) != - _num ; }	is the str a simple match pattern .
public string readscript ( string fname ) throws ioexception { stringbuilder sb = new stringbuilder ( ) ; bufferedreader in = null ; try { if ( fname . startswith ( _str ) || fname . startswith ( _str ) ) { filesystem fs = filesystem . get ( configurationmanager . getcachedjobconf ( ) ) ; path scriptpath = new path ( fname ) ; in = new bufferedreader ( new inputstreamreader ( fs . open ( scriptpath ) ) ) ; } else { in = new bufferedreader ( new filereader ( fname ) ) ; } string tmp = null ; while ( ( tmp = in . readline ( ) ) != null ) { sb . append ( tmp ) ; sb . append ( _str ) ; } } finally { ioutilfunctions . closesilently ( in ) ; } return sb . tostring ( ) ; }	read a dml or pydml file as a string .
public static binaryfieldaccessor create ( field field , int id ) { binarywritemode mode = binaryutils . mode ( field . gettype ( ) ) ; switch ( mode ) { case p_byte : return new byteprimitiveaccessor ( field , id ) ; case p_boolean : return new booleanprimitiveaccessor ( field , id ) ; case p_short : return new shortprimitiveaccessor ( field , id ) ; case p_char : return new charprimitiveaccessor ( field , id ) ; case p_int : return new intprimitiveaccessor ( field , id ) ; case p_long : return new longprimitiveaccessor ( field , id ) ; case p_float : return new floatprimitiveaccessor ( field , id ) ; case p_double : return new doubleprimitiveaccessor ( field , id ) ; case byte : case boolean : case short : case char : case int : case long : case float : case double : case decimal : case string : case uuid : case date : case timestamp : case byte_arr : case short_arr : case int_arr : case long_arr : case float_arr : case double_arr : case char_arr : case boolean_arr : case decimal_arr : case string_arr : case uuid_arr : case date_arr : case timestamp_arr : case enum_arr : case object_arr : case binary_obj : case binary : return new defaultfinalclassaccessor ( field , id , mode , _bool ) ; default : return new defaultfinalclassaccessor ( field , id , mode , ! u . isfinal ( field . gettype ( ) ) ) ; } }	create accessor for the field .
private string result ( httpurlconnection conn , boolean input ) throws ioexception { stringbuffer sb = new stringbuffer ( ) ; if ( input ) { inputstream is = conn . getinputstream ( ) ; bufferedreader reader = new bufferedreader ( new inputstreamreader ( is , _str ) ) ; string line = null ; while ( ( line = reader . readline ( ) ) != null ) { sb . append ( line ) ; } reader . close ( ) ; is . close ( ) ; } map < string , object > result = new hashmap < string , object > ( ) ; result . put ( _str , conn . getresponsecode ( ) ) ; result . put ( _str , conn . getresponsemessage ( ) ) ; result . put ( _str , conn . getcontenttype ( ) ) ; result . put ( _str , sb ) ; string output = string . valueof ( conn . getresponsecode ( ) ) ; setoutputresponsecode ( output ) ; gson gson = new gson ( ) ; string json = gson . tojson ( result ) ; logger . info ( _str + json ) ; return json ; }	report the result in json way.
public boolean isbannedmethod ( string sig ) { return banned_methods . contains ( sig ) ; }	used by the specification create to check if a method is legal to put in the spec.
private void attachplot ( svgplot newplot ) { this . plot = newplot ; if ( newplot == null ) { super . setsvgdocument ( null ) ; return ; } newplot . synchronizewith ( synchronizer ) ; super . setsvgdocument ( newplot . getdocument ( ) ) ; super . setdisableinteractions ( newplot . getdisableinteractions ( ) ) ; }	attach to a new plot , and display .
public e take ( ) throws interruptedexception { final reentrantlock lock = this . lock ; lock . lockinterruptibly ( ) ; try { for ( ; ; ) { e first = q . peek ( ) ; if ( first == null ) available . await ( ) ; else { long delay = first . getdelay ( nanoseconds ) ; if ( delay <= _num ) return q . poll ( ) ; first = null ; if ( leader != null ) available . await ( ) ; else { thread thisthread = thread . currentthread ( ) ; leader = thisthread ; try { available . awaitnanos ( delay ) ; } finally { if ( leader == thisthread ) leader = null ; } } } } } finally { if ( leader == null && q . peek ( ) != null ) available . signal ( ) ; lock . unlock ( ) ; } }	retrieves and removes the head of this queue , waiting if necessary until an element with an expired delay is available on this queue .
public void shutdown ( ) throws exception { try { if ( solrclient != null ) solrclient . close ( ) ; list < callable < jettysolrrunner > > shutdowns = new arraylist < > ( jettys . size ( ) ) ; for ( final jettysolrrunner jetty : jettys ) { shutdowns . add ( null ) ; } jettys . clear ( ) ; collection < future < jettysolrrunner > > futures = executor . invokeall ( shutdowns ) ; exception shutdownerror = checkforexceptions ( _str , futures ) ; if ( shutdownerror != null ) { throw shutdownerror ; } } finally { executor . shutdown ( ) ; executor . awaittermination ( _num , timeunit . seconds ) ; try { if ( ! externalzkserver ) { zkserver . shutdown ( ) ; } } finally { system . clearproperty ( _str ) ; } } }	shut down the cluster , including all solr nodes and zookeeper.
private static control createrequestcontrol ( final class clazz , final class [ ] paramtypes , final object [ ] params ) { constructor constructor = classutils . getconstructorifavailable ( clazz , paramtypes ) ; if ( constructor == null ) { ldapexceptionutils . generateerrorexception ( ldaperrorcodes . err_10005_control_contructor_not_found , new string [ ] { clazz . tostring ( ) , stringutils . arraytocommadelimitedstring ( paramtypes ) } , logger ) ; } control result = null ; try { result = ( control ) constructor . newinstance ( params ) ; } catch ( exception e ) { ldapexceptionutils . generateerrorexception ( ldaperrorcodes . err_10006_control_instance_failed , new string [ ] { clazz . tostring ( ) , stringutils . arraytocommadelimitedstring ( paramtypes ) , stringutils . arraytocommadelimitedstring ( params ) } , logger , e ) ; } return result ; }	permite crear una instancia de la clase pasada como parametro .
private static boolean isincornertargetzone ( float x , float y , float handlex , float handley , float targetradius ) { return math . abs ( x - handlex ) <= targetradius && math . abs ( y - handley ) <= targetradius ; }	determines if the specified coordinate is in the target touch zone for a corner handle .
public boolean isnewstate ( ) { return filename . equals ( _str ) ; }	tells whether this session is in a new state or not.
public boolean offer ( e e ) { final reentrantlock lock = this . lock ; lock . lock ( ) ; try { q . offer ( e ) ; if ( q . peek ( ) == e ) { leader = null ; available . signal ( ) ; } return _bool ; } finally { lock . unlock ( ) ; } }	inserts the specified element into this delay queue .
public void updateleaguehistory ( ) { collections . sort ( teamlist , new teamcomppoll ( ) ) ; string [ ] yeartop10 = new string [ _num ] ; team tt ; for ( int i = _num ; i < _num ; ++ i ) { tt = teamlist . get ( i ) ; yeartop10 [ i ] = tt . abbr + _str + tt . wins + _str + tt . losses + _str ; } leaguehistory . add ( yeartop10 ) ; }	at the end of the year , record the top 10 teams for the league ' s history .
public suffixfilefilter ( string [ ] suffixes , iocase casesensitivity ) { if ( suffixes == null ) { throw new illegalargumentexception ( _str ) ; } this . suffixes = new string [ suffixes . length ] ; system . arraycopy ( suffixes , _num , this . suffixes , _num , suffixes . length ) ; this . casesensitivity = casesensitivity == null ? iocase . sensitive : casesensitivity ; }	constructs a new suffix file filter for an array of suffixs specifying case - sensitivity.
private void updatefont ( ) { string fontname = fontlist . getvalue ( ) ; integer fontsize = fallback_font_size ; try { fontsize = integer . parseint ( fontsizelist . getvalue ( ) ) ; } catch ( numberformatexception ex ) { } font = new font ( fontname , font . plain , fontsize ) ; preview . setfont ( font ) ; }	creates a new font based on the current settings and also updates the preview.
public static properties readpropertyfilefromfilesystem ( final file propertyfilelocation ) throws configurationexception { final properties fileproperties = new properties ( ) ; try { final inputstream inputstream = new fileinputstream ( propertyfilelocation ) ; fileproperties . load ( inputstream ) ; inputstream . close ( ) ; } catch ( ioexception e ) { throw new configurationexception ( _str , e ) ; } return fileproperties ; }	reads a property file into a properties object .
public void test_getcurve ( ) { assertequals ( _str , curve , ecps . getcurve ( ) ) ; }	test for getcurve ( ) method.
@ override public void close ( ) throws ioexception { finputstream . close ( ) ; }	close the stream . once a stream has been closed , further read ( ) , ready ( ) , mark ( ) , or reset ( ) invocations will throw an ioexception . closing a previously - closed stream , however , has no effect .
public static void sleep ( ) { try { thread . sleep ( testsettings . response_wait ) ; } catch ( interruptedexception e ) { } }	current thread sleeps for a predefined amount of time.
public void add ( uri uri , httpcookie cookie ) { if ( cookie == null ) { throw new nullpointerexception ( _str ) ; } lock . lock ( ) ; try { cookiejar . remove ( cookie ) ; if ( cookie . getmaxage ( ) != _num ) { cookiejar . add ( cookie ) ; if ( cookie . getdomain ( ) != null ) { addindex ( domainindex , cookie . getdomain ( ) , cookie ) ; } if ( uri != null ) { addindex ( uriindex , geteffectiveuri ( uri ) , cookie ) ; } } } finally { lock . unlock ( ) ; } }	add one cookie into cookie store .
public void delete ( randomaccessfile raf , randomaccessfile tempraf ) throws ioexception , cannotwriteexception { flactag emptytag = new flactag ( null , new arraylist < metadatablockdatapicture > ( ) ) ; raf . seek ( _num ) ; tempraf . seek ( _num ) ; write ( emptytag , raf , tempraf ) ; }	delete tag from file.
void show ( rectangle bounds ) { if ( ! iscreated ( ) ) { return ; } if ( log . isloggable ( platformlogger . level . finer ) ) { log . finer ( _str + getwindow ( ) + _str + bounds ) ; } xtoolkit . awtlock ( ) ; try { reshape ( bounds . x , bounds . y , bounds . width , bounds . height ) ; xsetvisible ( _bool ) ; tofront ( ) ; selectitem ( getfirstselectableitem ( ) , _bool ) ; } finally { xtoolkit . awtunlock ( ) ; } }	init window if it ' s not inited yet and show it at specified coordinates.
void downcase ( final stringbuffer text , final int leng ) { for ( int i = _num ; i < leng ; i ++ ) { if ( character . isuppercase ( text . charat ( i ) ) ) { text . setcharat ( i , character . tolowercase ( text . charat ( i ) ) ) ; } } }	lowercase the characters up to the given length.
public int indexofkey ( object key ) { return key == null ? indexofnull ( ) : indexof ( key , key . hashcode ( ) ) ; }	returns the index of a key in the set .
public void releaseexternalresources ( ) { if ( ! isclosed . get ( ) ) { logger . info ( _str ) ; actorconfig . shutdownactorsystemforce ( ) ; httpclientstore . shutdown ( ) ; tcpsshpingresourcestore . shutdown ( ) ; taskmanager . cleanwaittaskqueue ( ) ; taskmanager . cleaninprogressjobmap ( ) ; isclosed . set ( _bool ) ; logger . info ( _str + _str + _str ) ; } else { logger . debug ( _str ) ; } }	releases the external resources that this object depends on.
@ override public enumeration < option > listoptions ( ) { vector < option > newvector = new vector < option > ( _num ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str + _str + _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str + _str + _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; return newvector . elements ( ) ; }	returns an enumeration describing the available options .
public static bytestonamecanonicalizer createroot ( ) { long now = system . currenttimemillis ( ) ; int seed = ( ( ( int ) now ) + ( ( int ) now > > > _num ) ) | _num ; return createroot ( seed ) ; }	factory method to call to create a symbol table instance with a randomized seed value .
public void fillfieldvalues ( list < synapseupdaterule > rulelist ) { hebbianrule synapseref = ( hebbianrule ) rulelist . get ( _num ) ; if ( ! networkutils . isconsistent ( rulelist , hebbianrule . class , _str ) ) { tflearningrate . settext ( simbrainconstants . null_string ) ; } else { tflearningrate . settext ( double . tostring ( synapseref . getlearningrate ( ) ) ) ; } }	populate fields with current data .
public static int countargumentplaceholders ( final string messagepattern ) { if ( messagepattern == null ) { return _num ; } final int delim = messagepattern . indexof ( delim_start ) ; if ( delim == - _num ) { return _num ; } int result = _num ; boolean isescaped = _bool ; for ( int i = _num ; i < messagepattern . length ( ) ; i ++ ) { final char curchar = messagepattern . charat ( i ) ; if ( curchar == escape_char ) { isescaped = ! isescaped ; } else if ( curchar == delim_start ) { if ( ! isescaped && i < messagepattern . length ( ) - _num && messagepattern . charat ( i + _num ) == delim_stop ) { result ++ ; i ++ ; } isescaped = _bool ; } else { isescaped = _bool ; } } return result ; }	counts the number of unescaped placeholders in the given messagepattern .
protected abstract boolean isendofchunk ( char currprefix , string currlabel , char nextprefix , string nextlabel ) ;	determines whether the current outcome represents the end of a chunk.
public void clear ( ) { set . clear ( ) ; firecontentschanged ( this , _num , _num ) ; }	clears this list model .
static string tostring ( @ notnull final bytes buffer , long position , long len ) throws bufferunderflowexception { final long pos = buffer . readposition ( ) ; final long limit = buffer . readlimit ( ) ; buffer . readpositionremaining ( position , len ) ; try { final stringbuilder builder = new stringbuilder ( ) ; while ( buffer . readremaining ( ) > _num ) { builder . append ( ( char ) buffer . readbyte ( ) ) ; } return builder . tostring ( ) ; } finally { buffer . readlimit ( limit ) ; buffer . readposition ( pos ) ; } }	the buffer is not modified by this call.
void collectunresponsivemembers ( set s ) { if ( stillwaiting ( ) ) { internaldistributedmember [ ] memberlist = getmembers ( ) ; synchronized ( memberlist ) { for ( int i = _num ; i < memberlist . length ; i ++ ) { internaldistributedmember m = memberlist [ i ] ; if ( m != null ) { s . add ( m ) ; } } } } }	adds any unresponsive members to s.
private void initfromauthheader ( string authheader ) { this . authheader = authheader ; if ( authheader == null ) throw new nullpointerexception ( _str ) ; matcher authmatcher = scheme_pattern . matcher ( authheader ) ; if ( ! authmatcher . matches ( ) ) { throw new illegalstateexception ( _str + authheader ) ; } scheme = authmatcher . group ( _num ) ; if ( authmatcher . groupcount ( ) > _num ) { matcher parammatcher = param_pattern . matcher ( authmatcher . group ( _num ) ) ; while ( parammatcher . find ( ) ) { string value = parammatcher . group ( _num ) ; if ( value == null ) { value = parammatcher . group ( _num ) ; } parameters . put ( parammatcher . group ( _num ) , value ) ; } } }	initializes internal state from the contents of a www - authenticate header .
public string tostring ( ) { string s = _str ; hexdumpencoder encoder = new hexdumpencoder ( ) ; s += encoder . encodebuffer ( octetstring ) ; s += _str ; return ( s ) ; }	returns a printable representation of the keyusage .
public static void addstartuplistener ( startuplistener s ) { s_startuplisteners . add ( s ) ; }	add a listener to be notified when startup is complete.
public void testwrite2 ( ) throws exception { byte [ ] data = new byte [ ] { - _num , - _num , - _num , - _num , - _num , _num , _num , _num , _num , _num } ; testoutputstream tos = new testoutputstream ( ) ; cipheroutputstream cos = new cipheroutputstream ( tos , new nullcipher ( ) ) ; cos . write ( data ) ; cos . flush ( ) ; byte [ ] result = tos . tobytearray ( ) ; if ( ! arrays . equals ( result , data ) ) { fail ( _str ) ; } try { cos . write ( null ) ; fail ( _str ) ; } catch ( nullpointerexception e ) { } }	write ( byte [ ] b ) method testing.
@ visiblefortesting static boolean shouldopenafterdownload ( downloadinfo downloadinfo ) { string type = downloadinfo . getmimetype ( ) ; return downloadinfo . hasusergesture ( ) && ! isattachment ( downloadinfo . getcontentdisposition ( ) ) && mime_types_to_open . contains ( type ) ; }	determines if the download should be immediately opened after downloading .
@ transactional public void save ( final list < workflowmatrix > actualworkflowmatrixdetails , final string [ ] departments ) { for ( final string dept : departments ) { for ( final workflowmatrix workflowmatrix : actualworkflowmatrixdetails ) { final workflowmatrix wfobj = workflowmatrix . clone ( ) ; if ( dept . equals ( default ) ) { wfobj . setdepartment ( _str ) ; } else { wfobj . setdepartment ( dept ) ; } workflowmatrixrepository . save ( wfobj ) ; } } }	this method saves the workflow matrix details for every department selected.
public void write ( string file ) throws exception { write ( new file ( file ) ) ; }	writes the current dom document into the given file .
private static boolean fieldsequal ( object a , object b ) { return a == b || ( a != null && a . equals ( b ) ) ; }	checks to see if two objects are equal either as nulls or through their comparator.
public static string quoteifneeded ( string s , string delim ) { if ( s == null ) return null ; if ( s . length ( ) == _num ) return _str ; for ( int i = _num ; i < s . length ( ) ; i ++ ) { char c = s . charat ( i ) ; if ( c == _str || c == _str || c == _str || character . iswhitespace ( c ) || delim . indexof ( c ) >= _num ) { stringbuffer b = new stringbuffer ( s . length ( ) + _num ) ; quote ( b , s ) ; return b . tostring ( ) ; } } return s ; }	quote a string . the string is quoted only if quoting is required due to embedded delimiters , quote characters or the empty string .
public static void report ( ) { if ( license . isdeveloper ( ) ) { for ( final object obj : spies ) { diagnostic . developerlog ( obj . tostring ( ) ) ; } } }	generate a report to the log from all the current spies .
@ deprecated public void write ( byte b [ ] , int off , int len ) { if ( len < _num ) throw new arrayindexoutofboundsexception ( len ) ; for ( int i = _num ; i < len ; ++ i ) write ( b [ off + i ] ) ; }	write a subarray of bytes.
public final void testnextbytesbytearray03 ( ) throws nosuchalgorithmexception , nosuchproviderexception { securerandom sr1 ; securerandom sr2 ; byte [ ] mybytes1 ; byte [ ] mybytes2 ; for ( int i = _num ; i < length / _num ; i += incr ) { sr1 = securerandom . getinstance ( algorithm , provider ) ; sr2 = securerandom . getinstance ( algorithm , provider ) ; boolean flag = _bool ; mybytes1 = new byte [ i ] ; mybytes2 = new byte [ i ] ; sr1 . nextbytes ( mybytes1 ) ; sr2 . nextbytes ( mybytes2 ) ; for ( int j = _num ; j < i ; j ++ ) { flag &= mybytes1 [ j ] == mybytes2 [ j ] ; } sr1 . nextbytes ( mybytes1 ) ; sr2 . nextbytes ( mybytes2 ) ; for ( int j = _num ; j < i ; j ++ ) { flag &= mybytes1 [ j ] == mybytes2 [ j ] ; } if ( flag ) { fail ( _str + i ) ; } } }	test against the " void nextbytes ( byte [ ] ) " method ; it checks out that different securerandom objects being supplied with seed by themselves return different sequencies of bytes as results of their " nextbytes ( byte [ ] ) " methods.
public cursor query ( sqlitedatabase db , string [ ] projectionin , string selection , string [ ] selectionargs , string groupby , string having , string sortorder , string limit ) { if ( mtables == null ) { return null ; } if ( mstrict && selection != null && selection . length ( ) > _num ) { string sqlforvalidation = buildquery ( projectionin , _str + selection + _str , groupby , having , sortorder , limit ) ; validatesql ( db , sqlforvalidation ) ; } string sql = buildquery ( projectionin , selection , groupby , having , sortorder , limit ) ; return db . rawquerywithfactory ( mfactory , sql , selectionargs , sqlitedatabase . findedittable ( mtables ) ) ; }	perform a query by combining all current settings and the information passed into this method .
public boolean ispaused ( ) { return _bool ; }	whether or not the game is paused .
public builder trustcertificates ( keystore truststore ) throws generalsecurityexception { sslcontext sslcontext = sslutils . gettlssslcontext ( ) ; sslutils . initsslcontext ( sslcontext , truststore , sslutils . getpkixtrustmanagerfactory ( ) ) ; return setsslsocketfactory ( sslcontext . getsocketfactory ( ) ) ; }	sets the ssl socket factory based on a root certificate trust store .
public void rejectreinvite ( int code ) { if ( slogger . isactivated ( ) ) { slogger . debug ( _str ) ; } synchronized ( mwaituseranswer ) { mreinvitestatus = invitationstatus . invitation_rejected ; mwaituseranswer . notifyall ( ) ; } }	reject the session invitation.
public static point parsepoint ( string str , spatialcontext ctx ) throws invalidshapeexception { try { double x , y ; str = str . trim ( ) ; int commaidx = str . indexof ( _str ) ; if ( commaidx == - _num ) { int spaceidx = str . indexof ( _str ) ; if ( spaceidx == - _num ) throw new invalidshapeexception ( _str + str ) ; int middleendidx = findindexnotspace ( str , spaceidx + _num , + _num ) ; x = double . parsedouble ( str . substring ( _num , spaceidx ) ) ; y = double . parsedouble ( str . substring ( middleendidx ) ) ; } else { int middlestartidx = findindexnotspace ( str , commaidx - _num , - _num ) ; int middleendidx = findindexnotspace ( str , commaidx + _num , + _num ) ; y = double . parsedouble ( str . substring ( _num , middlestartidx + _num ) ) ; x = double . parsedouble ( str . substring ( middleendidx ) ) ; } x = ctx . normx ( x ) ; y = ctx . normy ( y ) ; return ctx . makepoint ( x , y ) ; } catch ( invalidshapeexception e ) { throw e ; } catch ( exception e ) { throw new invalidshapeexception ( e . tostring ( ) , e ) ; } }	parses either " lat , lon " ( spaces optional on either comma side ) or " x y " style formats.
public boolean isprune ( ) { return prune ; }	returns the value of the prune attribute .
public void enqueuenormal ( string methodname , int count ) { deque < invocationhandler > handlers = gethandlers ( methodname ) ; for ( int i = _num ; i < count ; i ++ ) { handlers . add ( delegatehandler ) ; } }	enqueues the specified number of normal operations.
@ suppresswarnings ( _str ) @ override protected object readpostprocess ( object o ) throws exception { enumeration < object > enm ; vector < vector < ? > > deserialized ; object key ; deserialized = ( vector < vector < ? > > ) super . readpostprocess ( o ) ; rebuildbeanconnections ( deserialized , regular_connection ) ; enm = m_beanconnectionrelation . keys ( ) ; while ( enm . hasmoreelements ( ) ) { key = enm . nextelement ( ) ; if ( ! ( key instanceof metabean ) ) { continue ; } rebuildbeanconnections ( deserialized , key ) ; } if ( getdatatype ( ) == datatype_usercomponents ) { removeusertoolbarbeans ( deserialized ) ; } return deserialized ; }	additional post - processing can happen in derived classes after reading from xml.
public static boolean cansee ( igame game , entity ae , targetable target ) { return cansee ( game , ae , target , _bool , null , null ) ; }	checks to see if the target is visible to the unit , always considering sensors .
@ override void toxml ( stringbuilder xml , int level ) { indent ( xml , level ) ; xml . append ( _str ) ; for ( int i = _num ; i < bytes . length ; i ++ ) { byte b = bytes [ i ] ; if ( b < _num ) xml . append ( _str ) ; xml . append ( integer . tohexstring ( b ) ) ; } xml . append ( _str ) ; }	there is no xml representation specified for uids.
public final int readline ( char [ ] buf , int length , boolean ischop ) throws ioexception { byte [ ] readbuffer = _readbuffer ; int offset = _num ; while ( _bool ) { int readoffset = _readoffset ; int sublen = math . min ( length , _readlength - readoffset ) ; for ( ; sublen > _num ; sublen -- ) { int ch = readbuffer [ readoffset ++ ] & _num ; if ( ch != _str ) { } else if ( ischop ) { _readoffset = readoffset ; if ( offset > _num && buf [ offset - _num ] == _str ) return offset - _num ; else return offset ; } else { buf [ offset ++ ] = ( char ) ch ; _readoffset = readoffset ; return offset + _num ; } buf [ offset ++ ] = ( char ) ch ; } _readoffset = readoffset ; if ( readoffset <= _readlength ) { if ( ! readbuffer ( ) ) { return offset ; } } if ( length <= offset ) return length + _num ; } }	reads a line into the character buffer.
public static void gotooffset ( final cdebugperspectivemodel model , final iaddress offset , final boolean focusmemorywindow ) { model . setactivememoryaddress ( offset , focusmemorywindow ) ; }	sets the caret of a hex control to a given offset .
public list < abstractcondition > toconditionslist ( ) { list < abstractcondition > list = new arraylist < > ( ) ; for ( node < abstractcondition > node : tolist ( ) ) { list . add ( node . getdata ( ) ) ; } return list ; }	get all conditions as a plain list .
protected void initbatchbuffer ( ) { try { if ( ! isincremental ( ) ) { m_batchbuffer = m_loader . getdataset ( ) ; } else { m_batchbuffer = null ; } } catch ( exception e ) { e . printstacktrace ( ) ; } }	initializes the batch buffer if necessary , i.
public bigdatasailrepositoryconnection cxn ( ) { return tltx . get ( ) ; }	direct access to the unisolated connection.
public static int hashobject ( object o ) { return o == null ? _num : o . hashcode ( ) ; }	null - safe hash code method for objects.
public synchronized void checkaccess ( licensecheckercallback callback ) { if ( mpolicy . allowaccess ( ) ) { log . i ( tag , _str ) ; callback . allow ( policy . licensed ) ; } else { licensevalidator validator = new licensevalidator ( mpolicy , new nulldevicelimiter ( ) , callback , generatenonce ( ) , mpackagename , mversioncode ) ; if ( mservice == null ) { log . i ( tag , _str ) ; try { boolean bindresult = mcontext . bindservice ( new intent ( _str ) , this , context . bind_auto_create ) ; if ( bindresult ) { mpendingchecks . offer ( validator ) ; } else { log . e ( tag , _str ) ; handleserviceconnectionerror ( validator ) ; } } catch ( exception e ) { callback . applicationerror ( licensecheckercallback . error_missing_permission ) ; } } else { mpendingchecks . offer ( validator ) ; runchecks ( ) ; } } }	checks if the user should have access to the app.
public area ( final stendhalrpzone zone , int x , int y , int width , int height ) { this . zone = zone ; final rectangle2d myshape = new rectangle2d . double ( ) ; myshape . setrect ( x , y , width , height ) ; this . shape = myshape ; }	creates a new area .
private byte nexttc ( ) throws ioexception { if ( haspushbacktc ) { haspushbacktc = _bool ; } else { pushbacktc = input . readbyte ( ) ; } return pushbacktc ; }	return the next token code ( tc ) from the receiver , which indicates what kind of object follows.
private void newline ( ) { print ( _str ) ; }	put the line separator string onto the print stream .
public static string digeststring ( string pass , string algorithm ) throws nosuchalgorithmexception { messagedigest md ; bytearrayoutputstream bos ; try { md = messagedigest . getinstance ( algorithm ) ; byte [ ] digest = md . digest ( pass . getbytes ( _str ) ) ; bos = new bytearrayoutputstream ( ) ; outputstream encodedstream = mimeutility . encode ( bos , _str ) ; encodedstream . write ( digest ) ; return bos . tostring ( _str ) ; } catch ( ioexception ioe ) { throw new runtimeexception ( _str + ioe ) ; } catch ( messagingexception me ) { throw new runtimeexception ( _str + me ) ; } }	calculate digest of given string using given algorithm.
public static boolean isdirectory ( string path ) { file f = new file ( path ) ; return f . isdirectory ( ) ; }	checks if the given path is a directory.
private void putwithvalidation ( string key , object value ) throws bitcoinuriparseexception { if ( parametermap . containskey ( key ) ) { throw new bitcoinuriparseexception ( string . format ( locale . us , _str , key ) ) ; } else { parametermap . put ( key , value ) ; } }	put the value against the key in the map checking for duplication.
static void transformkillslot ( final rpobject object ) { final rpobject kills = keyedslotutil . getkeyedslotobject ( object , _str ) ; if ( kills != null ) { final rpobject newkills = new rpobject ( ) ; for ( final string attr : kills ) { if ( ! attr . equals ( _str ) ) { string newattr = attr ; string value = kills . get ( attr ) ; if ( attr . indexof ( _str ) < _num ) { newattr = updateitemname ( newattr ) ; newattr = value + _str + newattr ; value = _str ; } newkills . put ( newattr , value ) ; } } final rpslot slot = object . getslot ( _str ) ; slot . remove ( kills . getid ( ) ) ; slot . add ( newkills ) ; } }	transform kill slot content to the new kill recording system .
public static charsequence trimtrailingwhitespace ( charsequence source ) { if ( source == null ) return _str ; int i = source . length ( ) ; while ( -- i >= _num && character . iswhitespace ( source . charat ( i ) ) ) { } return source . subsequence ( _num , i + _num ) ; }	trims trailing whitespace . removes any of these characters : 0009 , horizontal tabulation 000a , line feed 000b , vertical tabulation 000c , form feed 000d , carriage return 001c , file separator 001d , group separator 001e , record separator 001f , unit separator.
private static void writestringvectortofile ( vector inputvec , string filename ) throws stringvectortofileexception { try { bufferedwriter filew = new bufferedwriter ( new filewriter ( filename ) ) ; int linenum = _num ; while ( linenum < inputvec . size ( ) ) { filew . write ( ( string ) inputvec . elementat ( linenum ) ) ; filew . newline ( ) ; linenum = linenum + _num ; } ; filew . close ( ) ; } catch ( exception e ) { throw new stringvectortofileexception ( _str + filename ) ; } ; }	methods for reading and writing files.
public boolean before ( string userdefinedvalue ) throws illegalargumentexception { try { return value . before ( getdate ( userdefinedvalue ) ) ; } catch ( datatypevalidationexception e ) { throw new illegalargumentexception ( e . getmessage ( ) ) ; } }	indicates whether or not provided value is before .
public void close ( ) { if ( null != inputstreamreader ) { carbonutil . closestreams ( inputstreamreader ) ; } }	below method will be used to clear all the stream.
public static double exponent ( object left , object right ) throws pageexception { return strictmath . pow ( caster . todoublevalue ( left ) , caster . todoublevalue ( right ) ) ; }	calculate the exponent of the left value.
public synchronized void addactionlistener ( actionlistener actionlistener ) { if ( actionlisteners == null ) actionlisteners = new arraylist < actionlistener > ( ) ; actionlisteners . add ( actionlistener ) ; if ( fired ) { actionlistener . actionperformed ( new actionevent ( this , actionevent . action_performed , _str ) ) ; } }	adds a listener that will be notified upon completion of all of the running threads.
public string writedatafile ( ) throws datafileexception { bytearrayoutputstream bos = new bytearrayoutputstream ( ) ; writedatafile ( bos ) ; string outstring = bos . tostring ( ) ; try { if ( bos != null ) bos . close ( ) ; } catch ( ioexception e ) { debug . logwarning ( e , module ) ; } return outstring ; }	returns the records in this datafile object as a plain text data file content.
public static color determinebackgroundcolor ( final inaviinstruction startinstruction , final string trackedregister , final cinstructionresult result ) { preconditions . checknotnull ( startinstruction , _str ) ; preconditions . checknotnull ( trackedregister , _str ) ; preconditions . checknotnull ( result , _str ) ; if ( result . getinstruction ( ) == startinstruction ) { return color . decode ( _str ) ; } else if ( result . undefinesall ( ) ) { return color . decode ( _str ) ; } else if ( result . clearstrackedregister ( trackedregister ) ) { return color . decode ( _str ) ; } else if ( result . undefinessome ( ) ) { return color . decode ( _str ) ; } else if ( result . defines ( ) ) { return color . decode ( _str ) ; } else if ( result . updates ( ) ) { return color . decode ( _str ) ; } else if ( result . uses ( ) ) { return color . decode ( _str ) ; } else { return color . white ; } }	determines the background color to be used in the table and in the graph to highlight a given instruction result .
public void removeoncentralpositionchangedlistener ( oncentralpositionchangedlistener listener ) { moncentralpositionchangedlisteners . remove ( listener ) ; }	removes a listener that would be called when the central item of the list changes .
public void addpickuprs ( ) { int old = _pickuprs ; _pickuprs ++ ; setdirtyandfirepropertychange ( _str , integer . tostring ( old ) , integer . tostring ( _pickuprs ) ) ; }	increments the number of cars and or engines that will be picked up by a train at this location .
public double convert ( ) { return double . longbitstodouble ( ints2long ( high , low ) ) ; }	converts the internal representation ( two ints ) to a double .
public void warn ( xpathcontext xctxt , string msg , object args [ ] ) throws javax . xml . transform . transformerexception { string formattedmsg = xslmessages . createwarning ( msg , args ) ; errorlistener errhandler = xctxt . geterrorlistener ( ) ; errhandler . warning ( new transformerexception ( formattedmsg , ( saxsourcelocator ) xctxt . getsaxlocator ( ) ) ) ; }	warn the user of a problem .
public void cleararchivedirectory ( ) { file directory = new file ( getarchivedirectory ( ) ) ; if ( directory . exists ( ) && directory . isdirectory ( ) ) { string [ ] listing = directory . list ( ) ; for ( string alisting : listing ) { file file = new file ( getarchivedirectory ( ) , alisting ) ; file . delete ( ) ; } } if ( ! directory . exists ( ) ) { directory . mkdirs ( ) ; } }	clears the archive directory .
public void testdivideremainderiszero ( ) { string a = _str ; int ascale = - _num ; string b = _str ; int bscale = _num ; string c = _str ; int resscale = - _num ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) , ascale ) ; bigdecimal bnumber = new bigdecimal ( new biginteger ( b ) , bscale ) ; bigdecimal result = anumber . divide ( bnumber , resscale , bigdecimal . round_ceiling ) ; assertequals ( _str , c , result . tostring ( ) ) ; assertequals ( _str , resscale , result . scale ( ) ) ; }	divide : remainder is zero.
public static boolean nonemptyqueryresult ( resultset r ) { logger . trace ( _str ) ; boolean nonempty = _bool ; if ( r == null ) { return _bool ; } try { if ( r . getrow ( ) != _num ) { nonempty = _bool ; } else { logger . trace ( _str ) ; nonempty = r . first ( ) ; r . beforefirst ( ) ; } } catch ( throwable t ) { surfacethrowable ( _str , t ) ; } return nonempty ; }	since the resultset class mysteriously lacks a " size ( ) " method , and since simply iterating thru what might be a large resultset could be a costly exercise , we play the following games.
private string createfullmessagetext ( string sendername , string receivername , string text ) { if ( sendername . equals ( receivername ) ) { return _str + text ; } else { return sendername + _str + text ; } }	creates the full message based on the text provided by the player.
public void validate ( ) throws ignitecheckedexception { for ( cachepluginprovider provider : providerslist ) provider . validate ( ) ; }	validates cache plugin configurations.
protected boolean onesamenetwork ( macaddress m1 , macaddress m2 ) { string net1 = mactoguid . get ( m1 ) ; string net2 = mactoguid . get ( m2 ) ; if ( net1 == null ) return _bool ; if ( net2 == null ) return _bool ; return net1 . equals ( net2 ) ; }	checks to see if two mac addresses are on the same network .
public static object [ ] polar2cartesianarray ( double r , double alpha ) { double x = r . doublevalue ( ) * math . cos ( alpha . doublevalue ( ) ) ; double y = r . doublevalue ( ) * math . sin ( alpha . doublevalue ( ) ) ; return new object [ ] { new double ( x ) , new double ( y ) } ; }	convert polar coordinates to cartesian coordinates.
protected void singleensemble ( final double [ ] ensemble , final numbervector vec ) { double [ ] buf = new double [ _num ] ; for ( int i = _num ; i < ensemble . length ; i ++ ) { buf [ _num ] = vec . doublevalue ( i ) ; ensemble [ i ] = voting . combine ( buf , _num ) ; if ( double . isnan ( ensemble [ i ] ) ) { log . warning ( _str + formatutil . format ( buf ) + _str + voting . tostring ( ) ) ; } } applyscaling ( ensemble , scaling ) ; }	build a single - element " ensemble " .
@ override public boolean is_intbox ( ) { for ( int index = _num ; index < lines_size ( ) ; ++ index ) { plalineint curr_line = tline_get ( index ) ; if ( ! curr_line . is_orthogonal ( ) ) return _bool ; if ( ! corner_is_bounded ( index ) ) return _bool ; } return _bool ; }	checks if this simplex can be converted into an intbox.
public void additematindex ( t item , int index ) { if ( index <= items . size ( ) ) { items . add ( index , item ) ; firedatachangedevent ( datachangedlistener . added , index ) ; } }	adding an item to list at given index.
public static matchedvaluesrequestcontrol newcontrol ( final boolean iscritical , final string ... filters ) { reject . iffalse ( filters . length > _num , _str ) ; final list < filter > parsedfilters = new arraylist < > ( filters . length ) ; for ( final string filter : filters ) { parsedfilters . add ( validatefilter ( filter . valueof ( filter ) ) ) ; } return new matchedvaluesrequestcontrol ( iscritical , collections . unmodifiablelist ( parsedfilters ) ) ; }	creates a new matched values request control with the provided criticality and list of filters .
private void updateipendpointdetails ( map < string , object > keymap , storageport port , ciminstance ippointinstance , string portinstanceid ) throws ioexception { if ( null != port ) { updateipaddress ( getcimpropertyvalue ( ippointinstance , ipv4address ) , port ) ; _dbclient . persistobject ( port ) ; } }	update end point details.
public void replace ( string param , string value ) { int [ ] range ; while ( ( range = findtemplate ( param ) ) != null ) buff . replace ( range [ _num ] , range [ _num ] , value ) ; }	substitute the specified text for the parameter.
private jsonwriter open ( jsonscope empty , string openbracket ) throws ioexception { beforevalue ( _bool ) ; stack . add ( empty ) ; out . write ( openbracket ) ; return this ; }	enters a new scope by appending any necessary whitespace and the given bracket .
public static boolean iscompositionplaylist ( resourcebyterangeprovider resourcebyterangeprovider ) throws ioexception { try ( inputstream inputstream = resourcebyterangeprovider . getbyterangeasstream ( _num , resourcebyterangeprovider . getresourcesize ( ) - _num ) ) { documentbuilderfactory documentbuilderfactory = documentbuilderfactory . newinstance ( ) ; documentbuilderfactory . setnamespaceaware ( _bool ) ; documentbuilder documentbuilder = documentbuilderfactory . newdocumentbuilder ( ) ; document document = documentbuilder . parse ( inputstream ) ; nodelist nodelist = null ; for ( string cplnamespaceuri : supportedcplschemauris ) { nodelist = document . getelementsbytagnamens ( cplnamespaceuri , _str ) ; if ( nodelist != null && nodelist . getlength ( ) == _num ) { return _bool ; } } } catch ( parserconfigurationexception | saxexception e ) { return _bool ; } return _bool ; }	a method that confirms if the inputstream corresponds to a composition document instance .
public xmlparser ( final string namespace , final string schema ) throws xmlexception { try { jaxbcontext jc = jaxbcontext . newinstance ( namespace ) ; marshaller = jc . createmarshaller ( ) ; marshaller . setschema ( xmlschemautils . createschema ( schema ) ) ; unmarshaller = jc . createunmarshaller ( ) ; unmarshaller . setschema ( xmlschemautils . createschema ( schema ) ) ; } catch ( jaxbexception e ) { throw new xmlexception ( _str + namespace , e ) ; } }	creates the xmlparser with the namespace and schema file for validation .
public void warn ( string msg , object args [ ] ) throws org . xml . sax . saxexception { string formattedmsg = xslmessages . createwarning ( msg , args ) ; saxsourcelocator locator = getlocator ( ) ; errorlistener handler = m_stylesheetprocessor . geterrorlistener ( ) ; try { if ( null != handler ) handler . warning ( new transformerexception ( formattedmsg , locator ) ) ; } catch ( transformerexception te ) { throw new org . xml . sax . saxexception ( te ) ; } }	warn the user of an problem .
public shape triangle_up ( float x , float y , float height ) { m_path . reset ( ) ; m_path . moveto ( x , y + height ) ; m_path . lineto ( x + height / _num , y ) ; m_path . lineto ( x + height , ( y + height ) ) ; m_path . closepath ( ) ; return m_path ; }	returns a up - pointing triangle of the given dimenisions .
public double mindatadlifexists ( int index , double expfprate , boolean checkerr ) { double [ ] rulesetstat = new double [ _num ] ; for ( int j = _num ; j < m_simplestats . size ( ) ; j ++ ) { rulesetstat [ _num ] += m_simplestats . get ( j ) [ _num ] ; rulesetstat [ _num ] += m_simplestats . get ( j ) [ _num ] ; rulesetstat [ _num ] += m_simplestats . get ( j ) [ _num ] ; if ( j == m_simplestats . size ( ) - _num ) { rulesetstat [ _num ] = m_simplestats . get ( j ) [ _num ] ; rulesetstat [ _num ] = m_simplestats . get ( j ) [ _num ] ; rulesetstat [ _num ] = m_simplestats . get ( j ) [ _num ] ; } } double potential = _num ; for ( int k = index + _num ; k < m_simplestats . size ( ) ; k ++ ) { double [ ] rulestat = getsimplestats ( k ) ; double ifdeleted = potential ( k , expfprate , rulesetstat , rulestat , checkerr ) ; if ( ! double . isnan ( ifdeleted ) ) { potential += ifdeleted ; } } double datadlwith = datadl ( expfprate , rulesetstat [ _num ] , rulesetstat [ _num ] , rulesetstat [ _num ] , rulesetstat [ _num ] ) ; return ( datadlwith - potential ) ; }	compute the minimal data description length of the ruleset if the rule in the given position is not deleted . < br > the min_data_dl_if_n_deleted = data_dl_if_n_deleted - potential.
public static void writeintegercollection ( @ nonnull nbttagcompound data , @ nonnull collection < integer > coll ) { data . setinteger ( _str , coll . size ( ) ) ; final int [ ] ary = new int [ coll . size ( ) ] ; int i = _num ; for ( integer num : coll ) { ary [ i ] = num ; i ++ ; } data . settag ( _str , new nbttagintarray ( ary ) ) ; }	writes the given collection to the nbttagcompound as an intarray.
@ suppresswarnings ( _str ) public void queryfordump ( string cfname , string filename , string [ ] ids ) throws exception { final class clazz = getclassfromcfname ( cfname ) ; if ( clazz == null ) { return ; } initdumpxmlfile ( cfname ) ; for ( string id : ids ) { queryandprintrecord ( uri . create ( id ) , clazz , dbclioperation . dump ) ; } writetoxmlfile ( filename ) ; }	query and dump into xml for a particular id in a columnfamily.
private asciifuncs ( ) { }	utility class not to be instantiated .
public dialogueimporter importdialogue ( string dialoguefile ) { list < dialoguestate > turns = xmldialoguereader . extractdialogue ( dialoguefile ) ; dialogueimporter importer = new dialogueimporter ( this , turns ) ; importer . start ( ) ; return importer ; }	imports the dialogue specified in the provided file .
public static string transformfilename ( string filename ) { if ( ! filename . endswith ( _str ) ) { filename = filename + _str ; } return filename ; }	transform a user - entered filename into a proper filename , by adding the ".
public void hidevalidationmessages ( ) { for ( validationerrormessage invalidfield : validationmessages ) { view view = parentview . findviewwithtag ( invalidfield . getpaymentproductfieldid ( ) ) ; validationmessagerenderer . removevalidationmessage ( ( viewgroup ) view . getparent ( ) , invalidfield . getpaymentproductfieldid ( ) ) ; } validationmessages . clear ( ) ; fieldidsoferrormessagesshowing . clear ( ) ; }	hides all visible validationmessages.
private synchronized void removeloader ( classloader loader ) { int i ; for ( i = _loaders . size ( ) - _num ; i >= _num ; i -- ) { weakreference < classloader > ref = _loaders . get ( i ) ; classloader refloader = ref . get ( ) ; if ( refloader == null ) _loaders . remove ( i ) ; else if ( refloader == loader ) _loaders . remove ( i ) ; } }	removes the specified loader .
public static double parsestring ( string value ) { return double . parsedouble ( value ) ; }	parse string value returning a double .
private void writepostcontent ( httpurlconnection connection , string postcontent ) throws exception { connection . setrequestmethod ( _str ) ; connection . addrequestproperty ( _str , _str ) ; connection . setdooutput ( _bool ) ; connection . setdoinput ( _bool ) ; connection . setallowuserinteraction ( _bool ) ; dataoutputstream dstream = null ; try { connection . connect ( ) ; dstream = new dataoutputstream ( connection . getoutputstream ( ) ) ; dstream . writebytes ( postcontent ) ; dstream . flush ( ) ; } finally { if ( dstream != null ) { try { dstream . close ( ) ; } catch ( exception ex ) { _log . error ( _str + _str + ex , _str ) ; } } } }	send a post request with content to the specified connection.
public void add ( wfnode node ) { m_nodes . add ( node ) ; }	add component and add mouse listener.
@ override public int clampviewpositionvertical ( view child , int top , int dy ) { int topbound = _num ; int bottombound = _num ; switch ( draggerview . getdragposition ( ) ) { case top : if ( top > _num ) { topbound = draggerview . getpaddingtop ( ) ; bottombound = ( int ) draggerlistener . dragverticaldragrange ( ) ; } break ; case bottom : if ( top < _num ) { topbound = ( int ) - draggerlistener . dragverticaldragrange ( ) ; bottombound = draggerview . getpaddingtop ( ) ; } break ; default : break ; } return math . min ( math . max ( top , topbound ) , bottombound ) ; }	return the value of slide based on top and height of the element.
@ get @ produces ( { mediatype . application_xml , mediatype . application_json } ) @ path ( _str ) @ deprecated public hostlist listhosts ( @ pathparam ( _str ) uri id ) throws databaseexception { gettenantbyid ( id , _bool ) ; verifyauthorizedintenantorg ( id , getuserfromcontext ( ) ) ; hostlist list = new hostlist ( ) ; list . sethosts ( map ( resourcetypeenum . host , listchildren ( id , host . class , _str , _str ) ) ) ; return list ; }	lists the id and name for all the hosts that belong to the given tenant organization.
private void processdirectorstats ( map < string , metricheaderinfo > metricheaderinfomap , map < string , double > maxvalues , map < string , string > lastsample ) { metricheaderinfo headerinfo = metricheaderinfomap . get ( header_key_director_busy ) ; if ( headerinfo != null ) { string directorbusystring = lastsample . get ( header_key_director_busy ) ; if ( directorbusystring != null ) { double percentbusy = double . valueof ( directorbusystring ) ; double iops = ( maxvalues . containskey ( header_key_director_fe_ops ) ) ? maxvalues . get ( header_key_director_fe_ops ) : double . valueof ( lastsample . get ( header_key_director_fe_ops ) ) ; string lastsampletime = lastsample . get ( header_key_time_utc ) ; portmetricsprocessor . processfeadaptmetrics ( percentbusy , iops . longvalue ( ) , headerinfo . director , lastsampletime , _bool ) ; } } }	process the director metrics found in metricheaderinfomap.
public point2d transform ( point2d p ) { if ( p == null ) return null ; return transform . transform ( p , null ) ; }	applies the transform to the supplied point .
static public void assertequals ( string message , string expected , string actual ) { if ( expected == null && actual == null ) return ; if ( expected != null && expected . equals ( actual ) ) return ; throw new comparisonfailure ( message , expected , actual ) ; }	asserts that two strings are equal .
private void correctchanged ( ) { clock . setcorrecthardware ( correctcheckbox . isselected ( ) , _bool ) ; changed = _bool ; }	method to handle correct check box change.
private void writeofmessagestoswitch ( datapathid dpid , list < ofmessage > messages ) { iofswitch ofswitch = switchservice . getswitch ( dpid ) ; if ( ofswitch != null ) { if ( log . isdebugenabled ( ) ) { log . debug ( _str , messages . size ( ) , dpid ) ; } ofswitch . write ( messages ) ; } }	writes a list of ofmessages to a switch.
public void addcontainerrequest ( map < streamingcontaineragent . containerstartrequest , mutablepair < integer , containerrequest > > requestedresources , int loopcounter , list < containerrequest > containerrequests , streamingcontaineragent . containerstartrequest csr , containerrequest cr ) { mutablepair < integer , containerrequest > pair = new mutablepair < integer , containerrequest > ( loopcounter , cr ) ; requestedresources . put ( csr , pair ) ; containerrequests . add ( cr ) ; }	add container request to list of issued requests to yarn along with current loop counter.
public void waitforchannelstate ( distributedmember member , map channelstate ) throws interruptedexception { if ( thread . interrupted ( ) ) throw new interruptedexception ( ) ; tcpconduit tc = this . conduit ; if ( tc != null ) { tc . waitforthreadownedorderedconnectionstate ( member , channelstate ) ; } }	wait for the given connections to process the number of messages associated with the connection in the given map.
private boolean issamecircleoftrust ( baseconfigtype config , string realm , string entityid ) { boolean istrusted = _bool ; if ( config != null ) { map attr = idffmetautils . getattributes ( config ) ; list cotlist = ( list ) attr . get ( idffcotutils . cot_list ) ; if ( ( cotlist != null ) && ! cotlist . isempty ( ) ) { for ( iterator iter = cotlist . iterator ( ) ; iter . hasnext ( ) ; ) { string cotname = ( string ) iter . next ( ) ; if ( cotmanager . isincircleoftrust ( realm , cotname , cotconstants . idff , entityid ) ) { istrusted = _bool ; } } } } return istrusted ; }	checks if the remote entity identifier is in the entity config ' s circle of trust .
public rulegrounding ( ) { groundings = new hashset < assignment > ( ) ; groundings . add ( new assignment ( ) ) ; }	constructs an empty set of groundings.
public void removeindexkeyspace ( final string index ) throws ioexception { try { queryprocessor . process ( string . format ( _str , index ) , consistencylevel . local_one ) ; } catch ( throwable e ) { throw new ioexception ( e . getmessage ( ) , e ) ; } }	don ' t use queryprocessor.
public static string unhtmlanglebrackets ( string str ) { str = str . replaceall ( _str , _str ) ; str = str . replaceall ( _str , _str ) ; return str ; }	replace & amp ; lt ; & amp ; gt ; entities with & lt ; & gt ; characters .
public long next ( long fromtime ) { if ( getcurrentcount ( ) == _num || fromtime == _num || fromtime == startdate . gettime ( ) ) { return first ( ) ; } if ( debug . verboseon ( ) ) { debug . logverbose ( _str + ( rdatelist == null ? _num : rdatelist . size ( ) ) , module ) ; debug . logverbose ( _str + ( rruleslist == null ? _num : rruleslist . size ( ) ) , module ) ; } if ( rdatelist == null && rruleslist == null ) { return _num ; } long nextruletime = fromtime ; boolean hasnext = _bool ; iterator < recurrencerule > rulesiterator = getrecurrenceruleiterator ( ) ; while ( rulesiterator . hasnext ( ) ) { recurrencerule rule = rulesiterator . next ( ) ; while ( hasnext ) { nextruletime = getnexttime ( rule , nextruletime ) ; if ( nextruletime == _num || isvalid ( nextruletime ) ) { hasnext = _bool ; } } } return nextruletime ; }	returns the next recurrence from the specified time .
public resultt extractlatestattempted ( ) { arraylist < updatet > updates = new arraylist < > ( inflightattempted . size ( ) + _num ) ; synchronized ( attemptedlock ) { updates . add ( finishedattempted ) ; updates . addall ( inflightattempted . values ( ) ) ; } return aggregation . extract ( aggregation . combine ( updates ) ) ; }	extract the latest values from all attempted and in - progress bundles .
public set < jsonuser > loadknownusers ( ) throws interruptedexception , executionexception , remoteexception , operationapplicationexception { set < jsonuser > users = getusersfromdb ( ) ; if ( users . isempty ( ) ) { log . i ( _str ) ; users = syncknownusers ( ) ; } log . i ( string . format ( _str , users . size ( ) ) ) ; return users ; }	loads the known users from local store . if there is no user in db or the application can ' t retrieve from there , then it fetches the users from server.
public void start ( ) { eventlogthread . start ( ) ; logger . info ( _str + eventlogthread . getname ( ) + _str + eventlogthread . getid ( ) + _str ) ; }	starts the event log thread .
private static string htmlencode ( string str ) { if ( str == null ) { return _str ; } else { stringbuilder buf = new stringbuilder ( ) ; for ( char ch : str . tochararray ( ) ) { switch ( ch ) { case _str : buf . append ( _str ) ; break ; case _str : buf . append ( _str ) ; break ; case _str : buf . append ( _str ) ; break ; default : buf . append ( ch ) ; break ; } } return buf . tostring ( ) ; } }	escapes all ' < ' , ' > ' and ' & ' characters in a string .
public static void begin ( servletrequest request , servletresponse response , string servicename , string objectid ) throws servletexception { servicecontext context = ( servicecontext ) _localcontext . get ( ) ; if ( context == null ) { context = new servicecontext ( ) ; _localcontext . set ( context ) ; } context . _request = request ; context . _response = response ; context . _servicename = servicename ; context . _objectid = objectid ; context . _count ++ ; }	sets the request object prior to calling the service ' s method .
public final bufferedimage loadstoredimage ( string current_image ) { if ( current_image == null ) { return null ; } current_image = removeillegalfilenamecharacters ( current_image ) ; final string flag = image_type . get ( current_image ) ; bufferedimage image = null ; if ( flag == null ) { return null ; } else if ( flag . equals ( _str ) ) { image = loadstoredimage ( current_image , _str ) ; } else if ( flag . equals ( _str ) ) { image = loadstoredjpegimage ( current_image ) ; } else if ( flag . equals ( _str ) ) { image = loadstoredimage ( current_image , _str ) ; } else if ( flag . equals ( _str ) ) { image = loadstoredimage ( current_image , _str ) ; } return image ; }	load a image when required and remove from store.
public boolean canusecachedprojectdata ( ) { if ( ! mygradlepluginversion . equals ( gradle_plugin_recommended_version ) ) { return _bool ; } for ( map . entry < string , byte [ ] > entry : myfilechecksums . entryset ( ) ) { file file = new file ( entry . getkey ( ) ) ; if ( ! file . isabsolute ( ) ) { file = new file ( myrootdirpath , file . getpath ( ) ) ; } try { if ( ! arrays . equals ( entry . getvalue ( ) , createchecksum ( file ) ) ) { return _bool ; } } catch ( ioexception e ) { return _bool ; } } return _bool ; }	verifies that whether the persisted external project data can be used to create the project or not.
protected void waitforimage ( image image ) { int id = ++ nexttrackerid ; tracker . addimage ( image , id ) ; try { tracker . waitforid ( id , _num ) ; } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } tracker . removeimage ( image , id ) ; }	wait for an image to load .
@ override public object [ ] toarray ( ) { return newarray ( new object [ size ( ) ] ) ; }	returns all the elements in an array.
@ requestmapping ( value = _str ) public void sloerror ( locale locale , @ pathvariable ( value = _str ) string tenant , httpservletresponse response ) throws ioexception { logger . info ( _str + locale . tostring ( ) + _str + tenant ) ; slodefaulttenantbindingerror ( locale , response ) ; }	handle request sent with a wrong binding.
public static double cdf ( double x , double lambda ) { return _num - math . exp ( - lambda * x ) ; }	cumulative density function of the exponential distribution.
public void testaddmathcontextdiffscaleposneg ( ) { string a = _str ; int ascale = _num ; string b = _str ; int bscale = - _num ; string c = _str ; int cscale = - _num ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) , ascale ) ; bigdecimal bnumber = new bigdecimal ( new biginteger ( b ) , bscale ) ; mathcontext mc = new mathcontext ( _num , roundingmode . ceiling ) ; bigdecimal result = anumber . add ( bnumber , mc ) ; assertequals ( _str , c , c . tostring ( ) ) ; assertequals ( _str , cscale , result . scale ( ) ) ; }	add two numbers of different scales using mathcontext ; the first is positive.
private boolean isderivedbyrestriction ( string ancestorns , string ancestorname , xstypedefinition type ) { xstypedefinition oldtype = null ; while ( type != null && type != oldtype ) { if ( ( ancestorname . equals ( type . getname ( ) ) ) && ( ( ancestorns != null && ancestorns . equals ( type . getnamespace ( ) ) ) || ( type . getnamespace ( ) == null && ancestorns == null ) ) ) { return _bool ; } oldtype = type ; type = type . getbasetype ( ) ; } return _bool ; }	dom level 3 checks if a type is derived from another by restriction.
public static void onoperatorerror ( bifunction < ? super throwable , object , ? extends throwable > f ) { log . info ( _str ) ; onoperatorerrorhook = objects . requirenonnull ( f , _str ) ; }	override global operator error mapping which by default add as suppressed exception either data driven exception or error driven exception .
public boolean showjoinpartandquit ( ) { return preferences . getboolean ( resources . getstring ( r . string . key_show_joinpartquit ) , boolean . parseboolean ( resources . getstring ( r . string . default_show_joinpartquit ) ) ) ; }	should join , part and quit messages be displayed ?.
public void reset ( ) { lastmtd = null ; map . clear ( ) ; loadcnt . set ( _num ) ; putcnt . set ( _num ) ; putallcnt . set ( _num ) ; ts = system . currenttimemillis ( ) ; txs . clear ( ) ; }	resets the store to initial state .
public static configuration load ( inputstream stream ) throws ioexception { try { properties properties = new properties ( ) ; properties . load ( stream ) ; return from ( properties ) ; } finally { stream . close ( ) ; } }	obtain a configuration instance by loading the properties from the supplied stream .
private static string encode_base64 ( final byte d [ ] , final int len ) throws illegalargumentexception { int off = _num ; final stringbuffer rs = new stringbuffer ( ) ; int c1 , c2 ; if ( len <= _num || len > d . length ) { throw new illegalargumentexception ( _str ) ; } while ( off < len ) { c1 = d [ off ++ ] & _num ; rs . append ( base64_code [ c1 > > _num & _num ] ) ; c1 = ( c1 & _num ) << _num ; if ( off >= len ) { rs . append ( base64_code [ c1 & _num ] ) ; break ; } c2 = d [ off ++ ] & _num ; c1 |= c2 > > _num & _num ; rs . append ( base64_code [ c1 & _num ] ) ; c1 = ( c2 & _num ) << _num ; if ( off >= len ) { rs . append ( base64_code [ c1 & _num ] ) ; break ; } c2 = d [ off ++ ] & _num ; c1 |= c2 > > _num & _num ; rs . append ( base64_code [ c1 & _num ] ) ; rs . append ( base64_code [ c2 & _num ] ) ; } return rs . tostring ( ) ; }	encode a byte array using bcrypt ' s slightly - modified base64 encoding scheme.
protected byte readbyteprotected ( datainputstream istream ) throws java . io . ioexception { while ( _bool ) { int nchars ; nchars = istream . read ( rcvbuffer , _num , _num ) ; if ( nchars > _num ) { return rcvbuffer [ _num ] ; } } }	read a single byte , protecting against various timeouts , etc.
public static pcrunner serializableinstance ( ) { return pcrunner . serializableinstance ( ) ; }	generates a simple exemplar of this class to test serialization .
public void drawfigure ( graphics2d g ) { affinetransform savedtransform = null ; if ( get ( transform ) != null ) { savedtransform = g . gettransform ( ) ; g . transform ( get ( transform ) ) ; } paint paint = svgattributekeys . getfillpaint ( this ) ; if ( paint != null ) { g . setpaint ( paint ) ; drawfill ( g ) ; } paint = svgattributekeys . getstrokepaint ( this ) ; if ( paint != null && get ( stroke_width ) > _num ) { g . setpaint ( paint ) ; g . setstroke ( svgattributekeys . getstroke ( this ) ) ; drawstroke ( g ) ; } if ( get ( transform ) != null ) { g . settransform ( savedtransform ) ; } }	this method is invoked before the rendered image of the figure is composited .
public static string decodeattributecode ( string attributecode ) { return attributecode . startswith ( _str ) ? attributecode . substring ( _num ) : attributecode ; }	remove dynamic attribute marker ( + ) from attribute code ( if exists ).
public boolean toboolean ( element el , string attributename ) { return caster . tobooleanvalue ( el . getattribute ( attributename ) , _bool ) ; }	reads a xml element attribute ans cast it to a boolean value.
void savetostream ( dataoutputstream out ) throws ioexception { out . writeutf ( murl ) ; out . writeutf ( mname ) ; out . writeutf ( mvalue ) ; out . writeutf ( mdomain ) ; out . writeutf ( mpath ) ; out . writelong ( mcreation ) ; out . writelong ( mexpiration ) ; out . writelong ( mlastaccess ) ; out . writeboolean ( msecure ) ; out . writeboolean ( mhttponly ) ; out . writeboolean ( mfirstpartyonly ) ; out . writeint ( mpriority ) ; }	serializes for saving to disk.
public boolean delete ( file f ) { if ( f . isdirectory ( ) ) { for ( file child : f . listfiles ( ) ) { if ( ! delete ( child ) ) { return ( _bool ) ; } } } boolean result = f . delete ( ) ; mediascannerconnection . scanfile ( this , new string [ ] { f . getabsolutepath ( ) } , null , null ) ; return ( result ) ; }	recursively deletes a directory and its contents .
public static void replacehttpheadermapnodespecific ( map < string , string > httpheadermap , map < string , string > requestparameters ) { boolean needtoreplacevarinhttpheader = _bool ; for ( string parameter : requestparameters . keyset ( ) ) { if ( parameter . contains ( pcconstants . node_request_prefix_replace_var ) ) { needtoreplacevarinhttpheader = _bool ; break ; } } if ( ! needtoreplacevarinhttpheader ) { logger . debug ( _str ) ; return ; } for ( entry < string , string > entry : httpheadermap . entryset ( ) ) { string key = entry . getkey ( ) ; string valueoriginal = entry . getvalue ( ) ; string valueupdated = nodereqresponse . replacestrbymap ( requestparameters , valueoriginal ) ; httpheadermap . put ( key , valueupdated ) ; } }	! ! ! ! assumption : all var exists in http header must of type : apivarreplace_name_prefix_http_header 20140310 this may be costly ( o ( n ^ 2 ) ) of the updated related # of headers ; # of parameters in the requests.
private void mapput ( map map , string name , object preference ) throws ioexception { isempty = _bool ; if ( ( name . length ( ) == _num ) || ( name == null ) ) { throw new ioexception ( _str + _str ) ; } if ( map . put ( name , preference ) != null ) { throw new ioexception ( _str + name ) ; } }	insert a preference expression and value into a given map .
public builder withtags ( map < string , string > tags ) { this . tags = collections . unmodifiablemap ( tags ) ; return this ; }	add these tags to all metrics .
public static script createmultisiginputscript ( list < transactionsignature > signatures ) { list < byte [ ] > sigs = new arraylist < byte [ ] > ( signatures . size ( ) ) ; for ( transactionsignature signature : signatures ) sigs . add ( signature . encodetobitcoin ( ) ) ; return createmultisiginputscriptbytes ( sigs ) ; }	create a program that satisfies an op_checkmultisig program .
@ override public object [ ] toarray ( ) { final arraylist < object > out = new arraylist < object > ( ) ; final iterator < igpo > gpos = iterator ( ) ; while ( gpos . hasnext ( ) ) { out . add ( gpos . next ( ) ) ; } return out . toarray ( ) ; }	eagerly streams materialized objects into an array.
public static angle rhumbazimuth ( latlon p1 , latlon p2 ) { if ( p1 == null || p2 == null ) { throw new illegalargumentexception ( _str ) ; } double lat1 = p1 . getlatitude ( ) . radians ; double lon1 = p1 . getlongitude ( ) . radians ; double lat2 = p2 . getlatitude ( ) . radians ; double lon2 = p2 . getlongitude ( ) . radians ; if ( lat1 == lat2 && lon1 == lon2 ) return angle . zero ; double dlon = lon2 - lon1 ; double dphi = math . log ( math . tan ( lat2 / _num + math . pi / _num ) / math . tan ( lat1 / _num + math . pi / _num ) ) ; if ( math . abs ( dlon ) > math . pi ) { dlon = dlon > _num ? - ( _num * math . pi - dlon ) : ( _num * math . pi + dlon ) ; } double azimuthradians = math . atan2 ( dlon , dphi ) ; return double . isnan ( azimuthradians ) ? angle . zero : angle . fromradians ( azimuthradians ) ; }	computes the azimuth angle ( clockwise from north ) of a rhumb line ( a line of constant heading ) between two locations .
public void takecolumnfamilysnapshot ( string keyspacename , string columnfamilyname , string tag ) throws ioexception { if ( keyspacename == null ) throw new ioexception ( _str ) ; if ( operationmode == mode . joining ) throw new ioexception ( _str ) ; if ( columnfamilyname == null ) throw new ioexception ( _str ) ; if ( columnfamilyname . contains ( _str ) ) throw new illegalargumentexception ( _str ) ; if ( tag == null || tag . equals ( _str ) ) throw new ioexception ( _str ) ; keyspace keyspace = getvalidkeyspace ( keyspacename ) ; columnfamilystore columnfamilystore = keyspace . getcolumnfamilystore ( columnfamilyname ) ; if ( columnfamilystore . snapshotexists ( tag ) ) throw new ioexception ( _str + tag + _str ) ; columnfamilystore . snapshot ( tag ) ; }	takes the snapshot of a specific column family.
@ override public enumeration < option > listoptions ( ) { vector < option > newvector = new vector < option > ( _num ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; return newvector . elements ( ) ; }	returns an enumeration describing the available options.
private void dialogchanged ( ) { string filename = getfilename ( ) ; string set = getsetname ( ) ; if ( ( null == filename ) || ( filename . length ( ) < _num ) ) { updatestatus ( _str ) ; return ; } if ( ( null == set ) || ( set . length ( ) < _num ) ) { updatestatus ( _str ) ; return ; } updatestatus ( null ) ; }	check data entered . file name and set name must be specified .
@ suppresswarnings ( _str ) private void applytogroupandsubgroups ( final ast2bopcontext context , final queryroot queryroot , final queryhintscope scope , final graphpatterngroup < igroupmembernode > group , final string name , final string value ) { for ( igroupmembernode child : group ) { _applyqueryhint ( context , queryroot , scope , ( astbase ) child , name , value ) ; if ( child instanceof graphpatterngroup < ? > ) { applytogroupandsubgroups ( context , queryroot , scope , ( graphpatterngroup < igroupmembernode > ) child , name , value ) ; } } _applyqueryhint ( context , queryroot , scope , ( astbase ) group , name , value ) ; }	apply the query hint to the group and , recursively , to any sub - groups .
public static int readint ( final jsonobject jsonobject , final string key , final boolean required , final boolean notnull ) throws jsonexception { if ( required ) { return jsonobject . getint ( key ) ; } if ( notnull && jsonobject . isnull ( key ) ) { throw new jsonexception ( string . format ( locale . us , null_value_format_object , key ) ) ; } int value = _num ; if ( ! jsonobject . isnull ( key ) ) { value = jsonobject . getint ( key ) ; } return value ; }	reads the int value from the json object for specified tag .
public timetablexydataset ( ) { this ( timezone . getdefault ( ) , locale . getdefault ( ) ) ; }	creates a new dataset .
public void removetmpstore ( imxstore store ) { if ( null != store ) { mtmpstores . remove ( store ) ; } }	remove the dedicated store from the tmp stores list .
public static list < annotationdto > transformtodto ( list < annotation > annotations ) { if ( annotations == null ) { throw new webapplicationexception ( _str , status . internal_server_error ) ; } list < annotationdto > result = new arraylist < > ( ) ; for ( annotation annotation : annotations ) { result . add ( transformtodto ( annotation ) ) ; } return result ; }	converts list of alert entity objects to list of alertdto objects .
protected void enablebuttons ( ) { m_m_product_id = - _num ; m_productname = null ; m_price = null ; int row = m_table . getselectedrow ( ) ; boolean enabled = row != - _num ; if ( enabled ) { integer id = m_table . getselectedrowkey ( ) ; if ( id != null ) { m_m_product_id = id . intvalue ( ) ; m_productname = ( string ) m_table . getvalueat ( row , _num ) ; m_price = ( bigdecimal ) m_table . getvalueat ( row , _num ) ; } } f_ok . setenabled ( enabled ) ; log . fine ( _str + m_m_product_id + _str + m_productname + _str + m_price ) ; }	enable / set buttons and set id.
public void start ( ) { managedports . add ( createport ( ) ) ; fixnames ( ) ; ports . addobserver ( observer , _bool ) ; }	creates an initial port and starts to listen .
public hessiandebugoutputstream ( outputstream os , printwriter dbg ) { _os = os ; _state = new hessiandebugstate ( dbg ) ; }	creates an uninitialized hessian input stream .
public configurator fromfile ( file file ) { if ( ! file . exists ( ) ) { throw new filenotfoundexception ( file . getabsolutepath ( ) + _str ) ; } return new configurator ( file . getabsolutepath ( ) , _bool ) ; }	use a file as the pdf source.
public synchronized void inserttext ( string inputtype , string outputtype , string locale , string voice , string outputparams , string style , string effects , string inputtext , string outputtext ) throws sqlexception { if ( inputtype == null || outputtype == null || locale == null || voice == null || inputtext == null || outputtext == null ) { throw new nullpointerexception ( _str ) ; } if ( lookuptext ( inputtype , outputtype , locale , voice , outputparams , style , effects , inputtext ) != null ) { return ; } string query = _str + inputtype + _str + outputtype + _str + locale + _str + voice + _str + outputparams + _str + style + _str + effects + _str ; preparedstatement st = connection . preparestatement ( query ) ; st . setstring ( _num , inputtext ) ; st . setstring ( _num , outputtext ) ; st . executeupdate ( ) ; st . close ( ) ; }	insert a record of a mary request producing data of type text into the cache.
public boolean isempty ( ) { return _bool ; }	methods that need to be implemented from generaltaskrunnable .
public static boolean isnumericorpunctuationorsymbols ( string token ) { int len = token . length ( ) ; for ( int i = _num ; i < len ; ++ i ) { char c = token . charat ( i ) ; if ( ! ( character . isdigit ( c ) || characters . ispunctuation ( c ) || characters . issymbol ( c ) ) ) { return _bool ; } } return _bool ; }	returns true if a string consists entirely of numbers , punctuation , and / or symbols .
@ deprecated public dccppmessage ( string s ) { setbinary ( _bool ) ; setretries ( _nretries ) ; settimeout ( dccppmessagetimeout ) ; mymessage = new stringbuilder ( s ) ; _ndatachars = mymessage . length ( ) ; _datachars = new int [ _ndatachars ] ; }	create a dccppmessage from a string containing bytes . since dccppmessages are text , there is no hex - to - byte conversion.
@ override public void start ( ) throws baleenexception { }	will not start controllers .
public objectinstance ( objectname objectname , string classname ) { if ( objectname . ispattern ( ) ) { final illegalargumentexception iae = new illegalargumentexception ( _str + objectname . tostring ( ) ) ; throw new runtimeoperationsexception ( iae ) ; } this . name = objectname ; this . classname = classname ; }	allows an object instance to be created given an object name and the full class name , including the package name .
public static void flushel ( writer w ) { try { if ( w != null ) w . flush ( ) ; } catch ( exception e ) { } }	flush outputstream without a exception.
public dimension maximumlayoutsize ( container target ) { dimension size ; synchronized ( this ) { checkcontainer ( target ) ; checkrequests ( ) ; size = new dimension ( xtotal . maximum , ytotal . maximum ) ; } insets insets = target . getinsets ( ) ; size . width = ( int ) math . min ( ( long ) size . width + ( long ) insets . left + ( long ) insets . right , integer . max_value ) ; size . height = ( int ) math . min ( ( long ) size . height + ( long ) insets . top + ( long ) insets . bottom , integer . max_value ) ; return size ; }	returns the maximum dimensions the target container can use to lay out the components it contains .
private void addgrouptext ( formentrycaption [ ] groups ) { stringbuilder s = new stringbuilder ( _str ) ; string t = _str ; int i ; for ( formentrycaption g : groups ) { i = g . getmultiplicity ( ) + _num ; t = g . getlongtext ( ) ; if ( t != null ) { s . append ( t ) ; if ( g . repeats ( ) && i > _num ) { s . append ( _str + i + _str ) ; } s . append ( _str ) ; } } if ( s . length ( ) > _num ) { textview tv = new textview ( getcontext ( ) ) ; tv . settext ( s . substring ( _num , s . length ( ) - _num ) ) ; int questionfontsize = collect . getquestionfontsize ( ) ; tv . settextsize ( typedvalue . complex_unit_dip , questionfontsize - _num ) ; tv . setpadding ( _num , _num , _num , _num ) ; mview . addview ( tv , mlayout ) ; } }	/ / * add a textview containing the hierarchy of groups to which the question belongs . / /.
public static number plus ( number left , character right ) { return numbernumberplus . plus ( left , integer . valueof ( right ) ) ; }	add a number and a character.
public void addflag ( optionid optionid ) { parameters . add ( new parameterpair ( optionid , flag . set ) ) ; }	add a flag to the parameter list.
public static bytebuffer tobuffer ( string spacedhex ) { return bytebuffer . wrap ( tobytearray ( spacedhex ) ) ; }	convert the spaced hex form of a string into a bytebuffer .
protected void print ( char v ) throws ioexception { os . write ( v ) ; }	prints a char to the stream .
public static boolean isrightturn ( point p1 , point p2 , point p3 ) { if ( p1 . equals ( p2 ) || p2 . equals ( p3 ) ) { return _bool ; } double val = ( p2 . x * p3 . y + p1 . x * p2 . y + p3 . x * p1 . y ) - ( p2 . x * p1 . y + p3 . x * p2 . y + p1 . x * p3 . y ) ; return val > _num ; }	returns true , if the three given points make a right turn .
private string convertlessthanonethousand ( int number ) { string sofar ; if ( number % _num < _num ) { sofar = numnames [ number % _num ] ; number /= _num ; } else { sofar = numnames [ number % _num ] ; number /= _num ; string s = double . tostring ( number ) ; if ( s . endswith ( _str ) && ! sofar . equals ( _str ) ) sofar = _str + sofar . trim ( ) ; else if ( sofar . equals ( _str ) ) sofar = tensnames [ number % _num ] + _str + sofar ; else sofar = tensnames [ number % _num ] + _str + sofar ; number /= _num ; } if ( number == _num ) return tensnames [ number % _num ] + sofar ; if ( number > _num ) sofar = _str + sofar ; if ( number == _num && ! sofar . equals ( _str ) ) number = _num ; sofar = _str + sofar ; return numnames [ number ] + _str + sofar ; }	convert less than one thousand.
public boolean isrefreshtokenexpired ( ) { return refreshtokenexpiresat . before ( new date ( ) ) ; }	checks if the time the refresh access token will be valid are over.
public string tostring ( ) { if ( m_filteredinstances == null ) { return _str ; } string result = _str + getclassifierspec ( ) + _str + getfilterspec ( ) + _str + m_filteredinstances . tostring ( ) + _str + m_classifier . tostring ( ) ; return result ; }	output a representation of this classifier.
@ bean public springprocessengineconfiguration activitiprocessengineconfiguration ( asyncexecutor activitiasyncexecutor ) { springprocessengineconfiguration configuration = new springprocessengineconfiguration ( ) ; configuration . setdatasource ( herddatasource ) ; configuration . settransactionmanager ( herdtransactionmanager ) ; configuration . setdatabaseschemaupdate ( getactivitidbschemaupdateparambeanname ( ) ) ; configuration . setasyncexecutoractivate ( _bool ) ; configuration . setasyncexecutorenabled ( _bool ) ; configuration . setasyncexecutor ( activitiasyncexecutor ) ; configuration . setbeans ( new hashmap < > ( ) ) ; configuration . setdelegateinterceptor ( herddelegateinterceptor ) ; configuration . setcommandinvoker ( herdcommandinvoker ) ; initscriptingengines ( configuration ) ; configuration . setmailserverdefaultfrom ( configurationhelper . getproperty ( configurationvalue . activiti_default_mail_from ) ) ; list < processengineconfigurator > herdconfigurators = new arraylist < > ( ) ; herdconfigurators . add ( herdprocessengineconfigurator ) ; configuration . setconfigurators ( herdconfigurators ) ; return configuration ; }	gets the activiti process engine configuration .
protected < t > void runtasksconcurrent ( final list < abstracttask < t > > tasks ) throws interruptedexception { assert resourcemanager . overflowtasksconcurrent >= _num ; try { final list < future < t > > futures = resourcemanager . getconcurrencymanager ( ) . invokeall ( tasks , resourcemanager . overflowtimeout , timeunit . milliseconds ) ; final iterator < abstracttask < t > > titr = tasks . iterator ( ) ; for ( future < ? extends object > f : futures ) { final abstracttask < t > task = titr . next ( ) ; getfuturefortask ( f , task , _num , timeunit . nanoseconds ) ; } } finally { } }	runs the overflow tasks in parallel , cancelling any tasks which have not completed if we run out of time.
public void initcomponents ( ) { settitle ( bundle . getmessage ( _str ) ) ; container contentpane = getcontentpane ( ) ; contentpane . setlayout ( new boxlayout ( contentpane , boxlayout . y_axis ) ) ; contentpane . add ( initaddresspanel ( ) ) ; contentpane . add ( initnotespanel ( ) ) ; contentpane . add ( initbuttonpanel ( ) ) ; pack ( ) ; }	initialize the config window.
private static double calldoublemethodv ( jnienvironment env , int objjref , int methodid , address argaddress ) throws exception { if ( tracejni ) vm . syswrite ( _str ) ; runtimeentrypoints . checkjnicountdowntogc ( ) ; try { object obj = env . getjniref ( objjref ) ; object returnobj = jnihelpers . invokewithvararg ( obj , methodid , argaddress , typereference . double , _bool ) ; return reflection . unwrapdouble ( returnobj ) ; } catch ( throwable unexpected ) { if ( tracejni ) unexpected . printstacktrace ( system . err ) ; env . recordexception ( unexpected ) ; return _num ; } }	calldoublemethodv : invoke a virtual method that returns a double value.
private final int tradebonus ( position pos ) { final int wm = pos . wmtrl ; final int bm = pos . bmtrl ; final int wpawn = pos . wmtrlpawns ; final int bpawn = pos . bmtrlpawns ; final int deltascore = wm - bm ; int pbonus = _num ; pbonus += interpolate ( ( deltascore > _num ) ? wpawn : bpawn , _num , - _num * deltascore / _num , _num * pv , _num ) ; pbonus += interpolate ( ( deltascore > _num ) ? bm : wm , _num , _num * deltascore / _num , qv + _num * rv + _num * bv + _num * nv , _num ) ; return pbonus ; }	implement the " when ahead trade pieces , when behind trade pawns " rule .
private list < vcenter > filtervcentersbytenant ( list < vcenter > vcenters , uri tenantid ) { list < vcenter > tenantvcenterlist = new arraylist < vcenter > ( ) ; iterator < vcenter > vcenterit = vcenters . iterator ( ) ; while ( vcenterit . hasnext ( ) ) { vcenter vcenter = vcenterit . next ( ) ; if ( vcenter == null ) { continue ; } set < uri > tenanturis = _permissionshelper . getusageurisfromacls ( vcenter . getacls ( ) ) ; if ( collectionutils . isempty ( tenanturis ) ) { continue ; } if ( ! nullcolumnvaluegetter . isnulluri ( tenantid ) && ! tenanturis . contains ( tenantid ) ) { continue ; } iterator < uri > tenanturiit = tenanturis . iterator ( ) ; while ( tenanturiit . hasnext ( ) ) { if ( verifyauthorizedintenantorg ( tenanturiit . next ( ) ) ) { tenantvcenterlist . add ( vcenter ) ; } } } return tenantvcenterlist ; }	filters the vcenters by the tenant.
public void updatevisiblityvalue ( int referenceindex ) { mcachedvisiblearea = mlayouttab . computevisiblearea ( ) ; mcachedindexdistance = math . abs ( mindex - referenceindex ) ; mordersortingvalue = computeordersortingvalue ( mcachedindexdistance , mcachestackvisibility ) ; mvisiblitysortingvalue = computevisibilitysortingvalue ( mcachedvisiblearea , mordersortingvalue , mcachestackvisibility ) ; }	updates the cached visible area value to be used to sort tabs by visibility .
public boolean contains ( eventpoint ep ) { return events . contains ( ep ) ; }	determine whether event point already exists within the queue .
public facebookexception ( string format , object ... args ) { this ( string . format ( format , args ) ) ; }	constructs a new facebookexception .
private boolean isnanpanumberwithnationalprefix ( ) { return ( currentmetadata . getcountrycode ( ) == _num ) && ( nationalnumber . charat ( _num ) == _str ) && ( nationalnumber . charat ( _num ) != _str ) && ( nationalnumber . charat ( _num ) != _str ) ; }	returns true if the current country is a nanpa country and the national number begins with the national prefix .
public static void zipfiles ( file zip , file ... files ) throws ioexception { try ( bufferedoutputstream bufferedout = new bufferedoutputstream ( new fileoutputstream ( zip ) ) ) { zipfiles ( bufferedout , files ) ; } }	create an output zip stream and add each file to that stream.
protected void processclientpom ( ) throws ioexception { file pom = new file ( projectroot , client_pom ) ; string pomcontent = readfilecontent ( pom ) ; string depstring = gen_start + string . format ( _str , mavengroupid , mavenartifactid ) + gen_end ; if ( ! pomcontent . contains ( dep_end_tag ) ) { throw new ioexception ( string . format ( _str , client_pom , dep_end_tag ) ) ; } pomcontent = pomcontent . replace ( dep_end_tag , depstring + dep_end_tag ) ; writefilecontent ( pomcontent , pom ) ; }	insert dependency at the end of " dependencies " section .
public void put ( uri uri , byte [ ] bimg , bufferedimage img ) { synchronized ( bytemap ) { while ( bytesize > _num * _num * _num ) { uri olduri = bytemapaccessqueue . removefirst ( ) ; byte [ ] oldbimg = bytemap . remove ( olduri ) ; bytesize -= oldbimg . length ; log ( _str ) ; } bytemap . put ( uri , bimg ) ; bytesize += bimg . length ; bytemapaccessqueue . addlast ( uri ) ; } addtoimagecache ( uri , img ) ; }	put a tile image into the cache.
public static attribkey forattribute ( namespaces inscope , elkey el , string qname ) { namespaces ns ; string localname ; int colon = qname . indexof ( _str ) ; if ( colon < _num ) { ns = el . ns ; localname = qname ; } else { ns = inscope . forattrname ( el . ns , qname ) ; if ( ns == null ) { return null ; } ns = inscope . foruri ( ns . uri ) ; localname = qname . substring ( colon + _num ) ; } return new attribkey ( el , ns , localname ) ; }	looks up an attribute key by qualified name .
public void removemapeventslistener ( mapeventslistener listener ) { if ( mapeventslisteners != null ) { mapeventslisteners . remove ( listener ) ; } }	removes map event listener from the map .
@ requestmapping ( value = { _str , _str } , method = requestmethod . get ) @ responsebody public restwrapper listusingkey ( @ pathvariable ( _str ) string configgroup , @ pathvariable ( _str ) string key , principal principal ) { restwrapper restwrapper = null ; getgeneralconfig getgeneralconfig = new getgeneralconfig ( ) ; generalconfig generalconfig = getgeneralconfig . byconiggroupandkey ( configgroup , key ) ; if ( generalconfig . getrequired ( ) == _num ) { restwrapper = new restwrapper ( _str , restwrapper . error ) ; } else { restwrapper = new restwrapper ( generalconfig , restwrapper . ok ) ; logger . info ( _str + configgroup + _str + key + _str + principal . getname ( ) ) ; } return restwrapper ; }	this method calls proc getgenconfigproperty and fetches a record from generalconfig table corresponding to config group and key passed .
private colorstatelist applytextappearance ( paint p , int resid ) { textview tv = new textview ( mcontext ) ; if ( sutils . isapi_23_orhigher ( ) ) { tv . settextappearance ( resid ) ; } else { tv . settextappearance ( mcontext , resid ) ; } p . settypeface ( tv . gettypeface ( ) ) ; p . settextsize ( tv . gettextsize ( ) ) ; final colorstatelist textcolor = tv . gettextcolors ( ) ; if ( textcolor != null ) { final int enabledcolor = textcolor . getcolorforstate ( enabled_state_set , _num ) ; p . setcolor ( enabledcolor ) ; } return textcolor ; }	applies the specified text appearance resource to a paint , returning the text color if one is set in the text appearance .
public void removediscoverylistener ( discoverylistener l ) { synchronized ( registrars ) { if ( terminated ) { throw new illegalstateexception ( _str ) ; } listeners . remove ( l ) ; } }	indicate that a listener is no longer interested in receiving discoveryevent notifications .
public static void copyfile ( file in , file out ) throws ioexception { fileinputstream fis = new fileinputstream ( in ) ; fileoutputstream fos = new fileoutputstream ( out ) ; try { copystream ( fis , fos ) ; } finally { fis . close ( ) ; fos . close ( ) ; } }	copy a file from one place to another.
private int xtoscreencoords ( int mapcoord ) { return ( int ) ( mapcoord * map . getscale ( ) - map . getscrollx ( ) ) ; }	transforms coordinate in map coordinate system to screen coordinate system.
public alias filter ( map < string , object > filter ) { if ( filter == null || filter . isempty ( ) ) { this . filter = null ; return this ; } try { xcontentbuilder builder = xcontentfactory . contentbuilder ( xcontenttype . json ) ; builder . map ( filter ) ; this . filter = builder . string ( ) ; return this ; } catch ( ioexception e ) { throw new elasticsearchgenerationexception ( _str + filter + _str , e ) ; } }	associates a filter to the alias.
public void connecttobeancontext ( beancontext in_bc ) throws propertyvetoexception { if ( in_bc != null ) { in_bc . addbeancontextmembershiplistener ( this ) ; beancontextchildsupport . setbeancontext ( in_bc ) ; } }	layer method to just connect to the beancontext , without grabbing the iterator as in setbeancontext ( ).
public static certificateid createcertid ( biginteger subjectserialnumber , x509certificate issuer ) throws exception { return new certificateid ( createdigestcalculator ( sha1_id ) , new x509certificateholder ( issuer . getencoded ( ) ) , subjectserialnumber ) ; }	creates a new certificate id instance ( using sha - 1 digest calculator ) for the specified subject certificate serial number and issuer certificate .
public static final string converttotext ( final string input , final boolean isxmlextraction ) { final stringbuffer output_data ; if ( isxmlextraction ) { final byte [ ] rawdata = stringutils . tobytes ( input ) ; final int length = rawdata . length ; int ptr = _num ; boolean intoken = _bool ; for ( int i = _num ; i < length ; i ++ ) { if ( rawdata [ i ] == _str ) { intoken = _bool ; if ( rawdata [ i + _num ] == _str && rawdata [ i + _num ] == _str && rawdata [ i + _num ] == _str && rawdata [ i + _num ] == _str && rawdata [ i + _num ] == _str ) { rawdata [ ptr ] = _str ; ptr ++ ; } } else if ( rawdata [ i ] == _str ) { intoken = _bool ; } else if ( ! intoken ) { rawdata [ ptr ] = rawdata [ i ] ; ptr ++ ; } } final byte [ ] cleanedstring = new byte [ ptr ] ; system . arraycopy ( rawdata , _num , cleanedstring , _num , ptr ) ; output_data = new stringbuffer ( new string ( cleanedstring ) ) ; } else { output_data = new stringbuffer ( input ) ; } return output_data . tostring ( ) ; }	strip out xml tags and put in a tab ( do not use on chinese text ).
private int parsekey ( final byte [ ] b , final int off ) throws parseexception { final int bytestoparselen = b . length - off ; if ( bytestoparselen >= encryptedkeylen_ ) { encryptedkey_ = arrays . copyofrange ( b , off , off + encryptedkeylen_ ) ; return encryptedkeylen_ ; } else { throw new parseexception ( _str ) ; } }	parse the key in the provided bytes.
public static replyprocessor21 send ( set recipients , dm dm , int prid , int bucketid , bucketprofile bp , boolean requireack ) { if ( recipients . isempty ( ) ) { return null ; } replyprocessor21 rp = null ; int procid = _num ; if ( requireack ) { rp = new replyprocessor21 ( dm , recipients ) ; procid = rp . getprocessorid ( ) ; } bucketprofileupdatemessage m = new bucketprofileupdatemessage ( recipients , prid , procid , bucketid , bp ) ; dm . putoutgoing ( m ) ; return rp ; }	send a profile update to a set of members .
static boolean iscallersensitive ( membername mem ) { if ( ! mem . isinvocable ( ) ) return _bool ; return mem . iscallersensitive ( ) || canbecalledvirtual ( mem ) ; }	is this method a caller - sensitive method ? i.
public void stopsearch ( ) { mmatchednode . clear ( ) ; mquerytext . setlength ( _num ) ; msearchoverlay . hide ( ) ; mactive = _bool ; }	stop the current search.
boolean persistmanagedschema ( boolean createonly ) { if ( loader instanceof zksolrresourceloader ) { return persistmanagedschematozookeeper ( createonly ) ; } file managedschemafile = new file ( loader . getconfigdir ( ) , managedschemaresourcename ) ; outputstreamwriter writer = null ; try { file parentdir = managedschemafile . getparentfile ( ) ; if ( ! parentdir . isdirectory ( ) ) { if ( ! parentdir . mkdirs ( ) ) { final string msg = _str + parentdir . getabsolutepath ( ) ; log . error ( msg ) ; throw new solrexception ( errorcode . server_error , msg ) ; } } final fileoutputstream out = new fileoutputstream ( managedschemafile ) ; writer = new outputstreamwriter ( out , standardcharsets . utf_8 ) ; persist ( writer ) ; log . info ( _str + managedschemafile . getpath ( ) ) ; } catch ( ioexception e ) { final string msg = _str + managedschemafile ; log . error ( msg , e ) ; throw new solrexception ( errorcode . server_error , msg , e ) ; } finally { ioutils . closequietly ( writer ) ; try { fileutils . sync ( managedschemafile ) ; } catch ( ioexception e ) { final string msg = _str + managedschemafile ; log . error ( msg , e ) ; } } return _bool ; }	persist the schema to local storage or to zookeeper.
public static string makexmlsafe ( string text ) { if ( stringutil . isnullorempty ( text ) ) return _str ; text = text . replace ( esc_ampersand , _str ) ; text = text . replace ( _str , esc_quote ) ; text = text . replace ( _str , esc_ampersand ) ; text = text . replace ( _str , esc_apostrophe ) ; text = text . replace ( _str , esc_less_than ) ; text = text . replace ( _str , esc_greater_than ) ; text = text . replace ( _str , _str ) ; return text ; }	takes in a string , and replaces all xml special characters with the approprate escape strings .
final public mutablestring touppercase ( ) { int n = length ( ) ; final char [ ] a = array ; while ( n -- != _num ) a [ n ] = character . touppercase ( a [ n ] ) ; changed ( ) ; return this ; }	converts all of the characters in this mutable string to upper case using the rules of the default locale .
@ override public void handlemousepressed ( chartcanvas canvas , mouseevent e ) { this . mousepressedpoint = new point2d . double ( e . getx ( ) , e . gety ( ) ) ; }	handles a mouse pressed event by recording the location of the mouse pointer ( so that later we can check that the click isn ' t part of a drag ) .
public static path createtempfile ( string prefix , string suffix ) throws ioexception { path tempdirpath = paths . get ( systemproperties . gettempfilespath ( ) ) ; return createtempfile ( tempdirpath , prefix , suffix ) ; }	creates a temporary file on disk ( location specified by systemproperties.
public static short [ ] initializesubstatearray ( list < tree < string > > traintrees , list < tree < string > > validationtrees , numberer tagnumberer , short nsubstates ) { short [ ] nsub = new short [ _num ] ; nsub [ _num ] = _num ; nsub [ _num ] = nsubstates ; statesettreelist trainstatesettrees = new statesettreelist ( traintrees , nsub , _bool , tagnumberer ) ; @ suppresswarnings ( _str ) statesettreelist validationstatesettrees = new statesettreelist ( validationtrees , nsub , _bool , tagnumberer ) ; statesettreelist . initializetagnumberer ( traintrees , tagnumberer ) ; statesettreelist . initializetagnumberer ( validationtrees , tagnumberer ) ; short numstates = ( short ) tagnumberer . total ( ) ; short [ ] nsubstatearray = new short [ numstates ] ; arrays . fill ( nsubstatearray , nsubstates ) ; nsubstatearray [ _num ] = _num ; return nsubstatearray ; }	convert a single tree [ string ] to tree [ stateset ].
public void addpropertychangelistener ( propertychangelistener listener ) { propertychangesupport . addpropertychangelistener ( listener ) ; }	add a propertychangelistener to the listener list .
public plugindescriptionfile ( final string pluginname , final string pluginversion , final string mainclass ) { name = pluginname . replace ( _str , _str ) ; version = pluginversion ; main = mainclass ; }	creates a new plugindescriptionfile with the given detailed.
public void fill ( graphics2d g , shape s ) { rectangle bounds = s . getbounds ( ) ; int width = bounds . width ; int height = bounds . height ; bufferedimage bimage = effect . createbufferedimage ( width , height , _bool ) ; graphics2d gbi = bimage . creategraphics ( ) ; gbi . setcolor ( color . black ) ; gbi . fill ( s ) ; g . drawimage ( applyeffect ( bimage , null , width , height ) , _num , _num , null ) ; }	paint the effect based around a solid shape in the graphics supplied .
public void silentclear ( ) { mselectedwidgets . clear ( ) ; mmodifiedwidgets . clear ( ) ; }	clear the selection without warning listeners.
public static boolean isarray ( element arraye ) { string name = arraye . gettagname ( ) ; if ( name . equals ( _str ) || name . equals ( _str ) || name . equals ( _str ) || name . equals ( _str ) || name . equals ( _str ) || issparsearray ( arraye ) ) { return _bool ; } return _bool ; }	utility method to check if an xml element is an array .
public void addnotificationlistener ( objectname name , notificationlistener listener , notificationfilter filter , object handback ) throws instancenotfoundexception { mbsinterceptor . addnotificationlistener ( cloneobjectname ( name ) , listener , filter , handback ) ; }	adds a listener to a registered mbean .
static long readvarlong ( inputstream in ) throws ioexception { long x = in . read ( ) ; if ( x < _num ) { throw new eofexception ( ) ; } x = ( byte ) x ; if ( x >= _num ) { return x ; } x &= _num ; for ( int s = _num ; s < _num ; s += _num ) { long b = in . read ( ) ; if ( b < _num ) { throw new eofexception ( ) ; } b = ( byte ) b ; x |= ( b & _num ) << s ; if ( b >= _num ) { break ; } } return x ; }	read a variable size long value .
public static builder createbuilder ( abstractmanagedobjectdefinition < ? , ? > d , string propertyname ) { return new builder ( d , propertyname ) ; }	create a aci property definition builder .
public void filter ( file inputfile , printwriter o ) throws ioexception { bufferedwriter bw = new bufferedwriter ( o ) ; stringbuffer sb = ( stringbuffer ) filemap . get ( inputfile . tostring ( ) ) ; if ( sb == null ) { sb = loadfile ( inputfile ) ; } filter ( sb , bw ) ; bw . flush ( ) ; }	filters data from file .
public int update ( string sql , statementvisitor visitor ) throws sqlexception { connection connection = null ; preparedstatement stmt = null ; try { connection = source . getconnection ( ) ; stmt = connection . preparestatement ( sql ) ; visitor . visit ( stmt ) ; return stmt . executeupdate ( ) ; } finally { sqlutil . closequietly ( stmt ) ; sqlutil . closequietly ( connection ) ; } }	perform sql update statement.
public void stop ( ) { logger . info ( _str ) ; if ( thriftserver != null ) thriftserver . stop ( ) ; if ( nativeserver != null ) nativeserver . stop ( ) ; if ( fbutilities . iswindows ( ) ) system . exit ( _num ) ; if ( jmxserver != null ) { try { jmxserver . stop ( ) ; } catch ( ioexception e ) { logger . error ( _str , e ) ; } } }	stop the daemon , ideally in an idempotent manner . hook for jsvc / procrun.
private void compilemethod ( hotspotresolvedjavamethod method , int counter ) { try { long start = system . currenttimemillis ( ) ; long allocatedatstart = memusetrackerimpl . getcurrentthreadallocatedbytes ( ) ; int entrybci = jvmcicompiler . invocation_entry_bci ; hotspotcompilationrequest request = new hotspotcompilationrequest ( method , entrybci , _num ) ; boolean useprofilinginfo = _bool ; boolean installasdefault = _bool ; compilationtask task = new compilationtask ( jvmciruntime , compiler , request , useprofilinginfo , installasdefault ) ; task . runcompilation ( ) ; hotspotinstalledcode installedcode = task . getinstalledcode ( ) ; if ( installedcode != null ) { installedcode . invalidate ( ) ; } memoryused . getandadd ( memusetrackerimpl . getcurrentthreadallocatedbytes ( ) - allocatedatstart ) ; compiletime . getandadd ( system . currenttimemillis ( ) - start ) ; compiledmethodscounter . incrementandget ( ) ; } catch ( throwable t ) { println ( _str , counter , method . format ( _str ) ) ; printstacktrace ( t ) ; } }	compiles a method and gathers some statistics .
private static void docopydirectory ( file srcdir , file destdir , filefilter filter , boolean preservefiledate , list < string > exclusionlist ) throws ioexception { file [ ] srcfiles = filter == null ? srcdir . listfiles ( ) : srcdir . listfiles ( filter ) ; if ( srcfiles == null ) { throw new ioexception ( _str + srcdir ) ; } if ( destdir . exists ( ) ) { if ( destdir . isdirectory ( ) == _bool ) { throw new ioexception ( _str + destdir + _str ) ; } } else { if ( ! destdir . mkdirs ( ) && ! destdir . isdirectory ( ) ) { throw new ioexception ( _str + destdir + _str ) ; } } if ( destdir . canwrite ( ) == _bool ) { throw new ioexception ( _str + destdir + _str ) ; } for ( file srcfile : srcfiles ) { file dstfile = new file ( destdir , srcfile . getname ( ) ) ; if ( exclusionlist == null || ! exclusionlist . contains ( srcfile . getcanonicalpath ( ) ) ) { if ( srcfile . isdirectory ( ) ) { docopydirectory ( srcfile , dstfile , filter , preservefiledate , exclusionlist ) ; } else { docopyfile ( srcfile , dstfile , preservefiledate ) ; } } } if ( preservefiledate ) { destdir . setlastmodified ( srcdir . lastmodified ( ) ) ; } }	internal copy directory method .
public int processbyte ( byte in , byte [ ] out , int outoff ) throws datalengthexception , illegalstateexception { int resultlen = _num ; if ( bufoff == buf . length ) { resultlen = cipher . processblock ( buf , _num , out , outoff ) ; system . arraycopy ( buf , blocksize , buf , _num , blocksize ) ; bufoff = blocksize ; } buf [ bufoff ++ ] = in ; return resultlen ; }	process a single byte , producing an output block if necessary .
public esrishapeexport ( esrigraphiclist list , dbftablemodel dbf , string pathtofile ) { setgraphiclist ( list ) ; setmasterdbf ( dbf ) ; filepath = pathtofile ; debug = logger . isloggable ( level . fine ) ; }	create an esrishapeexport object .
void saveoffsetinexternalstore ( string topic , int partition , long offset ) { try { filewriter writer = new filewriter ( storagename ( topic , partition ) , _bool ) ; bufferedwriter bufferedwriter = new bufferedwriter ( writer ) ; bufferedwriter . write ( offset + _str ) ; bufferedwriter . flush ( ) ; bufferedwriter . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; throw new runtimeexception ( e ) ; } }	overwrite the offset for the topic in an external storage .
private centroidclustermodel assinepoints ( centroidclustermodel model ) { double [ ] values = new double [ attributes . size ( ) ] ; int i = _num ; for ( example example : exampleset ) { double [ ] examplevalues = getasdoublearray ( example , attributes , values ) ; double nearestdistance = measure . calculatedistance ( model . getcentroidcoordinates ( _num ) , examplevalues ) ; int nearestindex = _num ; int id = _num ; for ( centroid cr : model . getcentroids ( ) ) { double distance = measure . calculatedistance ( cr . getcentroid ( ) , examplevalues ) ; if ( distance < nearestdistance ) { nearestdistance = distance ; nearestindex = id ; } id ++ ; } centroidassignments [ i ] = nearestindex ; i ++ ; } model . setclusterassignments ( centroidassignments , exampleset ) ; return model ; }	assign the points to cluster.
public static string formatquantity ( bigdecimal quantity ) { if ( quantity == null ) return _str ; else return quantitydecimalformat . format ( quantity ) ; }	formats an bigdecimal representing a quantity into a string.
public void importpkcs8 ( burpcertificate certificate , string filename ) { setstatus ( _str ) ; fileinputstream fis ; file file = new file ( filename ) ; privatekey privatekey ; try { fis = new fileinputstream ( file ) ; datainputstream dis = new datainputstream ( fis ) ; byte [ ] keybytes = new byte [ ( int ) file . length ( ) ] ; dis . readfully ( keybytes ) ; dis . close ( ) ; pkcs8encodedkeyspec keyspec = new pkcs8encodedkeyspec ( keybytes ) ; keyfactory keyfactory = keyfactory . getinstance ( _str ) ; privatekey = keyfactory . generateprivate ( keyspec ) ; certificate . setprivatekey ( privatekey ) ; setcertificatetree ( ) ; setstatus ( _str ) ; } catch ( ioexception | nosuchalgorithmexception | invalidkeyspecexception e ) { setstatus ( _str + e . getmessage ( ) + _str ) ; e . printstacktrace ( ) ; } catch ( exception e ) { setstatus ( _str + e . getmessage ( ) + _str ) ; } }	import a private key in pkcs8 format in der format .
public collection < object > undo ( ) { hashset < object > modifiedobjects = null ; boolean done = _bool ; while ( ( indexofnextadd > _num ) && ! done ) { list < mxundoableedit > edits = history . get ( -- indexofnextadd ) ; for ( int i = edits . size ( ) - _num ; i >= _num ; i -- ) { mxundoableedit edit = edits . get ( i ) ; edit . undo ( ) ; modifiedobjects = edit . getaffectedobjects ( ) ; if ( edit . issignificant ( ) ) { fireevent ( new mxeventobject ( mxevent . undo , _str , edit ) ) ; done = _bool ; } } } return modifiedobjects ; }	undoes the last change .
public texparser ( string parsestring , texformula formula ) { this ( parsestring , formula , _bool ) ; }	create a new texparser.
public static < t > treenode < t > copy ( treedef < t > treedef , t root ) { return copy ( treedef , root , function . identity ( ) ) ; }	creates a hierarchy of treenodes that copies the structure and content of the given tree .
protected void drawwithoffset ( float zone , int pointsright , int pointsleft , float fixedpoints , canvas canvas , paint paint ) { int position = getpositionforzone ( zone ) ; int firstposition = ( int ) ( position - pointsleft - fixedpoints ) ; int lastposition = ( int ) ( position + pointsright + fixedpoints ) ; if ( lastposition > pointsnumber - _num && lastposition != pointsnumber ) { int offset = lastposition - pointsnumber - _num ; float [ ] pointsf = getarrayfloat ( points . sublist ( _num , offset ) ) ; lastposition = pointsnumber - _num ; canvas . drawpoints ( pointsf , paint ) ; } if ( firstposition < _num ) { int offset = math . abs ( firstposition ) ; float [ ] pointsf = getarrayfloat ( points . sublist ( ( pointsnumber - _num ) - offset , pointsnumber - _num ) ) ; canvas . drawpoints ( pointsf , paint ) ; firstposition = _num ; } float [ ] pointsf = getarrayfloat ( points . sublist ( firstposition , lastposition ) ) ; canvas . drawpoints ( pointsf , paint ) ; }	paint a line with a offset for right and left.
static string calculatenthpercentile ( list < string > values , int n ) { string [ ] valuesarr = new string [ values . size ( ) ] ; valuesarr = values . toarray ( valuesarr ) ; arrays . sort ( valuesarr ) ; int ordinalrank = ( int ) math . ceil ( n * values . size ( ) / _num ) ; return valuesarr [ ordinalrank - _num ] ; }	calculates nth percentile of a set of values using the nearest neighbor method .
private void boundschanged ( ) { if ( runlaterpending ) return ; runlaterpending = _bool ; platform . runlater ( null ) ; }	remembers the window bounds when the window is not iconified , maximized or in fullscreen .
public void clear ( ) { synchronized ( lock ) { file [ ] files = cachepath . listfiles ( ) ; if ( files == null ) { return ; } for ( file file : files ) { removefile ( file ) ; } pendingtasks . clear ( ) ; } }	gets rid of all pending commands .
@ nullable protected abstract url resolvetestdata ( string name ) ;	resolves a test data name relative to the root of all test data , returning a url to represent it .
public static boolean isfullaccessiblefield ( jfield field , jclasstype clazz ) { return field . ispublic ( ) || hasgetandsetmethods ( field , clazz ) ; }	verify if the given field is fully accessible .
public byte [ ] convert ( byte [ ] inbuffer , int size ) { byte [ ] result = null ; if ( inbuffer != null ) { drmconvertedstatus convertedstatus = null ; try { if ( size != inbuffer . length ) { byte [ ] buf = new byte [ size ] ; system . arraycopy ( inbuffer , _num , buf , _num , size ) ; convertedstatus = mdrmclient . convertdata ( mconvertsessionid , buf ) ; } else { convertedstatus = mdrmclient . convertdata ( mconvertsessionid , inbuffer ) ; } if ( convertedstatus != null && convertedstatus . statuscode == drmconvertedstatus . status_ok && convertedstatus . converteddata != null ) { result = convertedstatus . converteddata ; } } catch ( illegalargumentexception e ) { log . w ( tag , _str + mconvertsessionid , e ) ; } catch ( illegalstateexception e ) { log . w ( tag , _str + mconvertsessionid , e ) ; } } else { throw new illegalargumentexception ( _str ) ; } return result ; }	convert a buffer of data to protected format .
public void simulatemethod ( sootmethod method , referencevariable thisvar , referencevariable returnvar , referencevariable params [ ] ) { string subsignature = method . getsubsignature ( ) ; if ( subsignature . equals ( _str ) ) { java_lang_runtime_execinternal ( method , thisvar , returnvar , params ) ; return ; } else { defaultmethod ( method , thisvar , returnvar , params ) ; return ; } }	implements the abstract method simulatemethod.
@ deprecated private static void makejsforinlinesubmit ( appendable writer , map < string , object > context , modelform modelform , string hiddenformname ) throws ioexception { list < modelformfield > rowsubmitfields = modelform . getmultisubmitfields ( ) ; if ( rowsubmitfields != null ) { writer . append ( _str ) ; writer . append ( _str ) ; writer . append ( _str + hiddenformname + _str ) ; writer . append ( _str ) ; for ( modelformfield rowsubmitfield : rowsubmitfields ) { writer . append ( _str + rowsubmitfield . getcurrentcontainerid ( context ) + _str ) ; writer . append ( _str ) ; writer . append ( _str ) ; makehiddenfieldsforhiddenform ( writer ) ; writer . append ( _str ) ; writer . append ( _str ) ; } writer . append ( _str ) ; writer . append ( _str ) ; writer . append ( _str ) ; writer . append ( _str ) ; writer . append ( _str ) ; } }	scipio : creates js script to populate the target hidden form with the corresponding fields of the row that triggered the submission ( only when use - submit - row is false ).
private url createsearchurl ( url url ) throws malformedurlexception { if ( url == null ) { return url ; } string protocol = url . getprotocol ( ) ; if ( isdirectory ( url ) || protocol . equals ( _str ) ) { return url ; } if ( factory == null ) { return new url ( _str , _str , - _num , url . tostring ( ) + _str ) ; } return new url ( _str , _str , - _num , url . tostring ( ) + _str , factory . createurlstreamhandler ( _str ) ) ; }	returns an url that will be checked if it contains the class or resource.
public final void trackedaction ( core controller ) throws interruptedexception { long time = system . currenttimemillis ( ) ; statistics . usenow ( ) ; action ( controller ) ; time = system . currenttimemillis ( ) - time ; statistics . updateaverageexecutiontime ( time ) ; }	perform the action and track the statistics related to this action .
private boolean translatereadyops ( int ops , int initialops , selectionkeyimpl sk ) { int intops = sk . niointerestops ( ) ; int oldops = sk . nioreadyops ( ) ; int newops = initialops ; if ( ( ops & net . pollnval ) != _num ) { return _bool ; } if ( ( ops & ( net . pollerr | net . pollhup ) ) != _num ) { newops = intops ; sk . nioreadyops ( newops ) ; return ( newops & ~ oldops ) != _num ; } if ( ( ( ops & net . pollin ) != _num ) && ( ( intops & selectionkey . op_read ) != _num ) ) newops |= selectionkey . op_read ; if ( ( ( ops & net . pollout ) != _num ) && ( ( intops & selectionkey . op_write ) != _num ) ) newops |= selectionkey . op_write ; sk . nioreadyops ( newops ) ; return ( newops & ~ oldops ) != _num ; }	translates native poll revent ops into a ready operation ops.
public executor env ( map < string , string > env ) { this . env = env ; return this ; }	sets the environment variables for the child process .
public static keypair createeckeypair ( string name ) throws ioexception { try { ecgenparameterspec ecspec = new ecgenparameterspec ( name ) ; keypairgenerator keygen = keypairgenerator . getinstance ( _str ) ; keygen . initialize ( ecspec , new securerandom ( ) ) ; return keygen . generatekeypair ( ) ; } catch ( nosuchalgorithmexception | invalidalgorithmparameterexception ex ) { throw new ioexception ( ex ) ; } }	creates a random ecc key pair with the given curve name .
public void init ( boolean encrypting , cipherparameters params ) throws illegalargumentexception { this . encrypting = encrypting ; if ( params instanceof parameterswithiv ) { parameterswithiv ivparam = ( parameterswithiv ) params ; byte [ ] iv = ivparam . getiv ( ) ; if ( iv . length < iv . length ) { system . arraycopy ( iv , _num , iv , iv . length - iv . length , iv . length ) ; for ( int i = _num ; i < iv . length - iv . length ; i ++ ) { iv [ i ] = _num ; } } else { system . arraycopy ( iv , _num , iv , _num , iv . length ) ; } reset ( ) ; if ( ivparam . getparameters ( ) != null ) { cipher . init ( _bool , ivparam . getparameters ( ) ) ; } } else { reset ( ) ; if ( params != null ) { cipher . init ( _bool , params ) ; } } }	initialise the cipher and , possibly , the initialisation vector ( iv ).
public static document loaddocument ( inputstream stream ) throws exception { documentbuilderfactory factory = documentbuilderfactory . newinstance ( ) ; documentbuilder builder = factory . newdocumentbuilder ( ) ; return builder . parse ( stream ) ; }	loads a xml document from a stream and returns the corresponding dom document .
private int handlesinglenalunitpacket ( buffer input , buffer output ) { byte [ ] bufferdata = ( byte [ ] ) input . getdata ( ) ; int bufferdatalength = bufferdata . length ; byte [ ] data = new byte [ bufferdatalength ] ; system . arraycopy ( bufferdata , _num , data , _num , bufferdatalength ) ; output . setdata ( data ) ; output . setlength ( data . length ) ; output . setoffset ( _num ) ; output . settimestamp ( input . gettimestamp ( ) ) ; output . setsequencenumber ( input . getsequencenumber ( ) ) ; output . setvideoorientation ( input . getvideoorientation ( ) ) ; output . setformat ( input . getformat ( ) ) ; output . setflags ( input . getflags ( ) ) ; return buffer_processed_ok ; }	handle single nal unit packet.
public static < t > list < t > aslist ( t ... values ) { if ( values == null ) { return new arraylist < t > ( _num ) ; } else { return new arraylist < t > ( arrays . aslist ( values ) ) ; } }	collects the passed in objects into a list .
void messagereceived ( bytebuffer buf ) throws ignitecheckedexception , sslexception { if ( buf . limit ( ) > innetbuf . remaining ( ) ) { innetbuf = expandbuffer ( innetbuf , innetbuf . capacity ( ) + buf . limit ( ) * _num ) ; appbuf = expandbuffer ( appbuf , innetbuf . capacity ( ) * _num ) ; if ( log . isdebugenabled ( ) ) log . debug ( _str + innetbuf . capacity ( ) + _str + appbuf . capacity ( ) + _str + ses + _str ) ; } innetbuf . put ( buf ) ; if ( ! handshakefinished ) handshake ( ) ; else unwrapdata ( ) ; if ( isinbounddone ( ) ) { int newposition = buf . position ( ) - innetbuf . position ( ) ; if ( newposition >= _num ) { buf . position ( newposition ) ; if ( buf . hasremaining ( ) ) u . warn ( log , _str + ses ) ; } innetbuf . clear ( ) ; } }	called by ssl filter when new message was received .
public final object copy ( ) { dynamicintarray copy = new dynamicintarray ( m_objects . length ) ; copy . m_size = m_size ; copy . m_capacityincrement = m_capacityincrement ; copy . m_capacitymultiplier = m_capacitymultiplier ; system . arraycopy ( m_objects , _num , copy . m_objects , _num , m_size ) ; return copy ; }	produces a copy of this vector .
public static int deleteoldsms ( ) { long olderthan = system . currenttimemillis ( ) - old_sms_threshold ; return database . delete ( databaseopenhelper . sms_table_name , _str + olderthan , null ) ; }	deletes sms from the database that are older then 5 days.
private static string encodemetricfilters ( string metricstring , map < string , string > mapper ) { string finalstring = metricstring ; int counter = _num ; int startindex = _num ; int endindex = _num ; for ( int i = _num ; i < metricstring . length ( ) ; i ++ ) { char currentchar = metricstring . charat ( i ) ; startindex = ( currentchar == _str && counter == _num ) ? i : startindex ; counter = ( currentchar == _str ) ? counter + _num : counter ; if ( currentchar == _str ) { endindex = i ; counter = counter - _num ; } if ( counter == _num && startindex != _num ) { string filterstring = metricstring . substring ( startindex , endindex + _num ) ; finalstring = finalstring . replace ( filterstring , _str + startindex ) ; mapper . put ( _str + startindex , filterstring ) ; startindex = _num ; } } return finalstring ; }	returns modified metrics string.
private void finalizeadditions ( boolean addhomescreenshortcuts ) { finalizeworkfolder ( ) ; if ( addhomescreenshortcuts && ! mhomescreenapps . isempty ( ) ) { sortlist ( mhomescreenapps ) ; mmodel . addandbindaddedworkspaceitems ( mcontext , mhomescreenapps ) ; } }	adds and binds all shortcuts marked for addition .
private void stopcheckingstatus ( ) { executor . shutdownnow ( ) ; executor = executors . newsinglethreadexecutor ( ) ; future = null ; }	re - sets the executor and indicates the system is no longer checking the status of the transactions.
public void updatenotification ( int notificationid ) { try { notificationdao . open ( ) ; notificationdao . updatenotification ( notificationid , notification . status . dismissed ) ; } finally { notificationdao . close ( ) ; } }	this method is used to update the notification which is stored in the embedded db .
public static element addchildelementnsvalue ( element element , string childelementname , string childelementvalue , document document , string namespaceurl ) { element newelement = document . createelementns ( namespaceurl , childelementname ) ; newelement . appendchild ( document . createtextnode ( childelementvalue ) ) ; element . appendchild ( newelement ) ; return element ; }	creates a child element with the given namespace supportive name and appends it to the element child node list.
public void addcolumnlistener ( columnlistener listener ) { m_listeners . add ( listener ) ; }	adds a listener to be notified when this column changes.
public void loaddataset ( url url , iri context , parserconfig config ) throws repositoryexception { try { long since = lastmodified . get ( url ) ; urlconnection urlcon = url . openconnection ( ) ; if ( since != null ) { urlcon . setifmodifiedsince ( since ) ; } if ( since == null || since < urlcon . getlastmodified ( ) ) { load ( url , urlcon , context , config ) ; } } catch ( rdfparseexception e ) { throw new repositoryexception ( e ) ; } catch ( ioexception e ) { throw new repositoryexception ( e ) ; } }	inspects if the dataset at the supplied url location has been modified since the last load into this repository and if so loads it into the supplied context .
protected int read ( inputstream inputstream , byte [ ] buffer , char [ ] divider ) throws ioexception { int index = _num ; int dividerindex = _num ; do { byte readbyte = ( byte ) ( _num & inputstream . read ( ) ) ; if ( readbyte == - _num ) { return index ; } if ( readbyte == divider [ dividerindex ] ) { dividerindex ++ ; } if ( dividerindex == divider . length ) { index -= dividerindex - _num ; for ( int i = index ; i < index + dividerindex ; i ++ ) { if ( i >= buffer . length ) { break ; } buffer [ i ] = _num ; } return index ; } buffer [ index ] = readbyte ; index ++ ; } while ( index < buffer . length ) ; return index ; }	reads bytes from a given file reader until either a specified character sequence is read , the buffer is completely filled or the end of file is reached .
public void testnodedocumentfragmentnormalize1 ( ) throws throwable { document doc ; documentfragment docfragment ; string nodevalue ; text txtnode ; node retval ; doc = ( document ) load ( _str , builder ) ; docfragment = doc . createdocumentfragment ( ) ; txtnode = doc . createtextnode ( _str ) ; retval = docfragment . appendchild ( txtnode ) ; txtnode = doc . createtextnode ( _str ) ; retval = docfragment . appendchild ( txtnode ) ; docfragment . normalize ( ) ; txtnode = ( text ) docfragment . getfirstchild ( ) ; nodevalue = txtnode . getnodevalue ( ) ; assertequals ( _str , _str , nodevalue ) ; retval = txtnode . getnextsibling ( ) ; assertnull ( _str , retval ) ; }	runs the test case .
private void collecttimes ( tree tree , noderef node , set < noderef > excludenodesbelow , intervals intervals ) { intervals . addcoalescentevent ( tree . getnodeheight ( node ) ) ; for ( int i = _num ; i < tree . getchildcount ( node ) ; i ++ ) { noderef child = tree . getchild ( node , i ) ; boolean include = _bool ; if ( excludenodesbelow != null && excludenodesbelow . contains ( child ) ) { include = _bool ; } if ( ! include || tree . isexternal ( child ) ) { intervals . addsampleevent ( tree . getnodeheight ( child ) ) ; } else { collecttimes ( tree , child , excludenodesbelow , intervals ) ; } } }	extract coalescent times and tip information into arraylist times from tree .
public stringbody ( final string text , final string mimetype , charset charset ) throws unsupportedencodingexception { super ( mimetype ) ; if ( text == null ) { throw new illegalargumentexception ( _str ) ; } if ( charset == null ) { charset = charset . forname ( http . utf_8 ) ; } this . content = text . getbytes ( charset . name ( ) ) ; this . charset = charset ; }	create a stringbody from the specified text , mime type and character set .
public void makeimmutable ( ) { mutable = _bool ; if ( authncontextclassref != null ) { authncontextclassref = collections . unmodifiablelist ( authncontextclassref ) ; } if ( authncontextdeclref != null ) { authncontextdeclref = collections . unmodifiablelist ( authncontextdeclref ) ; } return ; }	makes the obejct immutable.
protected abstract int readskipdata ( int level , indexinput skipstream ) throws ioexception ;	subclasses must implement the actual skip data encoding in this method .
protected tamsmessage pollmessage ( ) { if ( disablepoll ) { return null ; } if ( ! pollqueue . isempty ( ) ) { pollmessage pm = pollqueue . peek ( ) ; if ( pm != null ) { tm = pm . getmessage ( ) ; return pm . getmessage ( ) ; } } return null ; }	check tams mc for status updates.
public path bin ( ) { return root . resolve ( _str ) ; }	gets the bin directory .
public static void safecopy ( final reader reader , final writer writer ) throws ioexception { try { ioutils . copy ( reader , writer ) ; } finally { ioutils . closequietly ( reader ) ; ioutils . closequietly ( writer ) ; } }	copy and close the reader and writer streams .
public static < t extends bean > t load ( bson query , t t ) { string collection = getcollection ( t . getclass ( ) ) ; if ( collection != null ) { try { return load ( query , null , t ) ; } catch ( exception e ) { if ( log . iserrorenabled ( ) ) log . error ( e . getmessage ( ) , e ) ; } } return null ; }	load the data full into the t .
private printelement createimageelement ( mprintformatitem item ) { object obj = m_data . getnode ( new integer ( item . getad_column_id ( ) ) ) ; if ( obj == null ) return null ; else if ( obj instanceof printdataelement ) ; else { log . log ( level . severe , _str + obj . getclass ( ) ) ; return null ; } printdataelement data = ( printdataelement ) obj ; if ( data . isnull ( ) && item . issuppressnull ( ) ) return null ; string url = data . getvaluedisplay ( m_format . getlanguage ( ) ) ; if ( ( url == null || url . length ( ) == _num ) ) { if ( item . issuppressnull ( ) ) return null ; else return null ; } imageelement element = null ; if ( data . getdisplaytype ( ) == displaytype . image ) { element = imageelement . get ( data , url ) ; } else { element = imageelement . get ( url ) ; } return element ; }	create image element from item.
public void resetcharges ( ) { pendingcharges . removeallelements ( ) ; }	resets the pending charges list .
static repaintmanager currentmanager ( appcontext appcontext ) { repaintmanager rm = ( repaintmanager ) appcontext . get ( repaintmanagerkey ) ; if ( rm == null ) { rm = new repaintmanager ( buffer_strategy_type ) ; appcontext . put ( repaintmanagerkey , rm ) ; } return rm ; }	returns the repaintmanager for the specified appcontext.
public int decrement ( ) { lock . lock ( ) ; int newvalue = -- value ; lock . unlock ( ) ; return newvalue ; }	decrements the counter by 1 .
private void addpoint ( point p ) { coordinate coord = p . getcoordinate ( ) ; insertpoint ( argindex , coord , location . interior ) ; }	add a point to the graph .
public boolean isconnectable ( ) { for ( deviceservice service : services . values ( ) ) { if ( service . isconnectable ( ) ) return _bool ; } return _bool ; }	whether the device has any deviceservices that require an active connection ( websocket , http registration , etc ).
private static void skiparray ( bytebuffer buf ) { int length = buf . getshort ( ) & _num ; for ( int i = _num ; i < length ; i ++ ) skipmembervalue ( buf ) ; }	skips the array value at the current position in the specified byte buffer.
public static byte [ ] hash ( byte [ ] input ) { if ( input != null ) { final messagedigest digest ; try { digest = messagedigest . getinstance ( _str ) ; byte [ ] hashedbytes = input ; digest . update ( hashedbytes , _num , hashedbytes . length ) ; return hashedbytes ; } catch ( nosuchalgorithmexception e ) { log . e ( tag , _str + input + _str + e . getmessage ( ) , e ) ; } } else { log . w ( tag , _str ) ; } return null ; }	created sha256 of input.
private void reopen ( ) { timeline animation = new timeline ( new keyframe ( duration . seconds ( _num ) , new keyvalue ( inputs . prefheightproperty ( ) , inputs . getmaxheight ( ) ) ) ) ; animation . play ( ) ; }	makes an animation to make the input vbox slide open over . 1 seconds.
private byte [ ] copyarray ( byte [ ] buffer , int length ) { byte [ ] result = new byte [ length ] ; system . arraycopy ( buffer , _num , result , _num , math . min ( buffer . length , length ) ) ; return result ; }	implement java . util . arrays . copyof ( ) for jdk 1 . 5 .
public static map < string , object > testsoapservice ( dispatchcontext dctx , map < string , ? > context ) { delegator delegator = dctx . getdelegator ( ) ; map < string , object > response = serviceutil . returnsuccess ( ) ; list < genericvalue > testingnodes = new linkedlist < genericvalue > ( ) ; for ( int i = _num ; i < _num ; i ++ ) { genericvalue testingnode = delegator . makevalue ( _str ) ; testingnode . put ( _str , _str + i ) ; testingnode . put ( _str , _str + i ) ; testingnode . put ( _str , utildatetime . nowtimestamp ( ) ) ; testingnodes . add ( testingnode ) ; } response . put ( _str , testingnodes ) ; return response ; }	generic test soap service.
public xmldom ( inputstream is ) throws saxexception { documentbuilderfactory factory = documentbuilderfactory . newinstance ( ) ; documentbuilder builder ; try { builder = factory . newdocumentbuilder ( ) ; document doc = builder . parse ( is ) ; this . root = ( element ) doc . getdocumentelement ( ) ; } catch ( parserconfigurationexception e ) { } catch ( ioexception e ) { throw new saxexception ( e ) ; } }	instantiates a new xml dom .
public void removekeylistener ( globalkeylistener listener ) { listeners . remove ( listener ) ; }	removes a global key listener.
public set search3 ( string tokenid , string startdn , string filter , int numofentries , int timelimit , boolean sortresults , boolean ascendingorder , set excludes ) throws smsexception , ssoexception , remoteexception { initialize ( ) ; if ( debug . messageenabled ( ) ) { debug . message ( _str + startdn + _str + filter + _str + excludes ) ; } iterator i = smsentry . search ( gettoken ( tokenid ) , startdn , filter , numofentries , timelimit , sortresults , ascendingorder , excludes ) ; set < string > result = new hashset < string > ( ) ; while ( i . hasnext ( ) ) { smsdataentry e = ( smsdataentry ) i . next ( ) ; try { result . add ( e . tojsonstring ( ) ) ; } catch ( jsonexception ex ) { debug . error ( _str + startdn + _str + filter + _str + excludes , ex ) ; } } return result ; }	searches the data store for objects that match the filter with an exclude set.
public boolean removeentry ( int xindex , int datasetindex ) { if ( datasetindex >= mdatasets . size ( ) ) return _bool ; t dataset = mdatasets . get ( datasetindex ) ; entry e = dataset . getentryforxindex ( xindex ) ; if ( e == null || e . getxindex ( ) != xindex ) return _bool ; return removeentry ( e , datasetindex ) ; }	removes the entry object at the given xindex from the dataset at the specified index.
void closestream ( closeable closeable ) { try { if ( closeable != null ) { closeable . close ( ) ; } } catch ( ioexception ex ) { utils . logissue ( _str , ex ) ; } }	attempt to close given fileinputstream.
public void testfromdate ( ) throws exception { timezone . setdefault ( timezone . gettimezone ( _str ) ) ; final calendar date = calendar . getinstance ( ) ; date . settime ( new date ( _num ) ) ; assert . assertequals ( _str , calendarserializer . serialize ( date ) ) ; final calendar datenomillis = calendar . getinstance ( ) ; datenomillis . settime ( new date ( _num ) ) ; assert . assertequals ( _str , calendarserializer . serialize ( datenomillis ) ) ; }	make sure that dates with and without millis can be converted properly into strings.
@ override public boolean eisset ( int featureid ) { switch ( featureid ) { case eippackage . metadata__key : return key_edefault == null ? key != null : ! key_edefault . equals ( key ) ; case eippackage . metadata__values : return values != null && ! values . isempty ( ) ; } return super . eisset ( featureid ) ; }	< ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
@ override public boolean ismodified ( ) { if ( _isdigestmodified ) { if ( log . isloggable ( level . fine ) ) log . fine ( _source . getnativepath ( ) + _str ) ; return _bool ; } long sourcelastmodified = _source . getlastmodified ( ) ; long sourcelength = _source . length ( ) ; if ( ! _requiresource && sourcelastmodified == _num ) { return _bool ; } else if ( sourcelength != _length ) { if ( log . isloggable ( level . fine ) ) { log . fine ( _source . getnativepath ( ) + _str + _length + _str + sourcelength + _str ) ; } return _bool ; } else if ( sourcelastmodified != _lastmodified ) { if ( log . isloggable ( level . fine ) ) log . fine ( _source . getnativepath ( ) + _str ) ; return _bool ; } else return _bool ; }	if the source modified date changes at all , treat it as a modification.
public byte [ ] tobytearray ( ) { int totallen = _pastlen + _currblockptr ; if ( totallen == _num ) { return no_bytes ; } byte [ ] result = new byte [ totallen ] ; int offset = _num ; for ( byte [ ] block : _pastblocks ) { int len = block . length ; system . arraycopy ( block , _num , result , offset , len ) ; offset += len ; } system . arraycopy ( _currblock , _num , result , offset , _currblockptr ) ; offset += _currblockptr ; if ( offset != totallen ) { throw new runtimeexception ( _str + totallen + _str + offset + _str ) ; } if ( ! _pastblocks . isempty ( ) ) { reset ( ) ; } return result ; }	method called when results are finalized and we can get the full aggregated result buffer to return to the caller.
public static < m extends message > string writejsonstream ( immutablelist < m > messages ) { bytearrayoutputstream resultstream = new bytearrayoutputstream ( ) ; messagewriter < m > writer = messagewriter . create ( output . forstream ( new printstream ( resultstream ) ) ) ; writer . writeall ( messages ) ; return resultstream . tostring ( ) ; }	returns the string representation of the stream of supplied messages.
public org . smpte_ra . schemas . st2067_2_2016 . contentmaturityratingtype buildcontentmaturityratingtype ( string agency , string rating , org . smpte_ra . schemas . st2067_2_2016 . contentmaturityratingtype . audience audience ) throws urisyntaxexception { org . smpte_ra . schemas . st2067_2_2016 . contentmaturityratingtype contentmaturityratingtype = new org . smpte_ra . schemas . st2067_2_2016 . contentmaturityratingtype ( ) ; if ( ! agency . matches ( _str ) == _bool ) { throw new urisyntaxexception ( _str , _str ) ; } contentmaturityratingtype . setagency ( agency ) ; contentmaturityratingtype . setrating ( rating ) ; contentmaturityratingtype . setaudience ( audience ) ; return contentmaturityratingtype ; }	a method to construct a contentmaturityratingtype conforming to the 2016 schema.
protected asn1sequence ( asn1encodablevector v ) { for ( int i = _num ; i != v . size ( ) ; i ++ ) { seq . addelement ( v . get ( i ) ) ; } }	create a sequence containing a vector of objects .
private final double readdatum ( final datainput in , final columntype columntype ) throws ioexception { switch ( columntype ) { case double : return in . readdouble ( ) ; case integer : int ivalue = in . readint ( ) ; if ( ivalue == integer . min_value + _num ) { boolean ismissing = in . readboolean ( ) ; if ( ismissing ) { return double . nan ; } else { return ivalue ; } } else { return ivalue ; } case nominal_byte : byte bvalue = in . readbyte ( ) ; if ( bvalue == - _num ) { return double . nan ; } else { return bvalue ; } case nominal_integer : ivalue = in . readint ( ) ; if ( ivalue == - _num ) { return double . nan ; } else { return ivalue ; } case nominal_short : short svalue = in . readshort ( ) ; if ( svalue == - _num ) { return double . nan ; } else { return svalue ; } default : throw new runtimeexception ( _str + columntype ) ; } }	reads a single datum in non - sparse representation of the given type and returns it as a double .
protected void closetransportlayer ( ) throws ioexception { super . close ( ) ; if ( input != null ) { input . close ( ) ; output . close ( ) ; } }	closes the transport data streams .
public double op ( final double x ) { final double sn = math . sin ( this . asr * ( - x + _num ) * _num ) ; return math . exp ( ( sn * hk - hs ) / ( _num - sn * sn ) ) ; }	computes equation 3 , see references.
public void listen ( stanzalistener stanzalistener , stanzafilter stanzafilter ) { connection . addasyncstanzalistener ( stanzalistener , stanzafilter ) ; logger . info ( _str ) ; }	begin listening for incoming messages .
public static void addinputmode ( string name , hashtable values , boolean firstupcase ) { initinputmodes ( ) ; inputmodes . put ( name , values ) ; if ( firstupcase ) { firstuppercaseinputmode . addelement ( name ) ; } }	adds a new inputmode hashtable with the given name and set of values.
@ override public void addenvvarupdatedlistener ( envvarupdateinterface listener ) { if ( ! listenerlist . contains ( listener ) ) { listenerlist . add ( listener ) ; } }	adds the env var updated listener .
private void init ( configuration exp ) throws ioexception { isinitialized = _bool ; }	private initializer method that sets up the generic resources .
public list < localvariable > visiblevariables ( ) throws absentinformationexception { validatestackframe ( ) ; createvisiblevariables ( ) ; list < localvariable > mapaslist = new arraylist < localvariable > ( visiblevariables . values ( ) ) ; collections . sort ( mapaslist ) ; return mapaslist ; }	return the list of visible variable in the frame.
public static void startservices ( servicehost host , class ... services ) throws instantiationexception , illegalaccessexception { checkargument ( services != null , _str ) ; for ( class service : services ) { startservice ( host , service ) ; } }	starts the list of services on the host .
private appliedmigration createappliedmigration ( int version , string description ) { return new appliedmigration ( version , version , migrationversion . fromversion ( integer . tostring ( version ) ) , description , migrationtype . cql , _str , null , new date ( ) , _str , _num , _bool ) ; }	creates a new applied migration with this version .
templateentry nextentry ( ) { if ( ! hasnext ( ) ) { throw new nosuchelementexception ( ) ; } final templateentry entry = nextentry ; nextentry = null ; return entry ; }	returns the next generated entry .
private void createrecordholderqueue ( file [ ] listfiles ) { this . recordholderheap = new priorityqueue < sorttempfilechunkholder > ( listfiles . length ) ; }	this method will be used to create the heap which will be used to hold the chunk of data.
public static double correlation ( double [ ] x , double [ ] y ) { if ( x . length == y . length ) { double mx = mathutils . mean ( x ) ; double my = mathutils . mean ( y ) ; double sx = math . sqrt ( mathutils . variance ( x ) ) ; double sy = math . sqrt ( mathutils . variance ( y ) ) ; int n = x . length ; double nval = _num ; for ( int i = _num ; i < n ; i ++ ) { nval += ( x [ i ] - mx ) * ( y [ i ] - my ) ; } double r = nval / ( ( n - _num ) * sx * sy ) ; return r ; } else throw new illegalargumentexception ( _str ) ; }	sample correlation coefficient ref : http : / / en.
public static int writemessagefully ( message msg , outputstream out , bytebuffer buf , messagewriter writer ) throws ioexception { assert msg != null ; assert out != null ; assert buf != null ; assert buf . hasarray ( ) ; if ( writer != null ) writer . setcurrentwriteclass ( msg . getclass ( ) ) ; boolean finished = _bool ; int cnt = _num ; while ( ! finished ) { finished = msg . writeto ( buf , writer ) ; out . write ( buf . array ( ) , _num , buf . position ( ) ) ; cnt += buf . position ( ) ; buf . clear ( ) ; } return cnt ; }	fully writes communication message to provided stream .
protected final void dragexit ( final int x , final int y ) { dragsourceevent event = new dragsourceevent ( getdragsourcecontext ( ) , x , y ) ; eventdispatcher dispatcher = new eventdispatcher ( dispatch_exit , event ) ; suntoolkit . invokelateronappcontext ( suntoolkit . targettoappcontext ( getcomponent ( ) ) , dispatcher ) ; startsecondaryeventloop ( ) ; }	upcall from native code.
public static string generaterandomstring ( int count ) { random random = new random ( ) ; stringbuffer buffer = new stringbuffer ( ) ; while ( count -- != _num ) { char ch = ( char ) ( random . nextint ( _num ) + _num ) ; buffer . append ( ch ) ; } return buffer . tostring ( ) ; }	generate a random string.
public void decrement ( ) { int counterval = counter . decrementandget ( ) ; if ( counterval == _num ) { if ( null != resourcecallback ) { resourcecallback . ontransitiontoidle ( ) ; } becameidleat = systemclock . uptimemillis ( ) ; } if ( debugcounting ) { if ( counterval == _num ) { log . i ( tag , _str + resourcename + _str + ( becameidleat - becamebusyat ) + _str ) ; } else { log . i ( tag , _str + resourcename + _str + counterval ) ; } } if ( counterval < _num ) { throw new illegalargumentexception ( _str ) ; } }	decrements the count of in - flight transactions to the resource being monitored.
public void removetestingcallback ( onesheeldtestingcallback testingcallback ) { if ( testingcallback != null && testingcallbacks . contains ( testingcallback ) ) testingcallbacks . remove ( testingcallback ) ; }	remove a testing callback .
public boolean shoulddataberouted ( simpleroutercontext context , datametadata datametadata , node node , boolean initialload , boolean initialloadselectused , triggerrouter triggerrouter ) { idatarouter router = getdatarouter ( datametadata . getrouter ( ) ) ; set < node > onenodeset = new hashset < node > ( _num ) ; onenodeset . add ( node ) ; collection < string > nodeids = router . routetonodes ( context , datametadata , onenodeset , initialload , initialloadselectused , triggerrouter ) ; return nodeids != null && nodeids . contains ( node . getnodeid ( ) ) ; }	for use in data load events.
@ override public object put ( object key , object value ) { entry tab [ ] = table ; int hash = _num ; int index = _num ; if ( key != null ) { hash = system . identityhashcode ( key ) ; index = ( hash & _num ) % tab . length ; for ( entry e = tab [ index ] ; e != null ; e = e . next ) { if ( ( e . hash == hash ) && key == e . key ) { object old = e . value ; e . value = value ; return old ; } } } else { for ( entry e = tab [ _num ] ; e != null ; e = e . next ) { if ( e . key == null ) { object old = e . value ; e . value = value ; return old ; } } } modcount ++ ; if ( count >= threshold ) { rehash ( ) ; tab = table ; index = ( hash & _num ) % tab . length ; } entry e = new entry ( hash , key , value , tab [ index ] ) ; tab [ index ] = e ; count ++ ; return null ; }	associates the specified value with the specified key in this map.
public static string backquotechars ( string string , char [ ] find , string [ ] replace ) { int index ; stringbuilder newstr ; int i ; if ( string == null ) return string ; for ( i = _num ; i < find . length ; i ++ ) { if ( string . indexof ( find [ i ] ) != - _num ) { newstr = new stringbuilder ( ) ; while ( ( index = string . indexof ( find [ i ] ) ) != - _num ) { if ( index > _num ) newstr . append ( string . substring ( _num , index ) ) ; newstr . append ( replace [ i ] ) ; if ( ( index + _num ) < string . length ( ) ) string = string . substring ( index + _num ) ; else string = _str ; } newstr . append ( string ) ; string = newstr . tostring ( ) ; } } return string ; }	converts specified characters into the string equivalents .
public void testbitlengthnegative2 ( ) { byte abytes [ ] = { - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num } ; int asign = - _num ; biginteger anumber = new biginteger ( asign , abytes ) ; assertequals ( _num , anumber . bitlength ( ) ) ; }	bitlength ( ) of a negative number with the leftmost bit set.
public void addlanguage ( executionlanguage language ) { languages . add ( _num , language ) ; }	registers a new executionlanguage to the registry .
private static boolean memberequals ( final class < ? > type , final object o1 , final object o2 ) { if ( o1 == o2 ) { return _bool ; } if ( o1 == null || o2 == null ) { return _bool ; } if ( type . isarray ( ) ) { return arraymemberequals ( type . getcomponenttype ( ) , o1 , o2 ) ; } if ( type . isannotation ( ) ) { return equals ( ( annotation ) o1 , ( annotation ) o2 ) ; } return o1 . equals ( o2 ) ; }	helper method for checking whether two objects of the given type are equal.
public encoding ( string name ) { this . name = name ; }	constructs a new encoding .
public string writelongtostring ( ) { stringbuilder builder = new stringbuilder ( ) ; for ( int i = _num ; i < ( bitset . getbits ( ) . length ) ; ++ i ) { builder . append ( long . tostring ( bitset . getbits ( ) [ i ] ) + _str ) ; } return builder . tostring ( ) ; }	writes vector to a string of the form 010 etc.
@ override public void committed ( long committedwindowid ) throws ioexception { log . debug ( _str , committedwindowid ) ; for ( long currentwindow : savedwindows . keyset ( ) ) { if ( currentwindow <= largestwindowaddedtotransferqueue ) { continue ; } if ( currentwindow <= committedwindowid ) { log . debug ( _str , currentwindow ) ; largestwindowaddedtotransferqueue = currentwindow ; windowstotransfer . add ( currentwindow ) ; } else { break ; } } }	transfers the data which has been committed till windowid to data files .
public void delete ( randomaccessfile raf , randomaccessfile tempraf ) throws cannotreadexception , cannotwriteexception , ioexception { raf . seek ( _num ) ; tempraf . seek ( _num ) ; deletetag ( raf , tempraf ) ; }	delete the tag ( if any ) present in the given randomaccessfile , and do not close it at the end .
void ondeferredenddrag ( dragview dragview ) { dragview . remove ( ) ; if ( mdragobject . deferdragviewcleanuppostanimation ) { for ( draglistener listener : new arraylist < > ( mlisteners ) ) { listener . ondragend ( ) ; } } }	this only gets called as a result of drag view cleanup being deferred in enddrag ( ) ;.
private byte [ ] pagetobytearray ( p page ) { try { if ( page == null ) { bytearrayoutputstream baos = new bytearrayoutputstream ( ) ; objectoutputstream oos = new objectoutputstream ( baos ) ; oos . writeint ( empty_page ) ; oos . close ( ) ; baos . close ( ) ; byte [ ] array = baos . tobytearray ( ) ; byte [ ] result = new byte [ pagesize ] ; system . arraycopy ( array , _num , result , _num , array . length ) ; return result ; } else { bytearrayoutputstream baos = new bytearrayoutputstream ( ) ; objectoutputstream oos = new objectoutputstream ( baos ) ; oos . writeint ( filled_page ) ; page . writeexternal ( oos ) ; oos . close ( ) ; baos . close ( ) ; byte [ ] array = baos . tobytearray ( ) ; if ( array . length > this . pagesize ) { throw new illegalargumentexception ( _str + page + _str + _str + array . length + _str + pagesize ) ; } else if ( array . length == this . pagesize ) { return array ; } else { byte [ ] result = new byte [ pagesize ] ; system . arraycopy ( array , _num , result , _num , array . length ) ; return result ; } } } catch ( ioexception e ) { throw new runtimeexception ( _str , e ) ; } }	serializes an object into a byte array .
void presentdecoranimations ( int position , float offset ) { int animmapsize = mdecoranimations . size ( ) ; for ( int i = _num ; i < animmapsize ; i ++ ) { decor decor = mdecoranimations . keyat ( i ) ; arraylist < animation > animations = mdecoranimations . get ( decor ) ; int animlistsize = animations . size ( ) ; for ( int j = _num ; j < animlistsize ; j ++ ) { animation animation = animations . get ( j ) ; if ( animation == null ) { continue ; } if ( ! animation . shouldanimate ( position ) ) { if ( mpreviousposition < position && animation . pageend < position ) { animation . animate ( decor . contentview , _num , _num , position ) ; } else if ( mpreviousposition > position && animation . pagestart > position ) { animation . animate ( decor . contentview , _num , _num , position ) ; } continue ; } animation . animate ( decor . contentview , offset , _num , position ) ; } } mpreviousposition = position ; }	run the animations based on the decor animations saved within the presenter and the offset of the scrolling .
public static boolean deltree ( file directory ) { if ( directory == null || ! directory . exists ( ) ) { return _bool ; } boolean result = _bool ; if ( directory . isfile ( ) ) { result = directory . delete ( ) ; } else { file [ ] list = directory . listfiles ( ) ; for ( int i = list . length ; i -- > _num ; ) { if ( ! deltree ( list [ i ] ) ) { result = _bool ; } } if ( ! directory . delete ( ) ) { result = _bool ; } } return result ; }	deletes the given file and everything under it .
public void invalidate ( long newfilesize ) { if ( newfilesize < filesize ) { filesize = newfilesize ; counters . clear ( ) ; blocksize = calcblocksize ( filesize ) ; } else if ( newfilesize > filesize ) compact ( newfilesize ) ; }	check if counters and blocksize should be adjusted according to file size .
public void addcase ( switchcase switchcase ) { assertnotnull ( switchcase ) ; if ( cases == null ) { cases = new arraylist < switchcase > ( ) ; } cases . add ( switchcase ) ; switchcase . setparent ( this ) ; }	adds a switch case statement to the end of the list .
public void test_atomicappendfullblock ( ) throws ioexception { final string id = _str ; final int version = _num ; random r = new random ( ) ; final byte [ ] expected = new byte [ block_size ] ; r . nextbytes ( expected ) ; final long block0 = repo . appendblock ( id , version , expected , _num , expected . length ) ; assertequals ( _str , _num , block0 ) ; assertequals ( _str , _num , repo . getblockcount ( id , version ) ) ; assertequals ( _str , expected , repo . readblock ( id , version , block0 ) ) ; assertequals ( _str , expected , read ( repo . inputstream ( id , version ) ) ) ; }	atomic append of a full block .
public static int hash ( byte [ ] data , int offset , int length , int seed ) { return hash ( bytebuffer . wrap ( data , offset , length ) , seed ) ; }	hashes bytes in part of an array .
public static boolean isfileexist ( string filepath , filetype filetype ) throws ioexception { filepath = filepath . replace ( _str , _str ) ; switch ( filetype ) { case hdfs : case viewfs : path path = new path ( filepath ) ; filesystem fs = path . getfilesystem ( configuration ) ; return fs . exists ( path ) ; case local : default : file defaultfile = new file ( filepath ) ; return defaultfile . exists ( ) ; } }	this method checks the given path exists or not and also is it file or not if the performfilecheck is true.
private void checkqopsupport ( byte [ ] qopinchallenge , byte [ ] ciphersinchallenge ) throws ioexception { string qopoptions ; if ( qopinchallenge == null ) { qopoptions = _str ; } else { qopoptions = new string ( qopinchallenge , encoding ) ; } string [ ] serverqoptokens = new string [ _num ] ; byte [ ] serverqop = parseqop ( qopoptions , serverqoptokens , _bool ) ; byte serverallqop = combinemasks ( serverqop ) ; switch ( findpreferredmask ( serverallqop , qop ) ) { case _num : throw new saslexception ( _str + _str ) ; case no_protection : negotiatedqop = _str ; break ; case integrity_only_protection : negotiatedqop = _str ; integrity = _bool ; rawsendsize = sendmaxbufsize - _num ; break ; case privacy_protection : negotiatedqop = _str ; privacy = integrity = _bool ; rawsendsize = sendmaxbufsize - _num ; checkstrengthsupport ( ciphersinchallenge ) ; break ; } if ( logger . isloggable ( level . fine ) ) { logger . log ( level . fine , _str , new integer ( rawsendsize ) ) ; } }	parses the ' qop ' directive.
public void close ( boolean pcloseunderlying ) throws ioexception { if ( closed ) { return ; } if ( pcloseunderlying ) { closed = _bool ; input . close ( ) ; } else { for ( ; ; ) { int av = available ( ) ; if ( av == _num ) { av = makeavailable ( ) ; if ( av == _num ) { break ; } } long skip = skip ( av ) ; if ( skip != av ) { if ( log . isdebugenabled ( ) ) { log . debug ( skip + _str ) ; } } } } closed = _bool ; }	closes the input stream .
protected void addnewevent ( object eventkey , t event ) { if ( unwrittenevents == null ) { unwrittenevents = maps . newhashmap ( ) ; } list < t > listevents = unwrittenevents . get ( eventkey ) ; if ( listevents == null ) { unwrittenevents . put ( eventkey , lists . newarraylist ( event ) ) ; } else { listevents . add ( event ) ; } }	add the given event into the unwritternevents map.
public static locale localefromstring ( final string localeasstring ) { if ( stringutils . isblank ( localeasstring ) ) { final list < apiparametererror > datavalidationerrors = new arraylist < > ( ) ; final apiparametererror error = apiparametererror . parametererror ( _str , _str , _str ) ; datavalidationerrors . add ( error ) ; throw new platformapidatavalidationexception ( _str , _str , datavalidationerrors ) ; } string languagecode = _str ; string countrycode = _str ; string variantcode = _str ; final string [ ] localeparts = localeasstring . split ( _str ) ; if ( localeparts != null && localeparts . length == _num ) { languagecode = localeparts [ _num ] ; } if ( localeparts != null && localeparts . length == _num ) { languagecode = localeparts [ _num ] ; countrycode = localeparts [ _num ] ; } if ( localeparts != null && localeparts . length == _num ) { languagecode = localeparts [ _num ] ; countrycode = localeparts [ _num ] ; variantcode = localeparts [ _num ] ; } return localefrom ( languagecode , countrycode , variantcode ) ; }	todo : vishwas move all locale related code to a separate utils class.
protected object decoderesponse ( inputstream inputstream , string contenttype ) throws ioexception { object value ; if ( contenttype . startswith ( json_mime_type ) ) { jsondecoder decoder = new jsondecoder ( ) ; value = decoder . readvalue ( inputstream ) ; } else if ( contenttype . startswith ( text_mime_type_prefix ) ) { textdecoder decoder = new textdecoder ( ) ; value = decoder . readvalue ( inputstream ) ; } else { value = null ; } return value ; }	decodes a response value .
public static void loadmodule ( final jtree tree , final inavimodule module ) { preconditions . checknotnull ( tree , _str ) ; preconditions . checknotnull ( module , _str ) ; loadmodulethreaded ( swingutilities . getwindowancestor ( tree ) , module , tree ) ; }	loads a module while showing a progress dialog .
public boolean evaluate ( featureclassinfo fci , int row ) { boolean ret = _bool ; stringbuffer reasoning = null ; if ( logger . isloggable ( level . fine ) ) { reasoning = new stringbuffer ( ) ; } if ( exp != null ) { ret = exp . evaluate ( fci , row , reasoning ) ; } if ( reasoning != null ) { reasoning . append ( _str ) ; logger . fine ( reasoning . tostring ( ) ) ; } return ret ; }	does the feature in row of fci pass the conditions of this expression .
public void addfunctionalinstrumentation ( specialinstrumentationpoint functionalinstrumentation ) { if ( null == functionalinstrumentations ) { functionalinstrumentations = new hashset < specialinstrumentationpoint > ( _num ) ; } functionalinstrumentations . add ( functionalinstrumentation ) ; }	adds functional instrumentation point .
public final list < integer > executeintlistquery ( string sql ) throws adeexception { return specialsqlqueries . executeintlistquery ( sql , m_connection ) ; }	executes a query that is expected to returned a column of integers .
@ apioperation ( value = _str ) @ requestmapping ( value = _str , method = requestmethod . post ) @ responsestatus ( httpstatus . no_content ) @ responsebody public final void postuninstall ( ) { uninstallimpl ( getsymmetricengine ( ) ) ; }	uninstalls all symmetricds objects from the given node ( database ) for the single engine on the node.
public boolean oneoutgoingtransitionleavescompositewithexitactions ( state state ) { set < state > sourceparentstates = new hashset < state > ( getparentstates ( state ) ) ; for ( transition transition : state . getoutgoingtransitions ( ) ) { set < state > targetparentstates = getparentstates ( transition . gettarget ( ) ) ; set < state > crossedstates = new hashset < state > ( sourceparentstates ) ; crossedstates . removeall ( targetparentstates ) ; for ( state crossedcompositestate : crossedstates ) { if ( hasexitaction ( crossedcompositestate ) ) return _bool ; } } return _bool ; }	checks if at least one of the outgoing transitions of the specified state leaves a parent composite of this state which has exit actions .
@ override public int read ( ) throws ioexception { int x = in . read ( ) ; if ( x != - _num ) { check . update ( x ) ; } return x ; }	reads one byte of data from the underlying input stream and updates the checksum with the byte data .
public static boolean removetable ( table t ) { try { tablelist . remove ( t ) ; } catch ( exception e ) { return _bool ; } return _bool ; }	remove the a table .
public plot add ( string label , population population , int x , int y ) { list < number > xs = new arraylist < number > ( ) ; list < number > ys = new arraylist < number > ( ) ; for ( solution solution : population ) { if ( ! solution . violatesconstraints ( ) ) { xs . add ( solution . getobjective ( x ) ) ; ys . add ( solution . getobjective ( y ) ) ; } } scatter ( label , xs , ys ) ; setlabelsifblank ( _str + ( x + _num ) , _str + ( y + _num ) ) ; return this ; }	displays the solutions in the given population in a 2d scatter plot.
private void initializeneighborhoods ( ) { list < individual > sortedpopulation = new arraylist < individual > ( population ) ; for ( individual individual : population ) { collections . sort ( sortedpopulation , new weightsorter ( individual ) ) ; for ( int i = _num ; i < neighborhoodsize ; i ++ ) { individual . addneighbor ( sortedpopulation . get ( i ) ) ; } } }	constructs the neighborhoods for all individuals in the population based on the distances between weights .
public void print ( boolean x ) { out . print ( x ) ; out . flush ( ) ; }	prints a boolean to this output stream and flushes this output stream .
public final boolean removeelement ( int s ) { for ( int i = _num ; i < m_firstfree ; i ++ ) { if ( m_map [ i ] == s ) { if ( ( i + _num ) < m_firstfree ) system . arraycopy ( m_map , i + _num , m_map , i - _num , m_firstfree - i ) ; else m_map [ i ] = java . lang . integer . min_value ; m_firstfree -- ; return _bool ; } } return _bool ; }	removes the first occurrence of the argument from this vector.
public vnxecommandjob restorelungroupsnap ( string snapid , vnxesnaprestoreparam restoreparam ) throws vnxeexception { stringbuilder urlbuilder = new stringbuilder ( url_instance ) ; urlbuilder . append ( snapid ) ; urlbuilder . append ( url_restore ) ; _url = urlbuilder . tostring ( ) ; return postrequestasync ( restoreparam ) ; }	restore lun group snapshot.
public haskellcatalog ( ) { this ( haskellcatalog . xml_path ) ; }	constructs a haskell catalog using the default file location .
public classfactory ( file dir , classloader parent ) { super ( parent ) ; this . output = dir ; dir . mkdirs ( ) ; }	create a given class factory with the given class loader .
static boolean issamecolumn ( constraintwidget a , constraintwidget b ) { return math . max ( a . getx ( ) , b . getx ( ) ) < math . min ( a . getx ( ) + a . getwidth ( ) , b . getx ( ) + b . getwidth ( ) ) ; }	are the two widgets in the same vertical area.
public boolean isexistingcommand ( ) { return ( ! name . equals ( commandtaghandle . cmd_unknown ) ) ; }	check whether the present commandtaghandle object represents a commandtag that exists on the server.
@ suppresswarnings ( _str ) protected void stopclassifier ( ) { if ( m_runthread != null ) { m_runthread . interrupt ( ) ; m_runthread . stop ( ) ; } }	stops the currently running classifier ( if any ) .
private void sleep ( long sleeptime ) { try { thread . sleep ( sleeptime ) ; } catch ( interruptedexception e ) { } }	make the current thread sleep .
protected void buildpanels ( ) { keypanels . clear ( ) ; inscrollpane . removeall ( ) ; for ( string key : order ) { string name = names . get ( key ) ; if ( name != null ) { string value = values . getproperty ( key ) ; keypanel keypanel = new keypanel ( name , value ) ; keypanel . setalignmentx ( left_alignment ) ; keypanel . setmaximumsize ( guisize ) ; inscrollpane . add ( keypanel ) ; keypanels . put ( key , keypanel ) ; } else { specialsetting special = specials . get ( key ) ; special . setalignmentx ( left_alignment ) ; inscrollpane . add ( special ) ; } } }	creates all key panels and special settings that have been registered .
public void loaddatastringfromfile ( string sfilename , boolean clearcurrentdata , string sencoding ) { try { bytearrayoutputstream bsout = new bytearrayoutputstream ( ) ; fileinputstream fiin = new fileinputstream ( sfilename ) ; int idata = _num ; while ( ( idata = fiin . read ( ) ) > - _num ) bsout . write ( idata ) ; string sdatastring = bsout . tostring ( ) ; setdatastring ( sdatastring , sourcengramsize , clearcurrentdata ) ; } catch ( ioexception ioe ) { ioe . printstacktrace ( ) ; setdatastring ( _str , _num , _bool ) ; } }	loads the contents of a file as the datastring .
public final char nextchar ( charsequence csq ) { return csq . charat ( index ++ ) ; }	returns the next character at this cursor position.
private long dragstartedago ( ) { if ( dragstarted == _num ) { return - _num ; } return system . currenttimemillis ( ) - dragstarted ; }	returns the time in milliseconds how long ago the current drag started .
public datetimezonebuilder addcutover ( int year , char mode , int monthofyear , int dayofmonth , int dayofweek , boolean advancedayofweek , int millisofday ) { if ( irulesets . size ( ) > _num ) { ofyear ofyear = new ofyear ( mode , monthofyear , dayofmonth , dayofweek , advancedayofweek , millisofday ) ; ruleset lastruleset = irulesets . get ( irulesets . size ( ) - _num ) ; lastruleset . setupperlimit ( year , ofyear ) ; } irulesets . add ( new ruleset ( ) ) ; return this ; }	adds a cutover for added rules.
private boolean isnullsetting ( boolean makedest , mappingtype mtd , mappingtype mts , stringbuilder result ) { if ( makedest && ( mtd == all_fields || mtd == only_valued_fields ) && mts == only_null_fields ) { result . append ( _str + stringofsetdestination + _str + newline ) ; return _bool ; } return _bool ; }	if it is a null setting returns the null mapping.
protected void findandinit ( iterator it ) { while ( it . hasnext ( ) ) { findandinit ( it . next ( ) ) ; } }	called when the menubar is a part of a beancontext , and it is added to the beancontext , or while other objects are added to the beancontext after that .
private boolean shouldemittypedefbyname ( jstype realtype ) { return realtype . isrecordtype ( ) || realtype . istemplatizedtype ( ) || realtype . isfunctiontype ( ) ; }	whether the typedef should be emitted by name or by the type it is defining.
public static node selectsinglenode ( node contextnode , string str , node namespacenode ) throws transformerexception { nodeiterator nl = selectnodeiterator ( contextnode , str , namespacenode ) ; return nl . nextnode ( ) ; }	use an xpath string to select a single node.
public static array listtoarraytrim ( string list , string delimiter , int [ ] info ) { if ( delimiter . length ( ) == _num ) return listtoarraytrim ( list , delimiter . charat ( _num ) , info ) ; if ( list . length ( ) == _num ) return new arrayimpl ( ) ; char [ ] del = delimiter . tochararray ( ) ; char c ; outer : while ( list . length ( ) > _num ) { c = list . charat ( _num ) ; for ( int i = _num ; i < del . length ; i ++ ) { if ( c == del [ i ] ) { info [ _num ] ++ ; list = list . substring ( _num ) ; continue outer ; } } break ; } int len ; outer : while ( list . length ( ) > _num ) { c = list . charat ( list . length ( ) - _num ) ; for ( int i = _num ; i < del . length ; i ++ ) { if ( c == del [ i ] ) { info [ _num ] ++ ; len = list . length ( ) ; list = list . substring ( _num , len - _num < _num ? _num : len - _num ) ; continue outer ; } } break ; } return listtoarray ( list , delimiter ) ; }	casts a list to array object , remove all empty items at start and end of the list and store count to info.
public biginteger calculateclientevidencemessage ( ) throws cryptoexception { if ( ( this . a == null ) || ( this . b == null ) || ( this . s == null ) ) { throw new cryptoexception ( _str + _str ) ; } this . m1 = srp6util . calculatem1 ( digest , n , a , b , s ) ; return m1 ; }	computes the client evidence message m1 using the previously received values.
public void removearguments ( string label ) { list < pbargument > remove = new arraylist < > ( ) ; for ( pbargument arg : l_arguments ) { if ( arg . islabel ( label ) ) remove . add ( arg ) ; } l_arguments . removeall ( remove ) ; }	removes all argument with the specific label .
public posmikheevfeatureextractor ( string viewname , string json ) { this . viewname = viewname ; this . counter = posmikheevcounter . read ( json ) ; }	construct the feature extractor given a trained counter in json format .
public static boolean endswithignorecase ( string src , string subs ) { string sub = subs . tolowercase ( ) ; int sublen = sub . length ( ) ; int j = _num ; int i = src . length ( ) - sublen ; if ( i < _num ) { return _bool ; } while ( j < sublen ) { char source = character . tolowercase ( src . charat ( i ) ) ; if ( sub . charat ( j ) != source ) { return _bool ; } j ++ ; i ++ ; } return _bool ; }	tests if this string ends with the specified suffix .
private void prefixsearch ( string query ) { m_curnode = m_trie . find ( query ) ; if ( m_curnode != null ) { iterator iter = trieiterator ( ) ; while ( iter . hasnext ( ) ) addinternal ( ( tuple ) iter . next ( ) ) ; } }	issues a prefix search and collects the results.
private void sendstageprogresspatch ( com . vmware . xenon . common . taskstate . taskstage stage ) { serviceutils . loginfo ( this , _str , stage ) ; taskutils . sendselfpatch ( this , buildpatch ( stage , null ) ) ; }	this method sends a patch operation to the current service instance to move to a new state .
@ nullable protected abstract object extractparameter ( @ nullable string cachename , string typename , typekind typekind , string fieldname , object obj ) throws cacheexception ;	get field value from object for use as query parameter .
public static boolean isviewablevalue ( object value ) { if ( value instanceof compositedata || value instanceof tabulardata ) { return _bool ; } if ( value instanceof compositedata [ ] || value instanceof tabulardata [ ] ) { return array . getlength ( value ) > _num ; } if ( value instanceof collection ) { collection < ? > c = ( collection < ? > ) value ; if ( c . isempty ( ) ) { return _bool ; } else { return utils . isuniformcollection ( c , compositedata . class ) || utils . isuniformcollection ( c , tabulardata . class ) ; } } return _bool ; }	the supplied value is viewable iff : - it ' s a compositedata / tabulardata , or - it ' s a non - empty array of compositedata / tabulardata , or - it ' s a non - empty collection of compositedata / tabulardata .
@ override public void reset ( ) throws ioexception { finputstream . reset ( ) ; }	reset the stream . if the stream has been marked , then attempt to reposition it at the mark . if the stream has not been marked , then attempt to reset it in some way appropriate to the particular stream , for example by repositioning it to its starting point . not all character - input streams support the reset ( ) operation , and some support reset ( ) without supporting mark ( ) .
public byte [ ] encode ( ) { char type = getattributetype ( ) ; byte binvalue [ ] = new byte [ header_length + getdatalength ( ) + ( _num - getdatalength ( ) % _num ) % _num ] ; binvalue [ _num ] = ( byte ) ( type > > _num ) ; binvalue [ _num ] = ( byte ) ( type & _num ) ; binvalue [ _num ] = ( byte ) ( getdatalength ( ) > > _num ) ; binvalue [ _num ] = ( byte ) ( getdatalength ( ) & _num ) ; system . arraycopy ( username , _num , binvalue , _num , getdatalength ( ) ) ; return binvalue ; }	returns a binary representation of this attribute .
public longstreamex prepend ( longstream other ) { return new longstreamex ( longstream . concat ( other , stream ( ) ) , context . combine ( other ) ) ; }	creates a lazily concatenated stream whose elements are all the elements of the other stream followed by all the elements of this stream.
public void disconnect ( ) { connected = _bool ; synchronized ( connlostwait ) { connlostwait . notify ( ) ; } if ( mqtt != null ) { try { mqtt . disconnect ( ) ; } catch ( exception ex ) { settitletext ( _str ) ; ex . printstacktrace ( ) ; system . exit ( _num ) ; } } if ( led . isflashing ( ) ) { led . setflash ( ) ; } led . setred ( ) ; setconnected ( _bool ) ; synchronized ( this ) { writelogln ( _str ) ; } }	a wrapper for the mqtt disconnect method.
private void addcdatasectionelement ( string uri_and_localname , vector v ) { stringtokenizer tokenizer = new stringtokenizer ( uri_and_localname , _str , _bool ) ; string s1 = tokenizer . nexttoken ( ) ; string s2 = tokenizer . hasmoretokens ( ) ? tokenizer . nexttoken ( ) : null ; if ( null == s2 ) { v . addelement ( null ) ; v . addelement ( s1 ) ; } else { v . addelement ( s1 ) ; v . addelement ( s2 ) ; } }	adds a uri / localname pair of strings to the list .
private void checkpermissions ( ) { securitymanager sm = system . getsecuritymanager ( ) ; if ( sm != null ) { enumeration < permission > enum_ = permissions . elements ( ) ; while ( enum_ . hasmoreelements ( ) ) { sm . checkpermission ( enum_ . nextelement ( ) ) ; } } }	check that the current access control context has all of the permissions necessary to load classes from this loader .
public spanmanager delete ( int start , int end ) { sb . delete ( start , end ) ; adjustlists ( start , start - end ) ; if ( calculatesrcpositions ) for ( int i = _num ; i < end - start ; i ++ ) ib . remove ( start ) ; return this ; }	deletes the content between start ( included ) and end ( excluded ) .
@ onerror public void onerror ( session session , throwable t ) { callinternal ( _str , session , t . getmessage ( ) ) ; logger . error ( t . getmessage ( ) , t ) ; }	on error raised handler.
public void removestrategy ( final weightingstrategy strategy ) { strategies_ . remove ( strategy ) ; }	removes the strategy from the weighting strategies collection .
public wildcardfilefilter ( string [ ] wildcards , iocase casesensitivity ) { if ( wildcards == null ) { throw new illegalargumentexception ( _str ) ; } this . wildcards = new string [ wildcards . length ] ; system . arraycopy ( wildcards , _num , this . wildcards , _num , wildcards . length ) ; this . casesensitivity = casesensitivity == null ? iocase . sensitive : casesensitivity ; }	construct a new wildcard filter for an array of wildcards specifying case - sensitivity.
public static pair < integer , boolean > parseinfofromfilename ( string name ) { try { if ( name . startswith ( saved_tab_state_file_prefix_incognito ) ) { int id = integer . parseint ( name . substring ( saved_tab_state_file_prefix_incognito . length ( ) ) ) ; return pair . create ( id , _bool ) ; } else if ( name . startswith ( saved_tab_state_file_prefix ) ) { int id = integer . parseint ( name . substring ( saved_tab_state_file_prefix . length ( ) ) ) ; return pair . create ( id , _bool ) ; } } catch ( numberformatexception ex ) { } return null ; }	parse the tab id and whether the tab is incognito from the tab state filename .
protected void initializeconnection ( mqttclientprovider provider ) throws exception { if ( ! isusessl ( ) ) { provider . connect ( _str + port ) ; } else { sslcontext ctx = sslcontext . getinstance ( _str ) ; ctx . init ( new keymanager [ _num ] , new trustmanager [ ] { new defaulttrustmanager ( ) } , new securerandom ( ) ) ; provider . setsslcontext ( ctx ) ; provider . connect ( _str + port ) ; } }	initialize an mqttclientprovider instance.
public void filterrows ( ) { if ( m_parent == null ) return ; cascadedrowmanager rowman = ( cascadedrowmanager ) m_rows ; intiterator crows = m_rows . rows ( ) ; while ( crows . hasnext ( ) ) { int crow = crows . nextint ( ) ; if ( ! m_rowfilter . getboolean ( m_parent . gettuple ( rowman . getparentrow ( crow ) ) ) ) { removecascadedrow ( crow ) ; } } iterator ptuples = m_parent . tuples ( m_rowfilter ) ; while ( ptuples . hasnext ( ) ) { tuple pt = ( tuple ) ptuples . next ( ) ; int prow = pt . getrow ( ) ; if ( rowman . getchildrow ( prow ) == - _num ) addcascadedrow ( prow ) ; } }	manually trigger a re - filtering of the rows of this table.
public int versionpointnumber ( ) { return integer . valueof ( properties . getproperty ( _str ) ) ; }	returns the point version number for the directory server .
private string [ ] splitseparator ( string sep , string s ) { vector v = new vector ( ) ; int tokenstart = _num ; int tokenend = _num ; while ( ( tokenend = s . indexof ( sep , tokenstart ) ) != - _num ) { v . addelement ( s . substring ( tokenstart , tokenend ) ) ; tokenstart = tokenend + _num ; } v . addelement ( s . substring ( tokenstart ) ) ; string [ ] retval = new string [ v . size ( ) ] ; v . copyinto ( retval ) ; return retval ; }	split a string based on the presence of a specified separator.
static boolean advancetofirstfont ( attributedcharacteriterator aci ) { for ( char ch = aci . first ( ) ; ch != characteriterator . done ; ch = aci . setindex ( aci . getrunlimit ( ) ) ) { if ( aci . getattribute ( textattribute . char_replacement ) == null ) { return _bool ; } } return _bool ; }	when this returns , the aci ' s current position will be at the start of the first run which does not contain a graphicattribute.
private static int count ( string pattern , string [ ] possiblevalues ) { int count = _num ; for ( string r : possiblevalues ) { if ( pattern . contains ( r ) ) { count ++ ; } } return count ; }	count the amount of renamer tokens per group.
public static module load ( int id ) { return modules . get ( id ) ; }	load the module by id.
public future < void > updatetableentityasync ( tableentity tableentity , boolean commit ) { updatetableentity ( tableentity , commit ) ; return new asyncresult < void > ( null ) ; }	updates the solr document for the given table entity asynchronly.
boolean hasnextsfeature ( ) { return ( sfeatureidx < sfeatures . size ( ) ) ; }	checks for next s feature .
public void testvalueoflongpositive2 ( ) { long longval = _num ; biginteger anumber = biginteger . valueof ( longval ) ; byte rbytes [ ] = { _num , - _num , _num , _num } ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = anumber . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , anumber . signum ( ) ) ; }	valueof ( long val ) : convert a positive long value to a biginteger.
private boolean processsingleevent ( ) { if ( eventbuffer . remaining ( ) < _num ) { return _bool ; } try { eventbuffer . getint ( ) ; final int bufferlength = eventbuffer . getint ( ) ; final int padding = ( _num - bufferlength ) & _num ; if ( eventbuffer . remaining ( ) < bufferlength + padding + _num ) return _bool ; final byte [ ] buffer = new byte [ bufferlength ] ; eventbuffer . get ( buffer ) ; eventbuffer . position ( eventbuffer . position ( ) + padding ) ; int eventcount = _num ; if ( bufferlength > _num ) { eventcount = iscvaxinteger ( buffer , bufferlength - _num , _num ) ; } eventbuffer . getlong ( ) ; int eventid = eventbuffer . getint ( ) ; log . debug ( string . format ( _str , eventid , eventcount ) ) ; channellistenerdispatcher . eventreceived ( this , new asynchronouschannellistener . event ( eventid , eventcount ) ) ; return _bool ; } catch ( bufferunderflowexception ex ) { return _bool ; } }	processes the event buffer for a single event .
@ override public string tostring ( ) { return name ; }	the string representation of this object .
public static < t > gitnotewriter < t > createnotewriter ( string reviewcommithash , final repository db , personident author , string ref ) { return new gitnotewriter < t > ( reviewcommithash , db , ref , author ) ; }	creates a writer to write comments to a given review .
private element toelement ( scheduletask task ) { element el = doc . createelement ( _str ) ; setattributes ( el , task ) ; return el ; }	translate a schedule task object to a xml element.
public static int inthash ( string ipstring ) { int val = _num ; string [ ] strs = ipstring . split ( _str ) ; int len = strs . length ; if ( len >= _num ) { val = intval ( strs [ _num ] ) ; val <<= _num ; val |= intval ( strs [ _num ] ) ; val <<= _num ; val |= intval ( strs [ _num ] ) ; val <<= _num ; val |= intval ( strs [ _num ] ) ; } return val ; }	this should be suitable for ipv6 as well but we will have to accommodate for the extra bytes later.
public fluentjdbcbuilder connectionprovider ( connectionprovider connectionprovider ) { checknotnull ( connectionprovider , _str ) ; this . connectionprovider = optional . of ( connectionprovider ) ; return this ; }	sets the connectionprovider for fluentjdbc.
public static void register ( string modelname , iwindmodel model , int awesomeness ) { models . put ( modelname , model ) ; if ( modelname . equalsignorecase ( usermodelchoice ) ) { awesomeness = integer . max_value ; } if ( awesomeness > best ) { best = awesomeness ; activemodel = model ; } }	registers a wind model.
public void notifytransactionterminated ( compositetransaction ct ) { boolean notifyofterminatedevent = _bool ; synchronized ( this ) { boolean alreadyterminated = isterminated ( ) ; iterator < transactioncontext > it = allcontexts . iterator ( ) ; while ( it . hasnext ( ) ) { transactioncontext b = it . next ( ) ; b . transactionterminated ( ct ) ; } if ( isterminated ( ) && ! alreadyterminated ) notifyofterminatedevent = _bool ; } if ( notifyofterminatedevent ) { if ( logger . istraceenabled ( ) ) logger . logtrace ( this + _str + this ) ; fireterminatedevent ( ) ; } }	notifies the session that the transaction was terminated .
public jcdiagnostic create ( diagnostictype kind , diagnosticsource source , diagnosticposition pos , string key , object ... args ) { return create ( kind , null , enumset . noneof ( diagnosticflag . class ) , source , pos , key , args ) ; }	create a new diagnostic of the given kind , which is not mandatory and which has no lint category .
public void exporttree ( tree tree ) { map < string , integer > idmap = writenexusheader ( tree ) ; out . println ( _str ) ; writenexustree ( tree , treeprefix + _num , _bool , idmap ) ; out . println ( _str ) ; }	export a tree with all its attributes .
archiveddesktopcomponent adddesktopcomponent ( final org . simbrain . workspace . gui . guicomponent < ? > dc ) { return desktopcomponent = new archiveddesktopcomponent ( this , dc ) ; }	adds a desktop component to this component entry .
public static file createtempdir ( ) { return createtempdir ( new file ( system . getproperty ( _str ) ) ) ; }	create a temporary directory in the directory given by java.
private void extendcolourmap ( int highest ) { for ( int i = m_colorlist . size ( ) ; i < highest ; i ++ ) { color pc = m_defaultcolors [ i % _num ] ; int ija = i / _num ; ija *= _num ; for ( int j = _num ; j < ija ; j ++ ) { pc = pc . brighter ( ) ; } m_colorlist . add ( pc ) ; } }	add more colours to the colour map.
protected void processresult ( final operation operation , final object result , final command commandobj ) throws basecollectionexception { processor _processor = null ; _processor = operation . getprocessor ( ) ; if ( null != _processor ) { list < object > argslist = new arraylist < object > ( ) ; argslist . add ( util . normalizedreadargs ( _keymap , commandobj . retreivearguments ( ) ) ) ; argslist . add ( commandobj . getcommandindex ( ) ) ; _processor . setprerequisiteobjects ( argslist ) ; _processor . processresult ( operation , result , _keymap ) ; } else { _logger . debug ( _str ) ; } }	move the result to processor.
public static string stringfilterstrict ( string searchtext ) { return searchtext . replaceall ( _str , _str ) ; }	remove useless and unsafe characters.
public enumeration enumuratequeue ( ) { vector elements = new vector ( ) ; synchronized ( lock ) { enumeration e = pending . elements ( ) ; while ( e . hasmoreelements ( ) ) { elements . addelement ( e . nextelement ( ) ) ; } } return elements . elements ( ) ; }	this method returns all pending connectiorequest connections .
public boolean hasprevious ( ) { return iterator . hasprevious ( ) ; }	similar to getting the iterator and calling hasprevious on it.
private void captionput ( int value , string text ) { captionmap . put ( new integer ( value ) , text ) ; }	caption put . save a mouse caption ( string ) corresponding to a character value . do not include a character number in the caption ; that is added by captionget ( ) .
public void sortlocations ( ) { if ( l_locations . isempty ( ) ) return ; collections . sort ( l_locations ) ; pblocation fst = l_locations . get ( _num ) , loc ; if ( ! fst . istype ( stringconst . empty ) ) { for ( int i = _num ; i < l_locations . size ( ) ; i ++ ) { loc = l_locations . get ( i ) ; if ( loc . istype ( stringconst . empty ) ) { loc . settype ( fst . gettype ( ) ) ; break ; } } fst . settype ( stringconst . empty ) ; } }	sorts the locations of this argument by their terminal ids and heights .
private static int uarimaxgt ( double value , double [ ] bv , int bvi [ ] , binaryoperator bop ) throws dmlruntimeexception { int ixmax = bv . length ; if ( value <= bv [ _num ] || value > bv [ bv . length - _num ] ) return ixmax ; int ix = arrays . binarysearch ( bv , value ) ; ix = math . abs ( ix ) - _num ; ixmax = bvi [ ix - _num ] + _num ; return ixmax ; }	find out rowindexmax for greaterthan operator .
private void persistvolumenativeid ( dbclient dbclient , uri volumeid , string nativeid , calendar creationtime ) throws ioexception { volume volume = dbclient . queryobject ( volume . class , volumeid ) ; volume . setcreationtime ( creationtime ) ; volume . setnativeid ( nativeid ) ; volume . setnativeguid ( nativeguidgenerator . generatenativeguid ( dbclient , volume ) ) ; dbclient . updateobject ( volume ) ; }	this method saves the native id info and creation time for the volume object.
public whitelist ( ) { this . patterns = collections . emptylist ( ) ; this . statuscode = - _num ; this . enabled = _bool ; }	creates an empty , disabled whitelist .
protected node conditionalexprpromotion ( node node , typemirror desttype ) { typemirror nodetype = node . gettype ( ) ; if ( types . issametype ( nodetype , desttype ) ) { return node ; } if ( typesutils . isprimitive ( nodetype ) && typesutils . isboxedprimitive ( desttype ) ) { return box ( node ) ; } boolean isboxedprimitive = typesutils . isboxedprimitive ( nodetype ) ; typemirror unboxednodetype = isboxedprimitive ? types . unboxedtype ( nodetype ) : nodetype ; typemirror unboxeddesttype = typesutils . isboxedprimitive ( desttype ) ? types . unboxedtype ( desttype ) : desttype ; if ( typesutils . isnumeric ( unboxednodetype ) && typesutils . isnumeric ( unboxeddesttype ) ) { if ( unboxednodetype . getkind ( ) == typekind . byte && desttype . getkind ( ) == typekind . short ) { if ( isboxedprimitive ) { node = unbox ( node ) ; } return widen ( node , desttype ) ; } typekind destkind = desttype . getkind ( ) ; if ( destkind == typekind . byte || destkind == typekind . char || destkind == typekind . short ) { if ( isboxedprimitive ) { return unbox ( node ) ; } else if ( nodetype . getkind ( ) == typekind . int ) { return narrow ( node , desttype ) ; } } return binarynumericpromotion ( node , desttype ) ; } if ( typesutils . isprimitive ( nodetype ) && ( desttype . getkind ( ) == typekind . declared || desttype . getkind ( ) == typekind . union || desttype . getkind ( ) == typekind . intersection ) ) { return box ( node ) ; } return node ; }	convert an operand of a conditional expression to the type of the whole expression .
public void removeconnection ( connection conn ) { int removalindex = findconnection ( conn ) ; if ( removalindex != - _num ) { mconnections . remove ( removalindex ) ; } }	remove the given connection from this list .
public attrset read ( java . security . principal principal , guid guid , string attrnames [ ] ) throws umsexception { string id = guid . getdn ( ) ; connectionentryreader entryreader ; searchrequest request = ldaprequests . newsearchrequest ( id , searchscope . base_object , _str , attrnames ) ; entryreader = readldapentry ( principal , request ) ; if ( entryreader == null ) { throw new accessrightsexception ( id ) ; } collection < attribute > attrs = new arraylist < > ( ) ; try ( connectionentryreader reader = entryreader ) { while ( reader . hasnext ( ) ) { if ( reader . isreference ( ) ) { reader . readreference ( ) ; } searchresultentry entry = entryreader . readentry ( ) ; for ( attribute attr : entry . getallattributes ( ) ) { attrs . add ( attr ) ; } } if ( attrs . isempty ( ) ) { throw new entrynotfoundexception ( i18n . getstring ( iumsconstants . entry_not_found , new string [ ] { id } ) ) ; } return new attrset ( attrs ) ; } catch ( ioexception e ) { throw new umsexception ( i18n . getstring ( iumsconstants . unable_to_read_entry , new string [ ] { id } ) , e ) ; } }	reads an ldap entry .
private function < string , tagstate > newtagretriever ( taggingclient client ) { return null ; }	builds a function to retrieve tags given and endpoint .
public static map < string , list < datafilefooter > > createdatafilefootermappingforsegments ( list < tableblockinfo > tableblockinfolist ) throws indexbuilderexception { map < string , list < datafilefooter > > segmentblockinfomapping = new hashmap < > ( ) ; for ( tableblockinfo blockinfo : tableblockinfolist ) { list < datafilefooter > eachsegmentblocks = new arraylist < > ( ) ; string segid = blockinfo . getsegmentid ( ) ; datafilefooter datafilematadata = null ; list < datafilefooter > metadatalist = segmentblockinfomapping . get ( segid ) ; try { datafilematadata = carbonutil . readmetadatfile ( blockinfo . getfilepath ( ) , blockinfo . getblockoffset ( ) , blockinfo . getblocklength ( ) ) ; } catch ( carbonutilexception e ) { throw new indexbuilderexception ( e ) ; } if ( null == metadatalist ) { eachsegmentblocks . add ( datafilematadata ) ; segmentblockinfomapping . put ( segid , eachsegmentblocks ) ; } else { metadatalist . add ( datafilematadata ) ; } } return segmentblockinfomapping ; }	to create a mapping of segment id and datafilefooter .
public t add ( t e ) { t olde = null ; while ( ! buffer . offerlast ( e ) ) { olde = buffer . poll ( ) ; } return olde ; }	adding an element to the circular buffer implies adding the element to the tail of the deque.
static arraylist < string > loadimage ( file file ) throws filenotfoundexception , runtimeexception { if ( file == null ) return null ; scanner sc ; sc = new scanner ( file ) ; arraylist < string > rows = new arraylist < string > ( ) ; string s = sc . nextline ( ) ; int len = s . length ( ) ; int idx = _num ; rows . add ( s ) ; while ( sc . hasnext ( ) ) { idx ++ ; s = sc . nextline ( ) ; if ( s . length ( ) != len ) { sc . close ( ) ; throw new runtimeexception ( _str + idx + _str + s . length ( ) + _str + len + _str ) ; } rows . add ( s ) ; } sc . close ( ) ; return rows ; }	helper function to load up images .
public static string cutpointstostring ( double [ ] cutpoints , boolean [ ] cutandleft ) { stringbuffer text = new stringbuffer ( _str ) ; if ( cutpoints == null ) { text . append ( _str ) ; } else { text . append ( _str + cutpoints . length + _str ) ; for ( int i = _num ; i < cutpoints . length ; i ++ ) { text . append ( _str + cutpoints [ i ] + _str ) ; text . append ( _str + cutandleft [ i ] + _str ) ; } text . append ( _str ) ; } return text . tostring ( ) ; }	returns a string representing the cutpoints.
private static int capacity ( int expectedmaxsize ) { return ( expectedmaxsize > maximum_capacity / _num ) ? maximum_capacity : ( expectedmaxsize <= _num * minimum_capacity / _num ) ? minimum_capacity : integer . highestonebit ( expectedmaxsize + ( expectedmaxsize << _num ) ) ; }	returns the appropriate capacity for the given expected maximum size.
private void resizenamecolumn ( int diff , boolean resizestatisticpanels ) { if ( diff != _num ) { if ( namedim == null ) { namedim = new dimension ( dimension_header_attribute_name . width + diff , dimension_header_attribute_name . height ) ; } else { int newwidth = namedim . width + diff ; int minwidth = resize_margin_shrink ; int maxwidth = columnheaderpanel . getwidth ( ) - ( dimension_header_missings . width + dimension_header_type . width + dimension_search_field . width + resize_margin_enlarge ) ; if ( newwidth > maxwidth ) { newwidth = maxwidth ; } if ( newwidth < minwidth ) { newwidth = minwidth ; } namedim = new dimension ( newwidth , namedim . height ) ; } sortinglabelattname . setminimumsize ( namedim ) ; sortinglabelattname . setpreferredsize ( namedim ) ; columnheaderpanel . revalidate ( ) ; columnheaderpanel . repaint ( ) ; } if ( resizestatisticpanels ) { revalidateattributepanels ( ) ; } }	called when resizing event occurs to resize the attribute name column.
public void copycheckpointsfrominstallationdirectory ( string destinationcheckpointsfilename ) throws ioexception { if ( destinationcheckpointsfilename == null ) { return ; } file destinationcheckpoints = new file ( destinationcheckpointsfilename ) ; if ( ! destinationcheckpoints . exists ( ) ) { file directory = new file ( _str ) ; string currentworkingdirectory = directory . getcanonicalpath ( ) ; string fileprefix = multibitservice . getfileprefix ( ) ; string checkpointsfilename = fileprefix + multibitservice . checkpoints_suffix ; string sourcecheckpointsfilename = currentworkingdirectory + file . separator + checkpointsfilename ; file sourceblockcheckpoints = new file ( sourcecheckpointsfilename ) ; if ( sourceblockcheckpoints . exists ( ) && ! destinationcheckpointsfilename . equals ( sourcecheckpointsfilename ) ) { log . info ( _str + sourcecheckpointsfilename + _str + destinationcheckpointsfilename + _str ) ; copyfile ( sourceblockcheckpoints , destinationcheckpoints ) ; long sourcelength = sourceblockcheckpoints . length ( ) ; long destinationlength = destinationcheckpoints . length ( ) ; if ( sourcelength != destinationlength ) { string errortext = _str + sourcecheckpointsfilename + _str + sourcelength + _str + destinationcheckpointsfilename + _str + destinationlength ; log . error ( errortext ) ; throw new filehandlerexception ( errortext ) ; } } } }	to support multiple users on the same machine , the checkpoints file is installed into the program installation directory and is then copied to the user ' s application data directory when multibit is first used.
public static boolean isvalidbedgraphline ( string line ) { string [ ] bdg = line . split ( _str ) ; if ( bdg . length < _num ) { return _bool ; } try { integer . parseint ( bdg [ _num ] ) ; integer . parseint ( bdg [ _num ] ) ; } catch ( numberformatexception e ) { return _bool ; } return _bool ; }	return true if line looks like a valid bedgraph record.
public boolean checkarguments ( list arguments ) { boolean validargs = _bool ; if ( arguments != null && arguments . size ( ) > _num ) { string specifiedargs = formatargs ( arguments ) ; debug . log ( _str + specifiedargs ) ; printconsolemessage ( loc_hr_msg_invalid_option , new object [ ] { specifiedargs } ) ; validargs = _bool ; } return validargs ; }	to make sure that migrate has no additional parameter .
public static final void initzk ( zookeeper zkc , string selfbrokerurl ) { try { localzookeeperconnectionservice . checkandcreatepersistnode ( zkc , owner_info_root ) ; cleanupnamespacenodes ( zkc , owner_info_root , selfbrokerurl ) ; } catch ( exception e ) { log . error ( e . getmessage ( ) , e ) ; throw new runtimeexception ( e ) ; } }	initzk is only called when the namespaceservice is initialized.
public e peekforward ( ) { int nextpos = ( pos + _num ) % size ; if ( nextpos >= data . size ( ) || pos == end ) { return null ; } return data . get ( nextpos ) ; }	return the next element ( if present ) , without moving the position in the history .
public boolean addall ( int index , collection c ) { int numnew = c . size ( ) ; synchronized ( this ) { object [ ] elements = getarray ( ) ; int len = elements . length ; if ( index > len || index < _num ) throw new indexoutofboundsexception ( _str + index + _str + len ) ; if ( numnew == _num ) return _bool ; int nummoved = len - index ; object [ ] newelements ; if ( nummoved == _num ) newelements = copyof ( elements , len + numnew ) ; else { newelements = new object [ len + numnew ] ; system . arraycopy ( elements , _num , newelements , _num , index ) ; system . arraycopy ( elements , index , newelements , index + numnew , nummoved ) ; } for ( iterator itr = c . iterator ( ) ; itr . hasnext ( ) ; ) { object e = itr . next ( ) ; newelements [ index ++ ] = e ; } setarray ( newelements ) ; return _bool ; } }	inserts all of the elements in the specified collection into this list , starting at the specified position.
protected static boolean isvalidclassname ( string classname ) { return ( classname . indexof ( _str ) == - _num ) ; }	checks whether the classname is a valid one , i.
public static internaldistributedmember readessentialdata ( datainput in ) throws ioexception , classnotfoundexception { final internaldistributedmember mbr = new internaldistributedmember ( ) ; mbr . _readessentialdata ( in ) ; return mbr ; }	this writes just the parts of the id that are needed for comparisons and communications.
private boolean eval ( final int value , final int threshold ) { logger . debug ( _str + value + _str + threshold ) ; if ( threshold < _num ) { logger . debug ( value < math . abs ( threshold ) ) ; return value < math . abs ( threshold ) ; } else { logger . debug ( value >= math . abs ( threshold ) ) ; return value >= threshold ; } }	evaluates the given value against the provided threshold .
public string tostring ( ) { long ncompleted ; int nworkers , nactive ; final reentrantlock mainlock = this . mainlock ; mainlock . lock ( ) ; try { ncompleted = completedtaskcount ; nactive = _num ; nworkers = workers . size ( ) ; for ( worker w : workers ) { ncompleted += w . completedtasks ; if ( w . islocked ( ) ) ++ nactive ; } } finally { mainlock . unlock ( ) ; } int c = ctl . get ( ) ; string rs = ( runstatelessthan ( c , shutdown ) ? _str : ( runstateatleast ( c , terminated ) ? _str : _str ) ) ; return super . tostring ( ) + _str + rs + _str + nworkers + _str + nactive + _str + workqueue . size ( ) + _str + ncompleted + _str ; }	returns a string identifying this pool , as well as its state , including indications of run state and estimated worker and task counts .
public static string hex ( float f ) { return integer . tohexstring ( float . floattointbits ( f ) ) ; }	print a float type ' s internal bit representation in hex.
public synchronized object remove ( int index ) { object [ ] elements = getarray ( ) ; int len = elements . length ; object oldvalue = elements [ index ] ; int nummoved = len - index - _num ; if ( nummoved == _num ) setarray ( copyof ( elements , len - _num ) ) ; else { object [ ] newelements = new object [ len - _num ] ; system . arraycopy ( elements , _num , newelements , _num , index ) ; system . arraycopy ( elements , index + _num , newelements , index , nummoved ) ; setarray ( newelements ) ; } return oldvalue ; }	removes the element at the specified position in this list.
public void testcompositeattributecanbenull ( ) throws exception { htmlpage page = getpage ( _str ) ; assertelementattributeequals ( page , _str , _str , _str ) ; assertelementattributeequals ( page , _str , _str , _str ) ; }	test for issue # 1986.
public static string doubletostring ( double d ) { if ( double . isinfinite ( d ) || double . isnan ( d ) ) { return _str ; } string string = double . tostring ( d ) ; if ( string . indexof ( _str ) > _num && string . indexof ( _str ) < _num && string . indexof ( _str ) < _num ) { while ( string . endswith ( _str ) ) { string = string . substring ( _num , string . length ( ) - _num ) ; } if ( string . endswith ( _str ) ) { string = string . substring ( _num , string . length ( ) - _num ) ; } } return string ; }	produce a string from a double.
@ override public enumeration < option > listoptions ( ) { vector < option > result = new vector < option > ( _num ) ; result . addelement ( new option ( _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str , _str , _num , _str ) ) ; result . addelement ( new option ( _str + _str + _str , _str , _num , _str ) ) ; result . addall ( collections . list ( super . listoptions ( ) ) ) ; return result . elements ( ) ; }	returns an enumeration describing the available options .
public static vector3 ceil ( vector3 o ) { return new vector3 ( math . ceil ( o . x ) , math . ceil ( o . y ) , math . ceil ( o . z ) ) ; }	rounds the x , y , and z values of the given vector3 up to the nearest integer value .
static void importmap ( inputstream is , map < string , string > m ) throws ioexception , invalidpreferencesformatexception { try { document doc = loadprefsdoc ( is ) ; element xmlmap = doc . getdocumentelement ( ) ; string mapversion = xmlmap . getattribute ( _str ) ; if ( mapversion . compareto ( map_xml_version ) > _num ) throw new invalidpreferencesformatexception ( _str + mapversion + _str + _str + map_xml_version + _str + _str ) ; nodelist entries = xmlmap . getchildnodes ( ) ; for ( int i = _num , numentries = entries . getlength ( ) ; i < numentries ; i ++ ) { element entry = ( element ) entries . item ( i ) ; m . put ( entry . getattribute ( _str ) , entry . getattribute ( _str ) ) ; } } catch ( saxexception e ) { throw new invalidpreferencesformatexception ( e ) ; } }	import map from the specified input stream , which is assumed to contain a map document as per the prefs dtd.
@ deprecated protected void wait ( int duration , runnable callback ) { executor . schedule ( callback , duration , timeunit . milliseconds ) ; }	unsafe method since not interruptible . use at own risk.
public synchronized void removeofchannelhandler ( ofchannelhandler h ) { connectedchannelhandlers . remove ( h ) ; }	remove ofchannelhandler . e . g . , due do disconnect .
public void clearcache ( ) { clearmemorycache ( ) ; cleardiskcache ( ) ; }	clears both the memory and disk cache associated with this imagecache object.
public void removepropertychangelistener ( propertychangelistener pcl ) { m_pcsupport . removepropertychangelistener ( pcl ) ; }	remove a property change listener.
@ suppresswarnings ( _str ) protected boolean isfastclocktimege ( int hr , int min ) { date now = fastclock . gettime ( ) ; nowhours = now . gethours ( ) ; nowminutes = now . getminutes ( ) ; if ( ( ( nowhours * _num ) + nowminutes ) >= ( ( hr * _num ) + min ) ) { return _bool ; } return _bool ; }	this method tests time assuming both times are on the same day ( ignoring midnight ) it also sets nowminutes and nowhours to the latest fast clock values.
public void testnegpossamelength ( ) { string numa = _str ; string numb = _str ; string res = _str ; biginteger anumber = new biginteger ( numa ) ; biginteger bnumber = new biginteger ( numb ) ; biginteger result = anumber . xor ( bnumber ) ; asserttrue ( res . equals ( result . tostring ( ) ) ) ; }	xor for two numbers of different signs and the same length.
public void removerenamingcallback ( onesheeldrenamingcallback renamingcallback ) { if ( renamingcallback != null && renamingcallbacks . contains ( renamingcallback ) ) renamingcallbacks . remove ( renamingcallback ) ; }	remove a renaming callback .
public boolean filliflive ( long timeout ) throws ioexception { streamimpl source = _source ; byte [ ] readbuffer = _readbuffer ; if ( readbuffer == null || source == null ) { _readoffset = _num ; _readlength = _num ; return _bool ; } if ( _readoffset > _num ) { system . arraycopy ( readbuffer , _readoffset , readbuffer , _num , _readlength - _readoffset ) ; _readlength -= _readoffset ; _readoffset = _num ; } if ( _readlength == readbuffer . length ) return _bool ; int readlength = source . readtimeout ( _readbuffer , _readlength , _readbuffer . length - _readlength , timeout ) ; if ( readlength >= _num ) { _readlength += readlength ; _position += readlength ; if ( _isenablereadtime ) _readtime = currenttime . currenttime ( ) ; return _bool ; } else if ( readlength == read_timeout ) { return _bool ; } else { return _bool ; } }	fills the buffer with a timed read , testing for the end of file.
public threaddata ( string threadname , string threadstate , long cputimeinnanoseconds ) { this . threadname = threadname ; this . threadstate = threadstate ; this . cputimeinnanoseconds = cputimeinnanoseconds ; }	instantiates a new thread data .
protected jfreechart createchart ( categorydataset dataset , string title , muom uom ) { jfreechart chart = chartfactory . createbarchart3d ( title , _str , _str , dataset , plotorientation . vertical , _bool , _bool , _bool ) ; if ( uom == null || uom . ishour ( ) ) { chart = chartfactory . createbarchart3d ( title , msg . translate ( env . getctx ( ) , _str ) , msg . translate ( env . getctx ( ) , _str ) , dataset , plotorientation . vertical , _bool , _bool , _bool ) ; } else { chart = chartfactory . createbarchart3d ( title , msg . translate ( env . getctx ( ) , _str ) , msg . translate ( env . getctx ( ) , _str ) , dataset , plotorientation . vertical , _bool , _bool , _bool ) ; } return chart ; }	create chart using the data set and uom.
private valuegraphvertex findorcreatevertex ( register r ) { valuegraphvertex v = getvertex ( r ) ; if ( v == null ) { v = new valuegraphvertex ( r ) ; v . setlabel ( r , _num ) ; graph . addgraphnode ( v ) ; namemap . put ( r , v ) ; } return v ; }	find or create an valuegraphvertex corresponding to a given register.
public radiusgraphelementaccessor ( ) { this ( math . sqrt ( double . max_value - _num ) ) ; }	creates an instance with an effectively infinite default maximum distance .
public void removelatestupdate ( password password ) throws pageexception { _removeupdate ( password , _bool ) ; }	run update from cfml engine.
public void notifyqueryrunning ( final boundentity song ) { synchronized ( mrunningqueries ) { mrunningqueries . add ( song ) ; } }	notifies an async task has started processing the art for the provided entity.
public void testbooleanoptions ( ) throws exception { databasemetadata dbmd = con . getmetadata ( ) ; asserttrue ( _str , dbmd . locatorsupdatecopy ( ) ) ; asserttrue ( _str , dbmd . supportsgetgeneratedkeys ( ) ) ; asserttrue ( _str , dbmd . supportsmultipleopenresults ( ) ) ; asserttrue ( _str , dbmd . supportsnamedparameters ( ) ) ; assertfalse ( _str , dbmd . supportsresultsetholdability ( resultset . hold_cursors_over_commit ) ) ; assertfalse ( _str , dbmd . supportsresultsetholdability ( resultset . close_cursors_at_commit ) ) ; asserttrue ( _str , dbmd . supportssavepoints ( ) ) ; asserttrue ( _str , dbmd . supportsstatementpooling ( ) ) ; }	test meta data functions that return boolean values .
private static properties createproperties1 ( ) { properties props = new properties ( ) ; props . setproperty ( mcast_port , _str ) ; props . setproperty ( locators , _str ) ; return props ; }	create properties for a loner vm.
public void connected ( ) { final string methodname = _str ; log . fine ( class_name , methodname , _str ) ; this . connected = _bool ; pingsender . start ( ) ; }	called when the client has successfully connected to the broker.
static float rotatex ( float px , float py , float cx , float cy , float angleindegrees ) { double angle = math . toradians ( angleindegrees ) ; return ( float ) ( math . cos ( angle ) * ( px - cx ) - math . sin ( angle ) * ( py - cy ) + cx ) ; }	rotate point p around center point c .
public boolean start ( float startscale , float targetscale , float centerx , float centery ) { if ( mrunning ) { return _bool ; } mcenterx = centerx ; mcentery = centery ; mtargetscale = targetscale ; mstarttime = system . currenttimemillis ( ) ; mstartscale = startscale ; mzoomingin = mtargetscale > mstartscale ; mvelocity = ( mtargetscale - mstartscale ) / zoom_animation_duration ; mrunning = _bool ; mstop = _bool ; mheader . post ( this ) ; return _bool ; }	starts the animation . there is no target scale bounds check .
private void dispatchonthirdpartyregistrationfailed ( ) { synchronized ( this ) { for ( thirdpartyregistrationlistener listener : mthirdpartyregistrationlisteners ) { try { listener . onthirdpartyregistrationfailed ( ) ; } catch ( exception e ) { log . e ( log_tag , _str + e . getlocalizedmessage ( ) ) ; } } mthirdpartyregistrationlisteners . clear ( ) ; } }	dispatch the onthirdpartyregistrationfailed to the listeners .
public void removecostemplates ( ) throws umsexception { arraylist alist = ( arraylist ) getcostemplates ( ) ; for ( int i = _num ; i < alist . size ( ) ; i ++ ) { costemplate costemplate = ( costemplate ) alist . get ( i ) ; costemplate . remove ( ) ; } }	removes all cos templates from this cos definition .
private void collectreferences ( final ioperandtreenode node , final set < iaddress > references ) { for ( final ireference reference : node . getreferences ( ) ) { if ( referencetype . iscodereference ( reference . gettype ( ) ) ) { references . add ( reference . gettarget ( ) ) ; } } for ( final ioperandtreenode child : node . getchildren ( ) ) { collectreferences ( child , references ) ; } }	collects all code references from an operand tree node and all of its children .
private applydeletesresult closesegmentstates ( indexwriter . readerpool pool , segmentstate [ ] segstates , boolean success , long gen ) throws ioexception { int numreaders = segstates . length ; throwable firstexc = null ; list < segmentcommitinfo > alldeleted = null ; long totdelcount = _num ; for ( int j = _num ; j < numreaders ; j ++ ) { segmentstate segstate = segstates [ j ] ; if ( success ) { totdelcount += segstate . rld . getpendingdeletecount ( ) - segstate . startdelcount ; segstate . reader . getsegmentinfo ( ) . setbuffereddeletesgen ( gen ) ; int fulldelcount = segstate . rld . info . getdelcount ( ) + segstate . rld . getpendingdeletecount ( ) ; assert fulldelcount <= segstate . rld . info . info . maxdoc ( ) ; if ( fulldelcount == segstate . rld . info . info . maxdoc ( ) ) { if ( alldeleted == null ) { alldeleted = new arraylist < > ( ) ; } alldeleted . add ( segstate . reader . getsegmentinfo ( ) ) ; } } try { segstates [ j ] . finish ( pool ) ; } catch ( throwable th ) { if ( firstexc != null ) { firstexc = th ; } } } if ( success ) { ioutils . rethrow ( firstexc ) ; } if ( infostream . isenabled ( _str ) ) { infostream . message ( _str , _str + totdelcount + _str ) ; } return new applydeletesresult ( totdelcount > _num , gen , alldeleted ) ; }	close segment states previously opened with opensegmentstates .
private void handleyarncontainerchange ( string containercountasstring ) throws ioexception , yarnexception { string applicationid = yarnutil . getrunningappid ( jobname , jobid ) ; int containercount = integer . valueof ( containercountasstring ) ; int currentnumtask = getcurrentnumtasks ( ) ; int currentnumcontainers = getcurrentnumcontainers ( ) ; if ( containercount == currentnumcontainers ) { log . error ( _str ) ; return ; } if ( containercount <= _num ) { log . error ( _str ) ; return ; } if ( containercount > currentnumtask ) { log . error ( _str ) ; return ; } log . info ( _str ) ; yarnutil . killapplication ( applicationid ) ; coordinatorserverurl = null ; try { string state = yarnutil . getapplicationstate ( applicationid ) ; thread . sleep ( _num ) ; int countsleep = _num ; while ( ! state . equals ( _str ) ) { state = yarnutil . getapplicationstate ( applicationid ) ; log . info ( _str + applicationid + _str ) ; thread . sleep ( _num ) ; countsleep ++ ; if ( countsleep > _num ) { throw new illegalstateexception ( _str ) ; } } } catch ( interruptedexception e ) { e . printstacktrace ( ) ; } log . info ( _str ) ; log . info ( _str ) ; skipunreadmessages ( ) ; jobrunner jobrunner = new jobrunner ( config ) ; jobrunner . run ( _bool ) ; }	this method handles setconfig messages that want to change the number of containers of a job.
public static boolean comparecellvalue ( double v1 , double v2 , double t , boolean ignorenan ) { if ( v1 == null ) v1 = _num ; if ( v2 == null ) v2 = _num ; if ( ignorenan && ( v1 . isnan ( ) || v1 . isinfinite ( ) || v2 . isnan ( ) || v2 . isinfinite ( ) ) ) return _bool ; if ( v1 . equals ( v2 ) ) return _bool ; return math . abs ( v1 - v2 ) <= t ; }	compares two double values regarding tolerance t.
public static int ping ( string url ) throws exception { url u = new url ( url ) ; httpurlconnection c = ( httpurlconnection ) u . openconnection ( ) ; c . connect ( ) ; int code = c . getresponsecode ( ) ; log . debug ( _str + url + _str + code ) ; c . disconnect ( ) ; return code ; }	ping the url , throw exception if occur error.
public static int secondaryidentityhash ( object key ) { return secondaryhash ( system . identityhashcode ( key ) ) ; }	computes an identity hash code and applies a supplemental hash function to defend against poor quality hash functions.
public config loadinstalledcodenvyconfig ( installtype installtype ) throws ioexception { map < string , string > properties = loadinstalledcodenvyproperties ( installtype ) ; return new config ( properties ) ; }	loads appropriate codenvy config for given installation type .
public geodistancesortbuilder point ( double lat , double lon ) { points . add ( new geopoint ( lat , lon ) ) ; return this ; }	the point to create the range distance facets from .
protected int indexfirstof ( final string s , final string delims , int offset ) { if ( s == null || s . length ( ) == _num ) { return - _num ; } if ( delims == null || delims . length ( ) == _num ) { return - _num ; } if ( offset < _num ) { offset = _num ; } else if ( offset > s . length ( ) ) { return - _num ; } int min = s . length ( ) ; final char [ ] delim = delims . tochararray ( ) ; for ( int i = _num ; i < delim . length ; i ++ ) { final int at = s . indexof ( delim [ i ] , offset ) ; if ( at >= _num && at < min ) { min = at ; } } return ( min == s . length ( ) ) ? - _num : min ; }	get the earlier index that to be searched for the first occurrance in one of any of the given string .
public namedcolor ( string [ ] namesarray , int r , int g , int b ) { super ( r , g , b ) ; names = new hashset < > ( ) ; names . addall ( arrays . aslist ( namesarray ) ) ; nameslowercase = new hashset < > ( ) ; for ( string thisname : namesarray ) { nameslowercase . add ( thisname . tolowercase ( ) ) ; } if ( namesarray . length == _num ) { name = _str ; } else { name = namesarray [ _num ] ; } }	constructs a new color with the given names and rgb values.
public void showcontent ( ) { switchstate ( content , null , null , null , null , null , collections . < integer > emptylist ( ) ) ; }	hide all other states and show content.
public static boolean isvalidtemplate ( string template ) { template = template . trim ( ) ; if ( template . indexof ( _str ) == - _num ) { return _bool ; } string s = template . trim ( ) ; if ( s . lastindexof ( _str ) != s . length ( ) - _num ) { return _bool ; } if ( getmethodsignature ( template ) == null ) { return _bool ; } if ( getmethodbody ( template ) == null ) { return _bool ; } return _bool ; }	validates the provided template .
private void awaitoperationsavailable ( ) throws interruptedexception { flushlock . lock ( ) ; try { do { if ( writecache . sizex ( ) <= cachemaxsize || cachemaxsize == _num ) { if ( cacheflushfreq > _num ) canflush . await ( cacheflushfreq , timeunit . milliseconds ) ; else canflush . await ( ) ; } } while ( writecache . sizex ( ) == _num && ! stopping . get ( ) ) ; } finally { flushlock . unlock ( ) ; } }	this method awaits until enough elements in map are available or given timeout is over .
public string tostring ( ) { stringbuffer buf = new stringbuffer ( ) ; if ( _isboot || ( _datachars [ _num ] == sprogmessage . stx ) ) { for ( int i = _num ; i < _ndatachars ; i ++ ) { buf . append ( _str ) ; buf . append ( _datachars [ i ] ) ; buf . append ( _str ) ; } } else { for ( int i = _num ; i < _ndatachars ; i ++ ) { buf . append ( ( char ) _datachars [ i ] ) ; } } return buf . tostring ( ) ; }	returns a string representation of this sprogreply.
public static boolean isnativecodeloaded ( ) { return nativecodeloader . isnativecodeloaded ( ) ; }	checks whether the native code has been successfully loaded for the platform .
abstract void replay ( ) ;	reapplies the change to prefscache .
private boolean readytoconnect ( ) { long now = system . currenttimemillis ( ) ; long lastexchangemillis = mstore . getlong ( last_exchange_time_key , - _num ) ; boolean timesincelastok ; if ( lastexchangemillis == - _num ) { timesincelastok = _bool ; } else if ( now - lastexchangemillis < time_between_exchanges_millis ) { timesincelastok = _bool ; } else { timesincelastok = _bool ; } if ( ! use_minimal_logging ) { log . info ( _str + ( timesincelastok && ( getconnecting ( ) == null ) ) ) ; log . info ( _str + getconnecting ( ) ) ; log . info ( _str + timesincelastok ) ; } return timesincelastok && ( getconnecting ( ) == null ) ; }	check whether we can connect , according to our policies.
public static void putdouble ( long addr , double val ) { if ( unaligned ) unsafe . putdouble ( addr , val ) ; else putlongbybyte ( addr , double . doubletolongbits ( val ) , big_endian ) ; }	stores given double value.
public void add ( t item ) { if ( items . add ( item ) ) { notifydatasetchanged ( ) ; } }	adds a new item to the adapter ' s list .
public dsnlayerstructure ( collection < dsnlayer > p_layer_list ) { arr = new dsnlayer [ p_layer_list . size ( ) ] ; iterator < dsnlayer > it = p_layer_list . iterator ( ) ; for ( int i = _num ; i < arr . length ; ++ i ) { arr [ i ] = it . next ( ) ; } }	creates a new instance of layerstructure from a list of layers.
public void writenext ( string [ ] nextline , boolean applyquotestoall ) { if ( nextline == null ) { return ; } stringbuilder sb = new stringbuilder ( initial_string_size ) ; for ( int i = _num ; i < nextline . length ; i ++ ) { if ( i != _num ) { sb . append ( separator ) ; } string nextelement = nextline [ i ] ; if ( nextelement == null ) { continue ; } boolean stringcontainsspecialcharacters = stringcontainsspecialcharacters ( nextelement ) ; if ( ( applyquotestoall || stringcontainsspecialcharacters ) && quotechar != no_quote_character ) { sb . append ( quotechar ) ; } if ( stringcontainsspecialcharacters ) { sb . append ( processline ( nextelement ) ) ; } else { sb . append ( nextelement ) ; } if ( ( applyquotestoall || stringcontainsspecialcharacters ) && quotechar != no_quote_character ) { sb . append ( quotechar ) ; } } sb . append ( lineend ) ; pw . write ( sb . tostring ( ) ) ; }	writes the next line to the file .
public double [ ] incominginstancetovectorfieldvals ( double [ ] incoming ) throws exception { double [ ] newinst = new double [ m_vectorfields . size ( ) ] ; for ( int i = _num ; i < m_vectorfields . size ( ) ; i ++ ) { fieldref fr = m_vectorfields . get ( i ) ; newinst [ i ] = fr . getresult ( incoming ) ; } return newinst ; }	convert an incoming instance to an array of values that corresponds to the fields referenced by the support vectors in the vector dictionary.
public source resolveuri ( string base , string urlstring , sourcelocator locator ) throws transformerexception , ioexception { source source = null ; if ( null != m_uriresolver ) { source = m_uriresolver . resolve ( urlstring , base ) ; } if ( null == source ) { string uri = systemidresolver . getabsoluteuri ( urlstring , base ) ; source = new streamsource ( uri ) ; } return source ; }	this will be called by the processor when it encounters an xsl : include , xsl : import , or document ( ) function .
private static void lognodeproperties ( org . osgi . service . prefs . preferences node ) { if ( node == null ) { return ; } try { log . info ( node . name ( ) + _str ) ; logproperties ( node ) ; string [ ] childrennames = node . childrennames ( ) ; for ( int i = _num ; i < childrennames . length ; i ++ ) { lognodeproperties ( node . node ( childrennames [ i ] ) ) ; } } catch ( exception t ) { log . error ( _str , t ) ; } }	logs all properties of a preference node and calls lognodeproperties for all children of this node .
public static < t extends dataobject > t findincollection ( collection < t > col , t obj ) { if ( col != null && obj != null ) { return findincollection ( col , obj . getid ( ) ) ; } return null ; }	finds an dataobject in a collection by matching it by id.
public codeviewer ( ) { sethighlightcolor ( default_highlight_color ) ; initactions ( ) ; setlayout ( new borderlayout ( ) ) ; codehighlightbar = createcodehighlightbar ( ) ; codehighlightbar . setvisible ( _bool ) ; add ( codehighlightbar , borderlayout . north ) ; codepanel = createcodepanel ( ) ; add ( codepanel , borderlayout . center ) ; applydefaults ( ) ; }	creates a new instance of codeviewer.
@ override public boolean equals ( object obj ) { if ( this == obj ) return _bool ; if ( obj == null ) return _bool ; if ( getclass ( ) != obj . getclass ( ) ) return _bool ; ifdstructure other = ( ifdstructure ) obj ; if ( count != other . count ) return _bool ; if ( offsetvalue != other . offsetvalue ) return _bool ; if ( tag != other . tag ) return _bool ; if ( type != other . type ) return _bool ; return _bool ; }	returns whether this object is equal to the given object .
public boolean isabsoluteuri ( ) { return ( _scheme != null ) ; }	tell whether or not this uri is absolute .
public synchronized boolean isconsumer ( imageconsumer ic ) { return ics . contains ( ic ) ; }	determine if an imageconsumer is on the list of consumers currently interested in data for this image .
public boolean ismandatory ( ) { return flags . contains ( diagnosticflag . mandatory ) ; }	check whether or not this diagnostic is required to be shown .
public static alarmcacheobject createtestalarm1 ( ) { alarmcacheobject alarm1 = new alarmcacheobject ( ) ; alarm1 . setid ( long . valueof ( _num ) ) ; alarm1 . setfaultfamily ( _str ) ; alarm1 . setfaultmember ( _str ) ; alarm1 . setfaultcode ( _num ) ; alarmcondition condition = alarmcondition . fromconfigxml ( _str + _str ) ; alarm1 . setcondition ( condition ) ; alarm1 . setinfo ( _str ) ; alarm1 . setstate ( alarmcondition . terminate ) ; alarm1 . settimestamp ( new timestamp ( system . currenttimemillis ( ) - _num ) ) ; alarm1 . setdatatagid ( _num ) ; return alarm1 ; }	does not set reference to tag id .
public boolean justserialized ( ) { return serialized . getandset ( _bool ) ; }	this is called on deserialization.
public object read ( string xml ) throws exception { return fromxml ( m_document . read ( xml ) ) ; }	parses the given xml string ( can be xml or a filename ) and returns an object generated from the representation.
protected t newinstance ( final class < ? extends t > cls , final iindexmanager indexmanager , final nt nt , final properties properties ) { if ( cls == null ) throw new illegalargumentexception ( ) ; if ( indexmanager == null ) throw new illegalargumentexception ( ) ; if ( nt == null ) throw new illegalargumentexception ( ) ; if ( properties == null ) throw new illegalargumentexception ( ) ; final constructor < ? extends t > ctor ; try { ctor = cls . getconstructor ( new class [ ] { iindexmanager . class , string . class , long . class , properties . class } ) ; } catch ( exception e ) { throw new runtimeexception ( _str + cls . getname ( ) + _str + e , e ) ; } final t r ; try { r = ctor . newinstance ( new object [ ] { indexmanager , nt . getname ( ) , nt . gettimestamp ( ) , properties } ) ; r . init ( ) ; if ( info ) { log . info ( _str + r ) ; } return r ; } catch ( exception ex ) { throw new runtimeexception ( _str + ex , ex ) ; } }	create a new view of the relation .
public builder ( ) { }	creates a new property . builder.
protected maptile findcovering ( int zoom , long i , long j ) { while ( zoom > _num ) { zoom -- ; i = i / _num ; j = j / _num ; maptile candidate = findtile ( zoom , i , j ) ; if ( ( candidate != null ) && ( ! candidate . loading ( ) ) ) { return candidate ; } } return null ; }	find the " nearest " lower - zoom tile that covers a specific tile . this is used to find out what tile we have to show while a new tile is still loading.
@ override public string format ( object obj ) throws illegalargumentexception { return format ( obj , new stringbuffer ( ) ) ; }	format a given object .
public boolean isempty ( ) { return ( ( values == null ) || ( values . isempty ( ) ) ) ; }	obtiene si la lista de valores esta vacia.
private static string [ ] processobjectclasses ( final string objectclass ) { string [ ] objectclasses = null ; if ( objectclass != null ) { objectclasses = objectclass . split ( _str ) ; } if ( objectclasses != null ) { string objclass = null ; for ( int i = _num ; i < objectclasses . length ; i ++ ) { objclass = objectclasses [ i ] ; if ( objclass != null ) { objectclasses [ i ] = objclass . trim ( ) ; } } } return objectclasses ; }	procesa un string con clases separadas por , para devolver un array.
public static string [ ] filterlightcolors ( string [ ] apalette , int athreshold ) { list < string > filtered = new arraylist < string > ( ) ; for ( string color : apalette ) { if ( ! istoolight ( color , athreshold ) ) { filtered . add ( color ) ; } } return ( string [ ] ) filtered . toarray ( new string [ filtered . size ( ) ] ) ; }	filter out too light colors from the palette - those that do not show propely on a ligth background.
synchronized int lookup ( final object tx , final boolean insert ) { if ( tx == null ) { throw new illegalargumentexception ( _str ) ; } integer index = ( integer ) mapping . get ( tx ) ; if ( index == null ) { if ( insert ) { final int capacity = capacity ( ) ; final int nvertices = mapping . size ( ) ; if ( nvertices == capacity ) { throw new multiprogrammingcapacityexceededexception ( _str + capacity + _str + nvertices ) ; } index = ( integer ) indices . remove ( _num ) ; mapping . put ( tx , index ) ; final int ndx = index . intvalue ( ) ; if ( transactions [ ndx ] != null ) { throw new assertionerror ( ) ; } transactions [ ndx ] = tx ; } else { return - _num ; } } return index . intvalue ( ) ; }	lookup index assigned to transaction object .
public void deregister ( trainschedule schedule ) { if ( schedule == null ) { return ; } integer oldsize = integer . valueof ( _schedulehashtable . size ( ) ) ; _schedulehashtable . remove ( schedule . getid ( ) ) ; setdirtyandfirepropertychange ( listlength_changed_property , oldsize , integer . valueof ( _schedulehashtable . size ( ) ) ) ; }	forget a namedbean object created outside the manager .
public int readleint ( ) throws ioexception { int byte1 , byte2 , byte3 , byte4 ; synchronized ( this ) { byte1 = in . read ( ) ; byte2 = in . read ( ) ; byte3 = in . read ( ) ; byte4 = in . read ( ) ; } if ( byte4 == - _num ) { throw new eofexception ( ) ; } return ( byte4 << _num ) + ( byte3 << _num ) + ( byte2 << _num ) + byte1 ; }	translates a little endian int into a big endian int.
public void initializeatomsfordp ( list < datum > data , string filename , random random ) { omega = new arraylist < > ( k ) ; dof = new double [ k ] ; beta = new double [ k ] ; if ( filename != null ) { try { loc = batchmixturemodel . initializeclustersfromfile ( filename , k ) ; log . debug ( _str , loc ) ; if ( loc . size ( ) < k ) { loc = batchmixturemodel . gonzalezinitializemixturecenters ( loc , data , k , random ) ; } } catch ( filenotfoundexception e ) { log . debug ( _str ) ; e . printstacktrace ( ) ; loc = batchmixturemodel . gonzalezinitializemixturecenters ( data , k , random ) ; } } else { loc = batchmixturemodel . gonzalezinitializemixturecenters ( data , k , random ) ; } for ( int i = _num ; i < k ; i ++ ) { beta [ i ] = _num ; dof [ i ] = basenu ; omega . add ( _num , algebrautils . invertmatrix ( baseomegainverse ) ) ; } }	initializes atom ( component ) distributions.
private string determineeventtypebasedonoperationalstatus ( hashtable < string , string > notification , string [ ] descs , string [ ] codes , string evtoktype , string evtnotoktype , list < string > propdescriptions , list < string > propcodes ) { logmessage ( _str , new object [ ] { } ) ; string evttype = null ; string [ ] values = descs ; if ( values . length > _num ) { evttype = evtnotoktype ; for ( string value : values ) { if ( propdescriptions . contains ( value ) ) { evttype = evtoktype ; break ; } } } else { values = codes ; if ( values . length > _num ) { evttype = evtnotoktype ; for ( string value : values ) { if ( propcodes . contains ( value ) ) { evttype = evtoktype ; break ; } } } else { logmessage ( _str , new object [ ] { } ) ; } } return evttype ; }	figure out the file and block related event type based on the operational status values available in the indication.
public static int tointaccess ( string access ) throws applicationexception { access = stringutil . tolowercase ( access . trim ( ) ) ; if ( access . equals ( _str ) ) return component . access_package ; else if ( access . equals ( _str ) ) return component . access_private ; else if ( access . equals ( _str ) ) return component . access_public ; else if ( access . equals ( _str ) ) return component . access_remote ; throw new applicationexception ( _str + access + _str ) ; }	cast a strong access definition to the int type.
static byte [ ] ntlm2sessionresponse ( final byte [ ] ntlmhash , final byte [ ] challenge , final byte [ ] clientchallenge ) throws authenticationexception { try { final messagedigest md5 = messagedigest . getinstance ( _str ) ; md5 . update ( challenge ) ; md5 . update ( clientchallenge ) ; final byte [ ] digest = md5 . digest ( ) ; final byte [ ] sessionhash = new byte [ _num ] ; system . arraycopy ( digest , _num , sessionhash , _num , _num ) ; return lmresponse ( ntlmhash , sessionhash ) ; } catch ( exception e ) { if ( e instanceof authenticationexception ) throw ( authenticationexception ) e ; throw new authenticationexception ( e . getmessage ( ) , e ) ; } }	calculates the ntlm2 session response for the given challenge , using the specified password and client challenge .
public boolean isancestorof ( ijavaelement e ) { ijavaelement parentelement = e . getparent ( ) ; while ( parentelement != null && ! parentelement . equals ( this ) ) { parentelement = parentelement . getparent ( ) ; } return parentelement != null ; }	returns true if this element is an ancestor of the given element , otherwise false .
protected final void enableretransmissiontimer ( int tickcount ) { if ( isinvitetransaction ( ) && ( this instanceof sipclienttransaction ) ) { retransmissiontimerticksleft = tickcount ; } else { retransmissiontimerticksleft = math . min ( tickcount , maximum_retransmission_tick_count ) ; } retransmissiontimerlasttickcount = retransmissiontimerticksleft ; retransmissionoutdatedtime = systemclock . elapsedrealtime ( ) + retransmissiontimerticksleft * base_timer_interval ; }	enables retransmission timer events for this transaction to begin after the number of ticks passed to this routine .
void tidy ( int windowstartyear ) { if ( lastrulelist . size ( ) == _num ) { throw new illegalstateexception ( _str ) ; } if ( windowend . equals ( localdatetime . max ) ) { maxlastrulestartyear = math . max ( maxlastrulestartyear , windowstartyear ) + _num ; for ( tzrule lastrule : lastrulelist ) { addrule ( lastrule . year , maxlastrulestartyear , lastrule . month , lastrule . dayofmonthindicator , lastrule . dayofweek , lastrule . time , lastrule . timeendofday , lastrule . timedefinition , lastrule . savingamountsecs ) ; lastrule . year = maxlastrulestartyear + _num ; } if ( maxlastrulestartyear == year_max_value ) { lastrulelist . clear ( ) ; } else { maxlastrulestartyear ++ ; } } else { int endyear = windowend . getyear ( ) ; for ( tzrule lastrule : lastrulelist ) { addrule ( lastrule . year , endyear + _num , lastrule . month , lastrule . dayofmonthindicator , lastrule . dayofweek , lastrule . time , lastrule . timeendofday , lastrule . timedefinition , lastrule . savingamountsecs ) ; } lastrulelist . clear ( ) ; maxlastrulestartyear = year_max_value ; } collections . sort ( rulelist ) ; collections . sort ( lastrulelist ) ; if ( rulelist . size ( ) == _num && fixedsavingamountsecs == null ) { fixedsavingamountsecs = _num ; } }	adds rules to make the last rules all start from the same year.
private int [ ] determinedimensions ( int sourcecodewords , int errorcorrectioncodewords ) throws writerexception { float ratio = _num ; int [ ] dimension = null ; for ( int cols = mincols ; cols <= maxcols ; cols ++ ) { int rows = calculatenumberofrows ( sourcecodewords , errorcorrectioncodewords , cols ) ; if ( rows < minrows ) { break ; } if ( rows > maxrows ) { continue ; } float newratio = ( ( _num * cols + _num ) * default_module_width ) / ( rows * height ) ; if ( dimension != null && math . abs ( newratio - preferred_ratio ) > math . abs ( ratio - preferred_ratio ) ) { continue ; } ratio = newratio ; dimension = new int [ ] { cols , rows } ; } if ( dimension == null ) { int rows = calculatenumberofrows ( sourcecodewords , errorcorrectioncodewords , mincols ) ; if ( rows < minrows ) { dimension = new int [ ] { mincols , minrows } ; } } if ( dimension == null ) { throw new writerexception ( _str ) ; } return dimension ; }	determine optimal nr of columns and rows for the specified number of codewords .
private void logafterload ( ) { enumeration elem = properties . keys ( ) ; list lp = collections . list ( elem ) ; collections . sort ( lp ) ; iterator iter = lp . iterator ( ) ; finer ( _str + properties . size ( ) + _str ) ; finer ( _str ) ; while ( iter . hasnext ( ) ) { string key = ( string ) iter . next ( ) ; string val = properties . getproperty ( key ) ; finer ( _str + key + _str + val ) ; } finer ( _str ) ; }	writes a log of loaded properties to the plumbing.
public t removeitembyposition ( int position ) { if ( position < mobjects . size ( ) && position != invalid_position ) { mobjectdeleted = mobjects . remove ( position ) ; mhasdeletedposition = position ; notifydatasetchanged ( ) ; return mobjectdeleted ; } else { throw new indexoutofboundsexception ( _str ) ; } }	remove the specified object by the position .
public static qname valueof ( charsequence name ) { qname qname = ( qname ) full_name_to_qname . get ( name ) ; return ( qname != null ) ? qname : qname . createnonamespace ( name . tostring ( ) ) ; }	returns the qualified name corresponding to the specified character sequence representation ( may include the " { namespaceuri } " prefix ) .
protected final void putchar ( char ch ) { if ( sp == sbuf . length ) { char [ ] newsbuf = new char [ sbuf . length * _num ] ; system . arraycopy ( sbuf , _num , newsbuf , _num , sbuf . length ) ; sbuf = newsbuf ; } sbuf [ sp ++ ] = ch ; }	append a character to sbuf .
@ transactional ( readonly = _bool ) @ cacheable ( value = _str , key = _str ) public int countdownloadsbyusersince ( final user user , final long period ) { objects . requirenonnull ( user , _str ) ; objects . requirenonnull ( period , _str ) ; long current_timestamp = system . currenttimemillis ( ) ; if ( period < _num || period > current_timestamp ) { throw new illegalargumentexception ( _str ) ; } date date = new date ( current_timestamp - period ) ; return networkusagedao . countdownloadbyusersince ( user , date ) ; }	returns number of downloads by a user on a given period .
public umuserpasswordresetoptionsdata ( string question , string questionlocalizedname , string answer , int datastatus ) { this . question = question . trim ( ) ; this . questionlocalizedname = questionlocalizedname ; this . answer = answer . trim ( ) ; this . datastatus = datastatus ; }	constructs a user password reset options data object.
private void assertcharvectors ( int n ) { int k = _num * n + _num ; int limit = ( int ) math . pow ( _num , k + _num ) ; for ( int i = _num ; i < limit ; i ++ ) { string encoded = integer . tostring ( i , _num ) ; assertlev ( encoded , n ) ; } }	tests all possible characteristic vectors for some n this exhaustively tests the parametric transitions tables .
static string expandenvironmentvariables ( string value ) { if ( null == value ) { return null ; } matcher m = env_var_pattern . matcher ( value ) ; stringbuffer sb = new stringbuffer ( ) ; while ( m . find ( ) ) { string envvarvalue = null ; string envvarname = null == m . group ( _num ) ? m . group ( _num ) : m . group ( _num ) ; if ( envvarname . startswith ( ( _str ) ) ) { envvarvalue = system . getenv ( envvarname . substring ( _num ) ) ; } else { envvarvalue = system . getproperty ( envvarname ) ; } m . appendreplacement ( sb , null == envvarvalue ? _str : matcher . quotereplacement ( envvarvalue ) ) ; } m . appendtail ( sb ) ; return sb . tostring ( ) ; }	return the string value , expanding any environment variables found in the expression.
public hashtokensessionmap ( environment environment ) { int sessiontimeoutvalue ; try { sessiontimeoutvalue = environment . getproperty ( api_session_timeout , _num ) ; } catch ( guacamoleexception e ) { logger . error ( _str , e . getmessage ( ) ) ; logger . debug ( _str , e ) ; sessiontimeoutvalue = _num ; } logger . info ( _str , sessiontimeoutvalue ) ; executor . scheduleatfixedrate ( new sessionevictiontask ( sessiontimeoutvalue * _num ) , _num , _num , timeunit . minutes ) ; }	create a new hashtokensessionmap configured using the given environment .
private int oidcclaimsusagecount ( string uuid ) throws ssoexception , smsexception { smsentry smsentry = new smsentry ( gettoken ( ) , getoauth2providerbasedn ( ) ) ; map < string , set < string > > attributes = smsentry . getattributes ( ) ; try { set < string > sunkeyvalues = getmapsetthrows ( attributes , _str ) ; if ( sunkeyvalues . contains ( _str + uuid ) ) { return _num ; } } catch ( valuenotfoundexception ignored ) { } return _num ; }	count how many times the script identified by the specified uuid is used in oidc claims .
public eventexpirethread ( ) { super ( _str ) ; setdaemon ( _bool ) ; }	create a daemon thread.
public boolean isheader ( int position ) { return position >= _num && position < mheaderviews . size ( ) ; }	jude is head view.
public void testcase6 ( ) { byte abytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; byte bbytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; int asign = - _num ; int bsign = - _num ; byte rbytes [ ] = { _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . subtract ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _num , result . signum ( ) ) ; }	subtract two negative numbers of the same length.
public void clearbreakpointspassive ( final breakpointtype type ) { preconditions . checknotnull ( type , _str ) ; navilogger . info ( _str , type ) ; switch ( type ) { case regular : throw new illegalstateexception ( _str ) ; case echo : echobreakpointstorage . clear ( ) ; return ; case step : stepbreakpointstorage . clear ( ) ; return ; default : throw new illegalstateexception ( string . format ( _str , type ) ) ; } }	clears all echo breakpoints without notifying the listeners about the deleted breakpoints .
public enumeration content ( ) { return table . elements ( ) ; }	returns enumeration of the elements of the hashtable " table " , which are pair of the form ( pair link , symbolnode sn ).
@ override @ suppresswarnings ( _str ) public synchronized < t > t [ ] toarray ( t [ ] contents ) { if ( elementcount > contents . length ) { return null ; } system . arraycopy ( elementdata , _num , contents , _num , elementcount ) ; if ( elementcount < contents . length ) { contents [ elementcount ] = null ; } return contents ; }	returns an array containing all elements contained in this vector.
public synchronized void cleardynamicproperties ( ) throws replicatorexception { logger . info ( _str ) ; if ( dynamicproperties != null ) dynamicproperties . clear ( ) ; if ( dynamicpropertiesfile . exists ( ) ) { if ( ! dynamicpropertiesfile . delete ( ) ) logger . error ( _str + dynamicpropertiesfile . getabsolutepath ( ) ) ; } if ( dynamicrolefile != null ) { if ( dynamicrolefile . exists ( ) ) { if ( ! dynamicrolefile . delete ( ) ) logger . error ( _str + dynamicrolefile . getabsolutepath ( ) ) ; } } }	clear in - memory dynamic properties and delete on - disk file , if it exists .
public string pullrequestsurl ( string account , string collection , string repoid ) { objects . requirenonnull ( repoid , _str ) ; return getteambaseurl ( account , collection ) + format ( pull_requests , repoid ) + getapiversion ( ) ; }	returns the url for pull requests .
protected abstract string defaultcolumnname ( ) ;	returns default name for cassandra column ( if it ' s not specified explicitly ) .
private void publishrtf ( resource resource , bigdecimal version ) throws publicationexception { if ( islocked ( resource . getshortname ( ) ) ) { throw new publicationexception ( publicationexception . type . locked , _str + resource . getshortname ( ) + _str ) ; } document doc = new document ( ) ; file rtffile = datadir . resourcertffile ( resource . getshortname ( ) , version ) ; outputstream out = null ; try { out = new fileoutputstream ( rtffile ) ; rtfwriter2 . getinstance ( doc , out ) ; eml2rtf . writeemlintortf ( doc , resource ) ; } catch ( filenotfoundexception e ) { throw new publicationexception ( publicationexception . type . rtf , _str + rtffile . getabsolutepath ( ) , e ) ; } catch ( documentexception e ) { throw new publicationexception ( publicationexception . type . rtf , _str + rtffile . getabsolutepath ( ) , e ) ; } catch ( exception e ) { throw new publicationexception ( publicationexception . type . rtf , _str + e . getmessage ( ) , e ) ; } finally { if ( out != null ) { try { out . close ( ) ; } catch ( ioexception e ) { log . warn ( _str ) ; } } } }	publishes a new version of the rtf file for the given resource .
public boolean connecttobroker ( final mqttasyncconnection connection ) { try { connection . connect ( new mqttcallbackhandler ( connection ) , new mqttasyncconnectionrunnable ( connection ) ) ; return _bool ; } catch ( spyexception e ) { platform . runlater ( new mqtteventhandler ( new mqttconnectionattemptfailureevent ( connection , e ) ) ) ; logger . error ( e . getmessage ( ) , e ) ; } return _bool ; }	connects the specified connection to a broker .
public void updatepacketsize ( final bigdecimal packetsize ) { mrepeatpacketsize = mrepeatpacketsize . add ( packetsize ) ; }	update total packet size to be downloaded / uploaded .
private string base_phone_number ( ) throws parseexception { stringbuilder s = new stringbuilder ( ) ; if ( debug ) dbg_enter ( _str ) ; try { int lc = _num ; while ( lexer . hasmorechars ( ) ) { char w = lexer . lookahead ( _num ) ; if ( lexer . isdigit ( w ) || w == _str || w == _str || w == _str || w == _str ) { lexer . consume ( _num ) ; s . append ( w ) ; lc ++ ; } else if ( lc > _num ) break ; else throw createparseexception ( _str + w ) ; } return s . tostring ( ) ; } finally { if ( debug ) dbg_leave ( _str ) ; } }	parser for the base phone number .
public org . smpte_ra . schemas . st2067_2_2016 . contentversiontype buildcontentversiontype ( string id , org . smpte_ra . schemas . st2067_2_2016 . usertexttype value ) { contentversiontype contentversiontype = new contentversiontype ( ) ; contentversiontype . setid ( id ) ; contentversiontype . setlabeltext ( value ) ; return contentversiontype ; }	a method to construct a contentversiontype object conforming to the 2016 schema.
protected void refillbuffer ( ) { if ( pendinglen > _num || eof ) return ; try { offset = _num ; pendinglen = stream . read ( buf ) ; if ( pendinglen < _num ) { close ( ) ; return ; } else return ; } catch ( ioexception e ) { throw new pngjinputexception ( e ) ; } }	if there are not pending bytes to be consumed tries to fill the buffer with bytes from the stream .
private static inputstream opensystemfile ( string filename ) throws filenotfoundexception { try { return new fileinputstream ( filename ) ; } catch ( filenotfoundexception e ) { string resname = filename . replace ( file . separatorchar , _str ) ; inputstream result = classloader . getsystemresourceasstream ( resname ) ; if ( result == null ) { throw e ; } return result ; } }	private copy from fileutil , to avoid cross - dependencies.
static pair < byte [ ] , long > decomposename ( column column ) { bytebuffer namebuffer ; if ( column . issetname ( ) ) { namebuffer = column . bufferforname ( ) ; } else { namebuffer = bytebuffer . wrap ( column . getname ( ) ) ; } return decompose ( namebuffer ) ; }	convenience method to get the name buffer for the specified column and decompose it into the name and timestamp .
public requesthandle delete ( string url , responsehandlerinterface responsehandler ) { return delete ( null , url , responsehandler ) ; }	perform a http delete request .
public void addlanguage ( string languageid ) { query . append ( _str + languageid ) ; }	adds a language limit to the query.
public static list < basemqttmessage > processmessagelog ( final list < loggedmqttmessage > list , final progressupdater progress , final long current , final long max ) { final list < basemqttmessage > mqttmessagelist = new arraylist < basemqttmessage > ( ) ; long item = _num ; for ( final loggedmqttmessage loggedmessage : list ) { if ( progress != null ) { if ( progress . iscancelled ( ) ) { logger . info ( _str ) ; return null ; } item ++ ; if ( item % _num == _num ) { progress . update ( current + item , max ) ; } } mqttmessagelist . add ( converttobasemqttmessage ( loggedmessage ) ) ; } logger . info ( _str , list . size ( ) ) ; return mqttmessagelist ; }	turns the given list of loggedmqttmessages into receivedmqttmessages .
public requesthandle delete ( context context , string url , header [ ] headers , requestparams params , responsehandlerinterface responsehandler ) { httpdelete httpdelete = new httpdelete ( geturlwithquerystring ( isurlencodingenabled , url , params ) ) ; if ( headers != null ) httpdelete . setheaders ( headers ) ; return sendrequest ( httpclient , httpcontext , httpdelete , null , responsehandler , context ) ; }	perform a http delete request .
public int [ ] updateremainingattributes ( int [ ] selectedattributes , int bestattribute ) { int [ ] remainingattributes ; if ( columntable . representsnominalattribute ( bestattribute ) ) { remainingattributes = removeattribute ( bestattribute , selectedattributes ) ; } else { remainingattributes = selectedattributes ; } return remainingattributes ; }	if the bestattribute is nominal , its number is removed from the selectedattributes , otherwise it stays the same .
public final void addelement ( int value ) { if ( ( m_firstfree + _num ) >= m_mapsize ) { m_mapsize += m_blocksize ; int newmap [ ] = new int [ m_mapsize ] ; system . arraycopy ( m_map , _num , newmap , _num , m_firstfree + _num ) ; m_map = newmap ; } m_map [ m_firstfree ] = value ; m_firstfree ++ ; }	append a int onto the vector .
int parsetrblockcontent ( int currentoffset , char openquote , char closequote ) { int blockstartoffset = currentoffset ; charsequence buffer = getbuffer ( ) ; int bufferend = getbufferend ( ) ; boolean isescaped = _bool ; boolean isquotediffers = openquote != closequote ; int quoteslevel = _num ; while ( currentoffset < bufferend ) { char currentchar = buffer . charat ( currentoffset ) ; if ( ! isescaped && quoteslevel == _num && currentchar == closequote ) { if ( currentoffset > blockstartoffset ) { pushpreparsedtoken ( blockstartoffset , currentoffset , string_content ) ; } break ; } if ( isquotediffers && ! isescaped ) { if ( currentchar == openquote ) { quoteslevel ++ ; } else if ( currentchar == closequote ) { quoteslevel -- ; } } isescaped = ( currentchar == _str && ! isescaped ) ; currentoffset ++ ; } return currentoffset ; }	parsing tr block content till close quote.
public boolean itemexists ( string name ) throws jmsexception { hashmap body = ( hashmap ) body ; return body . containskey ( name ) ; }	check if an item exists in this mapmessage.
@ override public boolean eisset ( int featureid ) { switch ( featureid ) { case sexecpackage . step__comment : return comment_edefault == null ? comment != null : ! comment_edefault . equals ( comment ) ; case sexecpackage . step__caller : return caller != null && ! caller . isempty ( ) ; } return super . eisset ( featureid ) ; }	< ! - - begin - user - doc - - > < ! - - end - user - doc - - >.
public string todisplaystring ( ) { return todisplaystring ( locale . getdefault ( ) ) ; }	gets localized string describing the key using the default locale .
private boolean conditionch1 ( string value , int index ) { return ( ( contains ( value , _num , _num , _str , _str ) || contains ( value , _num , _num , _str ) ) || contains ( value , index - _num , _num , _str , _str , _str ) || contains ( value , index + _num , _num , _str , _str ) || ( ( contains ( value , index - _num , _num , _str , _str , _str , _str ) || index == _num ) && ( contains ( value , index + _num , _num , l_r_n_m_b_h_f_v_w_space ) || index + _num == value . length ( ) - _num ) ) ) ; }	complex condition 1 for ' ch '.
public void removeelements ( final int from , final int to ) { chararrays . ensurefromto ( size , from , to ) ; system . arraycopy ( a , to , a , from , size - to ) ; size -= ( to - from ) ; }	removes elements of this type - specific list using optimized system calls .
public synchronized void add ( date x , double y ) { super . add ( x . gettime ( ) , y ) ; }	adds a new value to the series .
public static string smartquote ( string s ) { if ( s . contains ( _str ) ) { return dumbquote ( s ) ; } else { return s ; } }	quotes string when spaces are detected.
static boolean sleep ( final double howmuch ) { try { thread . sleep ( ( int ) ( _num * howmuch ) ) ; return _bool ; } catch ( @ suppresswarnings ( _str ) final interruptedexception __ ) { return _bool ; } }	the current spartanmovie is not releaseable.
public static rectangle2d toawtrectangle ( final rectangle rect ) { final rectangle2d rect2d = new rectangle2d . double ( ) ; rect2d . setrect ( rect . x , rect . y , rect . width , rect . height ) ; return rect2d ; }	transform a swt rectangle instance into an awt one .
private void testbug71396statementmulticheck ( connection testconn , string [ ] queries , int [ ] exprowcount ) throws sqlexception { if ( queries . length != exprowcount . length ) { fail ( _str ) ; } statement teststmt = testconn . createstatement ( ) ; testbug71396statementmulticheck ( teststmt , queries , exprowcount ) ; teststmt . close ( ) ; }	executes a set of queries using a statement ( newly created ) and tests if the results count is the expected .
public string knntiptext ( ) { return _str + _str ; }	returns the tip text for this property .
public void removeprotocols ( final set < string > protocols ) { if ( protocols != null && _protocols != null ) { hashset < string > removeprotocols = new hashset < string > ( ) ; removeprotocols . addall ( protocols ) ; _protocols . removeall ( removeprotocols ) ; } }	remove the protocols from set of protocols in virtualpool .
private list < file > findduplicatefiles ( list < file > files ) { hashset < file > sourcefileset = new hashset < > ( ) ; list < file > duplicatefiles = new arraylist < > ( ) ; for ( file file : files ) { if ( ! sourcefileset . contains ( file ) ) { sourcefileset . add ( file ) ; } else { duplicatefiles . add ( file ) ; } } return duplicatefiles ; }	returns a list of all duplicate files found in the specified list of files .
public static byte [ ] bitmaptojpg ( final bitmap image , final int quality ) { if ( image == null ) return null ; bytearrayoutputstream ba = new bytearrayoutputstream ( ) ; if ( image . compress ( compressformat . jpeg , quality , ba ) ) return ba . tobytearray ( ) ; else return null ; }	bitmap into compressed jpeg.
public class < ? > loadclass ( string name ) throws classnotfoundexception { return initclassloader . loadclass ( name ) ; }	return the class with the given name .
public boolean addall ( collection c ) { object [ ] a = c . toarray ( ) ; int numnew = a . length ; ensurecapacity ( size + numnew ) ; system . arraycopy ( a , _num , elementdata , size , numnew ) ; size += numnew ; return numnew != _num ; }	appends all of the elements in the specified collection to the end of this list , in the order that they are returned by the specified collection ' s iterator.
private void deletefileifempty ( ) throws ioexception { if ( files . size ( preferencesfilepath ) == _num ) { files . delete ( preferencesfilepath ) ; } }	it may happen that the file is empty when the process is forcibly killed , so remove the file if that happened .
public static < t extends throwable > t readstacktrace ( t throwable , streaminput in ) throws ioexception { final int stacktraceelements = in . readvint ( ) ; stacktraceelement [ ] stacktrace = new stacktraceelement [ stacktraceelements ] ; for ( int i = _num ; i < stacktraceelements ; i ++ ) { final string declaringclasss = in . readstring ( ) ; final string filename = in . readoptionalstring ( ) ; final string methodname = in . readstring ( ) ; final int linenumber = in . readvint ( ) ; stacktrace [ i ] = new stacktraceelement ( declaringclasss , methodname , filename , linenumber ) ; } throwable . setstacktrace ( stacktrace ) ; int numsuppressed = in . readvint ( ) ; for ( int i = _num ; i < numsuppressed ; i ++ ) { throwable . addsuppressed ( in . readthrowable ( ) ) ; } return throwable ; }	deserializes stacktrace elements as well as suppressed exceptions from the given output stream and adds it to the given exception .
public static int scan ( long v ) { if ( v == _num ) { return - _num ; } return long . numberoftrailingzeros ( v ) ; }	utility method with defined return value for 0 .
public int outputsequencecount ( ) { return outregressionseqs . size ( ) + outerrorseqs . size ( ) ; }	returns the total number of test sequences generated to output , including both regression tests and error - revealing tests .
private void writeoutputfiles ( ) { if ( config . getoutputnetworkfile ( ) != null && config . getoutputschedulefile ( ) != null ) { try { scheduletools . writetransitschedule ( schedule , config . getoutputschedulefile ( ) ) ; networktools . writenetwork ( network , config . getoutputnetworkfile ( ) ) ; } catch ( exception e ) { log . error ( _str ) ; long t = system . nanotime ( ) / _num ; try { scheduletools . writetransitschedule ( schedule , t + _str ) ; networktools . writenetwork ( network , t + _str ) ; } catch ( exception e1 ) { throw new runtimeexception ( _str ) ; } } if ( config . getoutputstreetnetworkfile ( ) != null ) { networktools . writenetwork ( networktools . filternetworkbylinkmode ( network , collections . singleton ( transportmode . car ) ) , config . getoutputstreetnetworkfile ( ) ) ; } } else { log . info ( _str ) ; log . info ( _str ) ; } }	write the schedule and network to output files ( if defined in config ).
public static int valueof ( string name ) { for ( int opcode = _num ; opcode < namearray . length ; ++ opcode ) { if ( name . equalsignorecase ( namearray [ opcode ] ) ) { return opcode ; } } throw new illegalargumentexception ( _str + name ) ; }	gets the opcode corresponding to a given mnemonic .
public void fixupvariables ( java . util . vector vars , int globalssize ) { if ( null != m_argvec ) { int nargs = m_argvec . size ( ) ; for ( int i = _num ; i < nargs ; i ++ ) { expression arg = ( expression ) m_argvec . elementat ( i ) ; arg . fixupvariables ( vars , globalssize ) ; } } }	this function is used to fixup variables from qnames to stack frame indexes at stylesheet build time .
public boolean canceltask ( task task ) { for ( threadrunnable threadrunnable : runablemap . keyset ( ) ) { if ( threadrunnable . task == task ) { future future = runablemap . remove ( threadrunnable ) ; if ( future != null ) { future . cancel ( _bool ) ; } return _bool ; } } return _bool ; }	cancel a single task.
static string internaltobinaryclassname ( string classname ) { if ( classname == null ) { return null ; } else { return classname . replace ( _str , _str ) ; } }	utility that returns the fully qualified binary class name from a path - like fqcn.
public static string readstring ( file file ) throws ioexception { fileinputstream in = new fileinputstream ( file ) ; try { return readstring ( in ) ; } finally { in . close ( ) ; } }	read the contents as a string from the given file .
public boolean hasvalue ( ) { return ! values . isempty ( ) ; }	indicates whether this argument has at least one value .
protected static compareop converttohbasecompareop ( comparisonoperator comp ) { if ( comp == comparisonoperator . equal || comp == comparisonoperator . like || comp == comparisonoperator . contains || comp == comparisonoperator . in || comp == comparisonoperator . is ) { return compareop . equal ; } else if ( comp == comparisonoperator . less ) { return compareop . less ; } else if ( comp == comparisonoperator . less_or_equal ) { return compareop . less_or_equal ; } else if ( comp == comparisonoperator . greater ) { return compareop . greater ; } else if ( comp == comparisonoperator . greater_or_equal ) { return compareop . greater_or_equal ; } else if ( comp == comparisonoperator . not_equal || comp == comparisonoperator . not_like || comp == comparisonoperator . not_contains || comp == comparisonoperator . is_not || comp == comparisonoperator . not_in ) { return compareop . not_equal ; } else { log . error ( _str , comp ) ; throw new illegalargumentexception ( _str + comp + _str + arrays . tostring ( comparisonoperator . values ( ) ) ) ; } }	convert comparisonoperator to native hbase compareop support : = , = ~ , contains , < , < = , > , > = , ! = , ! = ~.
public tbase < tbase < ? , ? > , tfieldidenum > newargs ( list < object > args ) { requirenonnull ( args , _str ) ; final tbase < tbase < ? , ? > , tfieldidenum > newargs = newargs ( ) ; final int size = args . size ( ) ; for ( int i = _num ; i < size ; i ++ ) { newargs . setfieldvalue ( argfields [ i ] , args . get ( i ) ) ; } return newargs ; }	returns a new arguments instance .
protected void dowrite ( httpservletrequest request , httpservletresponse response , string tunneluuid ) throws guacamoleexception { guacamoletunnel tunnel = gettunnel ( tunneluuid ) ; response . setcontenttype ( _str ) ; response . setheader ( _str , _str ) ; response . setcontentlength ( _num ) ; try { guacamolewriter writer = tunnel . acquirewriter ( ) ; reader input = new inputstreamreader ( request . getinputstream ( ) , _str ) ; try { int length ; char [ ] buffer = new char [ _num ] ; while ( tunnel . isopen ( ) && ( length = input . read ( buffer , _num , buffer . length ) ) != - _num ) writer . write ( buffer , _num , length ) ; } finally { input . close ( ) ; } } catch ( guacamoleconnectionclosedexception e ) { logger . debug ( _str , e ) ; } catch ( ioexception e ) { deregistertunnel ( tunnel ) ; tunnel . close ( ) ; throw new guacamoleserverexception ( _str + e . getmessage ( ) , e ) ; } finally { tunnel . releasewriter ( ) ; } }	called whenever the javascript guacamole client makes a write request.
public final void testaddallhelpertextsfromarray ( ) { charsequence helpertext1 = _str ; charsequence helpertext2 = _str ; charsequence [ ] helpertexts1 = new charsequence [ _num ] ; helpertexts1 [ _num ] = helpertext1 ; helpertexts1 [ _num ] = helpertext2 ; passwordedittext passwordedittext = new passwordedittext ( getcontext ( ) ) ; passwordedittext . addallhelpertexts ( helpertexts1 ) ; passwordedittext . addallhelpertexts ( helpertexts1 ) ; collection < charsequence > helpertexts2 = passwordedittext . gethelpertexts ( ) ; assertequals ( helpertexts1 . length , helpertexts2 . size ( ) ) ; iterator < charsequence > iterator = helpertexts2 . iterator ( ) ; assertequals ( helpertext1 , iterator . next ( ) ) ; assertequals ( helpertext2 , iterator . next ( ) ) ; }	tests the functionality of the method , which allows to add all helper texts , which are contained by an array .
public static < t extends object & comparable < ? super t > > t min ( collection < ? extends t > collection ) { iterator < ? extends t > it = collection . iterator ( ) ; t min = it . next ( ) ; while ( it . hasnext ( ) ) { t next = it . next ( ) ; if ( min . compareto ( next ) > _num ) { min = next ; } } return min ; }	searches the specified collection for the minimum element .
public static string join ( list < ? > things , string delim ) { stringbuilder builder = new stringbuilder ( ) ; boolean first = _bool ; for ( object thing : things ) { if ( first ) { first = _bool ; } else { builder . append ( delim ) ; } builder . append ( thing . tostring ( ) ) ; } return builder . tostring ( ) ; }	returns a list joined together by the provided delimiter , for example , [ " a " , " b " , " c " ] could be joined into " a , b , c ".
private void addurltoken ( string url , string text ) { addtoken ( tokenforurl ( url , text ) ) ; }	adds the appropriate token for the given url.
public void addsystemclass ( sootclass sc ) { allsystemclasses . add ( sc ) ; }	add the given class to the list of system classes.
public ipv4addriv ( final ipv4address value ) { super ( dte . extension ) ; this . value = value ; }	ctor with internal value specified .
public void logandsystemout ( string message ) { logandsystemout ( message , null ) ; }	sends the message to both logger and system . out ( for unit report ).
static char randomchar ( ) { return ( char ) testutil . nextint ( random ( ) , _str , _str ) ; }	returns random character ( a - z ).
private void initializekeymap ( accessprofile accessprofile ) { _keymap . put ( constants . dbclient , _dbclient ) ; _keymap . put ( constants . accessprofile , accessprofile ) ; _keymap . put ( constants . props , accessprofile . getprops ( ) ) ; _keymap . put ( constants . _serialid , accessprofile . getserialid ( ) ) ; _keymap . put ( constants . _nativeguids , sets . newhashset ( ) ) ; }	populate keymap with required attributes .
public static boundingbox create ( vector coords ) { int length = coords . size ( ) ; if ( length <= _num ) { throw new runtimeexception ( _str ) ; } coord [ ] coordsarray = new coord [ length ] ; coords . copyinto ( coordsarray ) ; return create ( coordsarray ) ; }	/ create a smallest bounding box that contains all of the given coordinates.
public static boolean isempty ( charsequence str ) { if ( str == null || str . length ( ) == _num ) return _bool ; else return _bool ; }	returns true if the string is null or 0 - length .
public percentescaper ( string safechars , boolean plusforspace ) { if ( safechars . matches ( _str ) ) { throw new illegalargumentexception ( _str + _str ) ; } if ( plusforspace && safechars . contains ( _str ) ) { throw new illegalargumentexception ( _str ) ; } if ( safechars . contains ( _str ) ) { throw new illegalargumentexception ( _str ) ; } this . plusforspace = plusforspace ; this . safeoctets = createsafeoctets ( safechars ) ; }	constructs a uri escaper with the specified safe characters and optional handling of the space character .
public fsfont resolvefont ( sharedcontext ctx , string [ ] families , float size , identvalue weight , identvalue style , identvalue variant ) { list < font > fonts = new arraylist < font > ( _num ) ; if ( families != null ) { for ( int i = _num ; i < families . length ; i ++ ) { font font = resolvefont ( ctx , families [ i ] , size , weight , style , variant ) ; if ( font != null ) { fonts . add ( font ) ; } } } string family = _str ; if ( style == identvalue . italic ) { family = _str ; } font fnt = createfont ( ctx , availablefontshash . get ( family ) , size , weight , style , variant ) ; instancehash . put ( getfontinstancehashname ( ctx , family , size , weight , style , variant ) , fnt ) ; fonts . add ( fnt ) ; return new awtfsfont ( fonts , size ) ; }	resolves a list of font families .
private int [ ] parsemonths ( string line ) { int [ ] months = new int [ _num ] ; string [ ] numbers = line . split ( _str ) ; if ( numbers . length != _num ) { throw new illegalargumentexception ( _str + arrays . tostring ( numbers ) + _str + numbers . length ) ; } for ( int i = _num ; i < _num ; i ++ ) { try { months [ i ] = integer . valueof ( numbers [ i ] ) ; } catch ( numberformatexception nfe ) { throw new illegalargumentexception ( _str + numbers [ i ] ) ; } } return months ; }	parses the 12 months lengths from a property value for a specific year .
private static int findclosest ( int desiredfactor , set < integer > factors ) { int bestfactor = _num ; int bestdelta = desiredfactor ; for ( integer factor : factors ) { int testdelta = math . abs ( desiredfactor - factor ) ; if ( testdelta < bestdelta ) { bestdelta = testdelta ; bestfactor = factor ; } } return bestfactor ; }	finds the factor that is closest to the desired factor , from an ordered list of factors .
private static long dostojavatime ( long dtime ) { @ suppresswarnings ( _str ) date d = new date ( ( int ) ( ( ( dtime > > _num ) & _num ) + _num ) , ( int ) ( ( ( dtime > > _num ) & _num ) - _num ) , ( int ) ( ( dtime > > _num ) & _num ) , ( int ) ( ( dtime > > _num ) & _num ) , ( int ) ( ( dtime > > _num ) & _num ) , ( int ) ( ( dtime << _num ) & _num ) ) ; return d . gettime ( ) ; }	converts dos time to java time ( number of milliseconds since epoch ) .
private void overshadowrect ( final rectangle2d rect , final graphics2d g ) { graphics2d g2 = ( graphics2d ) g . create ( ) ; g2 . setcolor ( gray_out ) ; g2 . fill ( rect ) ; g2 . dispose ( ) ; }	shadows the given rectangle.
private securityfunctionentity createsecurityfunctionentity ( string code ) { securityfunctionentity securityfunctionentity = new securityfunctionentity ( ) ; securityfunctionentity . setcode ( code ) ; return herddao . saveandrefresh ( securityfunctionentity ) ; }	creates and persists a security function entity .
public static < t > list < t > tolist ( t obj1 ) { list < t > list = new linkedlist < t > ( ) ; list . add ( obj1 ) ; return list ; }	create a list from passed objx parameters.
public string tostring ( final string name , final string header ) { final map < string , integer > items = contents . get ( name ) ; final stringbuilder sb = new stringbuilder ( header + _str ) ; for ( final entry < string , integer > entry : items . entryset ( ) ) { sb . append ( entry . getkey ( ) + _str + entry . getvalue ( ) + _str ) ; } return sb . tostring ( ) ; }	converts a shop into a human readable form.
private void processemail ( ) { }	create reauest / updates from email.
speedpredictor ( ) { times = new double [ vector_length ] ; wtwindowmanager wm = wtwindowmanager . getinstance ( ) ; prediction = mathhelper . parsedoubledefault ( wm . getproperty ( speed_property , double . tostring ( initial_predicted_speed ) ) , initial_predicted_speed ) ; jitter = mathhelper . parsedouble ( wm . getproperty ( jitter_property , _str ) ) ; double average = turn_length / prediction ; for ( int i = _num ; i < vector_length ; i ++ ) { times [ i ] = average ; } }	create a new speedpredictor with default initial prediction and history corresponding to that .
@ deactivate public void deactivate ( componentcontext context ) { logger . debug ( _str , config . get ( constants . service_pid ) ) ; config = null ; authenticators . clear ( ) ; if ( authfilterwrapper != null ) { try { authfilterwrapper . reset ( ) ; } catch ( exception ex ) { logger . warn ( _str , ex . getmessage ( ) , ex ) ; } } }	nulls the stored authentication jsonvalue .
public void write ( arraylist < keyvalue > metadata , long imagestart , raster raster , datatype datatype ) throws ioexception { outputstream ostream = new fileoutputstream ( filepath ) ; if ( ostream != null ) { outputstream = new bufferedoutputstream ( ostream ) ; } labelparser parser = new labelparser ( ) ; bufferedwriter writer = new bufferedwriter ( new outputstreamwriter ( outputstream ) ) ; long size = parser . writeobject ( writer , metadata , _str ) ; long pad = imagestart - size ; for ( int i = _num ; i < pad ; ++ i ) { writer . write ( _str ) ; } writer . flush ( ) ; datastream = new dataoutputstream ( outputstream ) ; writeraster ( raster , datatype ) ; }	write a raster to a file .
static void cleanup ( ir ir ) { for ( enumeration < instruction > e = ir . forwardinstrenumerator ( ) ; e . hasmoreelements ( ) ; ) { instruction s = e . nextelement ( ) ; if ( s . operator ( ) == pi ) { registeroperand result = guardedunary . getresult ( s ) ; operator mv = irtools . getmoveop ( result . gettype ( ) ) ; operand val = guardedunary . getval ( s ) ; move . mutate ( s , mv , result , val ) ; } } ir . actualssaoptions = null ; }	change all pi nodes to int_move instructions < p > side effect : invalidates ssa state.
public string generatefilename ( ) { return new uniquetestid ( ) . id + _str + getcurrenttestclassname ( ) + _str + getcurrenttestmethodname ( ) + _str + getcurrenttestmethodlinenumber ( ) ; }	generates the filename for screenshot.
public backupuploadstatus querybackupuploadstatus ( ) { coordinatorclient coordinatorclient = coordinator . getcoordinatorclient ( ) ; configuration cfg = coordinatorclient . queryconfiguration ( coordinatorclient . getsiteid ( ) , backupconstants . backup_upload_status , constants . global_id ) ; map < string , string > allitems = ( cfg == null ) ? new hashmap < string , string > ( ) : cfg . getallconfigs ( _bool ) ; backupuploadstatus uploadstatus = new backupuploadstatus ( allitems ) ; log . info ( _str , uploadstatus ) ; return uploadstatus ; }	query upload status from zk.
@ override public int process ( callback [ ] callbacks , int state ) throws loginexception { switch ( state ) { case isauthconstants . login_start : { setusersessionproperty ( jwtsessionmodule . token_idle_time_in_minutes_claim_key , tokenidletime . tostring ( ) ) ; setusersessionproperty ( jwtsessionmodule . max_token_life_in_minutes_key , maxtokenlife . tostring ( ) ) ; setusersessionproperty ( enforce_client_ip_setting_key , boolean . tostring ( enforceclientip ) ) ; setusersessionproperty ( secure_cookie_key , boolean . tostring ( securecookie ) ) ; setusersessionproperty ( http_only_cookie_key , boolean . tostring ( httponlycookie ) ) ; if ( cookiename != null ) { setusersessionproperty ( cookie_name_key , cookiename ) ; } string cookiedomainsstring = _str ; for ( string cookiedomain : cookiedomains ) { cookiedomainsstring += cookiedomain + _str ; } setusersessionproperty ( cookie_domains_key , cookiedomainsstring ) ; setusersessionproperty ( hmac_key , encryptedhmackey ) ; final subject clientsubject = new subject ( ) ; messageinfo messageinfo = persistentcookiemodulewrapper . preparemessageinfo ( gethttpservletrequest ( ) , gethttpservletresponse ( ) ) ; if ( process ( messageinfo , clientsubject , callbacks ) ) { if ( principal != null ) { setauthenticatingusername ( principal . getname ( ) ) ; } return isauthconstants . login_succeed ; } throw new authloginexception ( auth_resource_bundle_name , _str , null ) ; } default : { throw new authloginexception ( auth_resource_bundle_name , _str , null ) ; } } }	overridden as to call different method on underlying jaspi jwtsessionmodule .
private int distance2 ( point p0 , point p1 ) { int d0 = math . abs ( p0 . x - p1 . x ) ; int d1 = math . abs ( p0 . y - p1 . y ) ; return d0 * d0 + d1 * d1 ; }	returns the distance to the power of 2 between two points.
public jsonwriter ( odatauri odatauri , entitydatamodel entitydatamodel ) { this . odatauri = checknotnull ( odatauri ) ; this . entitydatamodel = checknotnull ( entitydatamodel ) ; expandedproperties . addall ( asjavalist ( getsimpleexpandpropertynames ( odatauri ) ) ) ; }	create an odata json writer .
protected static die die ( string why ) { return new die ( why ) ; }	create a new exception to indicate we won ' t continue .
public builder withsolrxml ( path solrxml ) { try { this . solrxml = new string ( files . readallbytes ( solrxml ) , charset . defaultcharset ( ) ) ; } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } return this ; }	read solr . xml from the provided path.
public double doublevalue ( ) { if ( val instanceof long || val instanceof integer ) { return ( double ) ( val . longvalue ( ) ) ; } return val . doublevalue ( ) ; }	returns a double numeric value.
public void prune ( ) { constpool cp = compact0 ( ) ; arraylist newattributes = new arraylist ( ) ; attributeinfo invisibleannotations = getattribute ( annotationsattribute . invisibletag ) ; if ( invisibleannotations != null ) { invisibleannotations = invisibleannotations . copy ( cp , null ) ; newattributes . add ( invisibleannotations ) ; } attributeinfo visibleannotations = getattribute ( annotationsattribute . visibletag ) ; if ( visibleannotations != null ) { visibleannotations = visibleannotations . copy ( cp , null ) ; newattributes . add ( visibleannotations ) ; } attributeinfo signature = getattribute ( signatureattribute . tag ) ; if ( signature != null ) { signature = signature . copy ( cp , null ) ; newattributes . add ( signature ) ; } arraylist list = methods ; int n = list . size ( ) ; for ( int i = _num ; i < n ; ++ i ) { methodinfo minfo = ( methodinfo ) list . get ( i ) ; minfo . prune ( cp ) ; } list = fields ; n = list . size ( ) ; for ( int i = _num ; i < n ; ++ i ) { fieldinfo finfo = ( fieldinfo ) list . get ( i ) ; finfo . prune ( cp ) ; } attributes = newattributes ; constpool = cp ; }	discards all attributes , associated with both the class file and the members such as a code attribute and exceptions attribute.
public void endgroup ( ) { stream . println ( _str ) ; }	ends the current group .
public void testfloatvalueminuszero ( ) { string a = _str ; bigdecimal anumber = new bigdecimal ( a ) ; int minuszero = - _num ; float result = anumber . floatvalue ( ) ; asserttrue ( _str , float . floattointbits ( result ) == minuszero ) ; }	float value of a small negative bigdecimal.
public static parametertype makefileparametertype ( parameterhandler parameterhandler , string parametername , string description , portprovider portprovider , string ... fileextensions ) { return makefileparametertype ( parameterhandler , parametername , description , portprovider , _bool , fileextensions ) ; }	creates the file parameter named by fileparametername that depends on whether or not the port returned by the given portprovider is connected .
public void save ( string key , object data , boolean isencrypted , string encryptkey ) { key = safetykey ( key ) ; string wrapperjsonserialized ; if ( data instanceof record ) { type type = jolyglot . newparameterizedtype ( data . getclass ( ) , object . class ) ; wrapperjsonserialized = jolyglot . tojson ( data , type ) ; } else { wrapperjsonserialized = jolyglot . tojson ( data ) ; } filewriter filewriter = null ; try { file file = new file ( cachedirectory , key ) ; filewriter = new filewriter ( file , _bool ) ; filewriter . write ( wrapperjsonserialized ) ; filewriter . flush ( ) ; filewriter . close ( ) ; filewriter = null ; if ( isencrypted ) { fileencryptor . encrypt ( encryptkey , new file ( cachedirectory , key ) ) ; } } catch ( exception e ) { throw new runtimeexception ( e ) ; } finally { try { if ( filewriter != null ) { filewriter . flush ( ) ; filewriter . close ( ) ; } } catch ( ioexception e ) { e . printstacktrace ( ) ; } } }	save in disk the object passed .
private void backupscreens ( backupdataoutput data ) throws ioexception { contentresolver cr = mcontext . getcontentresolver ( ) ; cursor cursor = cr . query ( launchersettings . workspacescreens . content_uri , screen_projection , null , null , null ) ; try { cursor . movetoposition ( - _num ) ; if ( debug ) log . d ( tag , _str + mlastbackuprestoretime ) ; while ( cursor . movetonext ( ) ) { final long id = cursor . getlong ( id_index ) ; final long updatetime = cursor . getlong ( id_modified ) ; key key = getkey ( key . screen , id ) ; mkeys . add ( key ) ; final string backupkey = keytobackupkey ( key ) ; if ( ! mexistingkeys . contains ( backupkey ) || updatetime >= mlastbackuprestoretime ) { writerowtobackup ( key , packscreen ( cursor ) , data ) ; } else { if ( verbose ) log . v ( tag , _str + id ) ; } } } finally { cursor . close ( ) ; } }	write all modified screens to the data stream .
public static double simpletest ( double [ ] test ) { double scale = _num / ( test . length + _num ) ; double maxdev = double . negative_infinity ; for ( int i = _num ; i < test . length ; i ++ ) { double expected = ( i + _num ) * scale ; double dev = math . abs ( test [ i ] - expected ) ; if ( dev > maxdev ) { maxdev = dev ; } } return math . abs ( maxdev ) ; }	simplest version of the test : test if a sorted array is approximately uniform distributed on [ 0 : 1 ] .
private void openline ( boolean firstentry ) throws ioexception { if ( firstentry ) { out . append ( _str ) ; } }	begin the entry for a new line .
private long [ ] converttoarray ( map < string , long > map , int size , boolean unitoffset ) { long [ ] values = new long [ size ] ; int arrayoffset = unitoffset ? - _num : _num ; for ( map . entry < string , long > cursor : map . entryset ( ) ) { int offset = integer . parseint ( cursor . getkey ( ) ) + arrayoffset ; values [ offset ] = cursor . getvalue ( ) ; } return values ; }	will convert a ( possibly sparse ) map whose keys are string versions of numbers between 0 and size , to an array .
private static void sortanonymous ( list < itype > anonymous , itype anontype ) { sourceoffsetcomparator sourcecomparator = new sourceoffsetcomparator ( ) ; final anonymclasscomparator classcomparator = new anonymclasscomparator ( anontype , sourcecomparator ) ; collections . sort ( anonymous , classcomparator ) ; }	sort given anonymous classes in order like java compiler would generate output classes , in context of given anonymous type.
public static boolean isdefaultuseinternalbrowser ( ) { return browserutil . canuseinternalwebbrowser ( ) ; }	returns whether the internal browser is used by default.
public nsobject [ ] objectsatindexes ( int ... indexes ) { nsobject [ ] result = new nsobject [ indexes . length ] ; arrays . sort ( indexes ) ; for ( int i = _num ; i < indexes . length ; i ++ ) result [ i ] = array [ indexes [ i ] ] ; return result ; }	returns a new array containing only the values stored at the given indices.
private static entry [ ] concat ( entry [ ] attrs1 , entry [ ] attrs2 ) { entry [ ] nattrs = new entry [ attrs1 . length + attrs2 . length ] ; system . arraycopy ( attrs1 , _num , nattrs , _num , attrs1 . length ) ; system . arraycopy ( attrs2 , _num , nattrs , attrs1 . length , attrs2 . length ) ; return nattrs ; }	return a concatenation of the two arrays .
public static list < shaperecord > rectangle ( double startx , double starty , double width , double height ) { list < shaperecord > shaperecords = new arraylist < shaperecord > ( ) ; shaperecords . add ( move ( startx , starty ) ) ; shaperecords . addall ( straightedge ( startx , starty , width , starty ) ) ; shaperecords . addall ( straightedge ( width , starty , width , height ) ) ; shaperecords . addall ( straightedge ( width , height , startx , height ) ) ; shaperecords . addall ( straightedge ( startx , height , startx , starty ) ) ; return shaperecords ; }	creates a list of shaperecord to draw a rectangle from the given origin ( startx , starty ) for the specified width and height ( in pixels ) .
public glowserver ( serverconfig config ) { materialvaluemanager = new builtinmaterialvaluemanager ( ) ; this . config = config ; opslist = new uuidlistfile ( config . getfile ( _str ) ) ; whitelist = new uuidlistfile ( config . getfile ( _str ) ) ; namebans = new glowbanlist ( this , type . name ) ; ipbans = new glowbanlist ( this , type . ip ) ; bukkit . setserver ( this ) ; loadconfig ( ) ; }	creates a new server .
public fpstextureview removechild ( @ nonnull displaybase displaybase ) { displaybase . disable ( ) ; boolean a = mdisplaylist . remove ( displaybase ) ; return this ; }	removes the specified child from the display list .
static int midpt ( final int a , final int b ) { return a + ( b - a ) / _num ; }	returns the middle point between two values.
public static reactiveseq < double > fromdoublestream ( final doublestream stream ) { objects . requirenonnull ( stream ) ; return streamutils . reactiveseq ( stream . boxed ( ) , optional . empty ( ) ) ; }	construct a reactiveseq from a stream.
string format ( date source , stringbuffer toappendto ) { return source . tostring ( ) ; }	format a given date .
public static list < string > availableinstances ( ) throws ioexception { path confpath = paths . get ( systemproperties . getconfigurationproxyconfpath ( ) ) ; return subdirectorynames ( confpath ) ; }	gets all existing subdirectory names from the configuration proxy configuration directory , which correspond to the configuration proxy instance ids .
public lazyfuturestream < integer > from ( final intstream stream ) { return fromstream ( stream . boxed ( ) ) ; }	start a reactive dataflow from a stream .
protected void resetoptions ( ) { m_trainselector = new weka . attributeselection . attributeselection ( ) ; setevaluator ( new cfssubseteval ( ) ) ; setsearch ( new bestfirst ( ) ) ; m_selectedattributes = null ; }	set options to their default values.
protected void limittransandscale ( matrix matrix ) { float [ ] vals = new float [ _num ] ; matrix . getvalues ( vals ) ; float curtransx = vals [ matrix . mtrans_x ] ; float curscalex = vals [ matrix . mscale_x ] ; mscalex = math . max ( _num , math . min ( getmaxscale ( ) , curscalex ) ) ; float maxtransx = - ( float ) mcontentrect . width ( ) * ( mscalex - _num ) ; float newtransx = math . min ( math . max ( curtransx , maxtransx ) , _num ) ; vals [ matrix . mtrans_x ] = newtransx ; vals [ matrix . mscale_x ] = mscalex ; matrix . setvalues ( vals ) ; }	limits the maximum scale and x translation of the given matrix.
public void testgetinputencoding ( ) throws exception { assertequals ( _str , documenta . getinputencoding ( ) ) ; assertequals ( _str , documentb . getinputencoding ( ) ) ; }	xml parsers are advised of the document ' s character set via two channels : via the declaration and also the document ' s input source.
protected void closedialogok ( ) { dispose ( ) ; }	overrideen to perform specific clean up when dialog closed .
public static boolean isdangerous ( double d ) { return double . isinfinite ( d ) || double . isnan ( d ) || d == _num ; }	returns true if the argument is a " dangerous " double to have around , namely one that is infinite , nan or zero .
public static byte [ ] frombase58withchecksum ( string s ) throws hyperledgerexception { byte [ ] b = frombase58 ( s ) ; if ( b . length < _num ) { throw new hyperledgerexception ( _str + s ) ; } byte [ ] cs = new byte [ _num ] ; system . arraycopy ( b , b . length - _num , cs , _num , _num ) ; byte [ ] data = new byte [ b . length - _num ] ; system . arraycopy ( b , _num , data , _num , b . length - _num ) ; byte [ ] h = new byte [ _num ] ; system . arraycopy ( hash . hash ( data ) , _num , h , _num , _num ) ; if ( arrays . equals ( cs , h ) ) { return data ; } throw new hyperledgerexception ( _str + s ) ; }	decode from base58 assuming a trailing checksum of four bytes.
public collection < class < ? extends closeable > > shardservices ( ) { return collections . emptylist ( ) ; }	per index shard service that will be automatically closed .
public static sparseintarray adjustposition ( sparseintarray positions , int startposition , int endposition , int adjustby ) { sparseintarray newpositions = new sparseintarray ( ) ; for ( int i = _num , size = positions . size ( ) ; i < size ; i ++ ) { int position = positions . keyat ( i ) ; if ( position < startposition || position > endposition ) { newpositions . put ( position , positions . valueat ( i ) ) ; } else if ( adjustby > _num ) { newpositions . put ( position + adjustby , positions . valueat ( i ) ) ; } else if ( adjustby < _num ) { if ( position > startposition + adjustby && position <= startposition ) { ; } else { newpositions . put ( position + adjustby , positions . valueat ( i ) ) ; } } } return newpositions ; }	internal method to handle the selections if items are added / removed.
public int compare ( object o1 , object o2 ) { string s1 = o1 . tostring ( ) ; if ( s1 == null ) s1 = _str ; string s2 = o2 . tostring ( ) ; if ( s2 == null ) s2 = _str ; return s1 . compareto ( s2 ) ; }	compare based on name.
private final arraylist < awtreenodeleaf > to_array ( ) { arraylist < awtreenodeleaf > result = new arraylist < awtreenodeleaf > ( leaf_count ) ; awtreenode curr_node = root_node ; if ( curr_node == null ) return result ; for ( ; ; ) { while ( curr_node instanceof awtreenodefork ) { curr_node = ( ( awtreenodefork ) curr_node ) . first_child ; } result . add ( ( awtreenodeleaf ) curr_node ) ; awtreenodefork curr_parent = curr_node . parent ; while ( curr_parent != null && curr_parent . second_child == curr_node ) { curr_node = curr_parent ; curr_parent = curr_node . parent ; } if ( curr_parent == null ) break ; curr_node = curr_parent . second_child ; } return result ; }	inserts the leaves of this tree into an array list.
public void unregister ( ) throws payloadexception , networkexception { if ( slogger . isactivated ( ) ) { slogger . debug ( _str ) ; } mregistration . deregister ( ) ; msip . closestack ( ) ; }	unregister from the ims.
public static int listfind ( string list , string value ) { return listfind ( list , value , _str ) ; }	finds a value inside a list , case sensitive.
public flacstreamreader ( randomaccessfile raf ) { this . raf = raf ; }	create instance for holding stream info.
public final void skipuntil ( final double when ) { this . skipuntil = when ; }	allow this snapshotgenerator to skip all snapshots up to , but not including , a give timestep.
public static byte [ ] serializetobytearray ( serializable value ) { try { bytearrayoutputstream buffer = new bytearrayoutputstream ( ) ; try ( objectoutputstream oos = new objectoutputstream ( new snappyoutputstream ( buffer ) ) ) { oos . writeobject ( value ) ; } return buffer . tobytearray ( ) ; } catch ( ioexception exn ) { throw new illegalargumentexception ( _str + value , exn ) ; } }	serializes the argument into an array of bytes , and returns it .
@ override public set < statement > gather ( final igasstate < set < statement > , set < statement > , set < statement > > state , final value u , final statement e ) { return collections . singleton ( e ) ; }	return the edge as a singleton set .
public void run ( e start ) { run ( collections . singleton ( start ) ) ; }	computes shortest paths to nodes in the graph .
private boolean toobig ( basicblock bb , int maxcost ) { int cost = _num ; for ( enumeration < instruction > e = bb . forwardrealinstrenumerator ( ) ; e . hasmoreelements ( ) ; ) { instruction s = e . nextelement ( ) ; if ( s . iscall ( ) ) { cost += _num ; } else if ( s . isallocation ( ) ) { cost += _num ; } else { cost ++ ; } if ( cost > maxcost ) return _bool ; } return _bool ; }	simplistic cost estimate ; since we are doing the splitting based on static hints , we are only willing to copy a very small amount of code .
@ override public boolean addentry ( principal caller , aclentry entry ) throws notownerexception { if ( ! isowner ( caller ) ) throw new notownerexception ( ) ; if ( entrylist . contains ( entry ) ) return _bool ; entrylist . addelement ( entry ) ; return _bool ; }	adds an acl entry to this acl.
private boolean has_colinear ( plapointint a_point ) { int count = point_alist . size ( ) ; if ( count < _num ) return _bool ; for ( int index = _num ; index < count - _num ; index ++ ) { plapointint start = point_alist . get ( index ) ; plapointint end = point_alist . get ( index + _num ) ; if ( a_point . side_of ( start , end ) != plaside . collinear ) continue ; double d_start_p = start . distance_square ( a_point ) ; double d_p_end = a_point . distance_square ( end ) ; double d_start_end = start . distance_square ( end ) ; if ( d_start_end >= d_start_p ) { if ( d_start_end >= d_p_end ) { return _bool ; } else { point_alist . set ( index , a_point ) ; return _bool ; } } else { if ( d_start_end >= d_p_end ) { point_alist . set ( index + _num , a_point ) ; return _bool ; } else { point_alist . set ( index , a_point ) ; return _bool ; } } } return _bool ; }	return true if the given point is colinear with two points in the list and should not be added now , the issue is that this point may be colinear ( on the same line ) but further away , so , it should be the one being kept , not the one currently in the list.
protected void incorporatedigestmethod ( final element parentdom , final digestalgorithm digestalgorithm ) { final element digestmethoddom = documentdom . createelementns ( xmlns , ds_digest_method ) ; final string digestalgorithmxmlid = digestalgorithm . getxmlid ( ) ; digestmethoddom . setattribute ( algorithm , digestalgorithmxmlid ) ; parentdom . appendchild ( digestmethoddom ) ; }	this method creates the ds : digestmethod dom object.
public static boolean isxml11validname ( string name ) { final int length = name . length ( ) ; if ( length == _num ) { return _bool ; } int i = _num ; char ch = name . charat ( _num ) ; if ( ! isxml11namestart ( ch ) ) { if ( length > _num && isxml11namehighsurrogate ( ch ) ) { char ch2 = name . charat ( _num ) ; if ( ! xmlchar . islowsurrogate ( ch2 ) || ! isxml11namestart ( xmlchar . supplemental ( ch , ch2 ) ) ) { return _bool ; } i = _num ; } else { return _bool ; } } while ( i < length ) { ch = name . charat ( i ) ; if ( ! isxml11name ( ch ) ) { if ( ++ i < length && isxml11namehighsurrogate ( ch ) ) { char ch2 = name . charat ( i ) ; if ( ! xmlchar . islowsurrogate ( ch2 ) || ! isxml11name ( xmlchar . supplemental ( ch , ch2 ) ) ) { return _bool ; } } else { return _bool ; } } ++ i ; } return _bool ; }	check to see if a string is a valid name according to [ 5 ] in the xml 1 . 1 recommendation.
public string resolvepath ( string pathinfo ) { if ( ( pathinfo == null ) || ( pathinfo . indexof ( _str ) != - _num ) ) { return null ; } int libstart = pathinfo . indexof ( _str ) + _num ; int libend = pathinfo . indexof ( _str , libstart ) ; if ( libend == - _num ) { libend = pathinfo . length ( ) ; } string libname = pathinfo . substring ( libstart , libend ) ; string subpath = pathinfo . substring ( libend ) ; string lib_home = getpath ( libname ) ; if ( lib_home == null ) { return null ; } return lib_home + _str + subpath ; }	return a file object that the path resolves to.
protected int rangeupper ( string range ) { int hyphenindex ; if ( ( hyphenindex = range . indexof ( _str ) ) >= _num ) { return math . max ( rangeupper ( range . substring ( _num , hyphenindex ) ) , rangeupper ( range . substring ( hyphenindex + _num ) ) ) ; } return rangesingle ( range ) ; }	translates a range into it ' s upper index.
@ override public boolean equals ( object that ) { try { if ( that == null ) { return _bool ; } rulebasedbreakiterator other = ( rulebasedbreakiterator ) that ; if ( checksum != other . checksum ) { return _bool ; } if ( text == null ) { return other . text == null ; } else { return text . equals ( other . text ) ; } } catch ( classcastexception e ) { return _bool ; } }	returns true if both breakiterators are of the same class , have the same rules , and iterate over the same text .
public static string extractresponse ( idiagnosticslogger log , stringwriter sw ) { string samlresponsefield = _str ; string responseasstring = sw . tostring ( ) ; log . debug ( _str + responseasstring ) ; int index = responseasstring . indexof ( samlresponsefield ) ; asserttrue ( index >= _num ) ; int startindex = index + samlresponsefield . length ( ) ; int endindex = responseasstring . indexof ( _str , startindex ) ; asserttrue ( endindex >= _num ) ; string encodedsamlresponse = responseasstring . substring ( startindex , endindex ) ; string decodedsamlresponse = new string ( base64 . decode ( encodedsamlresponse ) ) ; return decodedsamlresponse ; }	extract saml response which was written to a stream.
public void testpownegativenumtoevenexp ( ) { byte abytes [ ] = { _num , - _num , _num , _num , _num , _num , _num , - _num , - _num , _num } ; int asign = - _num ; int exp = _num ; byte rbytes [ ] = { _num , _num , - _num , - _num , - _num , - _num , - _num , _num , - _num , _num , - _num , _num , _num , _num , - _num , - _num , _num , _num , - _num , _num , _num , - _num , _num , - _num , - _num , _num , - _num , _num , _num , _num , - _num , - _num , _num , - _num , - _num , - _num , - _num , - _num , - _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger result = anumber . pow ( exp ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	exponentiation of a negative number to an even exponent .
public void putattribute ( final string attrid , final list ltvalues ) { if ( map == null ) { map = new hashmap ( ) ; } map . put ( attrid . tolowercase ( ) , new ldapentryattributevo ( attrid . tolowercase ( ) , ltvalues ) ) ; }	permite aniadir un atributo a la entrada ldap.
protected javafileobject preferredfileobject ( javafileobject a , javafileobject b ) { if ( prefersource ) return ( a . getkind ( ) == javafileobject . kind . source ) ? a : b ; else { long adate = a . getlastmodified ( ) ; long bdate = b . getlastmodified ( ) ; return ( adate > bdate ) ? a : b ; } }	implement policy to choose to derive information from a source file or a class file when both are present.
public void evaluate ( final multivariatefunction evaluationfunction , final comparator < pointvaluepair > comparator ) { for ( int i = _num ; i < simplex . length ; i ++ ) { final pointvaluepair vertex = simplex [ i ] ; final double [ ] point = vertex . getpointref ( ) ; if ( double . isnan ( vertex . getvalue ( ) ) ) { simplex [ i ] = new pointvaluepair ( point , evaluationfunction . value ( point ) , _bool ) ; } } arrays . sort ( simplex , comparator ) ; }	evaluate all the non - evaluated points of the simplex .
public void testtoengineeringstringzeronegexponent ( ) { string a = _str ; bigdecimal anumber = new bigdecimal ( a ) ; string result = _str ; assertequals ( _str , result , anumber . toengineeringstring ( ) ) ; }	convert a negative bigdecimal to an engineering string representation.
public selectclause add ( expression expression ) { selectlist . add ( new selectclauseexpression ( expression ) ) ; return this ; }	adds an expression to the select clause .
private void attemptresponse ( inetsocketaddress addr , int timeout ) throws exception { socket s = new socket ( ) ; try { s . connect ( addr , timeout ) ; respond ( s ) ; } finally { try { s . close ( ) ; } catch ( ioexception e ) { logger . log ( levels . handled , _str , e ) ; } } }	attempt a connection to multicast request client.
protected void addtoportmap ( iofswitch sw , macaddress mac , vlanvid vlan , ofport portval ) { map < macvlanpair , ofport > swmap = macvlantoswitchportmap . get ( sw ) ; if ( vlan == vlanvid . full_mask ) { vlan = vlanvid . ofvlan ( _num ) ; } if ( swmap == null ) { swmap = collections . synchronizedmap ( new lrulinkedhashmap < macvlanpair , ofport > ( max_macs_per_switch ) ) ; macvlantoswitchportmap . put ( sw , swmap ) ; } swmap . put ( new macvlanpair ( mac , vlan ) , portval ) ; }	adds a host to the mac / vlan - > switchport mapping.
public void save ( ) throws ssoexception , smsexception { if ( readonly ) { if ( debug . warningenabled ( ) ) { debug . warning ( _str + _str + dn ) ; } throw ( new smsexception ( smsexception . status_no_permission , _str ) ) ; } save ( ssotoken ) ; }	save the modification ( s ) to the object.
public errordialog ( final safehtml message ) { this ( ) ; body . add ( message . toblockwidget ( ) ) ; }	create a dialog box to show a single message string .
public list < annotation > findbyproject ( appcontext app , projectpk projectpk , string orderby ) { list < datastorequeryfield > queryfields = new arraylist < datastorequeryfield > ( _num ) ; queryfields . add ( new datastorequeryfield ( _str , projectpk . getprojectid ( ) ) ) ; return super . find ( app , projectpk , queryfields , findbyprojectcache , orderby ) ; }	find a list of annotations of a given project .
private void addtomap ( locatorreg reg ) { undiscoveredlocators . add ( reg ) ; queuediscoverytask ( reg ) ; }	adds the given locatorreg object to the set containing the objects corresponding to the locators of desired lookup services that have not yet been discovered , and queues a discoverytask to attempt , through unicast discovery , to discover the associated lookup service .
public static string [ ] createfixedrandomstrings ( int count ) { string [ ] strings = new string [ count ] ; random lengthrandom = new random ( ) ; lengthrandom . setseed ( seed ) ; random stringrandom = new random ( ) ; stringrandom . setseed ( seed ) ; for ( int i = _num ; i < count ; i ++ ) { int nextlength = lengthrandom . nextint ( max_length - min_length - _num ) ; nextlength += min_length ; strings [ i ] = randomstringutils . random ( nextlength , _num , chars . length , _bool , _bool , chars , stringrandom ) ; } return strings ; }	creates the same random sequence of strings .
protected void createfiltertoolbar ( ) { timer = new timer ( _num , null ) ; timer . setinitialdelay ( _num ) ; timer . setactioncommand ( cmd_filter_changed ) ; timer . setrepeats ( _bool ) ; searchfilter = new searchfilter ( ) ; searchfilter . setfiltertext ( stringutils . empty ) ; }	create the search filter for the toolbar.
public parseheaderstate ( httpheaders headers , stringbuilder logger ) { class < ? extends httpheaders > clazz = headers . getclass ( ) ; this . context = arrays . < type > aslist ( clazz ) ; this . classinfo = classinfo . of ( clazz , _bool ) ; this . logger = logger ; this . arrayvaluemap = new arrayvaluemap ( headers ) ; }	initializes a new parseheaderstate .
void updatedaycounter ( final long newmessages ) { gregoriancalendar cal = new gregoriancalendar ( ) ; int currentindex = cal . get ( calendar . hour_of_day ) ; boolean bupdate = _bool ; for ( int i = _num ; i <= currentindex ; i ++ ) { if ( counters [ i ] > - _num ) { bupdate = _bool ; } if ( bupdate == _bool ) { if ( counters [ i ] == - _num ) { counters [ i ] = _num ; } } } counters [ currentindex ] += newmessages ; }	update day counter hour array elements.
public float readfloat ( ) throws ioexception { return dis . readfloat ( ) ; }	read a float from the input stream .
private < t > stream < collection < t > > partitionedstream ( iterator < t > iterator ) { return streamsupport . stream ( spliterators . spliteratorunknownsize ( iterators . partition ( iterator , batchsize ) , spliterator . ordered ) , _bool ) ; }	partition a stream into a stream of collections , each with batchsize elements .
public void removelast ( ) { datachangeevent [ ] events ; synchronized ( this ) { int row = getrowcount ( ) - _num ; row r = new row ( this , row ) ; events = new datachangeevent [ getcolumncount ( ) ] ; for ( int col = _num ; col < events . length ; col ++ ) { events [ col ] = new datachangeevent ( this , col , row , r . get ( col ) , null ) ; } rows . remove ( row ) ; } notifydataremoved ( events ) ; }	removes the last row from the table .
public customentryconcurrenthashmap ( final map < ? extends k , ? extends v > m ) { this ( math . max ( ( int ) ( m . size ( ) / default_load_factor ) + _num , default_initial_capacity ) , default_load_factor , default_concurrency_level , _bool ) ; putall ( m ) ; }	creates a new map with the same mappings as the given map.
public filereadstream ( ) { }	create a new filereadstream .
public static string quote ( string s ) { if ( s == null ) return null ; if ( s . length ( ) == _num ) return _str ; stringbuffer b = new stringbuffer ( s . length ( ) + _num ) ; quote ( b , s ) ; return b . tostring ( ) ; }	quote a string . the string is quoted only if quoting is required due to embeded delimiters , quote characters or the empty string .
public void querysorted ( string type , int index , boolean ascending , int page , int limit , int visibilityscope , cloudresponse < cloudobject [ ] > response ) { try { queryimpl ( type , null , _num , page , limit , visibilityscope , _num , index , ascending , _bool , _bool , response ) ; } catch ( cloudexception e ) { response . onerror ( e ) ; } }	performs a query to the server finding the objects where the sort is equal to the given value.
private void logmessage ( string msg , object [ ] obj ) { if ( _monitoringpropertiesloader . istologindications ( ) ) { _logger . debug ( _str + msg , obj ) ; } }	log the messages . this method eliminates the logging condition check every time when we need to log a message .
public void actionperformed ( actionevent e ) { actionmap map = tabpane . getactionmap ( ) ; if ( map != null ) { string actionkey ; if ( e . getsource ( ) == scrollforwardbutton ) { actionkey = _str ; } else { actionkey = _str ; } action action = map . get ( actionkey ) ; if ( action != null && action . isenabled ( ) ) { action . actionperformed ( new actionevent ( tabpane , actionevent . action_performed , null , e . getwhen ( ) , e . getmodifiers ( ) ) ) ; } } }	actionlistener for the scroll buttons .
public double entropy ( int g , int lag ) { double h = _num ; int n = cases . length - lag ; double ln2 = math . log ( _num ) ; int n0 = _num ; for ( int i = _num ; i < n ; i ++ ) { if ( cases [ i + lag ] [ g ] == _num ) { n0 ++ ; } } double p ; if ( n0 == _num || n0 == n ) { return h ; } else { p = ( double ) n0 / ( double ) n ; h = - ( p * math . log ( p ) + ( _num - p ) * math . log ( _num - p ) ) / ln2 ; } return h ; }	this method implements the same definition of entropy as above but this specialized version is intended to be used by the mutualinformation method ( viz ).
public onupdateclause addassignment ( expression expression ) { assignments . add ( new assignment ( expression ) ) ; return this ; }	adds a variable to set to the clause .
public short readshortbe ( ) throws ioexception { return inputstream . readshort ( ) ; }	read a 16bit short in be.
public boolean removemetriccollector ( final igangliametricscollector c ) { if ( c == null ) throw new illegalargumentexception ( ) ; return metriccollectors . remove ( c ) ; }	remove a metrics collector .
private void fillcommentcombo ( combo combo ) { if ( previouscomments == null ) { previouscomments = new arraylist ( ) ; } for ( int i = previouscomments . size ( ) - _num ; i >= _num ; i -- ) { combo . add ( ( ( string ) previouscomments . get ( i ) ) ) ; } combo . select ( _num ) ; }	fill the comments combobox with previous search entries .
public static synchronized void removefromdisabledlist ( string classname ) { disabled . remove ( classname ) ; }	remove the supplied fully qualified class name from the list of disabled plugins.
public void refresh ( cloudobject [ ] objects , cloudresponse < integer > response ) { refreshimpl ( objects , response ) ; }	refresh the given objects with data from the server if they were modified on the server ( this is the asynchronous version of the method ).
public static string approxtimeuntil ( final int seconds ) { final stringbuilder sbuf = new stringbuilder ( ) ; approxtimeuntil ( sbuf , seconds ) ; return sbuf . tostring ( ) ; }	create a text representing a saying of approximate time until .
public static accessibilitynodeinfocompat searchfocus ( traversalstrategy traversal , accessibilitynodeinfocompat currentfocus , int direction , nodefilter filter ) { if ( traversal == null || currentfocus == null ) { return null ; } if ( filter == null ) { filter = default_filter ; } accessibilitynodeinfocompat targetnode = accessibilitynodeinfocompat . obtain ( currentfocus ) ; set < accessibilitynodeinfocompat > seennodes = new hashset < > ( ) ; try { do { seennodes . add ( targetnode ) ; targetnode = traversal . findfocus ( targetnode , direction ) ; if ( seennodes . contains ( targetnode ) ) { logutils . log ( accessibilitynodeinfoutils . class , log . error , _str , targetnode . getinfo ( ) ) ; return null ; } } while ( targetnode != null && ! filter . accept ( targetnode ) ) ; } finally { accessibilitynodeinfoutils . recyclenodes ( seennodes ) ; } return targetnode ; }	search focus that satisfied specified node filter from currentfocus to specified direction according to ordertraversal strategy.
private void collectwrapperandsuppressedinfo ( matcher matcher ) throws adeexception { m_suppressednonwrappermessagecount ++ ; m_suppressedmessagesremaining = integer . parseint ( matcher . group ( _num ) ) ; m_suppressedmessagesremaining -- ; m_messageinstancewaiting = m_messagetextpreprocessor . getextramessage ( m_prevmessageinstance ) ; }	record the wrapper and suppressed messages information by adding / subtracting from counts.
private static void assertmp4webvttsubtitleequals ( subtitle sub , cue ... expectedcues ) { assertequals ( _num , sub . geteventtimecount ( ) ) ; assertequals ( _num , sub . geteventtime ( _num ) ) ; list < cue > subtitlecues = sub . getcues ( _num ) ; assertequals ( expectedcues . length , subtitlecues . size ( ) ) ; for ( int i = _num ; i < subtitlecues . size ( ) ; i ++ ) { list < string > differences = getcuedifferences ( subtitlecues . get ( i ) , expectedcues [ i ] ) ; asserttrue ( _str + i + _str + arrays . tostring ( differences . toarray ( ) ) , differences . isempty ( ) ) ; } }	asserts that the subtitle ' s cues ( which are all part of the event at t = 0 ) are equal to the expected cues .
public string concatenate ( string start , list < string > chunks ) { stringbuffer buf ; if ( start == null ) { buf = new stringbuffer ( ) ; } else { buf = new stringbuffer ( start ) ; } if ( chunks != null ) { for ( string chunk : chunks ) { if ( chunk != null ) { buf . append ( chunk ) ; } } } return ( buf . length ( ) == _num ) ? null : buf . tostring ( ) ; }	concatenates a single string and a list of string into a single long string .
public list < string > createentity ( string ... entitiesasjson ) throws atlasserviceexception { return createentity ( new jsonarray ( arrays . aslist ( entitiesasjson ) ) ) ; }	create the given entity.
private void populatecompletedactivitisteps ( job job , list < historicactivityinstance > historicactivititasks ) { list < workflowstep > completedworkflowsteps = new arraylist < > ( ) ; for ( historicactivityinstance historicactivityinstance : historicactivititasks ) { completedworkflowsteps . add ( new workflowstep ( historicactivityinstance . getactivityid ( ) , historicactivityinstance . getactivityname ( ) , herddateutils . getxmlgregoriancalendarvalue ( historicactivityinstance . getstarttime ( ) ) , herddateutils . getxmlgregoriancalendarvalue ( historicactivityinstance . getendtime ( ) ) ) ) ; } job . setcompletedworkflowsteps ( completedworkflowsteps ) ; }	populates the job object with completed workflow steps .
public static string join ( string separator , double ... elements ) { if ( elements == null || elements . length == _num ) { return _str ; } list < number > list = new arraylist < number > ( elements . length ) ; for ( double elem : elements ) { list . add ( elem ) ; } return join ( separator , list ) ; }	returns a string with all double values concatenated by a specified separator .
public double entropynmisqrt ( ) { if ( entropyfirst ( ) * entropysecond ( ) <= _num ) { return entropymutualinformation ( ) ; } return ( entropymutualinformation ( ) / math . sqrt ( entropyfirst ( ) * entropysecond ( ) ) ) ; }	get the sqrt - normalized mutual information ( normalized , 0 = unequal ).
public void applyall ( collection < ? extends ichange > changes ) throws badlocationexception { final map < uri , list < iatomicchange > > changesperfile = organize ( changes ) ; for ( uri curruri : changesperfile . keyset ( ) ) { final ixtextdocument document = getdocument ( curruri ) ; applyallinsamedocument ( changesperfile . get ( curruri ) , document ) ; } }	applies all given changes .
public static string now ( ) { calendar cal = calendar . getinstance ( ) ; simpledateformat sdf = new simpledateformat ( date_format_now ) ; return sdf . format ( cal . gettime ( ) ) ; }	get the current date and time in a format so that sorting the string will sort the date .
public void clearselections ( ) { mselectedtags . clear ( ) ; refreshselectedtags ( ) ; }	clears all the selected tags.
@ override public synchronized void addtestsetlistener ( testsetlistener tsl ) { m_listeners . addelement ( tsl ) ; }	add a listener for test sets.
public void addobserver ( observer observer ) { assert . notnull ( _str , observer ) ; observers . addifabsent ( observer ) ; }	adds an observer to the set of observers for this object .
protected void applyvalue ( t value ) { bean . setvalue ( property , value ) ; }	applies the given value , which means that the property that this configurator configures is set to the value .
protected object convertattributevalue ( object value ) { if ( value == null || value instanceof string || value instanceof byte || value instanceof long || value instanceof double || value instanceof boolean || value instanceof integer || value instanceof short || value instanceof float ) { return value ; } return value . tostring ( ) ; }	convert the attribute value if necessary .
@ override public int hashcode ( ) { int myposition = position ; int hash = _num ; long l ; while ( myposition < limit ) { l = double . doubletolongbits ( get ( myposition ++ ) ) ; hash = hash + ( ( int ) l ) ^ ( ( int ) ( l > > _num ) ) ; } return hash ; }	calculates this buffer ' s hash code from the remaining chars.
public void lockui ( processinfo pi ) { m_islocked = _bool ; }	lock user interface called from the worker before processing.
public static number ceil ( number a ) { if ( isfloatingpoint ( a ) ) { return math . ceil ( a . doublevalue ( ) ) ; } else { return a . longvalue ( ) ; } }	returns the smallest integer value greater than or equal to the given number .
private void unregister ( ) { if ( close != null ) { close . removeactionlistener ( listener ) ; } }	removes the actionlistener from the close - button of the bubble.
private static shape bottomedge ( bufferedimage image ) { generalpath path = new generalpath ( ) ; point2d p1 = null ; point2d p2 = null ; line2d line = new line2d . float ( ) ; point2d p = new point2d . float ( ) ; int foundpointx = - _num ; for ( int i = _num ; i < image . getwidth ( ) ; i ++ ) { for ( int j = image . getheight ( ) - _num ; j >= _num ; j -- ) { if ( ( image . getrgb ( i , j ) & _num ) != _num ) { p . setlocation ( i , j ) ; foundpointx = i ; break ; } } if ( foundpointx >= _num ) { if ( p2 == null ) { p1 = new point2d . float ( foundpointx , _num ) ; path . moveto ( p1 . getx ( ) , p1 . gety ( ) ) ; p2 = new point2d . float ( ) ; p2 . setlocation ( p ) ; } else { p2 = detectline ( p1 , p2 , p , line , path ) ; } } } path . lineto ( p . getx ( ) , p . gety ( ) ) ; if ( foundpointx >= _num ) { path . lineto ( foundpointx , _num ) ; } path . closepath ( ) ; return path ; }	trace the bottom of the image.
public void addsentencestone ( sentencetone analysis ) { sentencestone . add ( analysis ) ; }	adds the sentences tone .
public static boolean assertdistribution ( final double [ ] da ) { double sum = _num ; for ( final double d : da ) { exam . asserttrue ( utils . realformat ( d ) , d >= _num && d <= ( _num + tolerance ) && ! double . isnan ( d ) ) ; sum += d ; } if ( exam . checkequals ( _num , sum , _num ) ) { return _bool ; } throw new exam . examexception ( _str + utils . realformat ( sum ) + _str + utils . realformatarray ( da ) ) ; }	assert that the array contains a valid probability distribution that sums to 1.
public void add ( iticket ticket ) { if ( tickets . contains ( ticket ) ) { return ; } tickets . add ( ticket ) ; tick |= ticket . shouldtick ( ) ; }	add a ticket to this tickets.
public static mapbean createmapbean ( projection proj , border border ) { mapbean mapbeano = new bufferedlayermapbean ( ) ; mapbeano . setborder ( border ) ; if ( proj != null ) { mapbeano . setprojection ( proj ) ; mapbeano . setpreferredsize ( new dimension ( proj . getwidth ( ) , proj . getheight ( ) ) ) ; } return mapbeano ; }	a static method that creates a mapbean and sets its projection and border to the values given .
public static boolean volumedetachedfromfullcopies ( volume volume , dbclient dbclient ) { boolean detached = _bool ; stringset fullcopyids = volume . getfullcopies ( ) ; if ( ( fullcopyids != null ) && ( ! fullcopyids . isempty ( ) ) ) { iterator < string > fullcopyidsiter = fullcopyids . iterator ( ) ; while ( fullcopyidsiter . hasnext ( ) ) { string fullcopyid = fullcopyidsiter . next ( ) ; volume fullcopyvolume = dbclient . queryobject ( volume . class , uri . create ( fullcopyid ) ) ; if ( ! isfullcopydetached ( fullcopyvolume , dbclient ) ) { detached = _bool ; } } } return detached ; }	verify that a volume with full copies can be deleted .
public final t xmlns ( string uri ) { return xmlns ( uri , null ) ; }	sets the default namespace on the last started tag .
public boolean isentity ( ) { return isstring ( ) && string . startswith ( _str ) && string . endswith ( _str ) ; }	checks if the content is an entity.
public void savedeviceprofiles ( string username , string realm , list < jsonvalue > profiles ) throws internalservererrorexception { final amidentity identity = getidentity ( username , realm ) ; set < string > vals = new hashset < > ( ) ; try { final deviceservice deviceservice = servicefactory . create ( realm ) ; final deviceserialisation deviceserialisation = deviceservice . getdeviceserialisationstrategy ( ) ; final string attrname = deviceservice . getconfigstorageattributename ( ) ; for ( jsonvalue profile : profiles ) { vals . add ( deviceserialisation . deviceprofiletostring ( profile ) ) ; } map < string , set > attrmap = new hashmap < > ( ) ; attrmap . put ( attrname , vals ) ; identity . setattributes ( attrmap ) ; identity . store ( ) ; } catch ( ssoexception | idrepoexception | smsexception e ) { throw new internalservererrorexception ( e . getmessage ( ) , e ) ; } }	saves a user ' s device profiles .
@ requestmapping ( value = _str , method = requestmethod . delete ) @ responsebody public restwrapper delete ( @ pathvariable ( _str ) integer appdeploymentstatusid , principal principal ) { restwrapper restwrapper = null ; try { appdeploymentqueuestatusdao . delete ( appdeploymentstatusid . shortvalue ( ) ) ; restwrapper = new restwrapper ( null , restwrapper . ok ) ; logger . info ( recordwithid + appdeploymentstatusid + _str + principal . getname ( ) ) ; } catch ( exception e ) { logger . error ( e ) ; return new restwrapper ( e . getmessage ( ) , restwrapper . error ) ; } return restwrapper ; }	this method calls deletedeploystatus and fetches a record corresponding to the deploystatusid passed .
@ override public socket connect ( ) { log . d ( tag , _str + address . gethostaddress ( ) + _str + integer . tostring ( port ) ) ; final serversocket tempsocket ; try { tempsocket = new serversocket ( port , _num , address ) ; } catch ( ioexception e ) { reporterror ( _str + e . getmessage ( ) ) ; return null ; } synchronized ( rawsocketlock ) { if ( serversocket != null ) { log . e ( tag , _str ) ; } serversocket = tempsocket ; } try { return tempsocket . accept ( ) ; } catch ( ioexception e ) { reporterror ( _str + e . getmessage ( ) ) ; return null ; } }	opens a listening socket and waits for a connection .
@ namespacepermission ( fields = _str , permissions = namespacepermissionenum . read ) private void mockmethod ( string namespace ) { }	do not invoke this method.
public boolean matches ( inventorycrafting inv , world worldin ) { itemstack itemstack = null ; list < itemstack > list = lists . < itemstack > newarraylist ( ) ; for ( int i = _num ; i < inv . getsizeinventory ( ) ; ++ i ) { itemstack itemstack1 = inv . getstackinslot ( i ) ; if ( itemstack1 != null ) { if ( itemstack1 . getitem ( ) instanceof itemarmor ) { itemarmor itemarmor = ( itemarmor ) itemstack1 . getitem ( ) ; if ( itemarmor . getarmormaterial ( ) != cyberwarecontent . trenchmat || itemstack != null ) { return _bool ; } itemstack = itemstack1 ; } else { if ( itemstack1 . getitem ( ) != items . dye ) { return _bool ; } list . add ( itemstack1 ) ; } } } return itemstack != null && ! list . isempty ( ) ; }	used to check if a recipe matches current crafting inventory.
public void putdelegate ( string alias , x509extendedkeymanager newdelegate ) { if ( ! alias . equals ( alias . tolowercase ( ) ) ) { throw new illegalargumentexception ( _str ) ; } delegates . put ( alias , newdelegate ) ; }	add a delegate identified by the given unique key ( can be used to remove it later ).
@ override public void actionperformed ( actionevent e ) { filedialog chooser = new filedialog ( frame , _str , filedialog . save ) ; chooser . setvisible ( _bool ) ; if ( chooser . getfile ( ) != null ) { save ( chooser . getdirectory ( ) + file . separator + chooser . getfile ( ) ) ; } }	opens a save dialog box when the user selects " save as " from the menu .
public void paintsliderthumbborder ( synthcontext context , graphics g , int x , int y , int w , int h , int orientation ) { paintborder ( context , g , x , y , w , h , orientation ) ; }	paints the border of the thumb of a slider .
private void calculateathashclaim ( final oauth2accesstokenentity accesstoken , final jwsalgorithm signingalg , final jwtclaimsset . builder idclaims , final set < string > responsetypes ) { if ( responsetypes . contains ( oidcconstants . token ) ) { final base64url athash = idtokenhashutils . getaccesstokenhash ( signingalg , accesstoken ) ; idclaims . claim ( oidcconstants . at_hash , athash ) ; log . debug ( _str , oidcconstants . at_hash , athash ) ; } }	calculate at hash claim .
public static double [ ] roundtosignificantdigits ( double x , double y , int nsignif ) { double [ ] rounded = new double [ _num ] ; double diff = math . abs ( x - y ) ; if ( diff < _num ) { rounded [ _num ] = x ; rounded [ _num ] = y ; return rounded ; } if ( diff > _num ) { rounded [ _num ] = math . rint ( x * math . pow ( _num , nsignif ) ) / math . pow ( _num , nsignif ) ; rounded [ _num ] = math . rint ( y * math . pow ( _num , nsignif ) ) / math . pow ( _num , nsignif ) ; return rounded ; } else { int nzeros = ( int ) ( math . ceil ( math . abs ( math . log10 ( diff ) ) ) + nsignif ) ; rounded [ _num ] = math . rint ( x * math . pow ( _num , nzeros ) ) / math . pow ( _num , nzeros ) ; rounded [ _num ] = math . rint ( y * math . pow ( _num , nzeros ) ) / math . pow ( _num , nzeros ) ; return rounded ; } }	function to round x and y to a number of digits enough to show the difference in range this is for pretty printing only .
public static string sanitizestrings ( string str ) { char [ ] c = getchars ( str ) ; int idx = _num ; string newstr = str ; stringbuilder sb = null ; boolean instring = _bool ; char stringsep = _str ; int lastidx = _num ; while ( idx < c . length ) { if ( instring && stringsep == c [ idx ] ) { instring = _bool ; stringsep = _str ; } else if ( ! instring ) { if ( _str == c [ idx ] ) { instring = _bool ; stringsep = _str ; } else if ( _str == c [ idx ] ) { instring = _bool ; stringsep = _str ; } } if ( instring ) { if ( _str == c [ idx ] ) { if ( null == sb ) { sb = new stringbuilder ( ) ; } sb . append ( c , lastidx , idx - lastidx ) ; sb . append ( _str ) ; lastidx = idx + _num ; } } idx ++ ; } if ( null != sb ) { if ( lastidx < c . length ) { sb . append ( c , lastidx , c . length - lastidx ) ; } newstr = sb . tostring ( ) ; } return newstr ; }	replace whitespaces in strings enclosed in single quotes with ' % 20 '.
private void forcequit ( ) { if ( stdout != null ) { stdout . close ( ) ; } try { if ( shell != null ) { shell . disconnect ( ) ; } } catch ( runtimeexception e ) { log . error ( e . getmessage ( ) , e ) ; } finally { shell = null ; } try { if ( session != null ) { session . disconnect ( ) ; } } catch ( runtimeexception e ) { log . error ( e . getmessage ( ) , e ) ; } finally { session = null ; } }	forcibly quits the session .
public boolean isblinking ( ) { return modifiers . contains ( sgr . blink ) ; }	returns true if this textcharacter has the blink modifier active.
@ inject public hbaseschemaservice ( systemconfiguration config ) { super ( config ) ; _config = config ; }	creates a new hbaseschemaservice object .
public static string readoutput ( bufferedreader in ) throws ioexception { stringbuffer output = new stringbuffer ( ) ; string line = null ; while ( ( line = in . readline ( ) ) != null ) { output . append ( line ) ; output . append ( tools . getlineseparator ( ) ) ; } return output . tostring ( ) ; }	reads the output of the reader and delivers it as string .
private boolean schedulenext ( ) { final string tag = _str + taskid + _str ; try { log . finer ( tag + _str + delaybeforenext + _str ) ; if ( cancelled || ! notifystatechange ( scheduled , _str ) ) { log . finer ( tag + _str ) ; return _bool ; } final sessiontask nexttask = new sessiontask ( delaybeforenext ) ; if ( ! schedulesession ( nexttask , delaybeforenext ) ) return _bool ; log . finer ( tag + _str ) ; } catch ( exception x ) { if ( log . isloggable ( level . finest ) ) { log . log ( level . finest , tag + _str + x , x ) ; } else if ( log . isloggable ( level . fine ) ) { log . fine ( tag + _str + x ) ; } } return _bool ; }	schedule an identical task for next iteration .
@ override public double classifyinstance ( instance instance ) { return m_classvalue ; }	classifies a given instance .
private void addjsonforentry ( final stringbuilder result , entry entry , boolean includejusttextfields , boolean includeuserwassignin , boolean userwassignedin , boolean forcequotationtonote ) throws ioexception { result . append ( _str + jsonbuilder . quote ( entry . getnoteortitle ( _str ) ) + _str ) ; result . append ( _str + jsonbuilder . quote ( entry . getquotation ( _str ) ) + _str ) ; result . append ( _str + entry . getispublic ( ) + _str ) ; string typetoadd = entry . gettype ( ) ; if ( typetoadd . equals ( dblogic . constants . quotation ) ) { typetoadd = dblogic . constants . note ; } result . append ( _str + typetoadd + _str ) ; if ( includeuserwassignin ) { result . append ( _str + userwassignedin + _str ) ; } if ( includejusttextfields ) { result . append ( _str + jsonbuilder . quote ( getnotehtml ( entry , _bool , entry . hasquotation ( ) , _bool ) ) + _str ) ; result . append ( _str + jsonbuilder . quote ( getquotationhtml ( entry , _bool ) ) + _str ) ; } else { final stringbuilder innerresult = new stringbuilder ( ) ; addentryhtmltotreesimple ( entry , innerresult , null , _num , ! entry . isnotebook ( ) ) ; result . append ( _str + jsonbuilder . quote ( innerresult . tostring ( ) ) + _str ) ; } }	adds json for the entry .
public void addviewpoint ( int index , string name ) { viewpointstore vps = viewpointnode . getviewpoint ( name ) ; viewpointlist . add ( index , vps ) ; }	add a viewpoint to the list.
public static boolean iskanji ( char chr ) { string [ ] pinyinstr = null ; try { pinyinstr = pinyinhelper . tohanyupinyinstringarray ( chr , format ) ; } catch ( badhanyupinyinoutputformatcombination e ) { e . printstacktrace ( ) ; } return ( null == pinyinstr ) ? ( _bool ) : ( _bool ) ; }	judge chr is kanji.
public builder rootsourcesectionequals ( sourcesection ... section ) { verifynotnull ( section ) ; expressions . add ( new eventfilterexpression . rootsourcesectionequals ( section ) ) ; return this ; }	add a filter for all root sources sections that equal one of the given source sections.
public sorting ( double [ ] array , boolean copyarray ) { if ( copyarray ) { a = new double [ array . length ] ; system . arraycopy ( array , _num , a , _num , array . length ) ; } else { a = array ; } order = new int [ a . length ] ; for ( int i = _num ; i < a . length ; i ++ ) { order [ i ] = i ; } sort ( a ) ; }	construct an ascending order .
public double cdf ( double x ) { if ( x <= _num ) return _num ; return _num - math . exp ( - x * lambda ) ; }	returns the cumulative distribution function .
public bytebuffer read ( final long off , final int nbytes ) throws ioexception { final bytebuffer tmp = bytebuffer . allocate ( nbytes ) ; filechannelutility . readall ( this , tmp , off ) ; tmp . flip ( ) ; return tmp ; }	read some data out of the file .
protected void initinfo ( ) { clearparameters ( ) ; initinfo ( _num , _str , m_m_warehouse_id , m_m_pricelist_id ) ; }	reset the criteria panel.
public static connection enlistconnection ( xaconnection xacon ) throws generictransactionexception { if ( xacon == null ) { return null ; } try { xaresource resource = xacon . getxaresource ( ) ; transactionutil . enlistresource ( resource ) ; return xacon . getconnection ( ) ; } catch ( sqlexception e ) { throw new generictransactionexception ( _str , e ) ; } }	enlists the given xaconnection and if a transaction is active in the current thread , returns a plain jdbc connection.
@ override public void run ( int connid , string [ ] args ) { if ( ! canrunrestrictedcommand ( connid ) ) { server . sendserverchat ( connid , _str ) ; return ; } if ( args . length > _num ) { string sfinalfile = args [ _num ] ; if ( ! sfinalfile . endswith ( _str ) && ! sfinalfile . endswith ( _str ) ) { sfinalfile = sfinalfile + _str ; } if ( ! sfinalfile . endswith ( _str ) ) { sfinalfile = sfinalfile + _str ; } load ( new file ( _str , sfinalfile ) , connid ) ; } else { server . sendserverchat ( connid , _str ) ; } }	run this command with the arguments supplied.
private queryresult ( final querytask task ) { mtask = task ; }	construct a query result.
protected void deletefamilyset ( ) { itempalette . removeiconmap ( _itemtype , _family ) ; _family = null ; _currenticonmap = null ; updatefamiliespanel ( ) ; }	action item for delete family.
protected static modbusresponse readrequest ( int functioncode , int register , int count ) { modbusudptransaction trans ; udpmasterconnection connection = null ; try { connection = new udpmasterconnection ( inetaddress . getbyname ( testutils . getfirstip4address ( ) ) ) ; connection . setport ( port ) ; connection . connect ( ) ; connection . settimeout ( _num ) ; modbusrequest req = null ; switch ( functioncode ) { case modbus . read_coils : req = new readcoilsrequest ( register , count ) ; break ; case modbus . read_input_discretes : req = new readinputdiscretesrequest ( register , count ) ; break ; case modbus . read_input_registers : req = new readinputregistersrequest ( register , count ) ; break ; case modbus . read_holding_registers : req = new readmultipleregistersrequest ( register , count ) ; break ; default : fail ( string . format ( _str , functioncode ) ) ; } req . setunitid ( unit_id ) ; trans = new modbusudptransaction ( connection ) ; trans . setrequest ( req ) ; trans . execute ( ) ; return trans . getresponse ( ) ; } catch ( exception e ) { logger . debug ( e . getmessage ( ) ) ; } finally { if ( connection != null ) { connection . close ( ) ; } } return null ; }	executes a read transaction using the function code , register and count.
public static void loadproperties ( boolean reload ) { if ( reload || s_prop . size ( ) == _num ) { if ( iswebstartclient ( ) ) { loadwebstartproperties ( ) ; } else { loadproperties ( getfilename ( s_client ) ) ; } } }	load ini parameters from disk.
static list < file > tidydatabaselist ( list < file > databasefiles ) { set < file > originalasset = new hashset < file > ( databasefiles ) ; list < file > tidiedlist = new arraylist < file > ( ) ; for ( file databasefile : databasefiles ) { string databasefilename = databasefile . getpath ( ) ; string sanssuffix = removesuffix ( databasefilename , uninteresting_filename_suffixes ) ; if ( sanssuffix . equals ( databasefilename ) || ! originalasset . contains ( new file ( sanssuffix ) ) ) { tidiedlist . add ( databasefile ) ; } } return tidiedlist ; }	attempt to smartly eliminate uninteresting shadow databases such as - journal and - uid.
public void select ( segment segment , boolean addtoselection ) { if ( segment . isnone ( ) ) { return ; } if ( ! addtoselection ) { deselectallsegments ( ) ; } if ( segment . isunpaired ( ) ) { if ( addtoselection ) { boolean allsegmentsselected = _bool ; for ( segment other : segments . getpairedsegments ( segment ) ) { if ( ! isselected ( other ) ) { allsegmentsselected = _bool ; break ; } } if ( allsegmentsselected ) { deselectsegment ( segment ) ; return ; } } if ( isselected ( segment ) ) { deselectsegment ( segment ) ; } else { selectsegment ( segment ) ; } } else { if ( isselected ( segment ) ) { deselectsegment ( segment ) ; } else { selectsegment ( segment ) ; } } }	adds or removes the given segment to the selection.
public void testusingproxy ( ) throws exception { mockserver server = new mockserver ( _str ) ; mockserver proxy = new mockserver ( _str ) ; url url = new url ( _str + server . port ( ) ) ; httpurlconnection connection = ( httpurlconnection ) url . openconnection ( new proxy ( proxy . type . http , new inetsocketaddress ( _str , proxy . port ( ) ) ) ) ; connection . setconnecttimeout ( _num ) ; connection . setreadtimeout ( _num ) ; server . start ( ) ; synchronized ( bound ) { if ( ! server . started ) bound . wait ( _num ) ; } proxy . start ( ) ; synchronized ( bound ) { if ( ! proxy . started ) bound . wait ( _num ) ; } connection . connect ( ) ; server . join ( ) ; proxy . join ( ) ; asserttrue ( _str , connection . usingproxy ( ) ) ; asserttrue ( _str , proxy . accepted ) ; httpurlconnection huc = ( httpurlconnection ) url . openconnection ( proxy . no_proxy ) ; assertfalse ( huc . usingproxy ( ) ) ; }	test checks if the proxy specified in openconnection method will be used for connection to the server.
static int convertunits ( string units , int defaultsuffix ) { if ( units == null ) { return - _num ; } int factor = _num ; int i = _num ; boolean suffixfound = _bool ; for ( ; i < csselement . css_length_suffix . length ; i ++ ) { if ( units . endswith ( csselement . css_length_suffix [ i ] ) ) { factor = css_length_factors [ i ] ; units = units . substring ( _num , units . length ( ) - _num ) ; suffixfound = _bool ; break ; } } if ( ! suffixfound ) { i = defaultsuffix ; factor = css_length_factors [ i ] ; } try { int result = ( int ) ( float . parsefloat ( units ) * factor ) ; if ( ( i == length_suffix_em ) || ( i == length_suffix_ex ) ) { result += val_ex ; } return result ; } catch ( numberformatexception nfe ) { return - _num ; } }	converts the given css length string to pixels.
public static void hiddenfromencodedstring ( projectfiltersettings result , string s ) { if ( s . length ( ) > _num ) { int bar = s . indexof ( field_delimiter ) ; string categories ; if ( bar >= _num ) { categories = s . substring ( _num , bar ) ; } else { categories = s ; } stringtokenizer t = new stringtokenizer ( categories , listitem_delimiter ) ; while ( t . hasmoretokens ( ) ) { string category = t . nexttoken ( ) ; result . removecategory ( category ) ; } } }	set the hidden bug categories on the specifed projectfiltersettings from an encoded string.
public java . lang . stringbuilder insert ( int offset , java . lang . object obj ) { return insert ( offset , obj . tostring ( ) ) ; }	inserts the string representation of the object argument into this string buffer.
private void layoutselectedchild ( layoutparams lp ) { int l = math . round ( lp . left ) ; int t = math . round ( lp . top ) ; int r = l + mselectedchild . getmeasuredwidth ( ) ; int b = t + mselectedchild . getmeasuredheight ( ) ; lp . moved = _bool ; mselectedchild . layout ( l , t , r , b ) ; }	this method can be used to force layout on a child to recalculate its hit - rect , otherwise outline border of the selected child is drawn at the old position.
public aemradiogroup selectbyvalue ( string value ) { for ( aemradiooption option : values ) { if ( value . equals ( option . getvalue ( ) ) ) { option . setselected ( ) ; } } return this ; }	searches for the option by the option ' s value and selects it .
@ override public void close ( ) { try { reader . close ( ) ; } catch ( ioexception e ) { throw dbexception . convertioexception ( e , null ) ; } }	close the underlying reader .
void onresponse ( t result ) ;	the callback run on a valid response .
public static string report ( ) { stringbuilder sb = new stringbuilder ( ) ; for ( tap tap : dispatchescopy ( ) ) { int length = sb . length ( ) ; tap . appendreport ( null , sb ) ; if ( sb . length ( ) > length ) { sb . append ( new_line ) ; } } string result = sb . tostring ( ) ; log . debug ( _str + new_line + new_line + result + new_line ) ; return result ; }	return a string containing a formatted report generated by traversing and appending results from all registered taps.
public final testsubscriber assertcomplete ( ) { string prefix = _str ; boolean passed = _bool ; if ( done . getcount ( ) != _num ) { prefix = _str ; fail ( _str ) ; passed = _bool ; } long c = completions ; if ( c == _num ) { fail ( prefix , _str , errors ) ; fail ( _str ) ; passed = _bool ; } else if ( c > _num ) { fail ( prefix , _str + c , errors ) ; fail ( _str ) ; passed = _bool ; } pass ( _str , passed ) ; return this ; }	assert that this testsubscriber received exactly one oncomplete event .
public static int nextsmallerprime ( int n ) { if ( n <= _num ) { return _num ; } if ( n == _num ) { return _num ; } if ( ( n & _num ) == _num ) { n -- ; } else { n -= _num ; } while ( n > _num & ! isprime ( n ) ) { n -= _num ; } return n ; }	returns the largest prime smaller than the given integer.
public synchronized void deletetypesubstitution ( final inavioperandtreenode node ) throws couldntdeleteexception { preconditions . checknotnull ( node , _str ) ; final typesubstitution substitution = node . gettypesubstitution ( ) ; typescontainer . deletetypesubstitution ( substitution ) ; backend . deletetypesubstitution ( substitution ) ; node . settypesubstitution ( null ) ; notifysubstitutionsdeleted ( collections . singleton ( substitution ) ) ; }	removes the type substitution from the given tree node and deletes the corresponding database record .
private void paintbackground ( graphics graphics , jcomponent button ) { styleutil . fillbackground ( style , graphics , _num , _num , button . getwidth ( ) , button . getheight ( ) ) ; }	draw the background image .
public string [ ] headers ( final string name ) { final map < string , list < string > > headers = headers ( ) ; if ( headers == null || headers . isempty ( ) ) return empty_strings ; final list < string > values = headers . get ( name ) ; if ( values != null && ! values . isempty ( ) ) return values . toarray ( new string [ values . size ( ) ] ) ; else return empty_strings ; }	get all values of the given header from the response.
@ override public int hashcode ( ) { int result ; long temp ; temp = double . doubletolongbits ( this . x1 ) ; result = ( int ) ( temp ^ ( temp > > > _num ) ) ; temp = double . doubletolongbits ( this . x2 ) ; result = _num * result + ( int ) ( temp ^ ( temp > > > _num ) ) ; temp = double . doubletolongbits ( this . y1 ) ; result = _num * result + ( int ) ( temp ^ ( temp > > > _num ) ) ; temp = double . doubletolongbits ( this . y2 ) ; result = _num * result + ( int ) ( temp ^ ( temp > > > _num ) ) ; return result ; }	returns a hash code .
public object eval ( callstack callstack , interpreter interpreter ) throws evalerror { try { namespace namespace = callstack . top ( ) ; bshtype typenode = gettypenode ( ) ; class type = typenode . gettype ( callstack , interpreter ) ; bshvariabledeclarator [ ] bvda = getdeclarators ( ) ; for ( int i = _num ; i < bvda . length ; i ++ ) { bshvariabledeclarator dec = bvda [ i ] ; object value = dec . eval ( typenode , callstack , interpreter ) ; try { namespace . settypedvariable ( dec . name , type , value , modifiers ) ; } catch ( utilevalerror e ) { throw e . toevalerror ( this , callstack ) ; } } } catch ( evalerror e ) { e . rethrow ( _str ) ; } return primitive . void ; }	evaluate the type and one or more variable declarators , e.
private void finishitemlistitem ( stringbuilder result ) { result . append ( _str ) ; }	called to finish adding an item to an item list .
public static int launchfilewindows ( string path ) throws ioexception { try { return systemutils . openfile ( path ) ; } catch ( ioexception iox ) { throw new launchexception ( iox , path ) ; } }	launches the given file on windows .
private void profilescb ( ) { profile profile ; string host ; profile = ( profile ) profilescombobox . getselecteditem ( ) ; if ( profile != null ) { host = profile . gethost ( ) ; serverfield . settext ( host ) ; serverportfield . settext ( string . valueof ( profile . getport ( ) ) ) ; usernamefield . settext ( profile . getuser ( ) ) ; passwordfield . settext ( profile . getpassword ( ) ) ; } else { serverportfield . settext ( string . valueof ( profile . default_server_port ) ) ; usernamefield . settext ( _str ) ; passwordfield . settext ( _str ) ; } }	called when a profile selection is changed .
public infoflowresults runinfoflow ( ) { return runinfoflow ( null ) ; }	runs the data flow analysis.
private static string createtooltip ( string columnname , string type , string rolename ) { stringbuilder tipbuilder = new stringbuilder ( ) ; tipbuilder . append ( _str ) ; tipbuilder . append ( i18n . getguilabel ( _str ) ) ; tipbuilder . append ( _str ) ; tipbuilder . append ( columnname ) ; tipbuilder . append ( _str ) ; tipbuilder . append ( i18n . getguilabel ( _str ) ) ; tipbuilder . append ( _str ) ; tipbuilder . append ( type ) ; tipbuilder . append ( _str ) ; if ( rolename != null ) { tipbuilder . append ( _str ) ; tipbuilder . append ( i18n . getguilabel ( _str ) ) ; tipbuilder . append ( _str ) ; tipbuilder . append ( rolename ) ; tipbuilder . append ( _str ) ; } tipbuilder . append ( _str ) ; return tipbuilder . tostring ( ) ; }	creates the tooltip text for the table header .
@ override public boolean equals ( object obj ) { if ( obj == this ) { return _bool ; } if ( ! ( obj instanceof defaultintervalcategorydataset ) ) { return _bool ; } defaultintervalcategorydataset that = ( defaultintervalcategorydataset ) obj ; if ( ! arrays . equals ( this . serieskeys , that . serieskeys ) ) { return _bool ; } if ( ! arrays . equals ( this . categorykeys , that . categorykeys ) ) { return _bool ; } if ( ! equal ( this . startdata , that . startdata ) ) { return _bool ; } if ( ! equal ( this . enddata , that . enddata ) ) { return _bool ; } return _bool ; }	tests this dataset for equality with an arbitrary object .
public static string cutsuffix ( string string , string suffix ) { if ( string . endswith ( suffix ) ) { string = string . substring ( _num , string . length ( ) - suffix . length ( ) ) ; } return string ; }	cuts sufix if exists .
@ override public void putall ( map < ? extends k , ? extends v > m ) { trypresize ( m . size ( ) ) ; for ( map . entry < ? extends k , ? extends v > e : m . entryset ( ) ) putval ( e . getkey ( ) , e . getvalue ( ) , _bool ) ; }	copies all of the mappings from the specified map to this one.
public datamatrix merge ( datamatrix that ) throws scopeexception { merger merger = new merger ( this , that ) ; return merger . merge ( _bool ) ; }	merge two matrix with different kpis but must be on the same space.
@ suppresswarnings ( _str ) private map < k , v > interceptget ( @ nullable collection < ? extends k > keys , map < k , v > map ) { if ( f . isempty ( keys ) ) return map ; cacheinterceptor < k , v > interceptor = cachecfg . getinterceptor ( ) ; assert interceptor != null ; map < k , v > res = u . newhashmap ( keys . size ( ) ) ; for ( map . entry < k , v > e : map . entryset ( ) ) { v val = interceptor . onget ( e . getkey ( ) , e . getvalue ( ) ) ; if ( val != null ) res . put ( e . getkey ( ) , val ) ; } if ( map . size ( ) != keys . size ( ) ) { for ( k key : keys ) { if ( key != null ) { if ( ! map . containskey ( key ) ) { v val = interceptor . onget ( key , null ) ; if ( val != null ) res . put ( key , val ) ; } } } } return res ; }	applies cache interceptor on result of ' get ' operation .
static int [ ] findnanpphonenumbers ( charsequence text ) { arraylist < integer > list = new arraylist < integer > ( ) ; int startpos = _num ; int endpos = text . length ( ) - nanp_min_digits + _num ; if ( endpos < _num ) { return new int [ ] { } ; } while ( startpos < endpos ) { while ( character . iswhitespace ( text . charat ( startpos ) ) && startpos < endpos ) { startpos ++ ; } if ( startpos == endpos ) { break ; } int matchend = findnanpmatchend ( text , startpos ) ; if ( matchend > startpos ) { list . add ( startpos ) ; list . add ( matchend ) ; startpos = matchend ; } else { while ( ! character . iswhitespace ( text . charat ( startpos ) ) && startpos < endpos ) { startpos ++ ; } } } int [ ] result = new int [ list . size ( ) ] ; for ( int i = list . size ( ) - _num ; i >= _num ; i -- ) { result [ i ] = list . get ( i ) ; } return result ; }	finds north american numbering plan ( nanp ) phone numbers in the input text .
public void writetostream ( outputstream os , int len ) throws ioexception { while ( len > _num ) { if ( _readlength <= _readoffset ) { if ( ! readbuffer ( ) ) return ; } int sublen = math . min ( len , _readlength - _readoffset ) ; os . write ( _readbuffer , _readoffset , sublen ) ; _readoffset += sublen ; len -= sublen ; } }	writes < code > len < code > bytes to the output stream from this stream .
public static void main ( string [ ] args ) { log . printline ( _str ) ; try { int num_user = _num ; calendar calendar = calendar . getinstance ( ) ; boolean trace_flag = _bool ; cloudsim . init ( num_user , calendar , trace_flag ) ; @ suppresswarnings ( _str ) datacenter datacenter0 = createdatacenter ( _str ) ; @ suppresswarnings ( _str ) datacenter datacenter1 = createdatacenter ( _str ) ; datacenterbroker broker = createbroker ( ) ; int brokerid = broker . getid ( ) ; vmlist = createvm ( brokerid , _num ) ; cloudletlist = createcloudlet ( brokerid , _num ) ; broker . submitvmlist ( vmlist ) ; broker . submitcloudletlist ( cloudletlist ) ; cloudsim . startsimulation ( ) ; list < cloudlet > newlist = broker . getcloudletreceivedlist ( ) ; cloudsim . stopsimulation ( ) ; printcloudletlist ( newlist ) ; log . printline ( _str ) ; } catch ( exception e ) { e . printstacktrace ( ) ; log . printline ( _str ) ; } }	creates main ( ) to run this example.
public void test_selectleftouterjoin ( ) throws sqlexception { string sql = _str + databasecreator . customers_table + _str + databasecreator . salespeople_table + _str ; resultset result = statement . executequery ( sql ) ; hashmap < integer , integer > value = new hashmap < integer , integer > ( ) ; value . put ( _num , _num ) ; value . put ( _num , _num ) ; value . put ( _num , _num ) ; value . put ( _num , _num ) ; value . put ( _num , _num ) ; while ( result . next ( ) ) { int key = result . getint ( _str ) ; object val = result . getobject ( _str ) ; asserttrue ( _str , value . containskey ( key ) ) ; assertequals ( _str , value . get ( key ) , ( integer ) val ) ; value . remove ( key ) ; } asserttrue ( _str , value . isempty ( ) ) ; result . close ( ) ; }	selectfunctionalitytest # test_selectleftouterjoin ( ) . selects records from a table using left join.
void swapactions ( int row ) { conditionalaction temp = _actionlist . get ( row ) ; for ( int i = row ; i > _nextinorder ; i -- ) { _actionlist . set ( i , _actionlist . get ( i - _num ) ) ; } _actionlist . set ( _nextinorder , temp ) ; _nextinorder ++ ; if ( _nextinorder >= _actionlist . size ( ) ) { _inreordermode = _bool ; } _actiontablemodel . firetabledatachanged ( ) ; }	responds to the first / next ( delete ) button in the edit conditional window.
public static list < ? extends element > childelementlist ( element element , string childelementname ) { if ( element == null ) return null ; list < element > elements = new linkedlist < element > ( ) ; node node = element . getfirstchild ( ) ; if ( node != null ) { do { if ( node . getnodetype ( ) == node . element_node && ( childelementname == null || childelementname . equals ( node . getnodename ( ) ) ) ) { element childelement = ( element ) node ; elements . add ( childelement ) ; } } while ( ( node = node . getnextsibling ( ) ) != null ) ; } return elements ; }	return a list of element objects that have the given name and are immediate children of the given element ; if name is null , all child elements will be included .
public void reset ( collection < e > collection , @ nullable diffutil . callback callback ) { items . clear ( ) ; items . addall ( collection ) ; if ( callback != null ) { updateitemstask = new updateitemstask ( ) ; updateitemstask . execute ( callback ) ; } else { notifydatasetchanged ( ) ; } }	resets the current adapter state - clear current items , add new ones and execute updateitems task .
private custominternaln4jsparser collectfollowelements ( tokensource tokens , boolean strict , set < followelement > result ) { custominternaln4jsparser parser = createparser ( ) ; parser . setstrict ( strict ) ; try { observablextexttokenstream tokenstream = new observablextexttokenstream ( tokens , parser ) ; result . addall ( dogetfollowelements ( parser , tokenstream ) ) ; } catch ( infiniterecursion infinite ) { result . addall ( parser . getfollowelements ( ) ) ; } return parser ; }	first pass . use the tokens that have been computed from the production parser ' s result and collect the follow elements from those .
public dsubjectalternativename ( jdialog parent ) { super ( parent ) ; settitle ( res . getstring ( _str ) ) ; initcomponents ( ) ; }	creates a new dsubjectalternativename dialog .
private string nexthost ( ) { currenthost ++ ; if ( currenthost == hostsarray . length ) { currenthost = _num ; } return hostsarray [ currenthost ] ; }	return the string ip of the next host using round - robin technique.
public static void showerror ( final string messagetext ) { joptionpane . showmessagedialog ( null , messagetext , translate ( _str ) , joptionpane . error_message ) ; }	shows an error message box to the user.
@ nonnull public list < trayitem > queryprovidersafe ( @ nonnull final uri uri ) { try { return queryprovider ( uri ) ; } catch ( trayexception e ) { return new arraylist < > ( ) ; } }	sends a query for trayitems to the provider , doesn ' t throw when the database access couldn ' t be established.
@ override public void countexample ( example example ) { int label = classnamemap . get ( example . getnominalvalue ( labelattribute ) ) ; int plabel = classnamemap . get ( example . getnominalvalue ( predictedlabelattribute ) ) ; double weight = _num ; if ( weightattribute != null ) { weight = example . getvalue ( weightattribute ) ; } counter [ label ] [ plabel ] += weight ; }	increases the prediction value in the matrix .
void acc_expand ( ) { int len = digits . length ; int oldones [ ] = digits ; digits = new int [ len + _num ] ; system . arraycopy ( oldones , _num , digits , _num , len ) ; }	expand by one and release past ( internal ) memory.
protected double updatedistance ( double currdist , double diff ) { double result ; result = currdist ; diff = math . abs ( diff ) ; if ( diff > result ) result = diff ; return result ; }	updates the current distance calculated so far with the new difference between two attributes.
public string goback ( ) { if ( pointer > _num ) { pointer -- ; } if ( messages . size ( ) > _num ) { return messages . get ( pointer ) ; } return null ; }	go back in history.
private synchronized void addnodejsinstalls ( iconfigurationelement [ ] cf , list < iembeddednodejs > list ) { for ( iconfigurationelement ce : cf ) { try { list . add ( new nodejsinstall ( ce ) ) ; trace . trace ( trace . extension_point , _str + ce . getattribute ( _str ) ) ; } catch ( throwable t ) { trace . trace ( trace . severe , _str + ce . getattribute ( _str ) , t ) ; } } }	load the nodejs installs .
public static list < file > samplefiles ( file folder , int number , filefilter filter ) { list < file > result = null ; if ( ! folder . exists ( ) || ! folder . isdirectory ( ) || ! folder . canread ( ) ) { log . error ( _str + folder . getabsolutepath ( ) ) ; return null ; } file [ ] filelist = folder . listfiles ( filter ) ; if ( filelist . length > _num ) { result = new arraylist < file > ( ) ; if ( filelist . length < number ) { log . warn ( _str + number + _str + filelist . length + _str ) ; } int [ ] permutation = randompermutation . getrandompermutation ( filelist . length ) ; int index = _num ; while ( result . size ( ) < number && index < permutation . length ) { result . add ( filelist [ permutation [ index ++ ] - _num ] ) ; } log . info ( _str + result . size ( ) + _str ) ; return result ; } else { log . warn ( _str ) ; return null ; } }	the method samples from a filtered file list .
public instance placemovieclip ( symbol symbol , transform matrix2 , alphatransform cxform , string name , actions [ ] clipactions ) { transform matrix = matrix2 ; int depth = timeline . getavailabledepth ( ) ; instance inst = new instance ( symbol , depth ) ; timeline . setavailabledepth ( depth + _num ) ; if ( matrix == null ) { matrix = new transform ( ) ; } placement placement = new placement ( inst , matrix , cxform , name , - _num , - _num , framenumber , _bool , _bool , clipactions ) ; placements . add ( placement ) ; return inst ; }	place a movie clip at the next available depth with the given properties .
public void message ( map headers , string body ) { transmit ( command . message , headers , body ) ; }	called by the server ; sends a message to this client .
protected lighticon addlight ( ) { lighticon l = new lighticon ( this ) ; iconadder editor = geticoneditor ( _str ) ; l . setofficon ( editor . geticon ( _str ) ) ; l . setonicon ( editor . geticon ( _str ) ) ; l . setinconsistenticon ( editor . geticon ( _str ) ) ; l . setunknownicon ( editor . geticon ( _str ) ) ; l . setlight ( ( light ) editor . gettableselection ( ) ) ; l . setdisplaylevel ( lights ) ; setnextlocation ( l ) ; putitem ( l ) ; return l ; }	add a light indicator to the target.
public static boolean checkifinitiatorsforrp ( dbclient dbclient , stringset initiatorlist ) { if ( dbclient == null || initiatorlist == null ) { return _bool ; } list < initiator > initiators = new arraylist < initiator > ( ) ; for ( string initiatorid : initiatorlist ) { initiator initiator = dbclient . queryobject ( initiator . class , uri . create ( initiatorid ) ) ; if ( initiator != null ) { initiators . add ( initiator ) ; } } return checkifinitiatorsforrp ( initiators ) ; }	checks to see if the initiators passed in are for recoverpoint.
@ deprecated public static file createtempdirectory ( string prefix ) throws ioexception { return createtempdirectory ( null , prefix ) ; }	create temporary directory and use ' java.
public int timepassed ( ) { final long time = animationutils . currentanimationtimemillis ( ) ; final long starttime = math . min ( mscrollerx . mstarttime , mscrollery . mstarttime ) ; return ( int ) ( time - starttime ) ; }	returns the time elapsed since the beginning of the scrolling .
private void createcache ( ) throws exception { if ( this . distributedsystem == null ) { this . distributedsystem = internaldistributedsystem . getconnectedinstance ( ) ; } this . cache = cachefactory . create ( this . distributedsystem ) ; }	create the cache to be used by this migration server.
public abstract boolean doinit ( boolean ignorecancel ) throws throwable ;	initialize the model checker.
public static void apply ( collection coll , function func ) { for ( iterator i = coll . iterator ( ) ; i . hasnext ( ) ; ) { func . execute ( i . next ( ) ) ; } }	executes a function on each item in a collection but does not accumulate the result.
public static boolean checkconnection ( connection conn ) { string sql = _str ; statement stmt = null ; resultset rs = null ; try { stmt = conn . createstatement ( ) ; stmt . setquerytimeout ( _num ) ; rs = stmt . executequery ( sql ) ; if ( rs != null && rs . next ( ) ) return _bool ; return _bool ; } catch ( exception ex ) { } finally { close ( rs ) ; close ( stmt ) ; } return _bool ; }	check if the given jdbc connection is still good.
protected static dynamicfield [ ] dynamicfieldlisttosortedarray ( list < dynamicfield > dynamicfieldlist ) { dynamicfield [ ] dfields = dynamicfieldlist . toarray ( new dynamicfield [ dynamicfieldlist . size ( ) ] ) ; arrays . sort ( dfields ) ; log . trace ( _str + arrays . tostring ( dfields ) ) ; return dfields ; }	sort the dynamic fields and stuff them in a normal array for faster access .
protected void triggerpreferredleaderelection ( zkutils zkutils , list < partitioninfo > partitioninfolist ) { scala . collection . mutable . hashset < topicandpartition > scalapartitioninfoset = new scala . collection . mutable . hashset < > ( ) ; for ( partitioninfo javapartitioninfo : partitioninfolist ) { scalapartitioninfoset . add ( new topicandpartition ( _topic , javapartitioninfo . partition ( ) ) ) ; } preferredreplicaleaderelectioncommand . writepreferredreplicaelectiondata ( zkutils , scalapartitioninfoset ) ; }	this runs the preferred replica election for all partitions .
public dataviewcomponent ( masterview masterview , masterviewconfiguration masterareaconfiguration ) { initcomponents ( ) ; createmasterview ( masterview ) ; configuremasterview ( masterareaconfiguration ) ; }	creates new instance of dataviewcomponent .
public boolean deleteentry ( int index ) { system . arraycopy ( entries , index + _num , entries , index , numentries - index - _num ) ; entries [ -- numentries ] = null ; return _bool ; }	deletes the entry at the specified index and shifts all entries after the index to left .
public void removeitem ( int position ) { mdatas . remove ( position ) ; notifydatasetchanged ( ) ; }	remove data for position.
public void resolveurls ( ) { try { pool = executors . newfixedthreadpool ( numthreads ) ; bufferedreader buffread = new bufferedreader ( new filereader ( new file ( urlsfile ) ) ) ; string urlstr = null ; while ( ( urlstr = buffread . readline ( ) ) != null ) { log . info ( _str + urlstr ) ; pool . execute ( new resolverthread ( urlstr ) ) ; } buffread . close ( ) ; pool . awaittermination ( _num , timeunit . seconds ) ; } catch ( exception e ) { pool . shutdownnow ( ) ; log . info ( stringutils . stringifyexception ( e ) ) ; } pool . shutdown ( ) ; log . info ( _str + numtotal . get ( ) + _str + numresolved . get ( ) + _str + numerrored . get ( ) + _str + totaltime . get ( ) / numtotal . get ( ) ) ; }	creates a thread pool for resolving urls.
public void addtextbox ( sprite sprite , double x , double y , int textlength ) { int sx = convertworldxtoscaledscreen ( x ) ; int sy = convertworldytoscaledscreen ( y ) ; sy -= sprite . getheight ( ) ; sx = keepspriteonmapx ( sprite , sx ) ; sy = keepspriteonmapy ( sprite , sy ) ; boolean found = _bool ; int tries = _num ; while ( found ) { found = _bool ; synchronized ( texts ) { for ( final removablesprite item : texts ) { if ( ( item . getx ( ) == sx ) && ( item . gety ( ) == sy ) ) { found = _bool ; sy += size_unit_pixels / _num ; sy = keepspriteonmapy ( sprite , sy ) ; break ; } } } tries ++ ; if ( tries > _num ) { break ; } } texts . add ( new removablesprite ( sprite , sx , sy , math . max ( removablesprite . standard_persistence_time , textlength * removablesprite . standard_persistence_time / _num ) ) ) ; }	adds a text bubble at a give position .
public void dispose ( ) { m_debugperspectivemodel . removelistener ( m_debuglistener ) ; synchronizedebugger ( m_debugperspectivemodel . getcurrentselecteddebugger ( ) , null ) ; }	clears up allocated resources .
public string dump ( object data ) { list < object > list = new arraylist < object > ( _num ) ; list . add ( data ) ; return dumpall ( list . iterator ( ) ) ; }	serialize a java object into a yaml string .
private void decrementaccesscount ( ) { if ( accesscount . get ( ) > _num ) { accesscount . decrementandget ( ) ; } }	this method will decrement the access count for a column by 1 whenever a column usage is complete.
public tiledirectory ( ) { tilename = _str ; this . tileid = - _num ; westlon = eastlon = northlat = southlat = float . nan ; }	construct an untiled tiledirectory . since this object does not have valid boundaries , it is an error to call inregion on it.
public boolean isletterordigitahead ( ) { int pos = currentposition ; while ( pos < maxposition ) { if ( character . isletterordigit ( str . charat ( pos ) ) ) return _bool ; pos ++ ; } return _bool ; }	tells if there is a digit or a letter character ahead .
public static string addttdir ( final string fontpath , string failed ) { checkfonttablesinitialised ( ) ; final file currentdir = new file ( fontpath ) ; if ( ( currentdir . exists ( ) ) && ( currentdir . isdirectory ( ) ) ) { final string [ ] files = currentdir . list ( ) ; if ( files != null ) { for ( final string currentfont : files ) { addfontfile ( currentfont , fontpath ) ; } } } else { if ( failed == null ) { failed = fontpath ; } else { failed = failed + _str + fontpath ; } } return failed ; }	add a truetype font directory and contents to substitution.
public static string tohex ( string arg ) { return string . format ( _str , new biginteger ( _num , arg . getbytes ( ) ) ) ; }	create queries with mid for type i.
public static string addtocartbulkrequirements ( httpservletrequest request , httpservletresponse response ) { shoppingcart cart = getcartobject ( request ) ; delegator delegator = ( delegator ) request . getattribute ( _str ) ; localdispatcher dispatcher = ( localdispatcher ) request . getattribute ( _str ) ; shoppingcarthelper carthelper = new shoppingcarthelper ( delegator , dispatcher , cart ) ; string controldirective ; map < string , object > result ; map < string , object > parammap = utilhttp . getparametermap ( request ) ; string catalogid = catalogworker . getcurrentcatalogid ( request ) ; result = carthelper . addtocartbulkrequirements ( catalogid , parammap ) ; controldirective = processresult ( result , request ) ; if ( controldirective . equals ( error ) ) { return _str ; } else { return _str ; } }	adds a set of requirements to the cart.
public static void saveasgnustepascii ( nsdictionary root , file out ) throws ioexception { file parent = out . getparentfile ( ) ; if ( ! parent . exists ( ) && ! parent . mkdirs ( ) ) { throw new ioexception ( _str ) ; } outputstreamwriter w = new outputstreamwriter ( new fileoutputstream ( out ) , _str ) ; w . write ( root . tognustepasciipropertylist ( ) ) ; w . close ( ) ; }	saves a property list with the given object as root into a ascii file .
protected rewrittenoutboundurl processencodeurl ( httpservletresponse hsresponse , httpservletrequest hsrequest , boolean encodeurlhasbeenrun , string outboundurl ) { if ( log . isdebugenabled ( ) ) { log . debug ( _str + outboundurl ) ; } if ( outboundurl == null ) { return new rewrittenoutboundurl ( null , _bool ) ; } boolean finalencodeoutboundurl = _bool ; string finaltourl = outboundurl ; final list outboundrules = conf . getoutboundrules ( ) ; try { for ( int i = _num ; i < outboundrules . size ( ) ; i ++ ) { final outboundrule outboundrule = ( outboundrule ) outboundrules . get ( i ) ; if ( ! encodeurlhasbeenrun && outboundrule . isencodefirst ( ) ) { continue ; } if ( encodeurlhasbeenrun && ! outboundrule . isencodefirst ( ) ) { continue ; } final rewrittenoutboundurl rewrittenurl = outboundrule . execute ( finaltourl , hsrequest , hsresponse ) ; if ( rewrittenurl != null ) { if ( log . isdebugenabled ( ) ) { log . debug ( _str + outboundrule . getdisplayname ( ) + _str ) ; } finaltourl = rewrittenurl . gettarget ( ) ; finalencodeoutboundurl = rewrittenurl . isencode ( ) ; if ( outboundrule . islast ( ) ) { log . debug ( _str ) ; break ; } } } } catch ( invocationtargetexception e ) { try { handleinvocationtargetexception ( hsrequest , hsresponse , e ) ; } catch ( servletexception e1 ) { log . error ( e1 ) ; } catch ( ioexception e1 ) { log . error ( e1 ) ; } } return new rewrittenoutboundurl ( finaltourl , finalencodeoutboundurl ) ; }	handles rewriting urls in jsp ' s etc , i.
@ override public iterator < shoppingcartitem > iterator ( ) { return cartlines . iterator ( ) ; }	returns an iterator of cart items .
public static string escapexml ( string buffer ) { int start = _num ; int length = buffer . length ( ) ; char [ ] arraybuffer = buffer . tochararray ( ) ; stringbuffer escapedbuffer = null ; for ( int i = _num ; i < length ; i ++ ) { char c = arraybuffer [ i ] ; if ( c <= highest_special ) { char [ ] escaped = specialcharactersrepresentation [ c ] ; if ( escaped != null ) { if ( start == _num ) { escapedbuffer = new stringbuffer ( length + _num ) ; } if ( start < i ) { escapedbuffer . append ( arraybuffer , start , i - start ) ; } start = i + _num ; escapedbuffer . append ( escaped ) ; } } } if ( start == _num ) { return buffer ; } if ( start < length ) { escapedbuffer . append ( arraybuffer , start , length - start ) ; } return escapedbuffer . tostring ( ) ; }	performs the following substring replacements ( to facilitate output to xml / html pages ) : & - > & amp ; < - > & lt ; > - > & gt ; " - > & # 034 ; ' - > & # 039 ; see also outsupport.
private static short callstaticshortmethodv ( jnienvironment env , int classjref , int methodid , address argaddress ) throws exception { if ( tracejni ) vm . syswrite ( _str ) ; runtimeentrypoints . checkjnicountdowntogc ( ) ; try { object returnobj = jnihelpers . invokewithvararg ( methodid , argaddress , typereference . short ) ; return reflection . unwrapshort ( returnobj ) ; } catch ( throwable unexpected ) { if ( tracejni ) unexpected . printstacktrace ( system . err ) ; env . recordexception ( unexpected ) ; return _num ; } }	callstaticshortmethodv : invoke a static method that returns a short value.
private static string removebrackets ( string subquery ) { if ( subquery . indexof ( _str ) == _num && subquery . lastindexof ( _str ) == subquery . length ( ) - _num ) { return subquery . substring ( _num , subquery . length ( ) - _num ) ; } return subquery ; }	removes the first and the last bracket from the sub - query .
public static string [ ] stringarrayfromstring ( string string , char delimiter ) { list < string > result = new arraylist < string > ( _num ) ; if ( stringutils . isnotblank ( string ) ) { raptorstringtokenizer tok = new raptorstringtokenizer ( string , string . valueof ( delimiter ) , _bool ) ; while ( tok . hasmoretokens ( ) ) { string token = tok . nexttoken ( ) ; result . add ( token ) ; } } return result . toarray ( new string [ _num ] ) ; }	returns a string [ ] of strings from a string that is formatted in what tostring ( string [ ] ) returns .
public float textwidth ( string str ) { if ( textfont == null ) { defaultfontordeath ( _str ) ; } int length = str . length ( ) ; if ( length > textwidthbuffer . length ) { textwidthbuffer = new char [ length + _num ] ; } str . getchars ( _num , length , textwidthbuffer , _num ) ; float wide = _num ; int index = _num ; int start = _num ; while ( index < length ) { if ( textwidthbuffer [ index ] == _str ) { wide = math . max ( wide , textwidthimpl ( textwidthbuffer , start , index ) ) ; start = index + _num ; } index ++ ; } if ( start < length ) { wide = math . max ( wide , textwidthimpl ( textwidthbuffer , start , index ) ) ; } return wide ; }	return the width of a line of text.
protected void initclassdefaults ( uidefaults table ) { super . initclassdefaults ( table ) ; final string windowspackagename = _str ; object [ ] uidefaults = { _str , windowspackagename + _str , _str , windowspackagename + _str , _str , windowspackagename + _str , _str , windowspackagename + _str , _str , windowspackagename + _str , _str , windowspackagename + _str , _str , windowspackagename + _str , _str , windowspackagename + _str , _str , windowspackagename + _str , _str , windowspackagename + _str , _str , windowspackagename + _str , _str , windowspackagename + _str , _str , windowspackagename + _str , _str , windowspackagename + _str , _str , windowspackagename + _str , _str , windowspackagename + _str , _str , windowspackagename + _str , _str , windowspackagename + _str , _str , windowspackagename + _str , _str , windowspackagename + _str , _str , windowspackagename + _str , _str , windowspackagename + _str , _str , windowspackagename + _str , _str , windowspackagename + _str , _str , windowspackagename + _str , _str , windowspackagename + _str , _str , windowspackagename + _str , _str , windowspackagename + _str , _str , windowspackagename + _str , _str , windowspackagename + _str , _str , windowspackagename + _str , _str , windowspackagename + _str , _str , windowspackagename + _str , _str , windowspackagename + _str } ; table . putdefaults ( uidefaults ) ; }	initialize the uiclassid to basiccomponentui mapping.
public namedthreadfactory ( string nameprefix ) { this . _nameprefix = nameprefix ; _delegate = executors . defaultthreadfactory ( ) ; }	constructs the thread factory .
private void writeheaderline ( list < extensionproperty > propertylist , int totalcolumns , archivefile af , writer writer ) throws ioexception { string [ ] headers = new string [ totalcolumns ] ; headers [ id_column_index ] = id_column_name ; int c = _num ; for ( extensionproperty property : propertylist ) { headers [ c ] = property . simplename ( ) ; c ++ ; } string headerline = tabrow ( headers ) ; af . setignoreheaderlines ( _num ) ; writer . write ( headerline ) ; }	write the header column line to file .
private list < usericon > parsechaticons ( string json , string stream ) { try { jsonparser parser = new jsonparser ( ) ; jsonobject root = ( jsonobject ) parser . parse ( json ) ; list < usericon > iconsnew = new arraylist < > ( ) ; addusericon ( iconsnew , usericon . type . mod , null , getchaticonurl ( root , _str , _str ) ) ; addusericon ( iconsnew , usericon . type . sub , stream , getchaticonurl ( root , _str , _str ) ) ; addusericon ( iconsnew , usericon . type . turbo , null , getchaticonurl ( root , _str , _str ) ) ; addusericon ( iconsnew , usericon . type . broadcaster , null , getchaticonurl ( root , _str , _str ) ) ; addusericon ( iconsnew , usericon . type . staff , null , getchaticonurl ( root , _str , _str ) ) ; addusericon ( iconsnew , usericon . type . admin , null , getchaticonurl ( root , _str , _str ) ) ; addusericon ( iconsnew , usericon . type . global_mod , null , getchaticonurl ( root , _str , _str ) ) ; return iconsnew ; } catch ( parseexception ex ) { logger . warning ( _str + ex . getlocalizedmessage ( ) ) ; return null ; } }	parses the icons info returned from the twitchapi into a chaticons object containing the urls .
public float distance ( vec3 b ) { float x = this . m [ _num ] - b . m [ _num ] ; float y = this . m [ _num ] - b . m [ _num ] ; float z = this . m [ _num ] - b . m [ _num ] ; float result = ( float ) math . sqrt ( x * x + y * y + z * z ) ; return result ; }	\ brief distance ( this , b ).
@ deprecated public spider ( extensionspider extension , spiderparam spiderparam , connectionparam connectionparam , model model , context scancontext ) { this ( _str , extension , spiderparam , connectionparam , model , scancontext ) ; }	instantiates a new spider .
private static boolean evaluateoptionsrules ( list reqoptions , list regoptions ) { if ( reqoptions == null || regoptions == null || ( reqoptions . size ( ) == _num ) ) { return _bool ; } iterator i = reqoptions . iterator ( ) ; while ( i . hasnext ( ) ) { string option = ( string ) i . next ( ) ; if ( regoptions . contains ( option ) ) { return _bool ; } } return _bool ; }	performs options matching for queries.
public void overridebutton ( string button , boolean override ) { log . i ( _str , _str ) ; if ( button . equals ( _str ) ) { webview . setbuttonplumbedtojs ( keyevent . keycode_volume_up , override ) ; } else if ( button . equals ( _str ) ) { webview . setbuttonplumbedtojs ( keyevent . keycode_volume_down , override ) ; } else if ( button . equals ( _str ) ) { webview . setbuttonplumbedtojs ( keyevent . keycode_menu , override ) ; } }	override the default behavior of the android volume buttons.
public static boolean removeiconfromcache ( context context , appinfo appinfo ) { file file = new file ( context . getcachedir ( ) , appinfo . getapk ( ) ) ; return file . delete ( ) ; }	delelete an app icon from cache folder.
private static int determineconsecutivetextcount ( charsequence msg , int startpos ) { int len = msg . length ( ) ; int idx = startpos ; while ( idx < len ) { char ch = msg . charat ( idx ) ; int numericcount = _num ; while ( numericcount < _num && isdigit ( ch ) && idx < len ) { numericcount ++ ; idx ++ ; if ( idx < len ) { ch = msg . charat ( idx ) ; } } if ( numericcount >= _num ) { return idx - startpos - numericcount ; } if ( numericcount > _num ) { continue ; } ch = msg . charat ( idx ) ; if ( ! istext ( ch ) ) { break ; } idx ++ ; } return idx - startpos ; }	determines the number of consecutive characters that are encodable using text compaction .
public static void dowithfields ( class < ? > clazz , fieldcallback fc , fieldfilter ff ) { class < ? > targetclass = clazz ; do { field [ ] fields = targetclass . getdeclaredfields ( ) ; for ( field field : fields ) { if ( ff != null && ! ff . matches ( field ) ) { continue ; } try { fc . dowith ( field ) ; } catch ( illegalaccessexception ex ) { throw new illegalstateexception ( _str + field . getname ( ) + _str + ex ) ; } } targetclass = targetclass . getsuperclass ( ) ; } while ( targetclass != null && targetclass != object . class ) ; }	invoke the given callback on all fields in the target class , going up the class hierarchy to get all declared fields .
private propertydescriptor [ ] propertydescriptors ( class c ) throws sqlexception { beaninfo beaninfo ; try { beaninfo = introspector . getbeaninfo ( c ) ; } catch ( introspectionexception e ) { throw new sqlexception ( _str + e . getmessage ( ) ) ; } return beaninfo . getpropertydescriptors ( ) ; }	returns a propertydescriptor [ ] for the given class .
@ override public list < appentry > loadinbackground ( ) { list < applicationinfo > apps = mpm . getinstalledapplications ( packagemanager . get_uninstalled_packages | packagemanager . get_disabled_components ) ; if ( apps == null ) { apps = new arraylist < > ( ) ; } final context context = getcontext ( ) ; list < appentry > entries = new arraylist < > ( apps . size ( ) ) ; for ( int i = _num ; i < apps . size ( ) ; i ++ ) { appentry entry = new appentry ( this , apps . get ( i ) ) ; entry . loadlabel ( context ) ; entries . add ( entry ) ; } collections . sort ( entries , alpha_comparator ) ; return entries ; }	this is where the bulk of our work is done.
public static long parseduration ( string durationstr ) { long duration = - _num ; string [ ] componentarr = durationstr . split ( _str ) ; switch ( componentarr . length ) { case _num : duration = parsedurationfromseconds ( durationstr ) ; break ; case _num : case _num : durationstr = ensuresegmentedduration ( durationstr ) ; duration = parsedurationfromstring ( durationstr ) ; break ; default : break ; } return duration ; }	parses a duration string into milliseconds.
public boolean exists ( ) { return file . exists ( ) ; }	tells if the file exists .
private void startdownloadrepeat ( final string hostname , final int port , final string uri ) { mrepeatdownload = _bool ; mspeedtestsocket . startdownload ( hostname , port , uri ) ; }	start download for download repeat .
public void init ( boolean forencryption , cipherparameters param ) { core . init ( forencryption , param ) ; if ( param instanceof parameterswithrandom ) { parameterswithrandom rparam = ( parameterswithrandom ) param ; key = ( rsakeyparameters ) rparam . getparameters ( ) ; random = rparam . getrandom ( ) ; } else { key = ( rsakeyparameters ) param ; random = new securerandom ( ) ; } }	initialise the rsa engine .
public void exec ( final string service , final string action , final string callbackid , final string rawargs ) { cordovaplugin plugin = getplugin ( service ) ; if ( plugin == null ) { log . d ( tag , _str + service ) ; pluginresult cr = new pluginresult ( pluginresult . status . class_not_found_exception ) ; app . sendpluginresult ( cr , callbackid ) ; return ; } callbackcontext callbackcontext = new callbackcontext ( callbackid , app ) ; try { long pluginstarttime = system . currenttimemillis ( ) ; boolean wasvalidaction = plugin . execute ( action , rawargs , callbackcontext ) ; long duration = system . currenttimemillis ( ) - pluginstarttime ; if ( duration > slow_exec_warning_threshold ) { log . w ( tag , _str + service + _str + action + _str + duration + _str ) ; } if ( ! wasvalidaction ) { pluginresult cr = new pluginresult ( pluginresult . status . invalid_action ) ; callbackcontext . sendpluginresult ( cr ) ; } } catch ( jsonexception e ) { pluginresult cr = new pluginresult ( pluginresult . status . json_exception ) ; callbackcontext . sendpluginresult ( cr ) ; } catch ( exception e ) { log . e ( tag , _str , e ) ; callbackcontext . error ( e . getmessage ( ) ) ; } }	receives a request for execution and fulfills it by finding the appropriate java class and calling it ' s execute method.
public void pushstream ( char [ ] instream , int infileid , string name , string inbasedir , string inencoding ) { includestack . push ( new includestate ( cursor , line , col , fileid , filename , basedir , encoding , stream ) ) ; cursor = _num ; line = _num ; col = _num ; fileid = infileid ; filename = name ; basedir = inbasedir ; encoding = inencoding ; stream = instream ; }	sets this mark ' s state to a new stream.
protected void stopoutputtest ( ) { if ( testrunning && outtest ) { outtimer . stop ( ) ; statustext1 . settext ( _str + integer . tostring ( numiterations ) + _str ) ; statustext1 . setvisible ( _bool ) ; statustext2 . settext ( _str ) ; statustext2 . setvisible ( _bool ) ; } }	local method to stop an output test.
public builder ( ) { this . created = new date ( system . currenttimemillis ( ) ) ; this . lastmodified = this . created ; }	constructs a new builder with the created and last modified time set to the current time.
@ override public tabledto create ( @ nonnull qualifiedname name ) { tabledto result = null ; log . info ( _str , name ) ; optional < tabledto > otable = tableservice . get ( name , _bool ) ; if ( otable . ispresent ( ) ) { tabledto table = otable . get ( ) ; string viewname = createviewname ( name ) ; qualifiedname targetname = qualifiedname . oftable ( name . getcatalogname ( ) , view_db_name , viewname ) ; log . info ( _str , targetname ) ; optional < tabledto > oviewtable = optional . empty ( ) ; try { oviewtable = tableservice . get ( targetname , _bool ) ; } catch ( notfoundexception ignored ) { } if ( ! oviewtable . ispresent ( ) ) { log . info ( _str , targetname ) ; result = tableservice . copy ( table , targetname ) ; } else { result = oviewtable . get ( ) ; } } else { throw new tablenotfoundexception ( new schematablename ( name . getdatabasename ( ) , name . gettablename ( ) ) ) ; } return result ; }	creates the materialized view using the schema of the give table assumes that the " franklinviews " database name already exists in the given catalog .
public int intheader ( final string name , final int defaultvalue ) throws httprequestexception { closeoutputquietly ( ) ; return connection . getheaderfieldint ( name , defaultvalue ) ; }	get an integer header value from the response falling back to the given default value if the header is missing or if parsing fails.
public string buildjvmvendor ( ) { return properties . getproperty ( _str ) ; }	returns the vendor for the jvm used to generate this build .
public static void valuetodocument ( value value , string rootnodename , document document ) { element root = document . createelement ( rootnodename ) ; document . appendchild ( root ) ; _valuetodocument ( value , root , document ) ; }	transforms a jolie . value object to an xml document instance .
public void stoplogging ( ) { active = _bool ; }	method to for asynchronous termination of sampling loops.
private void mergeforcecollapse ( ) { while ( stacksize > _num ) { int n = stacksize - _num ; if ( n > _num && runlen [ n - _num ] < runlen [ n + _num ] ) n -- ; mergeat ( n ) ; } }	merges all runs on the stack until only one remains.
private void showabout ( ) { if ( about == null ) { about = new commonaboutdialog ( frame ) ; } about . setvisible ( _bool ) ; }	called when the user selects the " help - > about " menu item .
public list < linearconstraint > normalizeconstraints ( collection < linearconstraint > originalconstraints ) { list < linearconstraint > normalized = new arraylist < linearconstraint > ( originalconstraints . size ( ) ) ; for ( linearconstraint constraint : originalconstraints ) { normalized . add ( normalize ( constraint ) ) ; } return normalized ; }	get new versions of the constraints which have positive right hand sides .
public oslib ( ) { }	create and oslib instance .
protected void teardown ( ) { objarray = null ; objarray2 = null ; hm = null ; }	tears down the fixture , for example , close a network connection.
@ override protected void initrequest ( ) { super . initrequest ( ) ; _state = _state . toactive ( ) ; httpbufferstore bufferstore = gethttpbufferstore ( ) ; _method . clear ( ) ; _methodstring = null ; _protocol . clear ( ) ; _urilength = _num ; if ( bufferstore == null ) { _uri = getsmalluribuffer ( ) ; _headerbuffer = getsmallheaderbuffer ( ) ; _headerkeys = getsmallheaderkeys ( ) ; _headervalues = getsmallheadervalues ( ) ; } _urihost . clear ( ) ; _host = null ; _keepalive = keepalivestate . init ; _headersize = _num ; _headerlength = _num ; _inoffset = _num ; _ischunkedin = _bool ; _isfirst = _bool ; }	clear the request variables in preparation for a new request .
@ override public void removedatasourcelistener ( datasourcelistener dsl ) { m_datalisteners . remove ( dsl ) ; }	remove a data souce listener.
public static void dowithfields ( class < ? > clazz , fieldcallback fc ) throws illegalargumentexception { dowithfields ( clazz , fc , null ) ; }	invoke the given callback on all fields in the target class , going up the class hierarchy to get all declared fields .
public static distributionconfigimpl produce ( properties props , boolean isconnected ) { if ( props != null ) { object o = props . get ( ds_config_name ) ; if ( o instanceof distributionconfigimpl ) { return ( distributionconfigimpl ) o ; } } return new distributionconfigimpl ( props , _bool , isconnected ) ; }	produce a distributionconfigimpl for the given properties and return it .
public shape createpoint ( point2d point ) { rectangle2d . double pointmarker = new rectangle2d . double ( _num , _num , size , size ) ; pointmarker . x = ( double ) ( point . getx ( ) - ( size / _num ) ) ; pointmarker . y = ( double ) ( point . gety ( ) - ( size / _num ) ) ; return pointmarker ; }	creates a shape representing a point .
private void repaintchildren ( final rectangle r ) { final rectangle content = getcontentsize ( ) ; for ( final lwcomponentpeer < ? , ? > child : getchildren ( ) ) { final rectangle childbounds = child . getbounds ( ) ; rectangle topaint = r . intersection ( childbounds ) ; topaint = topaint . intersection ( content ) ; topaint . translate ( - childbounds . x , - childbounds . y ) ; child . repaintpeer ( topaint ) ; } }	paints all the child peers in the straight z - order , so the bottom - most ones are painted first .
private long calculatemillisfor ( mppordernode node , long commonbase ) { final bigdecimal qty = node . getqtytodeliver ( ) ; long totalduration = + node . getqueuingtime ( ) + node . getsetuptimerequired ( ) + node . getmovingtime ( ) + node . getwaitingtime ( ) ; final bigdecimal workingtime = routingservice . estimateworkingtime ( node , qty ) ; totalduration += workingtime . doublevalue ( ) ; return ( long ) ( totalduration * commonbase * _num ) ; }	calculate how many millis take to complete given qty on given node ( operation ) .
protected void add ( string type , string info ) { string seperator = seperator ; if ( start ( type ) ) { text = new stringbuilder ( ) ; text . append ( timestamp ( ) ) ; text . append ( type ) ; text . append ( _str ) ; seperator = _str ; } text . append ( seperator ) ; text . append ( info ) ; length ++ ; if ( length >= max_length ) { close ( ) ; } }	prints something in compact mode , meaning that nick events of the same type appear in the same line , for as long as possible.
public void resizecapacity ( int newcapacity ) { if ( newcapacity == capacity_ ) return ; totalquads_ = math . min ( totalquads_ , newcapacity ) ; capacity_ = newcapacity ; bytebuffer tbb = bytebuffer . allocatedirect ( ccquad2 . size * newcapacity * _num ) ; tbb . order ( byteorder . nativeorder ( ) ) ; floatbuffer tmptexcoords = tbb . asfloatbuffer ( ) ; tmptexcoords . put ( texturecoordinates ) ; texturecoordinates = tmptexcoords ; texturecoordinates . position ( _num ) ; bytebuffer vbb = bytebuffer . allocatedirect ( ccquad3 . size * newcapacity * _num ) ; vbb . order ( byteorder . nativeorder ( ) ) ; floatbuffer tmpvertexcoords = vbb . asfloatbuffer ( ) ; tmpvertexcoords . put ( vertexcoordinates ) ; vertexcoordinates = tmpvertexcoords ; vertexcoordinates . position ( _num ) ; bytebuffer isb = bytebuffer . allocatedirect ( _num * newcapacity * _num ) ; isb . order ( byteorder . nativeorder ( ) ) ; shortbuffer tmpindices = isb . asshortbuffer ( ) ; tmpindices . put ( indices ) ; indices = tmpindices ; indices . position ( _num ) ; initindices ( ) ; if ( withcolorarray_ ) { bytebuffer cbb = bytebuffer . allocatedirect ( _num * cccolor4b . size * newcapacity * _num ) ; cbb . order ( byteorder . nativeorder ( ) ) ; floatbuffer tmpcolors = cbb . asfloatbuffer ( ) ; tmpcolors . put ( colors ) ; colors = tmpcolors ; colors . position ( _num ) ; } }	resize the capacity of the texture atlas.
public string convertstatement ( string orastatement ) { convert . logmigrationscript ( orastatement , null , null ) ; return orastatement ; }	convert an individual oracle style statements to target database statement syntax .
public void annotationadded ( annotation annotation ) { addedannotations . add ( annotation ) ; }	adds the given annotation to the set of annotations that are reported as being added from the model.
private void computesnaps ( collection segstrings , collection snappts ) { for ( iterator i0 = segstrings . iterator ( ) ; i0 . hasnext ( ) ; ) { nodedsegmentstring ss = ( nodedsegmentstring ) i0 . next ( ) ; computesnaps ( ss , snappts ) ; } }	computes nodes introduced as a result of snapping segments to snap points ( hot pixels ).
public short calcrecordlength ( dbftablemodel model ) { int length = _num ; int columncount = model . getcolumncount ( ) ; for ( int i = _num ; i <= columncount - _num ; i ++ ) { length += model . getlength ( i ) ; } length += _num ; integer integer = new integer ( length ) ; return integer . shortvalue ( ) ; }	calculates the length of the record by aggregating the length of each field.
public static void planchangeaccepted ( @ analyticscnsts . planchange string planchangetype , double amount ) { date date = new date ( ) ; timestamp curtime = new timestamp ( date . gettime ( ) ) ; string json = gson . tojson ( new analyticsplanchange ( planchangetype , amount , curtime ) , analyticsplanchange . class ) ; jsonobject jsonobject = null ; try { jsonobject = new jsonobject ( json ) ; jsonobject . put ( _str , _str ) ; log . i ( _str , _str + jsonobject . tostring ( ) ) ; wlanalytics . log ( _str , jsonobject ) ; } catch ( jsonexception e ) { e . printstacktrace ( ) ; } }	planchangeaccepted ( ) sends an operational analytics log anytime a user accepts a plan change .
private boolean equals ( object o , object p ) { return ( o == p || ( ( o != null ) && o . equals ( p ) ) ) ; }	convenient method to test equality in two objects , taking into account nulls .
public void addexception ( final string key , final string value ) { if ( value == null ) { keyvalueexceptions . put ( key , null ) ; } else { set < string > values = maputils . getset ( key , keyvalueexceptions ) ; values . add ( value ) ; } }	adds an exception to the filter , that is if this key and value appears , the filter will return false.
public boolean isconfigured ( ) { return precalcmatchclient . isconfigured ( ) ; }	utility method to confirm if this service is working .
protected object conditionalcopy ( object o ) { if ( iscopyonread ( ) && ! token . isinvalid ( o ) ) { return copyhelper . copy ( o ) ; } else { return o ; } }	makes a copy , if copy - on - get is enabled , of the specified object .
private static boolean jwthasaudienceclaim ( jwtclaimsset jwtclaims ) throws authloginexception { list < string > audienceclaim = jwtclaims . getaudience ( ) ; return ( audienceclaim != null && ! audienceclaim . isempty ( ) ) ; }	check if the token has an authorized party ( " azp " ) entry .
protected testconfig createtestconfig ( string tempdir , list < string > protofiles ) { return new testconfig ( testdatalocator , tempdir , protofiles ) ; }	creates the model object based on the input proto files .
@ override public void removevetoablechangelistener ( string name , vetoablechangelistener vcl ) { m_bcsupport . removevetoablechangelistener ( name , vcl ) ; }	remove a vetoable change listener from this bean.
void update ( preparedstatement prep , string tracemessage ) throws sqlexception { test . trace ( tracemessage ) ; prep . executeupdate ( ) ; if ( test . iscollect ( ) ) { executedstatements . incrementandget ( ) ; } }	execute an sql statement .
private void wrap ( stringbuilder buffer , localizablemessage text ) { indentandwrap ( buffer , _str , text ) ; }	wraps long lines without indentation .
@ sideonly ( side . client ) public void addspecialitemtooltip ( int xpos , int ypos , itemstack stack , arraylist < string > tooltips ) { if ( mousex >= xpos && mousey >= ypos && mousex <= xpos + _num && mousey <= ypos + _num ) { if ( stack != null ) { list < string > tooltipdata = stack . gettooltip ( minecraft . getminecraft ( ) . theplayer , _bool ) ; list < string > parsedtooltip = new arraylist ( ) ; boolean first = _bool ; for ( string tip : tooltips ) tooltipdata . add ( tip ) ; for ( string s : tooltipdata ) { string s_ = s ; if ( ! first ) s_ = chatformatting . gray + s ; parsedtooltip . add ( s_ ) ; first = _bool ; } rendertooltip ( mousex , mousey , parsedtooltip , _num , _num ) ; } } }	adds a special tooltip in case you want to.
private int docancel ( ) { int deselected = _num ; set < selectionkey > cancelledkeys = cancelledkeys ( ) ; synchronized ( cancelledkeys ) { if ( cancelledkeys . size ( ) > _num ) { for ( selectionkey currentkey : cancelledkeys ) { mutablekeys . remove ( currentkey ) ; deregister ( ( abstractselectionkey ) currentkey ) ; if ( mutableselectedkeys . remove ( currentkey ) ) { deselected ++ ; } } cancelledkeys . clear ( ) ; } } return deselected ; }	removes cancelled keys from the key set and selected key set , and unregisters the corresponding channels.
public qname ( string qname , element namespacecontext , prefixresolver resolver ) { this ( qname , namespacecontext , resolver , _bool ) ; }	construct a qname from a string , resolving the prefix using the given namespace context and prefix resolver.
protected void mergecache ( list < object > objects ) { synchronized ( this ) { if ( this . objectlist != null ) { objects = new arraylist < > ( objects ) ; for ( int i = _num ; i < objects . size ( ) ; i ++ ) { object newobject = objects . get ( i ) ; string newobjectname = getobjectname ( newobject ) ; for ( int k = _num ; k < objectlist . size ( ) ; k ++ ) { object oldobject = objectlist . get ( k ) ; string oldobjectname = getobjectname ( oldobject ) ; if ( newobjectname . equals ( oldobjectname ) ) { objects . set ( i , oldobject ) ; break ; } } } } } setcache ( objects ) ; }	merges new cache with existing.
@ override public string tostring ( ) { return date . tostring ( ) ; }	generates a string representation of the date .
public void removesubconfig ( string subconfigname ) throws smsexception , ssoexception { validateserviceconfigimpl ( ) ; subconfigname = smsschema . unescapename ( subconfigname ) ; string sdn = _str + subconfigname + _str + sc . getdn ( ) ; serviceconfigmanagerimpl scmimpl = serviceconfigmanagerimpl . getinstance ( token , getservicename ( ) , getversion ( ) ) ; serviceconfigimpl sconfigimpl = sc . getsubconfig ( token , subconfigname ) ; if ( sconfigimpl != null ) { serviceconfigimpl . deleteinstance ( token , scmimpl , null , sdn , _str , sconfigimpl . getgroupname ( ) , ( getcomponentname ( ) + _str + smsschema . escapespecialcharacters ( subconfigname ) ) , _bool , ss ) ; } cachedsmsentry centry = cachedsmsentry . getinstance ( token , sdn ) ; if ( centry . isdirty ( ) ) { centry . refresh ( ) ; } smsentry entry = centry . getclonedsmsentry ( ) ; entry . delete ( token ) ; centry . refresh ( entry ) ; cachedsubentries cse = cachedsubentries . getinstance ( token , sc . getdn ( ) ) ; cse . remove ( subconfigname ) ; }	removes the service sub - configuration .
private static int stringtohash ( string s ) { int len = s . length ( ) ; int hash = len ; hash <<= _num ; hash += s . charat ( _num ) - _num ; int j = len ; for ( int i = _num ; i < _num && j > _num ; i ++ ) { j -- ; hash <<= _num ; hash += s . charat ( j ) - _num ; } return hash ; }	this method has to return a unique integer for each well - known lower - cased element name .
@ override public void onaction ( ) { onaction ( actiontype . look_closely ) ; }	perform the default action .
public void testequalobjects ( ) { string value1 = _str ; string value2 = _str ; biginteger anumber1 = new biginteger ( value1 ) ; biginteger anumber2 = new biginteger ( value2 ) ; int code1 = anumber1 . hashcode ( ) ; int code2 = anumber2 . hashcode ( ) ; if ( anumber1 . equals ( anumber2 ) ) { asserttrue ( _str , code1 == code2 ) ; } }	test hash codes for equal objects .
public void test_validate ( ) { }	unit test for validating a write set against the current ground state.
@ override public string tostring ( ) { if ( m_iterativeclassifier == null ) { return _str ; } else { stringbuffer sb = new stringbuffer ( ) ; sb . append ( _str + m_bestresult + _str ) ; sb . append ( _str + m_bestnumits + _str ) ; if ( m_thresholds != null ) { sb . append ( _str ) ; for ( int i = _num ; i < m_thresholds . length ; i ++ ) { sb . append ( m_thresholds [ i ] + _str ) ; } } sb . append ( _str ) ; sb . append ( m_iterativeclassifier . tostring ( ) ) ; return sb . tostring ( ) ; } }	returns a string describing the classifier .
private static boolean hasmodernrasterizer ( ) { try { class . forname ( awt_utilities_class_name ) ; return _bool ; } catch ( classnotfoundexception e ) { return _bool ; } }	checks and answers whether this java runtime has a modern rasterizer or not.
public set < accessright > applyaccessrights ( appcontext ctx , set < accessright > accessrights , set < accessright > newaccessrights ) { set < accessright > rightstoadd = new hashset < accessright > ( ) ; set < accessright > rightstoremove = new hashset < accessright > ( ) ; set < accessright > rights = new hashset < accessright > ( accessrights ) ; user user = ctx . getuser ( ) ; for ( accessright newright : newaccessrights ) { if ( ! accessrights . contains ( newright ) ) { if ( hasrole ( user , newaccessrights , newright . getrole ( ) ) ) { rightstoadd . add ( newright ) ; } else { throw new invalidcredentialsapiexception ( _str + newright . getrole ( ) + _str , ctx . isnoerror ( ) ) ; } } } if ( ! newaccessrights . isempty ( ) ) { for ( accessright right : accessrights ) { if ( ! newaccessrights . contains ( right ) ) { if ( hasrole ( user , newaccessrights , right . getrole ( ) ) ) { rightstoremove . add ( right ) ; } else { throw new invalidcredentialsapiexception ( _str + right . getrole ( ) + _str , ctx . isnoerror ( ) ) ; } } } } rights . addall ( rightstoadd ) ; rights . removeall ( rightstoremove ) ; return rights ; }	compute the access rights to apply based on the current user rights . < br >.
public void addroad ( road road ) { roads . addelement ( road ) ; }	add a road to this intersection .
symbol findinheritedmembertype ( env < attrcontext > env , type site , name name , typesymbol c ) { symbol bestsofar = typenotfound ; symbol sym ; type st = types . supertype ( c . type ) ; if ( st != null && st . hastag ( class ) ) { sym = findmembertype ( env , site , name , st . tsym ) ; if ( sym . kind < bestsofar . kind ) bestsofar = sym ; } for ( list < type > l = types . interfaces ( c . type ) ; bestsofar . kind != ambiguous && l . nonempty ( ) ; l = l . tail ) { sym = findmembertype ( env , site , name , l . head . tsym ) ; if ( bestsofar . kind < ambiguous && sym . kind < ambiguous && sym . owner != bestsofar . owner ) bestsofar = new ambiguityerror ( bestsofar , sym ) ; else if ( sym . kind < bestsofar . kind ) bestsofar = sym ; } return bestsofar ; }	find a member type inherited from a superclass or interface .
public static boolean isinitialized ( context ctx ) { vitamiopackage = ctx . getpackagename ( ) ; vitamiolibrarypath = contextutils . getdatadir ( ctx ) + _str ; file dir = new file ( getlibrarypath ( ) ) ; if ( dir . exists ( ) && dir . isdirectory ( ) ) { string [ ] libs = dir . list ( ) ; if ( libs != null ) { arrays . sort ( libs ) ; for ( string l : getrequiredlibs ( ) ) { if ( arrays . binarysearch ( libs , l ) < _num ) { log . e ( _str , l ) ; return _bool ; } } file lock = new file ( getlibrarypath ( ) + libs_lock ) ; bufferedreader buffer = null ; try { buffer = new bufferedreader ( new filereader ( lock ) ) ; int appversion = contextutils . getversioncode ( ctx ) ; int libversion = integer . valueof ( buffer . readline ( ) ) ; log . i ( _str , appversion , libversion ) ; if ( libversion == appversion ) return _bool ; } catch ( ioexception e ) { log . e ( _str , e ) ; } catch ( numberformatexception e ) { log . e ( _str , e ) ; } finally { ioutils . closesilently ( buffer ) ; } } } return _bool ; }	check if vitamio is initialized at this device.
@ override public set < statement > apply ( final igasstate < set < statement > , set < statement > , set < statement > > state , final value u , final set < statement > sum ) { if ( sum != null ) { final set < statement > us = state . getstate ( u ) ; us . addall ( sum ) ; return us ; } return null ; }	union the gathered edges with those already decorating the vertex .
public void addpredictions ( arraylist < prediction > predictions ) throws exception { for ( int i = _num ; i < predictions . size ( ) ; i ++ ) { addprediction ( ( nominalprediction ) predictions . get ( i ) ) ; } }	includes a whole bunch of predictions in the confusion matrix .
protected abstract void _actionperformed ( actionevent evt ) ;	change the underlying bean such that the it is consistent with the value displayed by this configurator .
synchronized void unregistertonotifications ( ) throws jmsexception { if ( eventsession == null ) { return ; } if ( _logger . isloggable ( level . fine ) ) { _logger . log ( level . fine , tostring2 ( ) + _str ) ; } try { eventsession . close ( ) ; } catch ( ioexception e ) { if ( _logger . isloggable ( level . fine ) ) { _logger . log ( level . fine , tostring2 ( ) + _str + e ) ; } jmsexception e1 = new jmsexception ( _str ) ; e1 . setlinkedexception ( e ) ; throw e1 ; } catch ( unknownleaseexception e ) { if ( _logger . isloggable ( level . fine ) ) { _logger . log ( level . fine , tostring2 ( ) + _str + e ) ; } jmsexception e1 = new jmsexception ( _str ) ; e1 . setlinkedexception ( e ) ; throw e1 ; } catch ( exception e ) { if ( _logger . isloggable ( level . fine ) ) { _logger . log ( level . fine , tostring2 ( ) + _str + e ) ; } jmsexception e1 = new jmsexception ( _str ) ; e1 . setlinkedexception ( e ) ; throw e1 ; } finally { eventsession = null ; } }	closes the notifydelegator so no more notifications will arrive .
public double [ ] [ ] predictintervals ( instance instance , double confidencelevel ) throws exception { univariateintervalestimator e = ( univariateintervalestimator ) getdensityestimator ( instance , _bool ) ; return e . predictintervals ( confidencelevel ) ; }	returns an n * 2 array , where n is the number of prediction intervals.
public static void registerupdatelistener ( updatelistener l ) { updatelisteners . add ( l ) ; }	register a callback for when the player service changes its state and the ui needs to be updated.
private int offset ( int i , int j ) { if ( i < _num || j > max || i > j ) { throw new runtimeexception ( string . format ( _str , i , j , max ) ) ; } return i * ( max + _num ) - i * ( i + _num ) / _num + j ; }	this computes the offset into the one - dimensional array for a given span .
protected double norm ( double x , int i ) { if ( double . isnan ( m_min [ i ] ) || utils . eq ( m_max [ i ] , m_min [ i ] ) ) { return _num ; } else { return ( x - m_min [ i ] ) / ( m_max [ i ] - m_min [ i ] ) ; } }	normalizes a given value of a numeric attribute .
public builder ( string host , int port ) { this . host = host ; this . port = integer . tostring ( port ) ; }	instantiates a new builder .
public static boolean haslowercasechar ( string s ) { char [ ] chars = s . tochararray ( ) ; for ( char c : chars ) { if ( character . islowercase ( c ) ) { return _bool ; } } return _bool ; }	does the string have a lowercase character ?.
public value [ ] readrow ( value [ ] row ) throws sqlexception { statementbuilder buff = new statementbuilder ( _str ) ; appendcolumnlist ( buff , _bool ) ; buff . append ( _str ) ; appendtablename ( buff ) ; appendkeycondition ( buff ) ; preparedstatement prep = conn . preparestatement ( buff . tostring ( ) ) ; setkey ( prep , _num , row ) ; resultset rs = prep . executequery ( ) ; if ( ! rs . next ( ) ) { throw dbexception . get ( errorcode . no_data_available ) ; } value [ ] newrow = new value [ columncount ] ; for ( int i = _num ; i < columncount ; i ++ ) { int type = result . getcolumntype ( i ) ; newrow [ i ] = datatype . readvalue ( conn . getsession ( ) , rs , i + _num , type ) ; } return newrow ; }	re - reads a row from the database and updates the values in the array .
private static double chicell ( double freq , double expected , boolean yates ) { if ( utils . smoreq ( expected , _num ) ) { return _num ; } double diff = math . abs ( freq - expected ) ; if ( yates ) { diff -= _num ; if ( diff < _num ) { diff = _num ; } } return ( diff * diff / expected ) ; }	computes chi - value for one cell in a contingency table .
@ override public void initiaize ( file file , int entrycount ) throws carbonsortkeyandgroupbyexception { try { stream = new dataoutputstream ( new bufferedoutputstream ( new fileoutputstream ( file ) , writebuffersize ) ) ; stream . writeint ( entrycount ) ; } catch ( filenotfoundexception e1 ) { throw new carbonsortkeyandgroupbyexception ( e1 ) ; } catch ( ioexception e ) { throw new carbonsortkeyandgroupbyexception ( e ) ; } }	below method will be used to initialize the stream and write the entry count.
public void testnumberofneighbors ( ) { int i ; int instindex ; instances neighbors ; try { m_nearestneighboursearch . setinstances ( m_instances ) ; } catch ( exception e ) { fail ( _str + e ) ; } for ( i = _num ; i <= m_numneighbors ; i ++ ) { instindex = m_random . nextint ( m_instances . numinstances ( ) ) ; try { neighbors = m_nearestneighboursearch . knearestneighbours ( m_instances . instance ( instindex ) , i ) ; assertequals ( _str , i , neighbors . numinstances ( ) ) ; } catch ( exception e ) { fail ( _str + i + _str + ( instindex + _num ) + _str + e ) ; } } }	tests whether the number of instances returned by the algorithms is the same as was requested.
public static long parselong ( string text ) { try { return long . parselong ( text ) ; } catch ( numberformatexception e ) { return _num ; } }	parse long value from a string , if null or exception , return 0.
public immutablelist < messagetype > filterdocumentingmessages ( protocontainerelement element ) { immutablelist . builder < messagetype > builder = immutablelist . builder ( ) ; for ( messagetype msg : element . getmessages ( ) ) { if ( ! msg . ismapentry ( ) ) { builder . add ( msg ) ; } } return builder . build ( ) ; }	return the list of messages within element which should be documented in ruby .
public static boolean isnull ( final object model , final string columnname ) { if ( model == null ) { return _bool ; } else if ( gridtabwrapper . ishandled ( model ) ) { return gridtabwrapper . isnull ( model , columnname ) ; } else if ( powrapper . ishandled ( model ) ) { return powrapper . isnull ( model , columnname ) ; } else { throw new adempiereexception ( _str + model + _str + model . getclass ( ) + _str ) ; } }	check if given columnname ' s value is null.
private static int parsenumber ( charsequence offsetid , int pos , boolean precededbycolon ) { if ( precededbycolon && offsetid . charat ( pos - _num ) != _str ) { throw new datetimeexception ( _str + offsetid ) ; } char ch1 = offsetid . charat ( pos ) ; char ch2 = offsetid . charat ( pos + _num ) ; if ( ch1 < _str || ch1 > _str || ch2 < _str || ch2 > _str ) { throw new datetimeexception ( _str + offsetid ) ; } return ( ch1 - _num ) * _num + ( ch2 - _num ) ; }	parse a two digit zero - prefixed number .
public static int compare ( char [ ] str1 , char [ ] str2 ) { int len1 = str1 . length ; int len2 = str2 . length ; int n = math . min ( len1 , len2 ) ; int i = _num ; while ( n -- != _num ) { char c1 = str1 [ i ] ; char c2 = str2 [ i ++ ] ; if ( c1 != c2 ) { return c1 - c2 ; } } return len1 - len2 ; }	compares two strings lexicographically.
public static boolean equals ( float [ ] field1 , float [ ] field2 ) { if ( field1 == null || field1 . length == _num ) { return field2 == null || field2 . length == _num ; } else { return arrays . equals ( field1 , field2 ) ; } }	checks repeated float field equality ; null - value and 0 - length fields are considered equal .
public void test_sessionprotection ( ) { final properties p = getproperties ( ) ; p . setproperty ( abstracttransactionservice . options . min_release_age , _str ) ; final journal store = getjournal ( p ) ; try { final irwstrategy bs = ( irwstrategy ) store . getbufferstrategy ( ) ; final byte [ ] buf = new byte [ _num ] ; r . nextbytes ( buf ) ; final bytebuffer bb = bytebuffer . wrap ( buf ) ; final long faddr = store . write ( bb ) ; final irawtx tx = bs . newtx ( ) ; bytebuffer rdbuf = store . read ( faddr ) ; bb . position ( _num ) ; assertequals ( bb , rdbuf ) ; store . delete ( faddr ) ; bb . position ( _num ) ; rdbuf = store . read ( faddr ) ; assertequals ( bb , rdbuf ) ; tx . close ( ) ; store . commit ( ) ; } finally { store . destroy ( ) ; } }	tests whether tasks are able to access and modify data safely by emulating transactions by calling activatetx and deactivatetx directly .
public static int hash ( int hash , float item ) { return hash * prime + float . floattointbits ( item ) ; }	add a float value to a given hash .
public static boolean iskeypairentry ( string alias , keystore keystore ) throws keystoreexception { return keystore . iskeyentry ( alias ) && keystore . getcertificatechain ( alias ) != null && keystore . getcertificatechain ( alias ) . length != _num ; }	is the named entry in the keystore a key pair entry ?.
public searchsourcebuilder fielddatafield ( string name ) { if ( fielddatafields == null ) { fielddatafields = new arraylist < > ( ) ; } fielddatafields . add ( name ) ; return this ; }	adds a field to load from the field data cache and return as part of the search request .
public boolean hasmore ( ) { return numleft . compareto ( biginteger . zero ) == _num ; }	returns true if there are more combinations left .
public void addlistener ( final filealterationlistener listener ) { if ( listener != null ) { listeners . add ( listener ) ; } }	add a file system listener .
public void removeclaimsfor ( int row , int col ) { effectclaims . remove ( getkeyforcoords ( row , col ) ) ; }	just removes all claims for the given row and column.
protected void loadframeinformation ( rpftocentry rpftocentry ) { try { if ( binfile == null && atocfilepath != null ) { binfile = new binarybufferedfile ( atocfilepath ) ; binfile . byteorder ( atocbyteorder ) ; readframeinformation ( binfile , rpftocentry ) ; binfile . close ( ) ; binfile = null ; } } catch ( ioexception ioe ) { debug . error ( _str + ioe ) ; } catch ( formatexception fe ) { debug . error ( _str + fe ) ; } }	should be called by the rpfframecachehandler before any frame files are loaded from a rpftocentry.
public static void debug ( final string message ) { debuglogger . accept ( message ) ; }	logs a message to the configured debug logger .
public void removenotificationlistener ( notificationlistener listener ) throws listenernotfoundexception { broadcaster . removenotificationlistener ( listener ) ; }	mbeannotification support - delegates to broadcaster .
public void test_passwordcallback ( ) { string prompt = _str ; try { passwordcallback pc = new passwordcallback ( prompt , _bool ) ; assertnotnull ( _str , pc ) ; assertequals ( prompt , pc . getprompt ( ) ) ; assertequals ( _bool , pc . isechoon ( ) ) ; } catch ( exception e ) { fail ( _str + e ) ; } try { passwordcallback pc = new passwordcallback ( prompt , _bool ) ; assertnotnull ( _str , pc ) ; assertequals ( prompt , pc . getprompt ( ) ) ; assertequals ( _bool , pc . isechoon ( ) ) ; } catch ( exception e ) { fail ( _str + e ) ; } try { passwordcallback pc = new passwordcallback ( null , _bool ) ; fail ( _str ) ; } catch ( illegalargumentexception npe ) { } try { passwordcallback pc = new passwordcallback ( _str , _bool ) ; fail ( _str ) ; } catch ( illegalargumentexception npe ) { } }	javax . security . auth . callback . passwordcallback # passwordcallback ( string prompt , boolean echoon ) javax . security . auth . callback . passwordcallback # getprompt ( ) javax . security . auth . callback . passwordcallback # isechoon ( ).
static string valuetostring ( object value ) { if ( value == null || value . equals ( null ) ) { return _str ; } if ( value instanceof string ) { return ( string ) value ; } if ( value instanceof float || value instanceof double || value instanceof byte || value instanceof short || value instanceof integer || value instanceof long ) { return numbertostring ( value ) ; } if ( value instanceof boolean || value instanceof map || value instanceof list ) { return value . tostring ( ) ; } return quote ( value . tostring ( ) ) ; }	make a json text of an object value.
public void test_htree_math_addressbits_8 ( ) { final int addressbits = _num ; final stringbuilder sb = new stringbuilder ( ) ; dohtreemath ( addressbits , sb ) ; if ( log . isinfoenabled ( ) ) log . info ( sb . tostring ( ) ) ; }	exercise the hash tree math for an 8 - bit address space .
protected final int isleft ( double [ ] a , double [ ] b , double [ ] o ) { final double cross = getrx ( a , o ) * getry ( b , o ) - getry ( a , o ) * getrx ( b , o ) ; if ( cross == _num ) { final double dista = math . abs ( getrx ( a , o ) ) + math . abs ( getry ( a , o ) ) ; final double distb = math . abs ( getrx ( b , o ) ) + math . abs ( getry ( b , o ) ) ; return double . compare ( dista , distb ) ; } return double . compare ( cross , _num ) ; }	test whether a point is left of the other wrt.
public socket createsocket ( ) throws ioexception { socket s = new socket ( ) ; s . bind ( new inetsocketaddress ( bindaddress , _num ) ) ; return s ; }	the same as the similarly named javax.
private conversation starttojoinmeeting ( ) { uri meetinguri = null ; conversation conversation = null ; try { meetinguri = new uri ( getstring ( r . string . meeting_url ) ) ; } catch ( urisyntaxexception e ) { e . printstacktrace ( ) ; } try { mapplication = application . getinstance ( this ) ; conversation = mapplication . joinmeetinganonymously ( getstring ( r . string . userdisplayname ) , meetinguri ) ; } catch ( sfbexception e ) { e . printstacktrace ( ) ; } return conversation ; }	connect to an existing skype for business meeting with the uri you get from a server - side ucwa - based web service .
public static boolean iscolumnhidden ( class < ? > controllerclass , string columnname ) { return hiddencolumnscache . contains ( getcolumnhash ( controllerclass , columnname ) ) ; }	returns if the cache has any knowledge if the column is hidden .
protected void removeallcurrentdownloads ( ) { log . i ( log_tag , _str ) ; arraylist < long > ids = new arraylist < long > ( ) ; cursor cursor = mdownloadmanager . query ( new query ( ) ) ; try { if ( cursor . movetofirst ( ) ) { do { int index = cursor . getcolumnindex ( downloadmanager . column_id ) ; long downloadid = cursor . getlong ( index ) ; ids . add ( downloadid ) ; } while ( cursor . movetonext ( ) ) ; } } finally { cursor . close ( ) ; } for ( long id : ids ) { mdownloadmanager . remove ( id ) ; } cursor = mdownloadmanager . query ( new query ( ) ) ; try { assertequals ( _num , cursor . getcount ( ) ) ; } finally { cursor . close ( ) ; } }	helper to remove all downloads that are registered with the dl manager.
public boolean visiblefrom ( ctclass clazz ) { int mod = getmodifiers ( ) ; if ( modifier . ispublic ( mod ) ) return _bool ; else if ( modifier . isprivate ( mod ) ) return clazz == declaringclass ; else { string declname = declaringclass . getpackagename ( ) ; string fromname = clazz . getpackagename ( ) ; boolean visible ; if ( declname == null ) visible = fromname == null ; else visible = declname . equals ( fromname ) ; if ( ! visible && modifier . isprotected ( mod ) ) return clazz . subclassof ( declaringclass ) ; return visible ; } }	returns true if this member is accessible from the given class .
void copyto ( intset target ) { if ( target . elements . length < size ) { target . elements = arrays . copyof ( elements , elements . length ) ; } else { system . arraycopy ( elements , _num , target . elements , _num , size ) ; } target . size = size ; }	copies the contents of this set to the target set .
public void testshiftleft2 ( ) { byte abytes [ ] = { _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num } ; int asign = _num ; int number = - _num ; byte rbytes [ ] = { _num , _num , _num , - _num , - _num , - _num , _num , - _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger result = anumber . shiftleft ( number ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	shiftleft ( int n ) , n < 0.
private static int resolvemethodrefoffset ( constantpool constantpool , class < ? > lambdatype ) { int offset = method_ref_offset ; if ( offset == - _num ) { int constantpoolsize = constantpool . getsize ( ) ; for ( int i = _num ; i < constantpoolsize ; i ++ ) { try { constantpool . getmemberrefinfoat ( constantpoolsize - i ) ; offset = i ; break ; } catch ( illegalargumentexception ignore ) { } } method_ref_offset = offset ; } if ( offset >= _num ) return offset ; else throw new methodrefoffsetresolutionfailed ( ) ; }	resolves method ref offset .
protected void write ( dataoutputstream stream ) throws exception { stream . writeint ( data . length ) ; stream . write ( data , _num , data . length ) ; }	saving method . ( see nbt_tag ).
public boolean equalheaders ( instances dataset ) { return ( equalheadersmsg ( dataset ) == null ) ; }	checks if two headers are equivalent .
public void storeserializable ( final string key , final ibean bean ) { m_map . put ( key , bean ) ; }	adds a new serializable to the cache.
public void initialize ( context context , timepickercontroller controller , boolean hasinnercircle , boolean disappearsout , int selectiondegrees , boolean isinnercircle ) { if ( misinitialized ) { log . e ( tag , _str ) ; return ; } resources res = context . getresources ( ) ; int accentcolor = controller . getaccentcolor ( ) ; mpaint . setcolor ( accentcolor ) ; mpaint . setantialias ( _bool ) ; mselectionalpha = controller . isthemedark ( ) ? selected_alpha_theme_dark : selected_alpha ; mis24hourmode = controller . is24hourmode ( ) ; if ( mis24hourmode ) { mcircleradiusmultiplier = float . parsefloat ( res . getstring ( r . string . mdtp_circle_radius_multiplier_24hourmode ) ) ; } else { mcircleradiusmultiplier = float . parsefloat ( res . getstring ( r . string . mdtp_circle_radius_multiplier ) ) ; mampmcircleradiusmultiplier = float . parsefloat ( res . getstring ( r . string . mdtp_ampm_circle_radius_multiplier ) ) ; } mhasinnercircle = hasinnercircle ; if ( hasinnercircle ) { minnernumbersradiusmultiplier = float . parsefloat ( res . getstring ( r . string . mdtp_numbers_radius_multiplier_inner ) ) ; mouternumbersradiusmultiplier = float . parsefloat ( res . getstring ( r . string . mdtp_numbers_radius_multiplier_outer ) ) ; } else { mnumbersradiusmultiplier = float . parsefloat ( res . getstring ( r . string . mdtp_numbers_radius_multiplier_normal ) ) ; } mselectionradiusmultiplier = float . parsefloat ( res . getstring ( r . string . mdtp_selection_radius_multiplier ) ) ; manimationradiusmultiplier = _num ; mtransitionmidradiusmultiplier = _num + ( _num * ( disappearsout ? - _num : _num ) ) ; mtransitionendradiusmultiplier = _num + ( _num * ( disappearsout ? _num : - _num ) ) ; minvalidateupdatelistener = new invalidateupdatelistener ( ) ; setselection ( selectiondegrees , isinnercircle , _bool ) ; misinitialized = _bool ; }	initialize this selector with the state of the picker .
private void computelabelsfromdepths ( ) { for ( iterator it = edgelist . iterator ( ) ; it . hasnext ( ) ; ) { edge e = ( edge ) it . next ( ) ; label lbl = e . getlabel ( ) ; depth depth = e . getdepth ( ) ; if ( ! depth . isnull ( ) ) { depth . normalize ( ) ; for ( int i = _num ; i < _num ; i ++ ) { if ( ! lbl . isnull ( i ) && lbl . isarea ( ) && ! depth . isnull ( i ) ) { if ( depth . getdelta ( i ) == _num ) { lbl . toline ( i ) ; } else { assert . istrue ( ! depth . isnull ( i , position . left ) , _str ) ; lbl . setlocation ( i , position . left , depth . getlocation ( i , position . left ) ) ; assert . istrue ( ! depth . isnull ( i , position . right ) , _str ) ; lbl . setlocation ( i , position . right , depth . getlocation ( i , position . right ) ) ; } } } } } }	update the labels for edges according to their depths.
public e putifabsent ( int key , e value ) { if ( value == null ) { throw new nullpointerexception ( ) ; } e prev ; if ( array . length <= key ) { array = arrays . copyof ( array , key * _num / _num + _num ) ; prev = null ; } else { prev = ( e ) array [ key ] ; } if ( prev == null ) { array [ key ] = value ; size ++ ; } return prev ; }	if the specified key is not already associated with a value associates it with the given value and returns null , else returns the current value .
public void reset ( ) { _unmanagedvolumeuristoprocessiterator = _unmanagedvolumeuristoprocess . iterator ( ) ; _currentunmanagedvolumeuri = null ; }	resets the unmanagedvolume iterator and sets the current unmanagedvolume back to null.
public static int copy ( reader in , writer out ) throws ioexception { assert . notnull ( in , _str ) ; assert . notnull ( out , _str ) ; try { int bytecount = _num ; char [ ] buffer = new char [ buffer_size ] ; int bytesread = - _num ; while ( ( bytesread = in . read ( buffer ) ) != - _num ) { out . write ( buffer , _num , bytesread ) ; bytecount += bytesread ; } out . flush ( ) ; return bytecount ; } finally { try { in . close ( ) ; } catch ( ioexception ex ) { } try { out . close ( ) ; } catch ( ioexception ex ) { } } }	copy the contents of the given reader to the given writer.
public static bidimap loadmapping ( file inputfile ) throws ioexception { objectinputstream inputstream = new objectinputstream ( new fileinputstream ( inputfile ) ) ; try { return ( bidimap ) inputstream . readobject ( ) ; } catch ( classnotfoundexception e ) { throw new ioexception ( e ) ; } finally { ioutils . closequietly ( inputstream ) ; } }	loads a serialized bidimap from file.
public static string convertbracketsfromptbformat ( string sentence ) { sentence = sentence . replaceall ( _str , _str ) ; sentence = sentence . replaceall ( _str , _str ) ; sentence = sentence . replaceall ( _str , _str ) ; sentence = sentence . replaceall ( _str , _str ) ; sentence = sentence . replaceall ( _str , _str ) ; sentence = sentence . replaceall ( _str , _str ) ; return sentence ; }	convert brackets from the penn treebank format ( which uses strings like - lrb - , - rrb - , etc to denote ' ( ' , ' ) ' , etc.
public void addpropertychangelistener ( propertychangelistener listener ) { propertysupport . addpropertychangelistener ( listener ) ; }	property change support for xbuilder.
public void updatetrackpoint ( point p ) { int newlocx = math . min ( p . x , this . anchor . x ) ; int newlocy = math . min ( p . y , this . anchor . y ) ; int deltax = math . abs ( p . x - this . anchor . x ) ; int deltay = math . abs ( p . y - this . anchor . y ) ; setlocation ( newlocx , newlocy ) ; setsize ( deltax , deltay ) ; }	updates the track point for the rubber band so that it extends from the initial location point to the point specified as the argument .
public static date parsedatestring ( string datestring , java . util . locale locale , string datesyntax ) { if ( debug . messageenabled ( ) ) { debug . message ( _str ) ; debug . message ( _str + datestring ) ; debug . message ( _str + datesyntax ) ; debug . message ( _str + locale . tostring ( ) ) ; } if ( ( datestring == null ) || ( datestring . length ( ) < _num ) || ( datesyntax == null ) || ( datesyntax . length ( ) < _num ) ) { return null ; } simpledateformat sdf = new simpledateformat ( datesyntax ) ; sdf . setlenient ( _bool ) ; parseposition pos = new parseposition ( _num ) ; date date = sdf . parse ( datestring , pos ) ; if ( date == null ) { debug . warning ( _str ) ; } return date ; }	gets date object from date string with specified locale .
public void preparepidpvs ( int obdservice , pvlist pvlist ) { resetfixedpid ( ) ; hashmap < string , ecudatapv > newlist = new hashmap < string , ecudatapv > ( ) ; for ( integer currpid : pidsupported ) { vector < ecudataitem > items = dataitems . getpiddataitems ( obdservice , currpid ) ; if ( items == null ) { log . warn ( string . format ( _str , currpid ) ) ; conversion [ ] dummycnvs = { ecuconversions . dfltcnv , ecuconversions . dfltcnv } ; ecudataitem newitem = new ecudataitem ( currpid , _num , _num , _num , _num , _num , dummycnvs , _str , null , null , string . format ( _str , currpid ) ) ; dataitems . appenditemtoservice ( obdservice , newitem ) ; items = dataitems . getpiddataitems ( obdservice , currpid ) ; } for ( ecudataitem pidpv : items ) { if ( pidpv != null ) { newlist . put ( pidpv . tostring ( ) , pidpv . pv ) ; } } } pvlist . putall ( newlist , pvchangeevent . pv_added , _bool ) ; }	prepare process variables for each pid.
public void registerextension ( string namespace ) { if ( namespaceindex ( namespace , m_extensions ) == - _num ) { int predef = namespaceindex ( namespace , m_predefextensions ) ; if ( predef != - _num ) m_extensions . add ( m_predefextensions . get ( predef ) ) ; else if ( ! ( m_unregisteredextensions . contains ( namespace ) ) ) m_unregisteredextensions . add ( namespace ) ; } }	if necessary , register the extension namespace found compiling a function or creating an extension element.
static boolean equals ( object o1 , object o2 ) { return o1 == o2 || ( o1 != null && o2 != null && o1 . equals ( o2 ) ) ; }	safe equals . null = = null , but null never equals anything else .
public static movavgmodel minimize ( movavgmodel model , evictingqueue < double > train , double [ ] test ) { double temp = _num ; double mintemp = _num ; int iterations = _num ; double alpha = _num ; movavgmodel bestmodel = model ; movavgmodel oldmodel = model ; double oldcost = cost ( model , train , test ) ; double bestcost = oldcost ; while ( temp > mintemp ) { for ( int i = _num ; i < iterations ; i ++ ) { movavgmodel newmodel = oldmodel . neighboringmodel ( ) ; double newcost = cost ( newmodel , train , test ) ; double ap = acceptanceprobability ( oldcost , newcost , temp ) ; if ( ap > math . random ( ) ) { oldmodel = newmodel ; oldcost = newcost ; if ( newcost < bestcost ) { bestcost = newcost ; bestmodel = newmodel ; } } } temp *= alpha ; } return bestmodel ; }	runs the simulated annealing algorithm and produces a model with new coefficients that , theoretically fit the data better and generalizes to future forecasts without overfitting .
private iproject [ ] asprojects ( projectsetserializationcontext context , string [ ] referencestrings , map < iproject , loadinfo > infomap ) throws svnexception { collection < iproject > result = new arraylist < iproject > ( ) ; for ( string referencestring : referencestrings ) { stringtokenizer tokenizer = new stringtokenizer ( referencestring , _str ) ; string version = tokenizer . nexttoken ( ) ; if ( ! version . equals ( _str ) ) { continue ; } loadinfo info = new loadinfo ( context , tokenizer ) ; iproject proj = info . getproject ( ) ; result . add ( proj ) ; infomap . put ( proj , info ) ; } return ( iproject [ ] ) result . toarray ( new iproject [ result . size ( ) ] ) ; }	translate the reference strings into projects to be loaded and build a mapping of project to project load information .
@ override public synchronized void connectionnotification ( string eventname , object source ) { super . connectionnotification ( eventname , source ) ; if ( connectionallowed ( eventname ) ) { if ( eventname . equals ( _str ) ) { m_dataprovider = _bool ; m_trainingprovider = _bool ; m_testprovider = _bool ; } else if ( eventname . equals ( _str ) ) { m_dataprovider = _bool ; m_trainingprovider = _bool ; m_testprovider = _bool ; } else if ( eventname . equals ( _str ) ) { m_dataprovider = _bool ; m_trainingprovider = _bool ; m_testprovider = _bool ; } } }	notify this object that it has been registered as a listener with a source with respect to the supplied event name.
public info createinfo ( string value ) { informationfield infoimpl = new informationfield ( ) ; try { infoimpl . setvalue ( value ) ; } catch ( sdpexception s ) { s . printstacktrace ( ) ; } return infoimpl ; }	returns info object with the specified value .
public static int findwordstart ( string line , int pos , string nowordsep ) { char ch = line . charat ( pos - _num ) ; if ( nowordsep == null ) nowordsep = _str ; boolean selectnoletter = ( ! character . isletterordigit ( ch ) && nowordsep . indexof ( ch ) == - _num ) ; int wordstart = _num ; for ( int i = pos - _num ; i >= _num ; i -- ) { ch = line . charat ( i ) ; if ( selectnoletter ^ ( ! character . isletterordigit ( ch ) && nowordsep . indexof ( ch ) == - _num ) ) { wordstart = i + _num ; break ; } } return wordstart ; }	locates the start of the word at the specified position .
public void insert ( double x1 , double x2 , object item ) { super . insert ( new interval ( math . min ( x1 , x2 ) , math . max ( x1 , x2 ) ) , item ) ; }	inserts an item having the given bounds into the tree .
public mapmaker initialcapacity ( int initialcapacity ) { builder . initialcapacity ( initialcapacity ) ; return this ; }	sets a custom initial capacity ( defaults to 16 ).
public final static byte [ ] extractchallengefromtype2message ( byte [ ] msg ) { byte [ ] challenge = new byte [ _num ] ; system . arraycopy ( msg , _num , challenge , _num , _num ) ; return challenge ; }	extracts the ntlm challenge from the type 2 message as an 8 byte array .
public static string tostring ( localdate data , string modelo ) { return data == null ? _str : data . format ( formatter ( modelo ) ) ; }	converte localdatetime para string indicando o formato da tostring.
public derrordetail ( jframe parent , dialog . modalitytype modality , throwable error ) { super ( parent , modality ) ; this . error = error ; initcomponents ( ) ; }	creates new derrordetail dialog where the parent is a frame .
public static < destin > list < destin > copypropertiestonewcollections ( class < destin > destclass , collection < ? > srccollection ) { list < destin > destinlist = new arraylist < destin > ( ) ; if ( srccollection == null ) { return destinlist ; } for ( object src : srccollection ) { destinlist . add ( copypropertiestonewobject ( destclass , src ) ) ; } return destinlist ; }	convert a collection of beans of type a , to a collection of beans of type b , by copying a ' s properties into b ' s.
protected resource updateresourceversion ( resource resource , bigdecimal oldversion , bigdecimal newversion ) { preconditions . checknotnull ( resource ) ; preconditions . checknotnull ( oldversion ) ; preconditions . checknotnull ( newversion ) ; if ( ! oldversion . equals ( newversion ) ) { try { file oldeml = datadir . resourceemlfile ( resource . getshortname ( ) , oldversion ) ; file neweml = datadir . resourceemlfile ( resource . getshortname ( ) , newversion ) ; if ( oldeml . exists ( ) && ! neweml . exists ( ) ) { files . move ( oldeml , neweml ) ; } file oldrtf = datadir . resourcertffile ( resource . getshortname ( ) , oldversion ) ; file newrtf = datadir . resourcertffile ( resource . getshortname ( ) , newversion ) ; if ( oldrtf . exists ( ) && ! newrtf . exists ( ) ) { files . move ( oldrtf , newrtf ) ; } file olddwca = datadir . resourcedwcafile ( resource . getshortname ( ) , oldversion ) ; file newdwca = datadir . resourcedwcafile ( resource . getshortname ( ) , newversion ) ; if ( olddwca . exists ( ) && ! newdwca . exists ( ) ) { files . move ( olddwca , newdwca ) ; } resource . setemlversion ( newversion ) ; } catch ( ioexception e ) { log . error ( _str + resource . getshortname ( ) , e ) ; throw new invalidconfigexception ( type . config_write , _str + resource . getshortname ( ) + _str + e . getmessage ( ) ) ; } } return resource ; }	update a resource ' s version , and rename its eml , rtf , and dwca versioned files to have the new version also .
public static injectorimpl current ( classloader loader ) { if ( loader instanceof dynamicclassloader ) { return _localmanager . getlevel ( loader ) ; } else { softreference < injectorimpl > injectref = _loadermanagermap . get ( loader ) ; if ( injectref != null ) { return injectref . get ( ) ; } else { return null ; } } }	returns the current inject manager .
@ zapapiignore public boolean isconfirmremovedomainalwaysinscope ( ) { return this . confirmremovedomainalwaysinscope ; }	tells whether or not the remotion of a " domain always in scope " needs confirmation .
protected void write ( dataoutputstream stream ) throws exception { stream . writeint ( data . length ) ; for ( int i = _num ; i < data . length ; i ++ ) stream . writeint ( data [ i ] ) ; }	saving method . ( see nbt_tag ).
private cluster < dendrogrammodel > makecluster ( dbidref lead , double depth , dbids members ) { final string name ; if ( members . size ( ) == _num ) { name = _str + dbidutil . tostring ( lead ) + _str + depth ; } else if ( ! double . isnan ( depth ) && double . isinfinite ( depth ) || ( members . size ( ) == _num && members . contains ( lead ) ) ) { name = _str + dbidutil . tostring ( lead ) ; } else if ( ! double . isnan ( depth ) ) { name = _str + dbidutil . tostring ( lead ) + _str + depth ; } else { name = _str + dbidutil . tostring ( lead ) ; } cluster < dendrogrammodel > cluster = new cluster < > ( name , members , new dendrogrammodel ( depth ) ) ; return cluster ; }	make the cluster for the given object.
public void write ( command command , int value , int index , bytebuffer buffer ) throws usbexception { if ( mdevicehandle != null ) { int transferred = libusb . controltransfer ( mdevicehandle , usb_request_out , command . getvalue ( ) , ( short ) value , ( short ) index , buffer , usb_timeout_ms ) ; if ( transferred < _num ) { throw new libusbexception ( _str , transferred ) ; } else if ( transferred != buffer . capacity ( ) ) { throw new libusbexception ( _str + transferred + _str + buffer . capacity ( ) + _str , transferred ) ; } } else { throw new libusbexception ( _str , libusb . error_no_device ) ; } }	writes the buffer contents to the device.
private static void removeinstrumentationfromorig ( ir ir , hashmap < basicblock , basicblock > origtodupmap ) { for ( basicblock origblock : origtodupmap . keyset ( ) ) { for ( enumeration < instruction > ie = origblock . forwardinstrenumerator ( ) ; ie . hasmoreelements ( ) ; ) { instruction i = ie . nextelement ( ) ; if ( isinstrumentationinstruction ( i ) || ( isyieldpoint ( i ) && ir . options . adaptive_remove_yp_from_checking ) ) { if ( debug ) vm . syswrite ( _str + i + _str ) ; i . remove ( ) ; } } } }	remove instrumentation from the original version of all duplicated basic blocks.
public serverconfigxml ( string xml ) throws exception { document doc = xmlutils . getxmldocument ( new bytearrayinputstream ( xml . getbytes ( _str ) ) ) ; node root = xmlutils . getrootnode ( doc , dsconfigmgr . root ) ; defaultservergroup = new servergroup ( xmlutils . getnamedchildnode ( root , dsconfigmgr . servergroup , dsconfigmgr . name , dsconfigmgr . default ) ) ; smsservergroup = new servergroup ( xmlutils . getnamedchildnode ( root , dsconfigmgr . servergroup , dsconfigmgr . name , _str ) ) ; }	creates an object representing server configuration xml .
@ override public double diffusiondiscretization ( final stochasticprocess1d sp , final double t0 , final double x0 , final double dt ) { return sp . diffusion ( t0 , x0 ) * math . sqrt ( dt ) ; }	returns an approximation of the diffusion defined as < p > \ sigma ( t_0 , x_0 ) \ sqrt \ delta t } }.
public void notifylistener ( omgraphic graphic , omaction action ) { if ( requestor != null ) { if ( debug ) { debug . output ( _str ) ; } requestor . drawingcomplete ( graphic , action ) ; } if ( canvas != null ) { canvas . repaint ( ) ; } }	notify the listener of an action to a graphic .
public classrunner ( class < ? > theclass , string [ ] commandargs ) throws exception { setdaemon ( _bool ) ; class < ? > [ ] argtemplate = { string [ ] . class } ; m_commandargs = commandargs ; m_mainmethod = theclass . getmethod ( _str , argtemplate ) ; if ( ( ( m_mainmethod . getmodifiers ( ) & modifier . static ) == _num ) || ( m_mainmethod . getmodifiers ( ) & modifier . public ) == _num ) { throw new nosuchmethodexception ( _str + theclass . getname ( ) + _str ) ; } }	sets up the class runner thread .
public int waitforcondition ( channel c , long timeout , int condition_mask ) { long end_time = _num ; boolean end_time_set = _bool ; synchronized ( c ) { while ( _bool ) { int current_cond = _num ; int stdoutavail = c . stdoutwritepos - c . stdoutreadpos ; int stderravail = c . stderrwritepos - c . stderrreadpos ; if ( stdoutavail > _num ) current_cond = current_cond | channelcondition . stdout_data ; if ( stderravail > _num ) current_cond = current_cond | channelcondition . stderr_data ; if ( c . eof ) current_cond = current_cond | channelcondition . eof ; if ( c . getexitstatus ( ) != null ) current_cond = current_cond | channelcondition . exit_status ; if ( c . getexitsignal ( ) != null ) current_cond = current_cond | channelcondition . exit_signal ; if ( c . state == channel . state_closed ) return current_cond | channelcondition . closed | channelcondition . eof ; if ( ( current_cond & condition_mask ) != _num ) return current_cond ; if ( timeout > _num ) { if ( ! end_time_set ) { end_time = system . currenttimemillis ( ) + timeout ; end_time_set = _bool ; } else { timeout = end_time - system . currenttimemillis ( ) ; if ( timeout <= _num ) return current_cond | channelcondition . timeout ; } } try { if ( timeout > _num ) c . wait ( timeout ) ; else c . wait ( ) ; } catch ( interruptedexception e ) { } } } }	wait until for a condition .
@ override public void storestate ( ) { partialbufferhelper . storestate ( ) ; for ( evolutionaryprocessdelegate evolutionaryprocessdelegate : evolutionaryprocessdelegates ) { evolutionaryprocessdelegate . storestate ( ) ; } if ( usescalefactors || useautoscaling ) { scalebufferhelper . storestate ( ) ; system . arraycopy ( scalebufferindices , _num , storedscalebufferindices , _num , scalebufferindices . length ) ; } flip = _bool ; }	stores the additional state other than model components.
public static boolean iscorefilesaver ( string classname ) { boolean result ; string [ ] classnames ; classnames = core_file_savers . split ( _str ) ; result = ( arrays . binarysearch ( classnames , classname ) >= _num ) ; return result ; }	checks whether the given class is one of the hardcoded core file savers .
private void assertconstructorthrowsexception ( soapbinding binding , securitytokenserviceconfig config ) { boolean exceptionthrown = _bool ; try { new securitytokenserviceimpl ( binding , config ) ; } catch ( illegalargumentexception e ) { exceptionthrown = _bool ; } finally { asserttrue ( exceptionthrown ) ; } }	asserts that an exception is thrown if one of the arguments is null.
public updatelogentry addfile ( jsonvalue file ) { files . add ( file ) ; return this ; }	add a file to this entry ' s list of update files.
private < t extends vcardproperty > map < string , list < t > > orderpropertiesbygroup ( list < t > properties ) { map < string , list < t > > groupedproperties = new hashmap < > ( ) ; for ( t property : properties ) { string group = property . getgroup ( ) ; if ( isempty ( group ) ) { continue ; } list < t > grouppropertieslist = groupedproperties . get ( group ) ; if ( grouppropertieslist == null ) { grouppropertieslist = new arraylist < t > ( ) ; groupedproperties . put ( group , grouppropertieslist ) ; } grouppropertieslist . add ( property ) ; } return groupedproperties ; }	groups properties by their group name .
protected void openfile ( file f ) { if ( f == null ) { return ; } if ( ! f . exists ( ) ) { debug . output ( _str + getname ( ) + _str ) ; return ; } e00file = f ; if ( gui != null ) { label . settext ( e00file . getname ( ) ) ; } }	description of the method.
public void addtext ( string text ) { if ( null != text ) { texts . add ( new textproperties ( text , currentsize , currentcolor ) ) ; reclamptext ( ) ; invalidate ( ) ; } }	adds a text to be drawn over the image , above existing texts .
public void received ( bytebuffer buffer ) { hasreceiveddata = _bool ; lastreceivetime = system . currenttimemillis ( ) ; }	method called when data is received .
public void resume ( ) { if ( ! ispaused ) return ; setanimationinterval ( oldanimationinterval_ ) ; lastupdate_ = system . currenttimemillis ( ) ; ispaused = _bool ; dt = _num ; }	resumes the paused ccscene the scheduled timers will be activated again . the " delta time " will be 0 ( as if the game wasn ' t paused ).
private static string stripleadingslash ( string name ) { if ( name . length ( ) < _num || name . charat ( _num ) != _str ) { return name ; } return name . substring ( _num ) ; }	removes a leading slash.
protected boolean removeifpresentestimate ( estimatemapkey key , loadestimatetask task ) { return estimatemap . remove ( key , task ) ; }	remove the task from the estimate map at the given key .
public void testdomainnotautomaticallyprefixedwithdot ( ) { httpcookie cookie = new httpcookie ( _str , _str ) ; cookie . setdomain ( _str ) ; assertequals ( _str , cookie . getdomain ( ) ) ; }	from the spec , " if an explicitly specified value does not start with a dot , the user agent supplies a leading dot.
public builder deletenickname ( ) { deletefields . add ( _str ) ; return this ; }	deletes the nickname of a existing user.
public boolean checkpassword ( string password ) { try { randomaccessfile raf = new randomaccessfile ( slockpasswordfilename , _str ) ; final byte [ ] stored = new byte [ ( int ) raf . length ( ) ] ; int got = raf . read ( stored , _num , stored . length ) ; raf . close ( ) ; if ( got <= _num ) { return _bool ; } return arrays . equals ( stored , passwordtohash ( password ) ) ; } catch ( filenotfoundexception fnfe ) { return _bool ; } catch ( ioexception ioe ) { return _bool ; } }	check to see if a password matches the saved password.
public static double stringtodouble ( string val ) { return double . valueof ( trim ( val ) ) ; }	converts string to double .
public static final void writedoublearrayxml ( double [ ] val , string name , xmlserializer out ) throws xmlpullparserexception , ioexception { if ( val == null ) { out . starttag ( null , _str ) ; out . endtag ( null , _str ) ; return ; } out . starttag ( null , _str ) ; if ( name != null ) { out . attribute ( null , _str , name ) ; } final int n = val . length ; out . attribute ( null , _str , integer . tostring ( n ) ) ; for ( int i = _num ; i < n ; i ++ ) { out . starttag ( null , _str ) ; out . attribute ( null , _str , double . tostring ( val [ i ] ) ) ; out . endtag ( null , _str ) ; } out . endtag ( null , _str ) ; }	flatten a double [ ] into an xmlserializer.
public boolean tostarting ( ) { lifecyclestate state ; synchronized ( this ) { state = _state ; if ( state . isafterstarting ( ) && ! state . isstopped ( ) ) { return _bool ; } _state = starting ; _lastchangetime = currenttime . currenttime ( ) ; if ( _log != null && _log . isloggable ( _level ) && _log . isloggable ( level . finer ) ) { _log . finer ( _str + _name ) ; } } notifylisteners ( state , starting ) ; return _bool ; }	changes to the starting state .
public void stop ( ) { isalive = _bool ; statssnapshot . stop ( ) ; holdingbuffer . clear ( ) ; ioutils . closequietly ( this ) ; }	the method is called in the deactivate method of the operator.
static void checkidentifier ( final string name , final string msg ) { checkidentifier ( name , _num , - _num , msg ) ; }	checks that the given string is a valid java identifier .
public static double [ ] createrandomgridvalues ( int width , int height , double min , double max , int numiterations , double smoothness ) { int numvalues = width * height ; double [ ] values = new double [ numvalues ] ; for ( int i = _num ; i < numiterations ; i ++ ) { double offset = _num - ( i / ( double ) numiterations ) ; int x1 = ( int ) math . round ( math . random ( ) * ( width - _num ) ) ; int x2 = ( int ) math . round ( math . random ( ) * ( width - _num ) ) ; int y1 = ( int ) math . round ( math . random ( ) * ( height - _num ) ) ; int y2 = ( int ) math . round ( math . random ( ) * ( height - _num ) ) ; int dx1 = x2 - x1 ; int dy1 = y2 - y1 ; for ( int y = _num ; y < height ; y ++ ) { int dy2 = y - y1 ; for ( int x = _num ; x < width ; x ++ ) { int dx2 = x - x1 ; if ( ( dx2 * dy1 - dx1 * dy2 ) >= _num ) values [ x + y * width ] += offset ; } } } smoothvalues ( width , height , values , smoothness ) ; scalevalues ( values , numvalues , min , max ) ; return values ; }	creates a 2d grid of random values with an optional smoothing parameter.
public zipentry ( zipentry e ) { objects . requirenonnull ( e , _str ) ; name = e . name ; xdostime = e . xdostime ; mtime = e . mtime ; atime = e . atime ; ctime = e . ctime ; crc = e . crc ; size = e . size ; csize = e . csize ; method = e . method ; flag = e . flag ; extra = e . extra ; comment = e . comment ; }	creates a new zip entry with fields taken from the specified zip entry .
public void removealltestingcallbacks ( ) { testingcallbacks . clear ( ) ; }	removes all board testing callbacks .
public static bigdecimal bytetobigdecimal ( byte [ ] raw ) { int scale = ( raw [ _num ] & _num ) ; byte [ ] unscale = new byte [ raw . length - _num ] ; system . arraycopy ( raw , _num , unscale , _num , unscale . length ) ; biginteger sig = new biginteger ( unscale ) ; return new bigdecimal ( sig , scale ) ; }	this method will convert a byte value back to big decimal value.
public string outputfiletiptext ( ) { return _str ; }	returns the tip text for this property.
public void sendmessage ( sipmessage sipmessage , inetaddress receiveraddress , int receiverport ) throws ioexception { long time = system . currenttimemillis ( ) ; sendmessage ( sipmessage , receiveraddress , receiverport , sipmessage instanceof siprequest ) ; logmessage ( sipmessage , receiveraddress , receiverport , time ) ; }	send a message given sip message .
protected void onservicestopped ( ) { unregisterreceiver ( mbluetoothstatebroadcastreceiver ) ; for ( final blemanager < blemanagercallbacks > manager : mblemanagers . values ( ) ) { manager . close ( ) ; manager . log ( logcontract . log . level . info , _str ) ; } mblemanagers . clear ( ) ; mmanageddevices . clear ( ) ; mblemanagers = null ; mmanageddevices = null ; }	called when the service has been stopped .
public bytestring snapshot ( ) { if ( size > integer . max_value ) { throw new illegalargumentexception ( _str + size ) ; } return snapshot ( ( int ) size ) ; }	returns an immutable copy of this buffer as a byte string .
public boolean removemiddleoflastthree ( ) { if ( ! hasthree ( ) ) return _bool ; int pos = points . size ( ) ; points . remove ( pos - _num ) ; return _bool ; }	returns middle of last three.
private void deletecurrentfile ( file filetodelete ) throws ioexception { logger . info ( _str , filetodelete ) ; if ( ! filetodelete . exists ( ) ) { logger . warn ( _str , filetodelete ) ; return ; } if ( ! filetodelete . delete ( ) ) { throw new ioexception ( _str + filetodelete ) ; } deletemetafile ( ) ; }	delete the given spooled file.
public void testconstructorbyteszero ( ) { byte abytes [ ] = { _num , _num , _num , - _num , + _num , _num , - _num } ; byte rbytes [ ] = { _num } ; biginteger anumber = new biginteger ( abytes ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = anumber . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , anumber . signum ( ) ) ; }	create a zero number from an array of zero bytes .
public bookmarkmanager ( final com . google . security . zynamics . binnavi . models . bookmarks . memory . bookmarkmanager bookmarkmanager ) { m_bookmarkmanager = bookmarkmanager ; for ( final cbookmark bookmark : m_bookmarkmanager ) { m_bookmarks . add ( new bookmark ( bookmark ) ) ; } m_bookmarkmanager . addlistener ( m_internalbookmarklistener ) ; }	creates a new api bookmark manager object .
public void store ( outputstream out , string header ) throws ioexception { printwriter writer = new printwriter ( new outputstreamwriter ( out , _str ) ) ; string line ; string key ; stringbuffer s = new stringbuffer ( ) ; for ( int i = _num ; i < linedata . size ( ) ; i ++ ) { line = ( string ) linedata . get ( i ) ; key = ( string ) keydata . get ( i ) ; if ( key . length ( ) > _num ) { formatforoutput ( key , s , _bool ) ; s . append ( _str ) ; formatforoutput ( ( string ) get ( key ) , s , _bool ) ; writer . println ( s ) ; } else { writer . println ( line ) ; } } writer . flush ( ) ; }	write the properties to the specified outputstream.
public static void appendmdstring ( final string alignedquery , final string alignedreference , final stringbuilder buffer ) { buffer . append ( _str ) ; int countmatches = _num ; boolean indeletion = _bool ; for ( int i = _num ; i < alignedquery . length ( ) ; i ++ ) { final char qchar = alignedquery . charat ( i ) ; final char rchar = alignedreference . charat ( i ) ; if ( qchar == _str ) { if ( countmatches > _num ) { buffer . append ( countmatches ) ; countmatches = _num ; } if ( ! indeletion ) { buffer . append ( _str ) ; indeletion = _bool ; } buffer . append ( rchar ) ; } else if ( rchar != _str ) { if ( qchar == rchar ) { countmatches ++ ; } else { if ( indeletion ) buffer . append ( _str ) ; if ( countmatches > _num ) { buffer . append ( countmatches ) ; countmatches = _num ; } buffer . append ( rchar ) ; } if ( indeletion ) indeletion = _bool ; } } if ( countmatches > _num ) buffer . append ( countmatches ) ; else if ( indeletion ) buffer . append ( _num ) ; }	append the md string.
static int measurechildforcells ( view child , int cellsize , int cellsremaining , int parentheightmeasurespec , int parentheightpadding ) { final layoutparams lp = ( layoutparams ) child . getlayoutparams ( ) ; final int childheightsize = measurespec . getsize ( parentheightmeasurespec ) - parentheightpadding ; final int childheightmode = measurespec . getmode ( parentheightmeasurespec ) ; final int childheightspec = measurespec . makemeasurespec ( childheightsize , childheightmode ) ; final actionmenuitemview itemview = child instanceof actionmenuitemview ? ( actionmenuitemview ) child : null ; final boolean hastext = itemview != null && itemview . hastext ( ) ; int cellsused = _num ; if ( cellsremaining > _num && ( ! hastext || cellsremaining >= _num ) ) { final int childwidthspec = measurespec . makemeasurespec ( cellsize * cellsremaining , measurespec . at_most ) ; child . measure ( childwidthspec , childheightspec ) ; final int measuredwidth = child . getmeasuredwidth ( ) ; cellsused = measuredwidth / cellsize ; if ( measuredwidth % cellsize != _num ) cellsused ++ ; if ( hastext && cellsused < _num ) cellsused = _num ; } final boolean expandable = ! lp . isoverflowbutton && hastext ; lp . expandable = expandable ; lp . cellsused = cellsused ; final int targetwidth = cellsused * cellsize ; child . measure ( measurespec . makemeasurespec ( targetwidth , measurespec . exactly ) , childheightspec ) ; return cellsused ; }	measure a child view to fit within cell - based formatting.
public componenttime ( string strdate ) { timestamp = componenttime . stringtostamp ( strdate ) ; }	construct from a date in this format : yyyy - mm - dd ' t ' hh : mi : ss . ffffff.
public void addextension ( string extension ) { if ( filters == null ) { filters = new hashtable < string , examplefilefilter > ( _num ) ; } if ( extension != null ) { filters . put ( extension . tolowercase ( ) , this ) ; } fulldescription = null ; }	adds a filetype " dot " extension to filter against.
private void logthreadstatistics ( ) { int threadcount = threadmxbean . getthreadcount ( ) ; long totalstartedthreads = threadmxbean . gettotalstartedthreadcount ( ) ; stringbuilder sb = new stringbuilder ( ) ; sb . append ( _str ) ; sb . append ( threadcount ) ; sb . append ( _str ) ; sb . append ( totalstartedthreads ) ; log . info ( sb . tostring ( ) ) ; }	log the thread statistics .
private list findstabbedsegments ( coordinate stabbingrayleftpt ) { list stabbedsegments = new arraylist ( ) ; for ( iterator i = subgraphs . iterator ( ) ; i . hasnext ( ) ; ) { buffersubgraph bsg = ( buffersubgraph ) i . next ( ) ; envelope env = bsg . getenvelope ( ) ; if ( stabbingrayleftpt . y < env . getminy ( ) || stabbingrayleftpt . y > env . getmaxy ( ) ) continue ; findstabbedsegments ( stabbingrayleftpt , bsg . getdirectededges ( ) , stabbedsegments ) ; } return stabbedsegments ; }	finds all non - horizontal segments intersecting the stabbing line.
public void discardundo ( ) { for ( undoable undoable : mundoactions ) { undoable . discard ( ) ; } mundoactions . clear ( ) ; mundopopup . dismiss ( ) ; }	discard all stored undos and hide the undo popup dialog .
public void updatelocations ( iterator iiter ) { if ( containerlist != null ) containerlist . clear ( ) ; containerlist = new arraylist ( ) ; while ( iiter . hasnext ( ) ) containerlist . add ( ( location ) iiter . next ( ) ) ; addbehaviour ( new migratebehaviour ( ) ) ; }	updates the location list and schedules migrations .
public ovector ( int c ) { vector = new object [ math . max ( defaultcapacity , c ) ] ; }	constructs a new vector with the specified capacity .
protected static void notifyacichangeevent ( string dn , int eventtype ) { if ( debug . messageenabled ( ) ) { debug . message ( _str + dn ) ; } synchronized ( objimpllisteners ) { if ( objimpllisteners . isempty ( ) ) { return ; } amevent dpevent = new amevent ( new amevent ( dn ) , eventtype ) ; switch ( eventtype ) { case amevent . object_changed : case amevent . object_renamed : if ( debug . messageenabled ( ) ) { debug . message ( _str + _str ) ; } notifyaffecteddns ( dn , dpevent ) ; break ; case amevent . object_removed : if ( debug . messageenabled ( ) ) { debug . message ( _str + _str ) ; } set objimplset = ( set ) objimpllisteners . get ( dn . tolowercase ( ) ) ; if ( objimplset == null ) { return ; } iterator itr = objimplset . iterator ( ) ; while ( itr . hasnext ( ) ) { amobjectimpl dpobjimpl = ( amobjectimpl ) itr . next ( ) ; dpobjimpl . sendevents ( dpevent ) ; } break ; default : ; } } }	notifies aci change . this method will be called by the < code > amidrepolistener to send notifications to all interested amobjectimp ' s whenever an aci change occurs .
vertex ( final vector2d location ) { this . location = location ; this . incoming = null ; this . outgoing = null ; this . lines = new arraylist < line > ( ) ; }	build a non - processed vertex not owned by any node yet .
@ override public completablefuture < optional < t > > findfirst ( ) { return completablefuture . supplyasync ( null , exec ) ; }	perform an asynchronous findany operation.
public static boolean isvalidianaencoding ( string ianaencoding ) { if ( ianaencoding != null ) { int length = ianaencoding . length ( ) ; if ( length > _num ) { char c = ianaencoding . charat ( _num ) ; if ( ( c >= _str && c <= _str ) || ( c >= _str && c <= _str ) ) { for ( int i = _num ; i < length ; i ++ ) { c = ianaencoding . charat ( i ) ; if ( ( c < _str || c > _str ) && ( c < _str || c > _str ) && ( c < _str || c > _str ) && c != _str && c != _str && c != _str ) { return _bool ; } } return _bool ; } } } return _bool ; }	returns true if the encoding name is a valid iana encoding.
private void appendstarttag ( string qname , attributes attributes ) { charbuf . append ( _str + qname ) ; for ( map . entry < string , string > entry : newnamespacemappings . entryset ( ) ) { string prefix = entry . getkey ( ) ; string namespace = entry . getvalue ( ) ; appendnamespacedecl ( charbuf , prefix , namespace ) ; } int attcount = attributes . getlength ( ) ; for ( int i = _num ; i < attcount ; i ++ ) { appendattribute ( charbuf , attributes . getqname ( i ) , attributes . getvalue ( i ) ) ; } charbuf . append ( _str ) ; int colonidx = qname . indexof ( _str ) ; string prefix = ( colonidx > _num ) ? qname . substring ( _num , colonidx ) : _str ; if ( ! xmlliteralprefixes . contains ( prefix ) && ! unknownprefixesinxmlliteral . contains ( prefix ) ) { unknownprefixesinxmlliteral . add ( prefix ) ; } }	appends a start tag to charbuf.
public void removequeryexecutelistener ( queryexecutelistener l ) { m_queryexecutelisteners . remove ( l ) ; }	removes the given listener from the list of listeners .
public static boolean isvalidimportstring ( string s ) { if ( s . equals ( _str ) ) return _bool ; boolean valid = _bool ; string t = s ; int index = t . indexof ( _str ) ; if ( index != - _num ) { if ( index == t . length ( ) - _num ) { if ( index - _num >= _num ) { valid = t . charat ( index - _num ) == _str ; t = t . substring ( _num , t . length ( ) - _num ) ; } } else return _bool ; } if ( valid ) { string [ ] javaids = t . split ( _str , t . length ( ) + _num ) ; for ( string javaid : javaids ) valid &= sourceversion . isidentifier ( javaid ) ; } return valid ; }	return true if the argument string is a valid import - style string specifying claimed annotations ; return false otherwise .
public static graphrequest newuploadvideorequest ( accesstoken accesstoken , file file , callback callback ) throws filenotfoundexception { parcelfiledescriptor descriptor = parcelfiledescriptor . open ( file , parcelfiledescriptor . mode_read_only ) ; bundle parameters = new bundle ( _num ) ; parameters . putparcelable ( file . getname ( ) , descriptor ) ; return new graphrequest ( accesstoken , my_videos , parameters , httpmethod . post , callback ) ; }	creates a new request configured to upload a video to the user ' s default video album.
public static long murmur ( final bitvector bv , final long prefixlength , final long [ ] state , final long lcp ) { final int startstateword = ( int ) ( math . min ( lcp , prefixlength ) / long . size ) ; long h = state [ startstateword ] , k ; long from = startstateword * long . size ; while ( prefixlength - from >= long . size ) { k = bv . getlong ( from , from += long . size ) ; k *= m ; k ^= k > > > r ; k *= m ; h ^= k ; h *= m ; } if ( prefixlength > from ) { k = bv . getlong ( from , prefixlength ) ; k *= m ; k ^= k > > > r ; k *= m ; h ^= k ; h *= m ; } k = prefixlength ; k *= m ; k ^= k > > > r ; k *= m ; h ^= k ; h *= m ; return h ; }	constant - time murmurhash 64 - bit hashing reusing precomputed state partially .
public static range iteratetofindzbounds ( xyzdataset dataset , list visibleserieskeys , range xrange , boolean includeinterval ) { paramchecks . nullnotpermitted ( dataset , _str ) ; paramchecks . nullnotpermitted ( visibleserieskeys , _str ) ; paramchecks . nullnotpermitted ( xrange , _str ) ; double minimum = double . positive_infinity ; double maximum = double . negative_infinity ; iterator iterator = visibleserieskeys . iterator ( ) ; while ( iterator . hasnext ( ) ) { comparable serieskey = ( comparable ) iterator . next ( ) ; int series = dataset . indexof ( serieskey ) ; int itemcount = dataset . getitemcount ( series ) ; for ( int item = _num ; item < itemcount ; item ++ ) { double x = dataset . getxvalue ( series , item ) ; double z = dataset . getzvalue ( series , item ) ; if ( xrange . contains ( x ) ) { if ( ! double . isnan ( z ) ) { minimum = math . min ( minimum , z ) ; maximum = math . max ( maximum , z ) ; } } } } if ( minimum == double . positive_infinity ) { return null ; } else { return new range ( minimum , maximum ) ; } }	returns the range of z - values in the specified dataset for the data items belonging to the visible series and with x - values in the given range .
public classentry ( dynamicclassloader loader , string name , path sourcepath , path classpath , codesource codesource ) { _loader = loader ; _name = name ; _classpath = classpath ; setdependpath ( classpath ) ; if ( sourcepath != null && ! sourcepath . equals ( classpath ) ) { _sourcepath = sourcepath ; _sourcelastmodified = sourcepath . getlastmodified ( ) ; _sourcelength = sourcepath . length ( ) ; } _codesource = codesource ; }	create a loaded class entry.
public rankingimagelistprovider inweeks ( int weeks ) { mtime = integer . tostring ( weeks ) + _str ; return this ; }	sets time limit for a ranking list in weeks ( the default value is all time ) .
public abstract optional < boolean > wanted ( ) ;	is the blank line wanted ?.
private void rewritesavefile ( iterable < trackpoint > data ) { fileoutputstream fileoutput = null ; dataoutputstream out = null ; try { fileoutput = ctx . openfileoutput ( savefile , context . mode_private ) ; out = new dataoutputstream ( new bufferedoutputstream ( fileoutput ) ) ; out . writeint ( trackpoint . format_version ) ; for ( trackpoint point : data ) { point . tostream ( out ) ; } } catch ( exception e ) { marksavingbroken ( _str , e ) ; } finally { savinghelper . close ( out ) ; } }	saves the given data to disk , overwriting anything already saved.
public node add ( node n ) { nodemap . put ( n . getcoordinate ( ) , n ) ; return n ; }	adds a node to the map , replacing any that is already at that location .
public static void printstutteringstate ( int num ) { mp . printstate ( ec . tlc_state_print3 , new string [ ] { string . valueof ( num + _num ) } , ( tlcstate ) null , num + _num ) ; }	reports that the state with a given number is stuttering.
public boolean isusecompression ( ) { return this . usecompression ; }	get method for configuration item - usecompression.
private void logmissingregions ( partitionedregion region ) { string namesofmissing = _str ; if ( ! missingchildren . isempty ( ) ) { namesofmissing = string . join ( _str , missingchildren ) ; } string multiplechildren ; string singular = _str ; string plural = _str ; multiplechildren = missingchildren . size ( ) > _num ? plural : singular ; namesofmissing = string . join ( _str , multiplechildren , namesofmissing ) ; logger . warn ( localizedmessage . create ( localizedstrings . colocationlogger_persistent_data_recovery_of_region_prevented_by_offline_colocated_children , new object [ ] { region . getfullpath ( ) , namesofmissing } ) ) ; }	write the a logger warning for a pr that has colocated child regions that are missing .
public static string [ ] split ( string text , pattern pattern ) { if ( text . length ( ) == _num ) { return empty_string_array ; } else { return pattern . split ( text , - _num ) ; } }	splits a string on a pattern.
static void createpasswordfiles ( string basedir , string keystorepwd , string keypassword ) throws ioexception { writecontent ( basedir + _str , keypassword ) ; writecontent ( basedir + _str , keystorepwd ) ; copyctxfile ( _str , _str , basedir ) ; copyctxfile ( _str , _str , basedir ) ; amkeyprovider jceks = new amkeyprovider ( _bool , basedir + _str , _str , _str , _str ) ; amkeyprovider jks = new amkeyprovider ( _bool , basedir + _str , _str , _str , _str ) ; jceks . setkey ( keystorepwd , keypassword ) ; jks . setkey ( keystorepwd , keypassword ) ; try { jceks . store ( ) ; jks . store ( ) ; } catch ( certificateexception | nosuchalgorithmexception | keystoreexception e ) { throw new ioexception ( _str , e ) ; } }	create the storepass and keypass files.
static optimizedclassdescriptor classdescriptor ( concurrentmap < class , optimizedclassdescriptor > clsmap , int id , classloader ldr , marshallercontext ctx , optimizedmarshalleridmapper mapper ) throws ioexception , classnotfoundexception { class cls ; try { cls = ctx . getclass ( id , ldr ) ; } catch ( ignitecheckedexception e ) { throw new ioexception ( _str + id , e ) ; } optimizedclassdescriptor desc = clsmap . get ( cls ) ; if ( desc == null ) { optimizedclassdescriptor old = clsmap . putifabsent ( cls , desc = new optimizedclassdescriptor ( cls , resolvetypeid ( cls . getname ( ) , mapper ) , clsmap , ctx , mapper ) ) ; if ( old != null ) desc = old ; } return desc ; }	gets descriptor for provided id .
private boolean openforwriting ( ) { file root = new file ( properties . ctg_dir ) ; if ( root . exists ( ) ) { if ( root . isdirectory ( ) ) { if ( ! root . canwrite ( ) ) { logger . error ( _str + root . getabsolutepath ( ) ) ; return _bool ; } } else { boolean deleted = root . delete ( ) ; if ( ! deleted ) { logger . error ( _str + root + _str ) ; return _bool ; } else { if ( ! root . mkdirs ( ) ) { logger . error ( _str + root . getabsolutepath ( ) ) ; return _bool ; } } } } else { if ( ! root . mkdirs ( ) ) { logger . error ( _str + root . getabsolutepath ( ) ) ; return _bool ; } } file testsfolder = getbesttestfolder ( ) ; if ( ! testsfolder . exists ( ) ) { if ( ! testsfolder . mkdirs ( ) ) { logger . error ( _str + testsfolder . getabsolutepath ( ) ) ; return _bool ; } } file seedfolder = getseedinfolder ( ) ; if ( ! seedfolder . exists ( ) ) { if ( ! seedfolder . mkdirs ( ) ) { logger . error ( _str + seedfolder . getabsolutepath ( ) ) ; } } return _bool ; }	open connection to storage manager note : here we just make sure we can write on disk.
public static byte [ ] hexstringtobyte ( string hexstring ) { if ( ( hexstring . length ( ) & _num ) == _num ) hexstring = _str + hexstring ; byte [ ] tmp = new byte [ hexstring . length ( ) / _num ] ; for ( int i = _num ; i < tmp . length ; ++ i ) { string hexbyte = hexstring . substring ( i * _num , i * _num + _num ) ; tmp [ i ] = ( byte ) integer . parseint ( hexbyte , _num ) ; } return tmp ; }	converts a hex string to byte [ ].
private void addfield ( mappedclass clazz , string [ ] parts ) { string original = _str ; string newname = _str ; string desc = _str ; if ( parts . length == _num ) { original = parts [ _num ] ; newname = parts [ _num ] ; desc = parts [ _num ] ; } else if ( parts . length == _num ) { original = parts [ _num ] ; newname = parts [ _num ] ; desc = parts [ _num ] ; } else { return ; } if ( desc . contains ( _str ) ) { desc = desc . replace ( _str , _str ) ; } mappedmember mm = new mappedmember ( clazz , findfield ( clazz . getnode ( ) , original , desc ) , - _num , desc , original ) ; mm . setnewname ( newname ) ; clazz . addfield ( mm ) ; }	add a field to the given class .
public static void loadregistrations ( datainput in ) throws ioexception { while ( in . readint ( ) != _num ) { class dsclass = null ; boolean skip = _bool ; try { dsclass = dataserializer . readclass ( in ) ; } catch ( classnotfoundexception ex ) { skip = _bool ; } if ( skip ) { continue ; } register ( dsclass , _bool ) ; } }	read the data from in and register it with this class .
public static http2headers tonettyhttp2 ( httpheaders inputheaders ) { final http2headers outputheaders = new defaulthttp2headers ( _bool , inputheaders . size ( ) ) ; outputheaders . set ( inputheaders ) ; outputheaders . remove ( httpheadernames . connection ) ; outputheaders . remove ( httpheadernames . transfer_encoding ) ; outputheaders . remove ( httpheadernames . trailer ) ; return outputheaders ; }	converts the specified armeria http / 2 headers into netty http / 2 headers .
public void error ( level level , string messageid , string data [ ] , object session , map props ) throws logexception { if ( iserrorloggable ( level ) ) { ssotoken authssotoken = ( ssotoken ) accesscontroller . doprivileged ( admintokenaction . getinstance ( ) ) ; logrecord lr = getlogrecord ( messageid , data , session , props , authssotoken ) ; if ( lr != null ) { errorlogger . log ( lr , authssotoken ) ; } } }	writes error occurred in a component into a log .
protected population loadpopulationfile ( final string filename , scenario sc ) { population plans = sc . getpopulation ( ) ; log . info ( _str ) ; matsimreader plansreader = new populationreader ( sc ) ; plansreader . readfile ( filename ) ; log . info ( _str ) ; return plans ; }	load the plan file with the given path .
private void loadtheme ( ) { if ( uimanager . getlookandfeel ( ) instanceof metallookandfeel ) { } else { primary1 . setenabled ( _bool ) ; primary2 . setenabled ( _bool ) ; primary3 . setenabled ( _bool ) ; secondary1 . setenabled ( _bool ) ; secondary2 . setenabled ( _bool ) ; secondary3 . setenabled ( _bool ) ; } }	load theme from current setting ( if metallookandfeel ).
public static boolean computeinstancesstartedstatewithacceptederrorrate ( amazonec2asyncclient client , verificationhost host , list < string > instanceids , int errorrate ) throws throwable { if ( instanceids . size ( ) == _num ) { return _bool ; } arraylist < boolean > provisioningflags = new arraylist < boolean > ( instanceids . size ( ) ) ; for ( int i = _num ; i < instanceids . size ( ) ; i ++ ) { provisioningflags . add ( i , boolean . false ) ; } checkinstancesstarted ( host , client , instanceids , provisioningflags ) ; int totalcount = instanceids . size ( ) ; int passcount = ( int ) math . ceil ( ( ( ( _num - errorrate ) / hundered ) * totalcount ) ) ; int poweredoncount = _num ; for ( boolean startedflag : provisioningflags ) { if ( startedflag ) { poweredoncount ++ ; } } return ( poweredoncount >= passcount ) ; }	method that polls to see if the instances provisioned have turned on.
private static string computesdkregistrantskeyv3 ( ) { return sdk_registrants_key_prefix + _str + getinstallationid ( ) ; }	version 1 key was just " sdkregistrants ".
public final void testaddallhelpertextcolorsfromcollection ( ) { int helpertextcolor1 = color . black ; int helpertextcolor2 = color . gray ; collection < integer > helpertextcolors1 = new linkedlist < > ( ) ; helpertextcolors1 . add ( helpertextcolor1 ) ; helpertextcolors1 . add ( helpertextcolor2 ) ; passwordedittext passwordedittext = new passwordedittext ( getcontext ( ) ) ; passwordedittext . addallhelpertextcolors ( helpertextcolors1 ) ; passwordedittext . addallhelpertextcolors ( helpertextcolors1 ) ; collection < integer > helpertextcolors2 = passwordedittext . gethelpertextcolors ( ) ; assertequals ( helpertextcolors1 . size ( ) , helpertextcolors2 . size ( ) ) ; iterator < integer > iterator = helpertextcolors2 . iterator ( ) ; assertequals ( helpertextcolor1 , ( int ) iterator . next ( ) ) ; assertequals ( helpertextcolor2 , ( int ) iterator . next ( ) ) ; }	tests the functionality of the method , which allows to add all helper text colors , which are contained by a collection .
public boolean isincircleoftrust ( string realm , string name , string protocoltype , string entityid ) { set tproviders = new hashset ( ) ; try { circleoftrustdescriptor cotd = getcircleoftrust ( realm , name ) ; set pset = cotd . gettrustedproviders ( protocoltype ) ; return ( ( pset != null ) && ! pset . isempty ( ) && pset . contains ( entityid ) ) ; } catch ( exception me ) { debug . error ( _str , me ) ; string [ ] data = { me . getmessage ( ) , name , entityid , realm } ; logutil . error ( level . info , logutil . config_error_retreive_cot , data ) ; } return _bool ; }	determines if entity is in the circle of trust under the realm .
protected void firefatalconnectionerror ( sqlexception ex ) { connectionevent evt = new connectionevent ( this , ex ) ; for ( connectioneventlistener listener : connectioneventlisteners ) { listener . connectionerroroccurred ( evt ) ; } }	helper method to fire the connectionerroroccurred event.
public static typestree createdefaultdndtypestree ( final typemanager typemanager ) { preconditions . checknotnull ( typemanager , _str ) ; final typestree typestree = createdraganddroptypestree ( typemanager ) ; typestree . setmodel ( typestreemodel . createdefaultmodel ( typemanager ) ) ; return typestree ; }	creates a types tree control , sets the model that includes all existing types and installs drag ' n ' drop support .
public static boolean somepermissionpermanentlydenied ( @ nonnull object object , @ nonnull list < string > deniedpermissions ) { for ( string deniedpermission : deniedpermissions ) { if ( permissionpermanentlydenied ( object , deniedpermission ) ) { return _bool ; } } return _bool ; }	check if at least one permission in the list of denied permissions has been permanently denied ( user clicked " never ask again " ) .
public void encode ( outputstream out ) throws ioexception { if ( version == v1 ) { return ; } deroutputstream tmp = new deroutputstream ( ) ; tmp . putinteger ( version ) ; deroutputstream seq = new deroutputstream ( ) ; seq . write ( dervalue . createtag ( dervalue . tag_context , _bool , ( byte ) _num ) , tmp ) ; out . write ( seq . tobytearray ( ) ) ; }	encode the certificateversion period in der form to the stream .
public static string emptytonull ( string s ) { if ( s == null ) return null ; return s . length ( ) == _num ? null : s ; }	converts a 0 - length string to null , leaves the string as is otherwise .
public sentencesplitter ( string file ) { super ( file ) ; sentences = new linkedlist < > ( ) ; }	sentence splits the given file .
public static int size ( boolean [ ] array ) { return array . getlength ( array ) ; }	allows arrays to behave similar to collections .
private static string [ ] makelines ( int n ) { string [ ] ret = new string [ n ] ; for ( int i = _num ; i < n ; ++ i ) { ret [ i ] = _str + i ; } return ret ; }	helper to make an array of compressible strings.
@ sideeffectfree protected void printbound ( final string keyword , final annotatedtypemirror field , final set < annotatedtypemirror > visiting , final stringbuilder sb ) { if ( ! currentprintverbosegenerics && ( field == null || field . getkind ( ) == typekind . null ) ) { return ; } sb . append ( _str ) ; sb . append ( keyword ) ; sb . append ( _str ) ; if ( field == null ) { sb . append ( _str ) ; } else if ( field . getkind ( ) != typekind . null ) { sb . append ( visit ( field , visiting ) ) ; } else { sb . append ( annoformatter . formatannotationstring ( field . getannotations ( ) , currentprintinvisiblesetting ) ) ; sb . append ( _str ) ; } }	print to sb keyword followed by field . null types are substituted with their annotations followed by " void ".
protected void copyrequestheaders ( httpservletrequest servletrequest , httprequest proxyrequest ) { enumeration enumerationofheadernames = servletrequest . getheadernames ( ) ; while ( enumerationofheadernames . hasmoreelements ( ) ) { string headername = ( string ) enumerationofheadernames . nextelement ( ) ; if ( headername . equalsignorecase ( httpheaders . content_length ) ) continue ; if ( hopbyhopheaders . containsheader ( headername ) ) continue ; enumeration headers = servletrequest . getheaders ( headername ) ; while ( headers . hasmoreelements ( ) ) { string headervalue = ( string ) headers . nextelement ( ) ; if ( headername . equalsignorecase ( httpheaders . host ) ) { httphost host = gettargethost ( servletrequest ) ; headervalue = host . gethostname ( ) ; if ( host . getport ( ) != - _num ) headervalue += _str + host . getport ( ) ; } else if ( headername . equalsignorecase ( org . apache . http . cookie . sm . cookie ) ) { headervalue = getrealcookie ( headervalue ) ; } proxyrequest . addheader ( headername , headervalue ) ; } } }	copy request headers from the servlet client to the proxy request .
public static string computeshannonweaver ( viewerbase viewer , progresslistener progresslistener ) throws ioexception , canceledexception { if ( viewer instanceof mainviewer ) return tostring ( computeshannonweaver ( ( mainviewer ) viewer , progresslistener ) ) ; else if ( viewer instanceof classificationviewer ) return tostring ( computeshannonweaver ( ( classificationviewer ) viewer , progresslistener ) ) ; else return null ; }	compute the shannon - weaver diversity index in bits.
void addaccesskey ( int accesskey , component cmp , boolean override ) { if ( ( override ) && ( accesskeys . contains ( cmp ) ) ) { hashtable newaccesskeys = new hashtable ( ) ; for ( enumeration e = accesskeys . keys ( ) ; e . hasmoreelements ( ) ; ) { object key = e . nextelement ( ) ; component c = ( component ) accesskeys . get ( key ) ; if ( c != cmp ) { newaccesskeys . put ( key , c ) ; } } accesskeys = newaccesskeys ; } accesskeys . put ( new integer ( accesskey ) , cmp ) ; form form = getcomponentform ( ) ; if ( form != null ) { form . addkeylistener ( accesskey , this ) ; } }	adds the given access key to make it focus on the given component.
public static synchronized void addresource ( recoverableresource resource ) throws illegalstateexception { purgeresources ( ) ; if ( resources_ . containskey ( resource . getname ( ) ) ) throw new illegalstateexception ( _str + _str + resource . getname ( ) ) ; resource . setrecoveryservice ( recoveryservice_ ) ; resources_ . put ( resource . getname ( ) , resource ) ; resourcelist_ . add ( resource ) ; }	add a resource to the transaction manager domain.
public boolean removeselection ( int position ) { return mselectedpositions . remove ( position ) ; }	removes the selection status for the given position without notifying the change .
private static element adddomiciliofromdocumentaddress ( element persona , document docaddress ) { element rootaddres = docaddress . getrootelement ( ) ; list listadrres = rootaddres . selectnodes ( xpath_domicilio_root ) ; if ( ( listadrres != null ) && ( listadrres . size ( ) > _num ) ) { for ( iterator it = listadrres . iterator ( ) ; it . hasnext ( ) ; ) { element direccion = ( element ) it . next ( ) ; if ( direccion != null ) { persona = getpreferredadrres ( persona , direccion , listadrres . size ( ) ) ; } } } return persona ; }	66575267 - gabriel saiz.
public ldifentrywriter ( final list < string > ldiflines ) { super ( ldiflines ) ; }	creates a new ldif entry writer which will append lines of ldif to the provided list .
public static void sleep ( ) { try { thread . sleep ( long . max_value ) ; } catch ( interruptedexception iex ) { } }	puts a thread to sleep forever .
public list < a > reverse ( ) { if ( isempty ( ) || tail . isempty ( ) ) return this ; list < a > rev = nil ( ) ; for ( list < a > l = this ; l . nonempty ( ) ; l = l . tail ) rev = new list < a > ( l . head , rev ) ; return rev ; }	reverse list . if the list is empty or a singleton , then the same list is returned . otherwise a new list is formed .
public int loadstate ( ) { try { waitformigrationtofinish ( ) ; } catch ( interruptedexception e ) { } catch ( executionexception e ) { } mcancelnormaltabloads = _bool ; mcancelincognitotabloads = _bool ; mnormaltabsrestored = new sparseintarray ( ) ; mincognitotabsrestored = new sparseintarray ( ) ; int nextid = _num ; try { nextid = loadstateinternal ( ) ; } catch ( exception e ) { log . d ( tag , _str + e . tostring ( ) , e ) ; } cleanuppersistentdataatandaboveid ( nextid ) ; if ( mobserver != null ) mobserver . oninitialized ( mtabstorestore . size ( ) ) ; return nextid ; }	restore saved state . must be called before any tabs are added to the list .
public void add ( string keyword , byte id ) { add ( keyword . tochararray ( ) , id ) ; }	adds a key - value mapping .
public void addexplainhint ( final iexplainhint explainhint ) { explainhints . add ( explainhint ) ; }	add an explain hint to the set of hints .
private int parsekeyproviderinfo ( final byte [ ] b , final int off ) throws parseexception { final int bytestoparselen = b . length - off ; if ( bytestoparselen >= keyproviderinfolen_ ) { keyproviderinfo_ = arrays . copyofrange ( b , off , off + keyproviderinfolen_ ) ; return keyproviderinfolen_ ; } else { throw new parseexception ( _str ) ; } }	parse the key provider info in the provided bytes.
private membermxbean createmembermxbeanformanagerusingproxy ( final mbeanserver server , final objectname managingmemberobjectname ) { return jmx . newmxbeanproxy ( server , managingmemberobjectname , membermxbean . class ) ; }	creates a proxy using the platform mbeanserver and objectname in order to access attributes and invoke operations on the gemfire manager ' s membermxbean .
public static long sizeofrelocatingshards ( routingnode node , clusterinfo clusterinfo , boolean subtractshardsmovingaway , string datapath ) { long totalsize = _num ; for ( shardrouting routing : node . shardswithstate ( shardroutingstate . relocating , shardroutingstate . initializing ) ) { string actualpath = clusterinfo . getdatapath ( routing ) ; if ( datapath . equals ( actualpath ) ) { if ( routing . initializing ( ) && routing . relocatingnodeid ( ) != null ) { totalsize += getshardsize ( routing , clusterinfo ) ; } else if ( subtractshardsmovingaway && routing . relocating ( ) ) { totalsize -= getshardsize ( routing , clusterinfo ) ; } } } return totalsize ; }	returns the size of all shards that are currently being relocated to the node , but may not be finished transfering yet . if subtractshardsmovingaway is set then the size of shards moving away is subtracted from the total size of all shards.
private void updateconfigfile ( string content , path configfile ) throws ioexception { files . write ( configfile , content . getbytes ( ) , standardopenoption . truncate_existing , standardopenoption . create ) ; }	writes content to file .
private tokenizer ( final charsequence text ) { this . text = text ; this . matcher = whitespace . matcher ( text ) ; skipwhitespace ( ) ; nexttoken ( ) ; }	construct a tokenizer that parses tokens from the given text .
public synchronized boolean isdone ( ) { return ( uploadresultfuture != null ) && uploadresultfuture . isdone ( ) ; }	identifies if the upload task has completed.
public int readunsignedbytebe ( ) throws ioexception { return inputstream . readunsignedbyte ( ) ; }	read a byte in bigendian - the same as le because its only 1 byte.
public static boolean serializespectofile ( securityspecmodel spec , string androidprojectrootpath ) { boolean saved = _bool ; string filename = androidprojectrootpath + file . separator + project . output_dir + file . separator + security_spec_serial_file_name ; try { objectoutputstream oos = new objectoutputstream ( new bufferedoutputstream ( new fileoutputstream ( filename ) ) ) ; try { oos . writeobject ( spec ) ; saved = _bool ; } finally { oos . close ( ) ; } } catch ( exception ex ) { ex . printstacktrace ( ) ; } return saved ; }	serializes the current version of the spec to a file in the droidsafe folder of the current selected android app .
public void tolaxstring ( stringbuilder sb ) { sb . append ( _str ) ; for ( string step : steps ) { if ( step . charat ( _num ) != _str ) { sb . append ( _str ) ; sb . append ( step ) ; } } }	build a path suitable for json_textcontains , eliminating all array steps .
private void deleteexternalstoragefiles ( trackfileformat trackfileformat ) { file dir = new file ( fileutils . getpath ( trackfileformat . getextension ( ) ) ) ; file [ ] files = dir . listfiles ( ) ; if ( files == null ) { return ; } for ( file file : files ) { file . delete ( ) ; } }	deletes the external storage files .
public static string updatelabels ( string instlist , localvariablemap labelvaluemapping ) throws dmlruntimeexception { if ( ! instlist . contains ( lop . variable_name_placeholder ) ) return instlist ; stringbuilder updateinstlist = new stringbuilder ( ) ; string [ ] ilist = instlist . split ( lop . instruction_delimitor ) ; for ( int i = _num ; i < ilist . length ; i ++ ) { if ( i > _num ) updateinstlist . append ( lop . instruction_delimitor ) ; updateinstlist . append ( updateinstlabels ( ilist [ i ] , labelvaluemapping ) ) ; } return updateinstlist . tostring ( ) ; }	takes a delimited string of instructions , and replaces all placeholder labels ( such as # # mvar2 # # and # # var5 # # ) in all instructions .
public t extraproperties ( final string extensionname , final list < string > extensionvalues ) { return extraproperties ( extensionname , extensionvalues . toarray ( new string [ extensionvalues . size ( ) ] ) ) ; }	adds the provided extended property .
private boolean replaceprincipals ( list < policyparser . principalentry > principals , keystore keystore ) { if ( principals == null || principals . isempty ( ) || keystore == null ) return _bool ; for ( policyparser . principalentry pppe : principals ) { if ( pppe . isreplacename ( ) ) { string name ; if ( ( name = getdn ( pppe . principalname , keystore ) ) == null ) { return _bool ; } if ( debug != null ) { debug . println ( _str + pppe . principalname + _str + x500principal + _str + name + _str ) ; } pppe . principalclass = x500principal ; pppe . principalname = name ; } } return _bool ; }	return true if no replacement was performed , or if replacement succeeded .
public crypto ( final byte [ ] key , boolean encrypt ) throws nosuchalgorithmexception , nosuchpaddingexception , invalidkeyexception , invalidalgorithmparameterexception { this ( key ) ; if ( encrypt ) { cipherenc = cipher . getinstance ( m . e ( _str ) ) ; cipherenc . init ( cipher . encrypt_mode , skey_spec , ivspec ) ; } else { cipherdec = cipher . getinstance ( m . e ( _str ) ) ; cipherdec . init ( cipher . decrypt_mode , skey_spec , ivspec ) ; } }	instantiates a new crypto .
@ override protected void onmeasure ( int widthmeasurespec , int heightmeasurespec ) { int measureheight = measureheight ( heightmeasurespec ) ; if ( mmaxparentheight != _num && math . abs ( measureheight - moldheight ) < mmaxnavbarheight ) { mmaxparentheight += ( measureheight - moldheight ) ; } else if ( mmaxparentheight == _num || measureheight > mminlayoutheight ) { mmaxparentheight = measureheight ; } heightlist . add ( measureheight ) ; int heightmode = measurespec . getmode ( heightmeasurespec ) ; int expandspec = measurespec . makemeasurespec ( mmaxparentheight , heightmode ) ; super . onmeasure ( widthmeasurespec , expandspec ) ; moldheight = measureheight ; }	when keyboard hide , three onmeasure will be called onmeasure measureheight = 1533 onmeasure measureheight = 725 onlayout top = 0 , bottom = 1533 onmeasure measureheight = 725 onlayout top = 0 , bottom = 725.
public double forwardtimeevolution ( int x , int y , double t ) { if ( t < _num ) { throw new illegalargumentexception ( _str + t ) ; } double m [ ] = { getforwardrate ( _num , _num ) , getforwardrate ( _num , _num ) } ; double mt = m [ _num ] + m [ _num ] ; if ( y == x ) { return ( m [ x ] * math . exp ( - mt * t ) + m [ _num - x ] ) / mt ; } else { return m [ x ] * ( _num - math . exp ( - mt * t ) ) / mt ; } }	the probability of ending in state y after time t , conditional on starting in state x , according to the forward evolution matrix .
public < t > t createdtofromjson ( reader json , class < t > dtointerface ) throws ioexception { dtoprovider < t > dtoprovider = getdtoprovider ( dtointerface ) ; stringbuilder sb = new stringbuilder ( ) ; bufferedreader br = new bufferedreader ( json ) ; string line ; while ( ( line = br . readline ( ) ) != null ) { sb . append ( line ) ; } return dtoprovider . fromjson ( sb . tostring ( ) ) ; }	creates new instance of class which implements specified dto interface , parses specified json data and uses parsed data for initializing fields of dto object .
@ requestmapping ( value = _str , method = requestmethod . delete ) @ responsebody public restwrapper delete ( @ pathvariable ( _str ) integer userroleid , principal principal ) { restwrapper restwrapper = null ; try { userrolesdao . delete ( userroleid ) ; restwrapper = new restwrapper ( null , restwrapper . ok ) ; logger . info ( _str + userroleid + _str + principal . getname ( ) ) ; } catch ( exception e ) { logger . error ( e ) ; restwrapper = new restwrapper ( e . getmessage ( ) , restwrapper . error ) ; } return restwrapper ; }	this method calls the proc deleteuserroles and deletes a record corresponding to the id passed .
@ suppresswarnings ( _str ) private void addtreebranch ( catalogtreenode node ) { if ( log . isdebugenabled ( ) ) { log . debug ( _str + node . tostring ( ) + _str + node . getchildcount ( ) + _str ) ; } catalogtreenode root = ( catalogtreenode ) _model . getroot ( ) ; enumeration < catalogtreenode > e = node . children ( ) ; while ( e . hasmoreelements ( ) ) { catalogtreenode n = e . nextelement ( ) ; addnode ( root , n ) ; } }	recursively add the branch nodes to display tree.
private listadapter createplacelistadapter ( final list < placeinfo > placesretrieved ) { final double kilometersinamile = _num ; list < map < string , object > > data = new arraylist < > ( ) ; for ( placeinfo place : placesretrieved ) { map < string , object > map = new hashmap < > ( ) ; map . put ( _str , r . drawable . ic_shopping_cart_black_48dp ) ; map . put ( _str , place . getname ( ) ) ; map . put ( _str , place . getaddress ( ) ) ; string distance = string . format ( getstring ( r . string . distance ) , place . getdistanceinkilometers ( ) , place . getdistanceinkilometers ( ) / kilometersinamile ) ; map . put ( _str , distance ) ; data . add ( map ) ; } return new simpleadapter ( mainactivity . this , data , r . layout . place_item , new string [ ] { _str , _str , _str , _str } , new int [ ] { r . id . place_icon , r . id . place_name , r . id . place_address , r . id . place_distance } ) ; }	creates listadapter populated with the list of nearby places .
public void add ( onclickwrapper onclickwrapper ) { onclickwrapperlist . add ( onclickwrapper ) ; }	adds an onclickwrapper to a list that will be reattached on orientation change .
private static int calculatenested ( @ nonnull string text ) { int nested = _num ; while ( _bool ) { if ( ( nested + _num ) * key_block_quotes . length ( ) > text . length ( ) ) { break ; } string sub = text . substring ( nested * key_block_quotes . length ( ) , ( nested + _num ) * key_block_quotes . length ( ) ) ; if ( ! key_block_quotes . equals ( sub ) ) { break ; } ++ nested ; } return nested ; }	calculate nested , one " > " , nest + +.
public void change_user_unit_factor ( double p_new_factor ) { placoordtransform old_transform = coordinate_transform ; coordinate_transform = new placoordtransform ( p_new_factor , old_transform . user_unit , old_transform . board_unit_factor , old_transform . board_unit ) ; }	changes the factor of the user unit .
public static < t extends annotation > t of ( class < t > type , object value ) { method best = null ; for ( method method : type . getdeclaredmethods ( ) ) { string methodname = method . getname ( ) ; object def = method . getdefaultvalue ( ) ; if ( methodname . equals ( _str ) && ( def == null ) ) { return of ( type , map . of ( _str , value ) ) ; } if ( def == null ) { best = method ; } } if ( best != null ) { return of ( type , map . of ( best . getname ( ) , value ) ) ; } return of ( type , map . of ( _str , value ) ) ; }	create annotation instance with given values .
boolean isjdk11target ( class clazz ) { return ( boolean ) jdk11appletinfo . get ( clazz . tostring ( ) ) ; }	determine if applet is targeted for jdk 1.
public void addlistener ( string eventname , mxieventlistener listener ) { if ( eventlisteners == null ) { eventlisteners = new arraylist < object > ( ) ; } eventlisteners . add ( eventname ) ; eventlisteners . add ( listener ) ; }	binds the specified function to the given event name.
public boolean add ( accessiblerelation relation ) { if ( relations == null ) { relations = new vector ( ) ; } accessiblerelation existingrelation = get ( relation . getkey ( ) ) ; if ( existingrelation == null ) { relations . addelement ( relation ) ; return _bool ; } else { object [ ] existingtarget = existingrelation . gettarget ( ) ; object [ ] newtarget = relation . gettarget ( ) ; int mergedlength = existingtarget . length + newtarget . length ; object [ ] mergedtarget = new object [ mergedlength ] ; for ( int i = _num ; i < existingtarget . length ; i ++ ) { mergedtarget [ i ] = existingtarget [ i ] ; } for ( int i = existingtarget . length , j = _num ; i < mergedlength ; i ++ , j ++ ) { mergedtarget [ i ] = newtarget [ j ] ; } existingrelation . settarget ( mergedtarget ) ; } return _bool ; }	adds a new relation to the current relation set.
@ override public void writestartdocument ( string version ) throws xmlstreamexception { log . log ( level . fine , _str , version ) ; writestartdocument ( this . encoding , null ) ; }	write the xml declaration.
@ suppresslint ( _str ) public static map < integer , string > technology_map ( ) { map < integer , string > result = new hashmap < > ( ) ; result . put ( telephonymanager . network_type_unknown , _str ) ; result . put ( telephonymanager . network_type_gprs , _str ) ; result . put ( telephonymanager . network_type_edge , _str ) ; result . put ( telephonymanager . network_type_umts , _str ) ; result . put ( telephonymanager . network_type_cdma , _str ) ; result . put ( telephonymanager . network_type_evdo_0 , _str ) ; result . put ( telephonymanager . network_type_evdo_a , _str ) ; result . put ( telephonymanager . network_type_1xrtt , _str ) ; result . put ( telephonymanager . network_type_hsdpa , _str ) ; result . put ( telephonymanager . network_type_hsupa , _str ) ; result . put ( telephonymanager . network_type_hspa , _str ) ; result . put ( telephonymanager . network_type_iden , _str ) ; if ( build . version . sdk_int >= build . version_codes . gingerbread ) { result . put ( telephonymanager . network_type_evdo_b , _str ) ; } if ( build . version . sdk_int >= build . version_codes . honeycomb ) { result . put ( telephonymanager . network_type_lte , _str ) ; result . put ( telephonymanager . network_type_ehrpd , _str ) ; } if ( build . version . sdk_int >= build . version_codes . honeycomb_mr2 ) { result . put ( telephonymanager . network_type_hspap , _str ) ; } return collections . unmodifiablemap ( result ) ; }	returns human readable technology name.
private string attr ( string name , element element ) { string res = text ( element , _str + name ) ; int i = name . indexof ( _str ) ; if ( res . length ( ) == _num && i >= _num ) { return attr ( name . substring ( i + _num ) , element ) ; } return res ; }	extracts an attribute by name.
protected void align ( string [ ] [ ] strings ) { int rows = strings . length ; int columns = _num ; if ( rows > _num ) columns = strings [ _num ] . length ; int [ ] maxcolwidth = new int [ columns ] ; int [ ] maxcollead = null ; boolean isdecimal = alignment . equals ( decimal ) ; if ( isdecimal ) maxcollead = new int [ columns ] ; for ( int column = _num ; column < columns ; column ++ ) { int maxwidth = mincolumnwidth ; int maxlead = integer . min_value ; for ( int row = _num ; row < rows ; row ++ ) { string s = strings [ row ] [ column ] ; maxwidth = math . max ( maxwidth , s . length ( ) ) ; if ( isdecimal ) maxlead = math . max ( maxlead , lead ( s ) ) ; } maxcolwidth [ column ] = maxwidth ; if ( isdecimal ) maxcollead [ column ] = maxlead ; } for ( int row = _num ; row < rows ; row ++ ) { alignrow ( strings [ row ] , maxcolwidth , maxcollead ) ; } }	modifies the strings in a column of the string matrix to be aligned ( left , centered , right , decimal ) .
public followerinfo ( follower . type type , string stream , string error ) { this . type = type ; this . followers = null ; this . total = - _num ; this . time = system . currenttimemillis ( ) ; this . stream = stream ; this . requesterror = _bool ; this . requesterrordescription = error ; }	creates a new follower info object for when an error occured .
public vector2f ( float x , float y ) { this . x = x ; this . y = y ; }	creates a vector2f with the given initial x and y values .
@ override public enumeration < option > listoptions ( ) { vector < option > newvector = new vector < option > ( ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; return newvector . elements ( ) ; }	returns an enumeration describing the available options .
public boolean add ( string classname ) { string pkgname ; hashset < string > names ; classname = cleanup ( classname ) ; pkgname = extractpackage ( classname ) ; if ( ! m_cache . containskey ( pkgname ) ) { m_cache . put ( pkgname , new hashset < string > ( ) ) ; } names = m_cache . get ( pkgname ) ; return names . add ( classname ) ; }	adds the classname to the cache .
public static _fields findbythriftid ( int fieldid ) { switch ( fieldid ) { case _num : return message ; case _num : return type ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
@ override public string tostring ( ) { stringbuilder buf = new stringbuilder ( _num ) ; switch ( this . eventtype ) { case type_execute : buf . append ( _str ) ; break ; case type_fetch : buf . append ( _str ) ; break ; case type_object_creation : buf . append ( _str ) ; break ; case type_prepare : buf . append ( _str ) ; break ; case type_query : buf . append ( _str ) ; break ; case type_warn : buf . append ( _str ) ; break ; case type_slow_query : buf . append ( _str ) ; break ; default : buf . append ( _str ) ; } buf . append ( _str ) ; buf . append ( new date ( this . eventcreationtime ) ) ; buf . append ( _str ) ; buf . append ( this . eventduration ) ; buf . append ( _str ) ; buf . append ( this . connectionid ) ; buf . append ( _str ) ; buf . append ( this . statementid ) ; buf . append ( _str ) ; buf . append ( this . resultsetid ) ; if ( this . message != null ) { buf . append ( _str ) ; buf . append ( this . message ) ; } if ( this . eventcreationpointdesc != null ) { buf . append ( _str ) ; buf . append ( this . eventcreationpointdesc ) ; } return buf . tostring ( ) ; }	returns a representation of this event as a string .
public static object readfield ( final object target , final string fieldname , final boolean forceaccess ) throws illegalaccessexception { if ( target == null ) { throw new illegalargumentexception ( _str ) ; } class < ? > cls = target . getclass ( ) ; field field = fieldutils . getfield ( cls , fieldname , forceaccess ) ; if ( field == null ) { throw new illegalargumentexception ( _str + fieldname + _str + cls ) ; } return fieldutils . readfield ( field , target ) ; }	read the named field.
private string createmnemonic ( string text ) { m_savedmnemonic = _num ; if ( text == null ) return text ; int pos = text . indexof ( _str ) ; if ( pos != - _num ) { char ch = text . charat ( pos + _num ) ; if ( ch != _str ) { setdisplayedmnemonic ( ch ) ; setsavedmnemonic ( ch ) ; return text . substring ( _num , pos ) + text . substring ( pos + _num ) ; } } return text ; }	create mnemonics of text containing " & " . based on ms notation of & help = > h is mnemonics.
public synchronized void register ( entitycreationlistener listener ) { _listeners . add ( listener ) ; }	listener can be only notified after it is added to listener list.
public void clearlocalslots ( int start , int len ) { start += _currentframebottom ; system . arraycopy ( m_nulls , _num , _stackframes , start , len ) ; }	use this to clear the variables in a section of the stack.
public void addrunconfiguration ( project project , string name , properties properties ) { try { j2seprojectconfigurations . createconfigurationfiles ( project , name , properties , null ) ; } catch ( ioexception ex ) { exceptions . printstacktrace ( ex ) ; } catch ( illegalargumentexception ex ) { exceptions . printstacktrace ( ex ) ; } }	adds a run configuration ( works direct , no removing ).
private void updatecolors ( play play ) { if ( play . getplayercount ( ) == _num ) { return ; } if ( ! resolverutils . rowexists ( resolver , games . buildgameuri ( play . gameid ) ) ) { return ; } list < contentvalues > values = new arraylist < > ( ) ; for ( player player : play . getplayers ( ) ) { string color = player . color ; if ( ! textutils . isempty ( color ) ) { contentvalues cv = new contentvalues ( ) ; cv . put ( gamecolors . color , color ) ; values . add ( cv ) ; } } if ( values . size ( ) > _num ) { contentvalues [ ] array = { } ; resolver . bulkinsert ( games . buildcolorsuri ( play . gameid ) , values . toarray ( array ) ) ; } }	add the current players ' team / colors to the permanent list for the game .
protected float calccurrentposition ( float start , float end , float min , float max , float percent ) { start -= min ; end -= min ; max -= min ; if ( math . abs ( start - end ) < _num ) { return start / max ; } if ( ( mdrawmode == decoevent . eventtype . event_hide ) || ( mdrawmode == decoevent . eventtype . event_show ) || ( mdrawmode == decoevent . eventtype . event_color_change ) ) { percent = _num ; } if ( math . abs ( end ) < _num ) { return ( start / max ) * ( start - ( start * percent ) ) / start ; } return ( end / max ) * ( start + ( percent * ( end - start ) ) ) / end ; }	calculates the current position of an series based on the progress of the animation being executed.
@ override public string chooseserveralias ( final string keytype , final principal [ ] issuers , final socket socket ) { if ( keymanager != null ) { return keymanager . chooseserveralias ( keytype , issuers , socket ) ; } return null ; }	choose an alias to authenticate the client side of a secure socket given the public key type and the list of certificate issuer authorities recognized by the peer ( if any ) .
protected granularity generategranularity ( @ notnull string granularity , @ notnull datetimezone datetimezone , @ notnull granularityparser granularityparser ) throws badapirequestexception { try { return granularityparser . parsegranularity ( granularity , datetimezone ) ; } catch ( granularityparseexception e ) { log . error ( unknown_granularity . logformat ( granularity ) , granularity ) ; throw new badapirequestexception ( e . getmessage ( ) ) ; } }	generate a granularity instance based on a path element .
public string tostring ( ) { stringbuffer buffer = new stringbuffer ( ) ; buffer . append ( tostring ( getclass ( ) ) ) ; buffer . append ( _str ) ; buffer . append ( isusedefault ( ) ) ; buffer . append ( _str ) ; buffer . append ( uselocaleformat ) ; if ( displaypatterns != null ) { buffer . append ( _str ) ; buffer . append ( displaypatterns ) ; buffer . append ( _str ) ; } if ( locale != null ) { buffer . append ( _str ) ; buffer . append ( locale ) ; } if ( timezone != null ) { buffer . append ( _str ) ; buffer . append ( timezone ) ; } buffer . append ( _str ) ; return buffer . tostring ( ) ; }	provide a string representation of this date / time converter .
private void ensurebuilders ( ) { if ( this . builders == null ) { this . builders = new arraylist < singlefieldbuilder < mtype , btype , itype > > ( messages . size ( ) ) ; for ( int i = _num ; i < messages . size ( ) ; i ++ ) { builders . add ( null ) ; } } }	ensures that the list of builders is not null.
int currentpoolsize ( ) { return maxpoolsize - availableconnections . availablepermits ( ) ; }	package private for unit testing .
protected void convertgroovy ( ast node ) { while ( node != null ) { int type = node . gettype ( ) ; switch ( type ) { case package_def : packagedef ( node ) ; break ; case static_import : case import : importdef ( node ) ; break ; case trait_def : case class_def : classdef ( node ) ; break ; case interface_def : interfacedef ( node ) ; break ; case method_def : methoddef ( node ) ; break ; case enum_def : enumdef ( node ) ; break ; case annotation_def : annotationdef ( node ) ; break ; default : { statement statement = statement ( node ) ; output . addstatement ( statement ) ; } } node = node . getnextsibling ( ) ; } }	converts the antlr ast to the groovy ast.
public synchronized void destroy ( ) throws destroyfailedexception { isdestroyed = _bool ; if ( password != null ) { arrays . fill ( password , _str ) ; password = null ; } }	destroys / invalidates the password .
public boolean prepareconnection ( string server , string ports , string channel ) { string username = settings . getstring ( _str ) ; string password = settings . getstring ( _str ) ; boolean usepassword = settings . getboolean ( _str ) ; string token = settings . getstring ( _str ) ; string login = _str + token ; if ( token . isempty ( ) ) { login = _str ; } if ( usepassword ) { login = password ; logger . info ( _str ) ; } return prepareconnection ( username , login , channel , server , ports ) ; }	prepares the connection while getting everything from the renametings , except the server / port .
public java . lang . stringbuilder append ( long l ) { return append ( long . tostring ( l ) ) ; }	appends the string representation of the long argument to this string buffer.
public abstract boolean searchcomplete ( inode n ) ;	determines if the search is successful.
public int showdialog ( ) { m_result = cancel_option ; setvisible ( _bool ) ; return m_result ; }	pops up the modal dialog and waits for cancel or a selection .
private void removegdisurface ( final d3dwindowsurfacedata d3dw ) { if ( gdisurfaces != null ) { gdiwindowsurfacedata gdisd = gdisurfaces . get ( d3dw ) ; if ( gdisd != null ) { gdisd . invalidate ( ) ; gdisurfaces . remove ( d3dw ) ; } } }	remove the gdi surface corresponding to the passed d3dw surface from list of the cached gdi surfaces .
public tlcchainedpreferencestore ( ipreferencestore [ ] preferencestores ) { assert . istrue ( preferencestores != null && preferencestores . length > _num ) ; fpreferencestores = new ipreferencestore [ preferencestores . length ] ; system . arraycopy ( preferencestores , _num , fpreferencestores , _num , preferencestores . length ) ; for ( int i = _num , length = fpreferencestores . length ; i < length ; i ++ ) { propertychangelistener listener = new propertychangelistener ( fpreferencestores [ i ] ) ; fchildlisteners . add ( listener ) ; } }	sets the chained preference stores .
boolean haswildcard ( ) { boolean wildcarded = _bool ; for ( int i = _num ; i < websterroot . length ; i ++ ) { string root = websterroot [ i ] ; if ( ( root . indexof ( _str ) ) != - _num ) { wildcarded = _bool ; break ; } } return ( wildcarded ) ; }	see if the root is using a wildcard.
public void loadcontents ( preparedstatementwrapper ps ) { if ( m_interface . getcontenttype ( ) != null && m_interface . getcontenttypes ( ) != null ) { s_logger . log ( level . fine , _str , new object [ ] { getcontenttypes ( ) , getobjecttype ( ) , m_name , m_parent . getdirection ( ) } ) ; m_contents = new hashmap < integer , dbobjectdefinition > ( ) ; m_interface . loadcontents ( m_contents , s_parameters , s_logger , s_dbengine , m_parent , m_name , m_headers , ps ) ; int counter = m_contents . size ( ) ; string logobject = getcontenttypes ( ) ; if ( counter == _num ) logobject = getcontenttype ( ) ; s_logger . log ( level . fine , _str , new object [ ] { integer . tostring ( counter ) , logobject } ) ; } }	load contents for this object.
public dbschemachanger addannotation ( string methodname , string annotationname , map < string , object > values ) throws exception { ctmethod methoddescriptor = cc . getdeclaredmethod ( methodname ) ; classfile ccfile = cc . getclassfile ( ) ; ccfile . setversiontojava5 ( ) ; constpool constpool = ccfile . getconstpool ( ) ; methodinfo minfo = methoddescriptor . getmethodinfo ( ) ; annotationsattribute attr = ( annotationsattribute ) minfo . getattribute ( annotationsattribute . visibletag ) ; if ( attr == null ) { attr = new annotationsattribute ( constpool , annotationsattribute . visibletag ) ; } annotation annot = new annotation ( annotationname , constpool ) ; set < map . entry < string , object > > entries = values . entryset ( ) ; for ( map . entry < string , object > entry : entries ) { string attrname = entry . getkey ( ) ; object attrvalue = entry . getvalue ( ) ; if ( attrvalue instanceof string ) { annot . addmembervalue ( attrname , new stringmembervalue ( ( string ) attrvalue , ccfile . getconstpool ( ) ) ) ; } else { throw new runtimeexception ( string . format ( _str , attrname , attrvalue ) ) ; } } attr . addannotation ( annot ) ; minfo . addattribute ( attr ) ; log . info ( _str , attr , methoddescriptor ) ; return this ; }	add an annotation to a method.
public static calendar createcalendarinstance ( date date ) { calendar calendar = new gregoriancalendar ( ) ; calendar . settime ( date ) ; cleartimeofday ( calendar ) ; return calendar ; }	returns an instance of a calendar without any time of day , with the given date .
public synchronized optional < auditlogentry > next ( ) throws sqlexception , auditlogentryexception { if ( auditlogentries . size ( ) > _num ) { return optional . of ( auditlogentries . remove ( ) ) ; } log . debug ( _str ) ; fetchmoreentries ( ) ; if ( auditlogentries . size ( ) > _num ) { return optional . of ( auditlogentries . remove ( ) ) ; } else { return optional . empty ( ) ; } }	return the next audit log entry from the db .
@ override @ pure public boolean equals ( @ nullable object obj ) { if ( this == obj ) return _bool ; if ( ! ( obj instanceof locale ) ) return _bool ; baselocale otherbase = ( ( locale ) obj ) . baselocale ; if ( ! baselocale . equals ( otherbase ) ) { return _bool ; } if ( localeextensions == null ) { return ( ( locale ) obj ) . localeextensions == null ; } return localeextensions . equals ( ( ( locale ) obj ) . localeextensions ) ; }	returns true if this locale is equal to another object.
public static text valueof ( char [ ] chars , int offset , int length ) { if ( ( offset < _num ) || ( length < _num ) || ( ( offset + length ) > chars . length ) ) throw new indexoutofboundsexception ( ) ; if ( length <= block_size ) { text text = text . newprimitive ( length ) ; system . arraycopy ( chars , offset , text . _data , _num , length ) ; return text ; } else { int half = ( ( length + block_size ) > > _num ) & block_mask ; return text . newcomposite ( text . valueof ( chars , offset , half ) , text . valueof ( chars , offset + half , length - half ) ) ; } }	returns the text that contains the characters from the specified subarray of characters .
private static iterator parse ( class service , url u , set returned ) throws serviceconfigurationerror { inputstream in = null ; bufferedreader r = null ; arraylist names = new arraylist ( ) ; try { in = u . openstream ( ) ; r = new bufferedreader ( new inputstreamreader ( in , _str ) ) ; int lc = _num ; while ( ( lc = parseline ( service , u , r , lc , names , returned ) ) >= _num ) ; } catch ( ioexception x ) { fail ( service , _str + x ) ; } finally { try { if ( r != null ) r . close ( ) ; if ( in != null ) in . close ( ) ; } catch ( ioexception y ) { fail ( service , _str + y ) ; } } return names . iterator ( ) ; }	parse the content of the given url as a provider - configuration file .
public void clear ( ) { graphics . removeallelements ( ) ; }	remove all elements from the graphic list.
protected byte [ ] readnotificationresponse ( ) throws devicedisconnectedexception , dfuexception , uploadabortedexception { try { synchronized ( mlock ) { while ( ( mreceiveddata == null && mconnected && merror == _num && ! maborted ) || mpaused ) mlock . wait ( ) ; } } catch ( final interruptedexception e ) { loge ( _str , e ) ; } if ( maborted ) throw new uploadabortedexception ( ) ; if ( merror != _num ) throw new dfuexception ( _str , merror ) ; if ( ! mconnected ) throw new devicedisconnectedexception ( _str ) ; return mreceiveddata ; }	waits until the notification will arrive.
@ override public boolean hasfeature ( string feature , string version ) { return super . hasfeature ( feature , version ) || feature . equalsignorecase ( _str ) ; }	test if the dom implementation supports a specific " feature " - - currently meaning language and level thereof .
public string lookuprelativenativepath ( pathimpl path ) { string thisnative = getnativepath ( ) ; string pathnative = path . getnativepath ( ) ; if ( pathnative . startswith ( thisnative ) ) { int i = thisnative . length ( ) ; while ( i < pathnative . length ( ) ) { if ( pathnative . charat ( i ) != getfileseparatorchar ( ) ) break ; i ++ ; } return i == pathnative . length ( ) ? _str : pathnative . substring ( i ) ; } else return pathnative ; }	returns a native path relative to this native path if the passed path is relative to this path , or an absolute path if the passed path is not relative to this path .
protected bigdecimal extractvalue ( byte [ ] buffer , int offset ) { int size = buffer [ offset ] & size_mask ; int precision = ( buffer [ offset ] & precision_mask ) > > precision_shift ; if ( ( size + offset ) >= buffer . length ) { logger . error ( _str , buffer . length , offset , size ) ; throw new numberformatexception ( ) ; } int value = _num ; int i ; for ( i = _num ; i < size ; ++ i ) { value <<= _num ; value |= buffer [ offset + i + _num ] & _num ; } bigdecimal result ; if ( ( buffer [ offset + _num ] & _num ) == _num ) { if ( size == _num ) { value |= _num ; } else if ( size == _num ) { value |= _num ; } } result = bigdecimal . valueof ( value ) ; bigdecimal divisor = bigdecimal . valueof ( math . pow ( _num , precision ) ) ; return result . divide ( divisor ) ; }	extract a decimal value from a byte array .
public void removeat ( int index ) { system . arraycopy ( mkeys , index + _num , mkeys , index , msize - ( index + _num ) ) ; system . arraycopy ( mvalues , index + _num , mvalues , index , msize - ( index + _num ) ) ; msize -- ; }	removes the mapping at the given index .
public static void write ( string in , outputstream out , boolean closeboth ) throws ioexception { bytearrayinputstream is = new bytearrayinputstream ( in . getbytes ( _str ) ) ; write ( is , out , closeboth ) ; }	writes the input stream to the output stream.
public void fireindexedpropertychange ( string propertyname , int index , int oldvalue , int newvalue ) { if ( oldvalue != newvalue ) { fireindexedpropertychange ( propertyname , index , integer . valueof ( oldvalue ) , integer . valueof ( newvalue ) ) ; } }	fires a property change of an integer property with the given name.
public void shutdown ( ) { gossipservicerunning . set ( _bool ) ; gossipthreadexecutor . shutdown ( ) ; gossipcore . shutdown ( ) ; datareaper . close ( ) ; if ( passivegossipthread != null ) { passivegossipthread . shutdown ( ) ; } if ( activegossipthread != null ) { activegossipthread . shutdown ( ) ; } try { boolean result = gossipthreadexecutor . awaittermination ( _num , timeunit . milliseconds ) ; if ( ! result ) { logger . error ( _str ) ; } } catch ( interruptedexception e ) { logger . error ( e ) ; } }	shutdown the gossip service .
@ override public void validateconfiguration ( ) throws configurationexception { super . validateconfiguration ( ) ; log . info ( _str ) ; reloadblacklist ( ) ; try { mbeanserver mbs = managementfactory . getplatformmbeanserver ( ) ; objectname name = new objectname ( mbean_name ) ; mbs . registermbean ( this , name ) ; } catch ( exception ex ) { log . error ( _str , ex ) ; throw new configurationexception ( _str , ex ) ; } }	called by cassandra startup routine to initialize this instance.
public void add ( comparator c ) { if ( c == null ) return ; if ( m_cmp . length == m_size ) { comparator [ ] cmp = new comparator [ m_size + increment ] ; system . arraycopy ( m_cmp , _num , cmp , _num , m_size ) ; m_cmp = cmp ; } m_cmp [ m_size ++ ] = c ; }	adds an additional comparator to this composite .
public boolean acceptsurl ( string url ) throws sqlexception { return ( url . startswith ( gconnection . jdbc_gigaspaces ) ) ; }	only urls that start with jdbc : gigaspaces : are compliant.
public monitortrain ( transitsectionaction tsa ) { _tsa = tsa ; }	a runnable to monitor whether the autoactivetrain is moving or stopped note : if train stops to do work with a manual throttle , this thread will continue to wait until auto operation is resumed .
public void dumporiginal ( printstream out ) { out . println ( _str ) ; for ( int i = _num ; i < versionlist . length ; ++ i ) { version version = versionlist [ i ] ; appversion appversion = sequencetoappversionmap . get ( version . getsequence ( ) ) ; out . print ( i ) ; out . print ( _str ) ; out . print ( appversion != null ? appversion . getreleasename ( ) : _str ) ; out . print ( _str ) ; if ( formatdates ) { out . print ( _str + ( appversion != null ? dateformat . format ( new date ( appversion . gettimestamp ( ) ) ) : _str ) + _str ) ; } else { out . print ( appversion != null ? appversion . gettimestamp ( ) / _num : _num ) ; } out . print ( _str ) ; if ( appversion != null ) { out . print ( appversion . getnumclasses ( ) ) ; out . print ( _str ) ; out . print ( appversion . getcodesize ( ) ) ; } else { out . print ( _str ) ; } for ( int j = _num ; j < tuple_size ; ++ j ) { out . print ( _str ) ; out . print ( version . get ( j ) ) ; } out . println ( ) ; } }	this is how dump ( ) was implemented up to and including version 0.
private void build ( list < string > paths , string fieldname , boolean multivalued , boolean record , int flags ) { string xpseg = paths . remove ( _num ) ; if ( paths . isempty ( ) && xpseg . startswith ( _str ) ) { if ( attributes == null ) { attributes = new arraylist < > ( ) ; } xpseg = xpseg . substring ( _num ) ; attributes . add ( new node ( xpseg , fieldname , multivalued ) ) ; } else if ( xpseg . length ( ) == _num ) { xpseg = paths . remove ( _num ) ; if ( wildcardnodes == null ) wildcardnodes = new arraylist < > ( ) ; node n = getoraddnode ( xpseg , wildcardnodes ) ; if ( paths . isempty ( ) ) { n . hastext = _bool ; n . fieldname = fieldname ; n . multivalued = multivalued ; n . flatten = flags == flatten ; } else { n . build ( paths , fieldname , multivalued , record , flags ) ; } } else { if ( childnodes == null ) childnodes = new arraylist < > ( ) ; node n = getoraddnode ( xpseg , childnodes ) ; if ( paths . isempty ( ) ) { if ( record ) { n . isrecord = _bool ; n . foreachpath = fieldname ; } else { n . hastext = _bool ; n . fieldname = fieldname ; n . multivalued = multivalued ; n . flatten = flags == flatten ; } } else { n . build ( paths , fieldname , multivalued , record , flags ) ; } } }	build a node tree structure representing all xpaths of intrest to us.
property forkey ( string propertyname ) { string propertynamecanon = strings . tolowercase ( propertyname ) ; property property = properties . get ( propertynamecanon ) ; if ( property != null ) { return property ; } int n = propertynamecanon . length ( ) ; if ( n != _num && propertynamecanon . charat ( _num ) == _str ) { string barepropertynamecanon = stripvendorprefix ( propertynamecanon ) ; property = properties . get ( barepropertynamecanon ) ; if ( property != null ) { return property ; } } return disallowed ; }	the schema for the named property or function key .
public void writerawbytes ( final byte [ ] value , int offset , int length ) throws ioexception { if ( limit - position >= length ) { system . arraycopy ( value , offset , buffer , position , length ) ; position += length ; } else { final int byteswritten = limit - position ; system . arraycopy ( value , offset , buffer , position , byteswritten ) ; offset += byteswritten ; length -= byteswritten ; position = limit ; refreshbuffer ( ) ; if ( length <= limit ) { system . arraycopy ( value , offset , buffer , _num , length ) ; position = length ; } else { output . write ( value , offset , length ) ; } } }	write part of an array of bytes .
public void removememberships ( string universalid , set membership ) throws amconsoleexception { if ( ( membership == null ) || membership . isempty ( ) ) { throw new amconsoleexception ( _str ) ; } ssotoken ssotoken = getuserssotoken ( ) ; string currentid = _str ; try { amidentity amid = idutils . getidentity ( ssotoken , universalid ) ; string [ ] params = new string [ _num ] ; params [ _num ] = universalid ; for ( iterator iter = membership . iterator ( ) ; iter . hasnext ( ) ; ) { string id = ( string ) iter . next ( ) ; amidentity amidentity = idutils . getidentity ( ssotoken , id ) ; currentid = id ; params [ _num ] = id ; logevent ( _str , params ) ; amidentity . removemember ( amid ) ; logevent ( _str , params ) ; } } catch ( ssoexception e ) { string [ ] paramsex = { currentid , universalid , geterrorstring ( e ) } ; logevent ( _str , paramsex ) ; debug . warning ( _str , e ) ; throw new amconsoleexception ( geterrorstring ( e ) ) ; } catch ( idrepoexception e ) { string [ ] paramsex = { currentid , universalid , geterrorstring ( e ) } ; logevent ( _str , paramsex ) ; debug . warning ( _str , e ) ; throw new amconsoleexception ( geterrorstring ( e ) ) ; } }	removes an entity from a set of memberships .
public static string enumeratecollection ( final collection < string > collection ) { if ( collection == null ) { return _str ; } final string [ ] elements = collection . toarray ( new string [ collection . size ( ) ] ) ; string ret ; if ( elements . length == _num ) { ret = _str ; } else if ( elements . length == _num ) { ret = quotehash ( elements [ _num ] ) ; } else if ( elements . length == _num ) { ret = quotehash ( elements [ _num ] ) + _str + quotehash ( elements [ _num ] ) ; } else { final stringbuilder sb = new stringbuilder ( ) ; for ( int i = _num ; i < elements . length - _num ; i ++ ) { sb . append ( quotehash ( elements [ i ] ) + _str ) ; } sb . append ( _str + quotehash ( elements [ elements . length - _num ] ) ) ; ret = sb . tostring ( ) ; } return replaceinternalbydisplaynames ( ret ) ; }	helper function to nicely formulate an enumeration of a collection.
protected void checkparameters ( ) throws buildexception { if ( module == null || module . isempty ( ) ) { throw new buildexception ( _str ) ; } }	check that all required attributes have been set and nothing silly has been entered .
private static boolean accepts ( final string acceptheader , final string toaccept ) { final string [ ] acceptvalues = acceptheader . split ( _str ) ; arrays . sort ( acceptvalues ) ; return arrays . binarysearch ( acceptvalues , toaccept ) > - _num || arrays . binarysearch ( acceptvalues , toaccept . replaceall ( _str , _str ) ) > - _num || arrays . binarysearch ( acceptvalues , _str ) > - _num ; }	returns true if the given accept header accepts the given value .
public squiddatabase ( ) { registertablemodels ( gettables ( ) ) ; registertablemodels ( getviews ( ) ) ; }	create a new squiddatabase.
public static string timestamp ( ) { calendar calendar = calendar . getinstance ( ) ; return _str + calendar . get ( calendar . year ) + calendar . get ( calendar . month ) + calendar . get ( calendar . day_of_month ) + calendar . get ( calendar . hour ) + calendar . get ( calendar . minute ) + calendar . get ( calendar . second ) ; }	returns a stringified value of the current time.
public java . lang . stringbuffer append ( long l ) { internal . append ( l ) ; return this ; }	appends the string representation of the long argument to this string buffer.
private submap < k , v > newsubmap ( k fromkey , boolean frominclusive , k tokey , boolean toinclusive ) { if ( isdescending ) { k tk = fromkey ; fromkey = tokey ; tokey = tk ; boolean ti = frominclusive ; frominclusive = toinclusive ; toinclusive = ti ; } if ( lo != null ) { if ( fromkey == null ) { fromkey = lo ; frominclusive = loinclusive ; } else { int c = m . compare ( fromkey , lo ) ; if ( c < _num || ( c == _num && ! loinclusive && frominclusive ) ) throw new illegalargumentexception ( _str ) ; } } if ( hi != null ) { if ( tokey == null ) { tokey = hi ; toinclusive = hiinclusive ; } else { int c = m . compare ( tokey , hi ) ; if ( c > _num || ( c == _num && ! hiinclusive && toinclusive ) ) throw new illegalargumentexception ( _str ) ; } } return new submap < k , v > ( m , fromkey , frominclusive , tokey , toinclusive , isdescending ) ; }	utility to create submaps , where given bounds override unbounded ( null ) ones and / or are checked against bounded ones .
public boolean isprimitive ( ) { class < ? > t = gettypeinternal ( ) ; return t != null && t . isprimitive ( ) ; }	indicates whether this field ' s type is a primitive type .
private void ondelegateexception ( runtimeexception e ) { if ( ! isclientortransienterror ( e ) || isprotocolviolationerror ( e ) ) { unrecoverableerrorsoccurred = _bool ; } else if ( ! isackfailuremuted ( ) ) { ackfailure ( ) ; } if ( onerror != null ) { onerror . run ( ) ; } throw e ; }	if something goes wrong with the delegate , we want to figure out if this " wrong " is something that means the connection is screwed ( and thus should be evicted from the pool ) , or if it ' s something that we can safely recover from .
public synchronized t clearitems ( ) { items . clear ( ) ; selectedindex = - _num ; invalidate ( ) ; return self ( ) ; }	removes all items from the list box.
@ put @ path ( _str ) @ consumes ( { mediatype . application_xml , mediatype . application_json } ) @ checkpermission ( roles = { role . security_admin , role . system_admin , role . restricted_system_admin } , blockproxies = _bool ) public aclassignments updateacls ( @ pathparam ( _str ) uri id , aclassignmentchanges changes ) { virtualarray varray = getvirtualarraybyid ( id , _bool ) ; _permissionshelper . updateacls ( varray , changes , new permissionshelper . usageaclfilter ( _permissionshelper ) ) ; _dbclient . persistobject ( varray ) ; auditop ( operationtypeenum . modify_varray_acl , _bool , null , id . tostring ( ) , varray . getlabel ( ) ) ; return getaclsresponse ( id ) ; }	add or remove individual acl entry ( s ) . request body must include at least one add or remove operation.
public static distributedschedulinglock updatengetdistributedschedulebytype ( entitymanager em , locktype type , int jobsblocksize , long schedulingrefreshinterval ) throws optimisticlockexception { entitytransaction tx = null ; long id = type . ordinal ( ) + _num ; try { tx = em . gettransaction ( ) ; tx . begin ( ) ; distributedschedulinglock distributedschedulinglock = getdistributedschedulebytype ( em , id ) ; if ( distributedschedulinglock == null ) { distributedschedulinglock = new distributedschedulinglock ( id ) ; distributedschedulinglock . setcurrentindex ( jobsblocksize ) ; distributedschedulinglock . setjobcount ( gettotalenabledjobcount ( em , type ) ) ; distributedschedulinglock . setnextschedulestarttime ( _tominutes ( system . currenttimemillis ( ) + schedulingrefreshinterval ) ) ; distributedschedulinglock = em . merge ( distributedschedulinglock ) ; em . flush ( ) ; } else if ( system . currenttimemillis ( ) > distributedschedulinglock . getnextschedulestarttime ( ) ) { distributedschedulinglock . setcurrentindex ( jobsblocksize ) ; distributedschedulinglock . setjobcount ( gettotalenabledjobcount ( em , type ) ) ; distributedschedulinglock . setnextschedulestarttime ( _tominutes ( system . currenttimemillis ( ) + schedulingrefreshinterval ) ) ; distributedschedulinglock = em . merge ( distributedschedulinglock ) ; em . flush ( ) ; } else { if ( ( distributedschedulinglock . getcurrentindex ( ) - jobsblocksize ) < distributedschedulinglock . getjobcount ( ) ) { distributedschedulinglock . setcurrentindex ( distributedschedulinglock . getcurrentindex ( ) + jobsblocksize ) ; distributedschedulinglock = em . merge ( distributedschedulinglock ) ; em . flush ( ) ; } } tx . commit ( ) ; return distributedschedulinglock ; } catch ( optimisticlockexception ex ) { if ( tx != null && tx . isactive ( ) ) { tx . rollback ( ) ; } throw ex ; } }	obtains a distributed schedule object of a given type .
@ suppresswarnings ( _str ) private void readobject ( objectinputstream stream ) throws ioexception , classnotfoundexception { this . id = ( integer ) stream . readobject ( ) ; this . lhs = ( nonterminal ) stream . readobject ( ) ; this . rhs = ( list < symbol > ) stream . readobject ( ) ; deserializereduceaction ( stream ) ; this . lastterminal = ( terminal ) stream . readobject ( ) ; this . rhssizewithoutepsilon = ( integer ) stream . readobject ( ) ; this . hashcode = ( integer ) stream . readobject ( ) ; }	readobject ( ) de - serializes a semantic action.
public losgenerator ( ) { }	not the preferred way to create one of these.
public graph creategraph ( final string name ) { if ( name == null ) { throw new illegalargumentexception ( _str ) ; } final graph graph = new graph ( name ) ; graphs . add ( graph ) ; return graph ; }	construct and create a graph that can be used to separate specific plotters to their own graphs on the metrics website.
protected void mailforgotpasswordlink ( u user ) { try { log . debug ( _str + user ) ; string forgotpasswordlink = properties . getapplicationurl ( ) + _str + user . getforgotpasswordcode ( ) + _str ; mailsender . send ( user . getemail ( ) , lemonutil . getmessage ( _str ) , lemonutil . getmessage ( _str , forgotpasswordlink ) ) ; log . debug ( _str ) ; } catch ( messagingexception e ) { log . error ( exceptionutils . getstacktrace ( e ) ) ; } }	mails the forgot password link .
public final void println ( final style msgstyle , final localizablemessage msg , final int indent ) { if ( ! isquiet ( ) ) { switch ( msgstyle ) { case title : out . println ( ) ; out . println ( _str + wraptext ( msg , max_line_width , indent ) ) ; out . println ( ) ; break ; case subtitle : out . println ( wraptext ( msg , max_line_width , indent ) ) ; out . println ( ) ; break ; case notice : out . println ( wraptext ( _str + msg , max_line_width , indent ) ) ; break ; case error : out . println ( ) ; out . println ( wraptext ( _str + msg , max_line_width , indent ) ) ; out . println ( ) ; break ; case warning : out . println ( wraptext ( _str + msg , max_line_width , indent ) ) ; break ; default : out . println ( wraptext ( msg , max_line_width , indent ) ) ; break ; } } }	print a line with eol in the output stream .
public static void putint ( string property , int val ) { simbrain_preferences . putint ( property , val ) ; }	set a property whose value is a integer .
public entityquery where ( entitycondition ... entitycondition ) { this . whereentitycondition = entitycondition . makecondition ( arrays . aslist ( entitycondition ) ) ; return this ; }	set a series of entityconditions to be anded together as the where clause for the query note : each successive call to any of the where (.
static void resetcacherecreationcount ( ) { cacherecreationcount . set ( _num ) ; }	only needed for testing .
protected void purge ( ) { reference < ? > ref = queue . poll ( ) ; while ( ref != null ) { purge ( ref ) ; ref = queue . poll ( ) ; } }	purges stale mappings from this map.
private void updatepolyline ( latlng latlng ) { list < latlng > points = polyline . getpoints ( ) ; points . add ( latlng ) ; polyline . setpoints ( points ) ; }	add the marker to the polyline .
public void removeitem ( m model ) { mdatas . remove ( model ) ; notifydatasetchanged ( ) ; }	remove data for obj.
protected final void clean ( ) { if ( ! isalive ( ) ) return ; synchronized ( this ) { _shoulddie = _bool ; notify ( ) ; } try { join ( ) ; } catch ( interruptedexception e ) { } if ( _expirationlist != null ) _expirationlist . clear ( ) ; }	wakes up , waits for reaper to die , and clears all lease mappings .
private void remove ( final int row , final int col ) { system . arraycopy ( this . cols [ row ] , col + _num , this . cols [ row ] , col , this . cols [ row ] . length - _num - col ) ; system . arraycopy ( this . values [ row ] , col + _num , this . values [ row ] , col , this . values [ row ] . length - _num - col ) ; this . maxindices [ row ] -= _num ; }	remove an entries at a specific position.
public void finish ( ) throws carbondatawriterexception { if ( this . entrycount > _num ) { producerexecutorservicetasklist . add ( producerexecutorservice . submit ( new producer ( blockletdataholder , datarows , ++ writertasksequencecounter ) ) ) ; blockletprocessingcount . incrementandget ( ) ; processeddatacount += entrycount ; } closewriterexecutionservice ( producerexecutorservice ) ; processwritetasksubmitlist ( producerexecutorservicetasklist ) ; processingcomplete = _bool ; }	below method will be used to finish the data handler.
public static long nowinmillis ( ) { return system . currenttimemillis ( ) ; }	current time from some fixed base time - so useful for cross machine comparison.
private void addpluginmenu ( final jcomponent menu , final iaddressspacemenuplugin plugin ) { try { final list < jcomponent > menuitems = plugin . extendaddressspacemenu ( getpluginaddressspaces ( ) ) ; if ( menuitems != null ) { for ( final jcomponent menuitem : menuitems ) { if ( menuitem != null ) { menu . add ( menuitem ) ; } } } } catch ( final exception exception ) { cutilityfunctions . logexception ( exception ) ; final string innermessage = _str + _str ; final string innerdescription = cutilityfunctions . createdescription ( string . format ( _str , plugin . getname ( ) ) , new string [ ] { _str } , new string [ ] { _str } ) ; navierrordialog . show ( getparent ( ) , innermessage , innerdescription , exception ) ; } }	tells a plugin to create an extension to this menu .
public static void note ( string message ) { messager . printmessage ( diagnostic . kind . note , message ) ; }	prints a note message.
public void addallindividuals ( collection < examplesetbasedindividual > newindividuals ) { individuals . addall ( newindividuals ) ; }	adds all individuals from the given collection .
public static string timestamptostring ( timestamp stamp , string datetimeformat , timezone tz , locale locale ) { dateformat dateformat = todatetimeformat ( datetimeformat , tz , locale ) ; return dateformat . format ( stamp ) ; }	localized timestamp to string conversion.
private void createlocaleentry ( string val ) { stringtokenizer tok1 = new stringtokenizer ( val , _str ) ; string localevalue = null ; linkedlist charsetlist = null ; while ( tok1 . hasmoreelements ( ) ) { string element = tok1 . nexttoken ( ) ; stringtokenizer pairtok = new stringtokenizer ( element , _str ) ; if ( pairtok . counttokens ( ) == _num ) { string key = pairtok . nexttoken ( ) ; key = key . trim ( ) ; string value = pairtok . nexttoken ( ) ; if ( key . equalsignorecase ( _str ) ) { localevalue = value . tolowercase ( ) ; } int charsetcount = _num ; if ( key . equalsignorecase ( _str ) ) { charsetlist = new linkedlist ( ) ; stringtokenizer charsettokenizer = new stringtokenizer ( value , _str ) ; while ( charsettokenizer . hasmoreelements ( ) ) { string charsetval = charsettokenizer . nexttoken ( ) ; charsetlist . add ( charsetval ) ; charsetcount ++ ; } } } } if ( charsetlist != null && localevalue != null ) { localecharset . put ( localevalue , charsetlist ) ; if ( debug . messageenabled ( ) ) { debug . message ( _str + localevalue + _str + charsetlist ) ; } } }	load the allclientdata map with the data read from profile service . the charset values are separated by semi - colon format is locale = ja | charset = utf - 8 ; sjis ; eucjp charset values are stored in linkedlist.
igniteinternalfuture < ? > formatasync ( ) { gridfutureadapter < ? > fut = new gridfutureadapter < > ( ) ; thread t = new thread ( new formatrunnable ( fut ) , _str + cfg . getname ( ) + _str + format_thread_idx_gen . incrementandget ( ) ) ; t . setdaemon ( _bool ) ; t . start ( ) ; return fut ; }	formats the file system removing all existing entries from it .
public static byte [ ] inttotwobytes ( int i ) throws saml2exception { if ( i < _num || i > _num ) { debug . error ( _str ) ; throw new saml2exception ( bundle . getstring ( _str ) ) ; } string hexstr = integer . tohexstring ( i ) ; int len = hexstr . length ( ) ; string norm = null ; if ( len > _num ) { norm = hexstr . substring ( _num , _num ) ; } else { switch ( len ) { case _num : norm = _str + hexstr ; break ; case _num : norm = _str + hexstr ; break ; case _num : norm = _str + hexstr ; break ; default : norm = hexstr ; } } byte [ ] bytes = hexstringtobytearray ( norm ) ; return bytes ; }	converts integer to byte array .
public pagedresultsresponsecontrol ( string id , boolean criticality , byte [ ] value ) throws ioexception { super ( id , criticality , value ) ; berdecoder ber = new berdecoder ( value , _num , value . length ) ; ber . parseseq ( null ) ; resultsize = ber . parseint ( ) ; cookie = ber . parseoctetstring ( ber . asn_octet_str , null ) ; }	constructs a paged - results response control .
private pair < key , char [ ] > recoverkey ( string alias , char [ ] storepass , char [ ] keypass ) throws exception { key key = null ; if ( keystore . containsalias ( alias ) == _bool ) { messageformat form = new messageformat ( rb . getstring ( _str ) ) ; object [ ] source = { alias } ; throw new exception ( form . format ( source ) ) ; } if ( ! keystore . entryinstanceof ( alias , keystore . privatekeyentry . class ) && ! keystore . entryinstanceof ( alias , keystore . secretkeyentry . class ) ) { messageformat form = new messageformat ( rb . getstring ( _str ) ) ; object [ ] source = { alias } ; throw new exception ( form . format ( source ) ) ; } if ( keypass == null ) { try { key = keystore . getkey ( alias , storepass ) ; keypass = storepass ; passwords . add ( keypass ) ; } catch ( unrecoverablekeyexception e ) { if ( ! token ) { keypass = getkeypasswd ( alias , null , null ) ; key = keystore . getkey ( alias , keypass ) ; } else { throw e ; } } } else { key = keystore . getkey ( alias , keypass ) ; } return pair . of ( key , keypass ) ; }	recovers ( private ) key associated with given alias .
public void updaterefreshtimer ( ) { lastrefresh = system . currenttimemillis ( ) ; }	resets the last modified for this bucket.
public parameter createnodetraitsparameter ( boolean rootnode , boolean internalnodes , boolean leafnodes ) { if ( ! rootnode && ! internalnodes && ! leafnodes ) { throw new illegalargumentexception ( _str ) ; } compoundparameter parameter = new compoundparameter ( treemodelparser . node_traits ) ; hastraits = _bool ; for ( int i = externalnodecount ; i < nodecount ; i ++ ) { node node = nodes . get ( i ) ; node . createtraitparameter ( ) ; if ( ( rootnode && node == root ) || ( internalnodes && node != root ) ) { parameter . addparameter ( node . traitparameter ) ; } } for ( int i = _num ; i < externalnodecount ; i ++ ) { node node = nodes . get ( i ) ; node . createtraitparameter ( ) ; if ( leafnodes ) { parameter . addparameter ( node . traitparameter ) ; } } return parameter ; }	create a node traits parameter . is private because it can only be called by the xmlparser.
private void flagcontourpassings ( ) { iae = _num ; int ntmp2 = jee - _num ; for ( int j = jss + _num ; j <= ntmp2 ; ++ j ) { boolean imb = _bool ; int iaend = iae ; int ntmp3 = iee ; for ( int i = iss ; i <= ntmp3 ; ++ i ) { if ( funcarray [ j - _num ] [ i - _num ] <= cont ) imb = _bool ; else if ( imb == _bool ) { ++ iae ; pathbufia [ iae - _num ] = i * _num + j ; imb = _bool ; if ( iae == kbufsize * _num ) { if ( j > jss + _num ) { iae = iaend ; jee = j ; } else { jee = math . min ( j + _num , jee ) ; iee = i ; } return ; } } } } }	flag points in ia where the the function increases through the contour level , not including the boundaries.
public boolean isempty ( ) { boolean parametersempty = _bool ; if ( parameters != null ) for ( set < accesspathtuple > paramset : this . parameters ) if ( paramset != null && ! paramset . isempty ( ) ) { parametersempty = _bool ; break ; } return ( baseobjects == null || baseobjects . isempty ( ) ) && parametersempty && ( returnvalues == null || returnvalues . isempty ( ) ) ; }	checks whether this source / sink definition is empty , i.
private static boolean snaphorizontalgrid ( point candidatepoint ) { int x = candidatepoint . x ; x = ( x / scenedraw . grid_spacing ) * scenedraw . grid_spacing ; candidatepoint . x = x ; return _bool ; }	snap the widget on the horizontal axis to widgetsview . grid_spacing.
public string next ( ) { seq += inc ; if ( seq >= maxseq ) { randomizeprefix ( ) ; resetsequential ( ) ; } char [ ] b = new char [ totallen ] ; system . arraycopy ( pre , _num , b , _num , prelen ) ; int i = b . length ; for ( long l = seq ; i > prelen ; l /= base ) { i -- ; b [ i ] = digits [ ( int ) ( l % base ) ] ; } return new string ( b ) ; }	generate the next nuid string from this instance .
public void log ( string message , throwable exception ) { mylogwriter . println ( message ) ; exception . printstacktrace ( mylogwriter ) ; }	log the specified message and exception .
protected set < tuconstraint > aftotuconstraints ( set < ? extends afconstraint > afconstraints , set < typevariable > targets ) { final set < tuconstraint > outgoing = new linkedhashset < > ( ) ; for ( final afconstraint afconstraint : afconstraints ) { if ( ! afconstraint . isirreducible ( targets ) ) { errorreporter . errorabort ( _str + _str + pluginutil . join ( _str , afconstraints ) + _str + _str + pluginutil . join ( _str , targets ) + _str ) ; } outgoing . add ( afconstraint . totuconstraint ( ) ) ; } return outgoing ; }	convert afconstraints to tuconstraints.
public void addsharedavatar ( avatarconfig config ) { config . addcredentials ( this ) ; post ( this . url + _str , config . toxml ( ) ) ; }	add the shared avatar to the bot ' s avatars .
@ suppresswarnings ( { _str } ) public static boolean containsall ( map < ? , ? > base , map < ? , ? > map ) { assert base != null ; assert map != null ; for ( map . entry < ? , ? > entry : map . entryset ( ) ) if ( base . containskey ( entry . getkey ( ) ) ) { object val = base . get ( entry . getkey ( ) ) ; if ( val == null && entry . getvalue ( ) == null ) continue ; if ( val == null || entry . getvalue ( ) == null || ! val . equals ( entry . getvalue ( ) ) ) return _bool ; } else return _bool ; return _bool ; }	checks if the map passed in is contained in base map .
public final assertsubscriber < t > assertnotterminated ( ) { if ( cdl . getcount ( ) == _num ) { throw new assertionerror ( _str , null ) ; } return this ; }	assert no complete successfully or error signal has been received .
protected void commitconnection ( connection conn ) throws jobpersistenceexception { if ( conn != null ) { try { conn . commit ( ) ; } catch ( sqlexception e ) { throw new jobpersistenceexception ( _str + e . getmessage ( ) , e ) ; } } }	commit the supplied connection.
private string appendcommatext ( string result , string append , boolean addcomma ) { if ( result != null && ! result . isempty ( ) ) { if ( append != null && ! append . isempty ( ) ) { if ( addcomma ) result += getstring ( r . string . format_comma_prefix , append ) ; else result += getstring ( r . string . format_space_prefix , append ) ; } return result ; } else { return append ; } }	the method combines two strings.
final protected void firedirtyevent ( ) { assertnotreadonly ( ) ; final idirtylistener l = this . listener ; if ( l == null ) return ; if ( thread . interrupted ( ) ) { throw new runtimeexception ( new interruptedexception ( ) ) ; } l . dirtyevent ( this ) ; }	fire an event to the listener ( iff set ) .
public static list < vm > createvmlist ( int brokerid , int vmsnumber ) { list < vm > vms = new arraylist < vm > ( ) ; for ( int i = _num ; i < vmsnumber ; i ++ ) { int vmtype = i / ( int ) math . ceil ( ( double ) vmsnumber / constants . vm_types ) ; vms . add ( new powervm ( i , brokerid , constants . vm_mips [ vmtype ] , constants . vm_pes [ vmtype ] , constants . vm_ram [ vmtype ] , constants . vm_bw , constants . vm_size , _num , _str , new cloudletschedulerdynamicworkload ( constants . vm_mips [ vmtype ] , constants . vm_pes [ vmtype ] ) , constants . scheduling_interval ) ) ; } return vms ; }	creates the vm list .
private void initdxsettings ( ) { try { boolean d3d = ! settings . getboolean ( _str ) ; system . setproperty ( _str , d3d . tostring ( ) ) ; boolean ddraw = settings . getboolean ( _str ) ; system . setproperty ( _str , ddraw . tostring ( ) ) ; logger . info ( _str + d3d + _str + ddraw ) ; } catch ( securityexception ex ) { logger . warning ( _str + ex . getlocalizedmessage ( ) ) ; } }	based on the current renametings , rename the system properties to disable direct3d and / or directdraw .
public identityarraylist ( collection < ? extends e > c ) { elementdata = c . toarray ( ) ; size = elementdata . length ; if ( elementdata . getclass ( ) != object [ ] . class ) elementdata = arrays . copyof ( elementdata , size , object [ ] . class ) ; }	constructs a list containing the elements of the specified collection , in the order they are returned by the collection ' s iterator .
public static void println ( boolean x ) { out . println ( x ) ; }	prints a boolean to standard output and then terminates the line .
gridclientdatafactory ( set < gridclientcacheflag > flags ) { this . flags = flags ; }	factory which creates projections with given flags .
public static string encodejavaopts ( string javaopts ) { string javaoptsbase64 = datatypeconverter . printbase64binary ( javaopts . getbytes ( charset . forname ( _str ) ) ) ; return string . format ( _str , javaoptsbase64 . replace ( _str , _str ) ) ; }	encode the jvm options < br > 1.
public static boolean cantranslate ( string unlocalizedstring ) { if ( i18n . haskey ( unlocalizedstring ) ) return _bool ; else { if ( unlocalized_strings . size ( ) < _num && ! unlocalized_strings . contains ( unlocalizedstring ) ) unlocalized_strings . add ( unlocalizedstring ) ; return _bool ; } }	use this function if you want the string to be logged in debug mode.
public boolean drawimage ( image img , int x , int y , int width , int height , imageobserver observer ) { return drawimage ( img , x , y , width , height , null , observer ) ; }	draws an image scaled to x , y , w , h in nonblocking mode with a callback object .
public bayesupdatereditor ( rowsummingexactwrapper wrapper ) { this ( ( updaterwrapper ) wrapper ) ; }	constructs a new instanted model editor from a bayes im wrapper .
public static arraylist < string > extracttsconf ( string [ ] frame ) { arraylist < string > sorti = new arraylist < > ( ) ; string info = general . hextobin ( frame [ _num ] ) ; for ( ; info . length ( ) < _num ; ) { info = _str + info ; } string timeslot = string . valueof ( integer . parseint ( info . substring ( _num , _num ) , _num ) ) ; if ( info . charat ( _num ) == _str ) { sorti . add ( timeslot ) ; sorti . add ( _str ) ; } else { sorti . add ( timeslot ) ; sorti . add ( _str ) ; } return sorti ; }	extract time slot used for an immediate assignment ( frame has to be splitted before ).
private static int [ ] add ( int [ ] x , int [ ] y ) { if ( x . length < y . length ) { int [ ] tmp = x ; x = y ; y = tmp ; } int xindex = x . length ; int yindex = y . length ; int result [ ] = new int [ xindex ] ; long sum = _num ; if ( yindex == _num ) { sum = ( x [ -- xindex ] & long_mask ) + ( y [ _num ] & long_mask ) ; result [ xindex ] = ( int ) sum ; } else { while ( yindex > _num ) { sum = ( x [ -- xindex ] & long_mask ) + ( y [ -- yindex ] & long_mask ) + ( sum > > > _num ) ; result [ xindex ] = ( int ) sum ; } } boolean carry = ( sum > > > _num != _num ) ; while ( xindex > _num && carry ) carry = ( ( result [ -- xindex ] = x [ xindex ] + _num ) == _num ) ; while ( xindex > _num ) result [ -- xindex ] = x [ xindex ] ; if ( carry ) { int bigger [ ] = new int [ result . length + _num ] ; system . arraycopy ( result , _num , bigger , _num , result . length ) ; bigger [ _num ] = _num ; return bigger ; } return result ; }	adds the contents of the int arrays x and y.
@ rpcmethod public void provision ( list < string > datastorelist , set < string > imagedatastores , boolean usedforvms , string hostaddress , int hostport , double memoryovercommit , string loggingendpoint , string loglevel , statspluginconfig statspluginconfig , boolean managementonly , string hostid , string deploymentid , string ntpendpoint , asyncmethodcallback < agentcontrol . asyncclient . provision_call > handler ) throws rpcexception { ensureclient ( ) ; hashset < imagedatastore > imagedatastoreset = new hashset < > ( ) ; imagedatastores . foreach ( null ) ; provisionrequest provisionrequest = new provisionrequest ( ) ; provisionrequest . setdatastores ( datastorelist ) ; provisionrequest . setaddress ( new serveraddress ( hostaddress , hostport ) ) ; provisionrequest . setmemory_overcommit ( memoryovercommit ) ; provisionrequest . setmanagement_only ( managementonly ) ; provisionrequest . sethost_id ( hostid ) ; provisionrequest . setdeployment_id ( deploymentid ) ; provisionrequest . setntp_endpoint ( ntpendpoint ) ; provisionrequest . setimage_datastores ( imagedatastoreset ) ; provisionrequest . setstats_plugin_config ( statspluginconfig ) ; clientproxy . settimeout ( provision_timeout_ms ) ; logger . info ( _str , gethostip ( ) , provisionrequest ) ; try { clientproxy . provision ( provisionrequest , handler ) ; } catch ( texception e ) { throw new rpcexception ( e . getmessage ( ) ) ; } }	this method performs an asynchronous thrift call to provision an agent.
protected void removesunnypath ( ) { super . removesunnypath ( ) ; }	trims path data from the end to the first sun covered block.
public int pgrp ( ) { return integer . parseint ( fields [ _num ] ) ; }	the process group id of the process .
public void reportdeferreddiagnostics ( set < jcdiagnostic . kind > kinds ) { jcdiagnostic d ; while ( ( d = deferred . poll ( ) ) != null ) { if ( kinds . contains ( d . getkind ( ) ) ) prev . report ( d ) ; } deferred = null ; }	report selected deferred diagnostics .
static < k extends comparable < k > , v > smallsortedmap < k , v > newinstancefortest ( int arraysize ) { return new smallsortedmap < k , v > ( arraysize ) ; }	creates a new instance for testing .
private static void check ( methoddesc prev , methoddesc desc ) { if ( prev . types == null || arrays . equals ( prev . types , desc . types ) ) { stringbuffer buf = new stringbuffer ( ) ; prev . tostring ( buf , _bool ) ; buf . append ( _str ) ; desc . tostring ( buf , _bool ) ; throw new illegalargumentexception ( buf . tostring ( ) ) ; } }	throws illegalargumentexception if the parameter types of prev cover those of desc .
public tagtransformation ( string sourcetag , string desttag , boolean preservesourceattributes ) { this . sourcetag = sourcetag . tolowercase ( ) ; if ( desttag == null ) { this . desttag = null ; } else { this . desttag = utils . isvalidxmlidentifier ( desttag ) ? desttag . tolowercase ( ) : sourcetag ; } this . preservesourceattributes = preservesourceattributes ; }	creates new tag transformation from source tag to target tag specifying whether source tag attributes are preserved .
public solrconfig ( ) throws parserconfigurationexception , ioexception , saxexception { this ( ( solrresourceloader ) null , default_conf_file , null ) ; }	creates a default instance from the solrconfig.
public static void toxml ( final pluginscollectionconfig toconvert , final outputstream stream , boolean prettyxml ) throws jaxbexception { marshaller varmarshaller = getmarshaller ( prettyxml ) ; varmarshaller . marshal ( toconvert , stream ) ; }	converts pluginscollectionconfig to xml ,.
protected static void assureresultsdirectoryexists ( string resultsdirectory ) { file dir = new file ( resultsdirectory ) ; if ( ! dir . exists ( ) ) { runtimesingleton . info ( _str ) ; if ( dir . mkdirs ( ) ) { runtimesingleton . info ( _str ) ; } else { string errmsg = _str ; runtimesingleton . warn ( errmsg ) ; fail ( errmsg ) ; } } }	assures that the results directory exists.
public list < allocationcommand > commands ( ) { return this . commands ; }	get the commands wrapped by this instance.
public void deviceadded ( mtpdevice device ) ;	called when a new device has been added.
private void promoteinlinehandlertoreferencehandler ( int newpagenumber ) throws ioexception { int oldstartpage = _startpage ; bitset oldpagenumbers = ( bitset ) _pagenumbers . clone ( ) ; cleartableandpages ( ) ; _tablebuffer . put ( getrowstart ( ) , map_type_reference ) ; writetable ( ) ; _handler = new referencehandler ( ) ; readdpages ( oldstartpage , oldpagenumbers , newpagenumber ) ; }	promotes and inline usage map to a reference usage map .
int usecache ( solrcache sc , int numgets , int maxkey , int seed ) { int ret = _num ; random r = new random ( seed ) ; for ( int i = _num ; i < numgets ; i ++ ) { integer k = r . nextint ( maxkey ) ; integer v = ( integer ) sc . get ( k ) ; if ( v == null ) { sc . put ( k , k ) ; ret ++ ; } } return ret ; }	public void testperf ( ) { doperftest ( 1000000 , 100000 , 200000 ) ; / / big cache , warmup doperftest ( 2000000 , 100000 , 200000 ) ; / / big cache doperftest ( 2000000 , 100000 , 120000 ) ; / / smaller key space increases distance between oldest , newest and makes the first passes less effective . doperftest ( 6000000 , 1000 , 2000 ) ; / / small cache , smaller hit rate doperftest ( 6000000 , 1000 , 1200 ) ; / / small cache , bigger hit rate }.
final public int d ( ) { return d ; }	the number of hash functions used by this filter .
void updatestyleslisteningto ( ) { synchronized ( listeningstyles ) { stylecontext styles = ( stylecontext ) getattributecontext ( ) ; if ( stylechangelistener == null ) { stylechangelistener = createstylechangelistener ( ) ; } if ( stylechangelistener != null && styles != null ) { enumeration stylenames = styles . getstylenames ( ) ; vector v = ( vector ) listeningstyles . clone ( ) ; listeningstyles . removeallelements ( ) ; list < changelistener > stalelisteners = abstractchangehandler . getstalelisteners ( stylechangelistener ) ; while ( stylenames . hasmoreelements ( ) ) { string name = ( string ) stylenames . nextelement ( ) ; style astyle = styles . getstyle ( name ) ; int index = v . indexof ( astyle ) ; listeningstyles . addelement ( astyle ) ; if ( index == - _num ) { for ( changelistener l : stalelisteners ) { astyle . removechangelistener ( l ) ; } astyle . addchangelistener ( stylechangelistener ) ; } else { v . removeelementat ( index ) ; } } for ( int counter = v . size ( ) - _num ; counter >= _num ; counter -- ) { style astyle = ( style ) v . elementat ( counter ) ; astyle . removechangelistener ( stylechangelistener ) ; } if ( listeningstyles . size ( ) == _num ) { stylechangelistener = null ; } } } }	adds a changelistener to new styles , and removes changelistener from old styles .
public schematicreader ( nbtinputstream inputstream ) { checknotnull ( inputstream ) ; this . inputstream = inputstream ; }	create a new instance .
public void organize ( ) { if ( debug ) { logger . fine ( _str ) ; } initfileholder ( ) ; iterator it = filenames . iterator ( ) ; dtednametranslator dnt = gettranslator ( ) ; while ( it . hasnext ( ) ) { file file = ( file ) it . next ( ) ; string filename = file . getabsolutepath ( ) ; try { dnt . set ( filename ) ; int l = dnt . getlevel ( ) ; int lt = ( int ) ( dnt . getlat ( ) + _num ) ; int ln = ( int ) ( dnt . getlon ( ) + _num ) ; if ( debug ) { logger . fine ( _str + filename + _str + l + _str + lt + _str + ln + _str ) ; } files [ l ] [ lt ] [ ln ] = file ; } catch ( formatexception fe ) { continue ; } catch ( arrayindexoutofboundsexception aioobe ) { continue ; } } }	after all the files have been located , organized them spatially in the 3d array .
public shape createarrowleft ( final double x , final double y , final double w , final double h ) { path . reset ( ) ; path . moveto ( x + w , y ) ; path . lineto ( x , y + h / _num ) ; path . lineto ( x + w , y + h ) ; path . closepath ( ) ; return path ; }	return a path for an arrow pointing to the left .
@ override public string tostring ( ) { final stringbuffer nodestring = new stringbuffer ( ) ; for ( final instruction instruction : m_instructions ) { nodestring . append ( instruction . tostring ( ) ) ; nodestring . append ( _str ) ; } return nodestring . tostring ( ) ; }	returns a string representation of the code node .
private static string removetrailingspace ( string raw ) { char c ; int i = raw . length ( ) - _num ; for ( ; i >= _num ; i -- ) { c = raw . charat ( i ) ; if ( c != _str && c != _str ) { break ; } } return raw . substring ( _num , i + _num ) ; }	remove trailing space and tab from the raw string and return the new string .
public file createfileobject ( string path ) { if ( path . length ( ) >= _num && path . charat ( _num ) == _str && character . isletter ( path . charat ( _num ) ) ) { if ( path . length ( ) == _num ) { path += _str ; } else if ( path . charat ( _num ) != _str ) { path = path . substring ( _num , _num ) + _str + path . substring ( _num ) ; } } return super . createfileobject ( path ) ; }	returns a file object constructed from the given path string .
protected void fillandsort ( final int dim ) { for ( int j = _num ; j < size ; j ++ ) { e e = get ( j ) ; minsorting [ j ] . first = e . getmin ( dim ) ; minsorting [ j ] . second = j ; maxsorting [ j ] . first = e . getmax ( dim ) ; maxsorting [ j ] . second = j ; } arrays . sort ( minsorting ) ; arrays . sort ( maxsorting ) ; }	fill the array with the dimension projection needed for sorting .
public appendablesequenceaudioinputstream ( audioformat audioformat , collection < audioinputstream > audioinputstreams ) { super ( audioformat , audioinputstreams != null ? audioinputstreams : arrays . aslist ( new audioinputstream [ _num ] ) ) ; }	create a sequence audio input stream to which more audioinputstreams can be appended after creation.
public launcheredgeeffect ( ) { mpaint . setantialias ( _bool ) ; mpaint . setstyle ( paint . style . fill ) ; minterpolator = new decelerateinterpolator ( ) ; }	construct a new edgeeffect with a theme appropriate for the provided context .
public void doundo ( ) { if ( undo . canundo ( ) ) { undo . undo ( ) ; parse ( ) ; } }	perform an undo action , if possible.
public list < type > randomsplit ( random rand , double ... splits ) { if ( splits . length < _num ) throw new illegalargumentexception ( _str ) ; intlist randorder = new intlist ( getsamplesize ( ) ) ; listutils . addrange ( randorder , _num , getsamplesize ( ) , _num ) ; collections . shuffle ( randorder , rand ) ; int [ ] stops = new int [ splits . length ] ; double sum = _num ; for ( int i = _num ; i < splits . length ; i ++ ) { sum += splits [ i ] ; if ( sum >= _num ) throw new illegalargumentexception ( _str + i + _str + sum ) ; stops [ i ] = ( int ) math . round ( sum * randorder . size ( ) ) ; } list < type > datasets = new arraylist < type > ( splits . length ) ; int prev = _num ; for ( int i = _num ; i < stops . length ; i ++ ) { datasets . add ( getsubset ( randorder . sublist ( prev , stops [ i ] ) ) ) ; prev = stops [ i ] ; } return datasets ; }	splits the dataset randomly into proportionally sized partitions .
final public mutablestring append ( mutablestring s ) { if ( s == null ) s = null ; final int l = s . length ( ) ; if ( l == _num ) return this ; final int newlength = length ( ) + l ; expand ( newlength ) ; system . arraycopy ( s . array , _num , array , newlength - l , l ) ; hashlength = hashlength < _num ? - _num : newlength ; return this ; }	appends the given mutable string to this mutable string .
private void liveinatstatement ( ) { if ( statementindex == _num ) { blockn . addlivein ( regv ) ; bitset preds = blockn . getpredecessors ( ) ; liveoutblocks . or ( preds ) ; } else { statementindex -= _num ; nextfunction = nextfunction . live_out_at_statement ; } }	" v is live - in at s . ".
public void delete ( ) throws ioexception { close ( ) ; if ( m_channel . isopen ( ) ) throw new illegalstateexception ( _str ) ; if ( m_halogfile . exists ( ) ) { try { m_halogfile . delete ( ) ; } catch ( securityexception se ) { log . warn ( _str , se ) ; } } }	requests that the underlying log file is deleted .
public void removewatcher ( angularobjectwatcher watcher ) { synchronized ( watchers ) { watchers . remove ( watcher ) ; } }	remove a watcher from this object.
protected void enginesetpadding ( string padding ) throws nosuchpaddingexception { if ( ! padding . equalsignorecase ( _str ) ) { throw new nosuchpaddingexception ( _str + padding + _str ) ; } }	should never be called .
private void destroyinternalsession ( sessionid sessionid ) { internalsession sess = sessionaccessmanager . removeinternalsession ( sessionid ) ; if ( sess != null && sess . getstate ( ) != invalid ) { signalremove ( sess , sessioneventtype . destroy ) ; sessionauditor . auditactivity ( sess . tosessioninfo ( ) , am_session_destroyed ) ; } sessionaccessmanager . removesessionid ( sessionid ) ; }	destroy a internal session , whose session id has been specified .
public object eval ( string statements , namespace namespace ) throws evalerror { string s = ( statements . endswith ( _str ) ? statements : statements + _str ) ; return eval ( new stringreader ( s ) , namespace , _str + showevalstring ( s ) + _str ) ; }	evaluate the string in the specified namespace .
private void checkormarkprivateaccess ( expression source , methodnode mn ) { if ( mn == null ) { return ; } classnode declaringclass = mn . getdeclaringclass ( ) ; classnode enclosingclassnode = typecheckingcontext . getenclosingclassnode ( ) ; if ( declaringclass != enclosingclassnode || typecheckingcontext . getenclosingclosure ( ) != null ) { int mods = mn . getmodifiers ( ) ; boolean samemodule = declaringclass . getmodule ( ) == enclosingclassnode . getmodule ( ) ; string packagename = declaringclass . getpackagename ( ) ; if ( packagename == null ) { packagename = _str ; } if ( ( modifier . isprivate ( mods ) && samemodule ) ) { addprivatefieldormethodaccess ( source , declaringclass , statictypesmarker . pv_methods_access , mn ) ; } else if ( modifier . isprotected ( mods ) && ! packagename . equals ( enclosingclassnode . getpackagename ( ) ) && ! implementsinterfaceorissubclassof ( enclosingclassnode , declaringclass ) ) { classnode cn = enclosingclassnode ; while ( ( cn = cn . getouterclass ( ) ) != null ) { if ( implementsinterfaceorissubclassof ( cn , declaringclass ) ) { addprivatefieldormethodaccess ( source , cn , statictypesmarker . pv_methods_access , mn ) ; break ; } } } } }	given a method node , checks if we are calling a private method from an inner class .
@ px private int calculateindicatordotstart ( ) { final int dotcount = indicatordots . size ( ) ; final float halfdotcount = dotcount / _num ; final int dotwidth = _num * dotradius ; final float totaldotwidth = dotwidth * halfdotcount ; final float halfdotpaddingcount = math . max ( halfdotcount - _num , _num ) ; final float totaldotpaddingwidth = dotpadding * halfdotpaddingcount ; int startposition = getwidth ( ) / _num ; startposition -= totaldotwidth + totaldotpaddingwidth ; return startposition ; }	calculate the starting horizontal position for the line of indicator dots.
public static number power ( number self , number exponent ) { double base , exp , answer ; base = self . doublevalue ( ) ; exp = exponent . doublevalue ( ) ; answer = math . pow ( base , exp ) ; if ( ( double ) ( ( int ) answer ) == answer ) { return ( int ) answer ; } else if ( ( double ) ( ( long ) answer ) == answer ) { return ( long ) answer ; } else { return answer ; } }	power of a number to a certain exponent.
public void addmeta ( t meta ) { if ( meta != null ) { if ( mmeta == null ) { mmeta = new arraylist < > ( ) ; } mmeta . add ( meta ) ; } }	add single meta - data to range object .
public static double girardarea ( s2point a , s2point b , s2point c ) { s2point ab = s2point . crossprod ( a , b ) ; s2point bc = s2point . crossprod ( b , c ) ; s2point ac = s2point . crossprod ( a , c ) ; return math . max ( _num , ab . angle ( ac ) - ab . angle ( bc ) + bc . angle ( ac ) ) ; }	return the area of the triangle computed using girard ' s formula.
public void writefloat ( float value ) throws ioexception { writesi32 ( float . floattointbits ( value ) ) ; }	write a float value.
public compositelistener addlistener ( jamonlistener listener ) { if ( listener instanceof compositelistener || ! haslistener ( listener . getname ( ) ) ) { listenerlist . add ( listener ) ; } return this ; }	add a listener to the composite and return this object.
public static string escapeelemententities ( string str ) { if ( str == null ) return null ; stringbuffer buffer ; char ch ; string entity ; buffer = null ; for ( int i = _num ; i < str . length ( ) ; i ++ ) { ch = str . charat ( i ) ; switch ( ch ) { case _str : entity = _str ; break ; case _str : entity = _str ; break ; case _str : entity = _str ; break ; case _str : entity = _str ; break ; default : entity = null ; break ; } if ( buffer == null ) { if ( entity != null ) { buffer = new stringbuffer ( str . length ( ) + _num ) ; buffer . append ( str . substring ( _num , i ) ) ; buffer . append ( entity ) ; } } else { if ( entity == null ) { buffer . append ( ch ) ; } else { buffer . append ( entity ) ; } } } return ( buffer == null ) ? str : buffer . tostring ( ) ; }	this will take the three pre - defined entities in xml 1.
private set < osmelement > findviaelements ( way way ) { set < osmelement > result = new hashset < osmelement > ( ) ; for ( node n : way . getnodes ( ) ) { for ( way w : logic . getwaysfornode ( n ) ) { if ( w . gettagwithkey ( tags . key_highway ) != null ) { result . add ( w ) ; result . add ( n ) ; } } } return result ; }	finds which ways or nodes can be used as a via element in a restriction relation.
public wordwrap append ( string s ) { s = collapsews ( s ) ; string prependnext = s . endswith ( _str ) ? _str : _str ; s = prepend + trimright ( s ) ; prepend = prependnext ; breakiterator bi = breakiterator . getlineinstance ( ) ; bi . settext ( s ) ; int endoflast = _num ; int ii ; for ( ii = _num ; ii < s . length ( ) ; ii ++ ) { if ( exceedswidth ( endoflast , ii ) ) { endoflast = addlinebreak ( s , bi , endoflast , ii ) ; } } if ( exceedswidth ( endoflast , ii ) ) { ii -- ; endoflast = addlinebreak ( s , bi , endoflast , ii ) ; } s = s . substring ( endoflast ) ; out . append ( s ) ; return this ; }	appends the given string to the output .
public < r > futurew < r > flatmapcf ( final function < ? super t , ? extends completionstage < ? extends r > > mapper ) { return futurew . < r > of ( future . < r > thencompose ( null ) ) ; }	a flatmap operation that accepts a completeablefuture completionstage as the return type.
public static boolean isgeoheaderenabledforurl ( context context , string url , boolean isincognito ) { if ( isincognito ) return _bool ; if ( ! urlutilities . nativeisgooglesearchurl ( url ) ) return _bool ; uri uri = uri . parse ( url ) ; if ( ! https_scheme . equals ( uri . getscheme ( ) ) ) return _bool ; if ( islocationdisabledforurl ( uri ) ) return _bool ; return _bool ; }	whether the geo header is allowed to be sent for the current url .
public list < statistics > loadalldeepfromcursor ( cursor cursor ) { int count = cursor . getcount ( ) ; list < statistics > list = new arraylist < statistics > ( count ) ; if ( cursor . movetofirst ( ) ) { if ( identityscope != null ) { identityscope . lock ( ) ; identityscope . reserveroom ( count ) ; } try { do { list . add ( loadcurrentdeep ( cursor , _bool ) ) ; } while ( cursor . movetonext ( ) ) ; } finally { if ( identityscope != null ) { identityscope . unlock ( ) ; } } } return list ; }	reads all available rows from the given cursor and returns a list of new imageto objects .
public void commit ( ) throws sqlexception { if ( useconnection == null ) { log . info ( _str ) ; return ; } try { useconnection . commit ( ) ; } catch ( sqlexception e ) { log . warning ( _str + e . getmessage ( ) ) ; throw e ; } }	if this sql object was created with a connection then this method commits the connection.
public final void reset ( int [ ] dims ) { if ( dims == null ) { cells = null ; } else { if ( dims . length < _num ) { throw new illegalargumentexception ( _str + _str ) ; } for ( int i = _num ; i < dims . length ; i ++ ) { if ( dims [ i ] < _num ) { throw new illegalargumentexception ( _str + i + _str + _str + dims [ i ] ) ; } } this . numcells = _num ; for ( int dim : dims ) { this . numcells *= dim ; } cells = new hashmap < > ( ) ; this . dims = new int [ dims . length ] ; system . arraycopy ( dims , _num , this . dims , _num , dims . length ) ; } }	resets the table , allowing a different dimensionality.
private static boolean isnewcomment ( idocument document , int commandoffset , string partitioning ) { try { int lineindex = document . getlineofoffset ( commandoffset ) + _num ; if ( lineindex >= document . getnumberoflines ( ) ) { return _bool ; } iregion line = document . getlineinformation ( lineindex ) ; itypedregion partition = textutilities . getpartition ( document , partitioning , commandoffset , _bool ) ; int partitionend = partition . getoffset ( ) + partition . getlength ( ) ; if ( line . getoffset ( ) >= partitionend ) { return _bool ; } if ( document . getlength ( ) == partitionend ) { return _bool ; } string comment = document . get ( partition . getoffset ( ) , partition . getlength ( ) ) ; if ( comment . indexof ( _str , _num ) != - _num ) { return _bool ; } return _bool ; } catch ( badlocationexception e ) { return _bool ; } }	guesses if the command operates within a newly created sql multi - line comment or not.
protected bufferedimage scruborgetnewbufferedimage ( bufferedimage currentimage , int width , int height ) { int cwidth = - _num ; int cheight = - _num ; if ( currentimage != null ) { cwidth = currentimage . getwidth ( ) ; cheight = currentimage . getheight ( ) ; } if ( currentimage != null && cwidth == width && cheight == height ) { graphics2d graphics = ( graphics2d ) currentimage . getgraphics ( ) ; graphics . setcomposite ( alphacomposite . clear ) ; graphics . fillrect ( _num , _num , width , height ) ; graphics . setcomposite ( alphacomposite . srcover ) ; return null ; } return new bufferedimage ( width , height , bufferedimage . type_int_argb ) ; }	given the current image buffer , and the desired width and height of the new projection , return a fresh / refreshed image buffer ready for layer painting.
protected final void computeminmaxfromstrip ( datatype datatype , int numstrips , int size , int width , int height ) throws ioexception { if ( istream != null ) { istream . close ( ) ; } istream = new fileimageinputstream ( new file ( datafilepath ) ) ; istream . seek ( imagestart ) ; minimum = new double [ samplesperpixel ] ; arrays . fill ( minimum , double . max_value ) ; maximum = new double [ samplesperpixel ] ; arrays . fill ( maximum , - double . max_value ) ; byte [ ] bbarray = new byte [ size ] ; bytebuffer bbuf = bytebuffer . wrap ( bbarray ) ; bbuf . order ( byteorder ) ; bbuf . rewind ( ) ; for ( int i = _num ; i < numstrips ; ++ i ) { int h = math . min ( rasterlength - height * i , height ) ; int len = h * width * bytespersample ; istream . read ( bbarray , _num , len ) ; bbuf . rewind ( ) ; computeminmax ( bbuf ) ; } }	compute minimum and maximum .
public static byte [ ] generatex509publickey ( publickey publickey ) throws exception { x509encodedkeyspec x509encodedpublickey = key_factory . getkeyspec ( publickey , x509encodedkeyspec . class ) ; return x509encodedpublickey . getencoded ( ) ; }	generates x509 encoded public key bytes from a given public key .
private void drawviewsatlist ( ) { for ( int i = _num ; i < listviews . size ( ) ; ++ i ) { detailview dvview = listviews . get ( i ) ; view vchild = getchildat ( i ) ; int il = dvview . getpoint ( ) . x * munitwidth ; int it = dvview . getpoint ( ) . y * munitheight ; int ir = il + dvview . getwidthnum ( ) * munitwidth ; int ib = it + dvview . getheightnum ( ) * munitheight ; vchild . setleft ( il + mviewpadding ) ; vchild . settop ( it + mviewpadding ) ; vchild . setright ( ir - mviewpadding ) ; vchild . setbottom ( ib - mviewpadding ) ; } }	draw child views according to detailview ' s position in listviews.
protected double findmaximumticklabelheight ( list ticks , graphics2d g2 , rectangle2d drawarea , boolean vertical ) { rectangleinsets insets = getticklabelinsets ( ) ; font font = getticklabelfont ( ) ; g2 . setfont ( font ) ; double maxheight = _num ; if ( vertical ) { fontmetrics fm = g2 . getfontmetrics ( font ) ; iterator iterator = ticks . iterator ( ) ; while ( iterator . hasnext ( ) ) { tick tick = ( tick ) iterator . next ( ) ; rectangle2d labelbounds = null ; if ( tick instanceof logtick ) { logtick lt = ( logtick ) tick ; if ( lt . getattributedlabel ( ) != null ) { labelbounds = attrstringutils . gettextbounds ( lt . getattributedlabel ( ) , g2 ) ; } } else if ( tick . gettext ( ) != null ) { labelbounds = textutilities . gettextbounds ( tick . gettext ( ) , g2 , fm ) ; } if ( labelbounds != null && labelbounds . getwidth ( ) + insets . gettop ( ) + insets . getbottom ( ) > maxheight ) { maxheight = labelbounds . getwidth ( ) + insets . gettop ( ) + insets . getbottom ( ) ; } } } else { linemetrics metrics = font . getlinemetrics ( _str , g2 . getfontrendercontext ( ) ) ; maxheight = metrics . getheight ( ) + insets . gettop ( ) + insets . getbottom ( ) ; } return maxheight ; }	a utility method for determining the height of the tallest tick label .
public final boolean equals ( object obj ) { return super . equals ( obj ) ; }	finalizes the equals method.
@ override public boolean isvalid ( ) { return valid ; }	returns true when this destinationobject is valid .
private annotation [ ] extract ( annotation label ) throws exception { class union = label . annotationtype ( ) ; method [ ] list = union . getdeclaredmethods ( ) ; if ( list . length != _num ) { throw new unionexception ( _str , label , type ) ; } method method = list [ _num ] ; object value = method . invoke ( label ) ; return ( annotation [ ] ) value ; }	this is used to extract the individual annotations associated with the union annotation provided.
public void add ( final t value ) { add ( root , collections . singleton ( value ) ) ; rebalanceifnecessary ( ) ; }	simple add : might break balance ! recommended to build the full tree at construction.
public int size ( ) { return buffer . size ( ) ; }	get the number of items in queue.
public void close ( jarfile jarfile ) { synchronized ( instance ) { url urlremoved = urlcache . remove ( jarfile ) ; if ( urlremoved != null ) filecache . remove ( urlutil . urlnofragstring ( urlremoved ) ) ; } }	callback method of the urljarfileclosecontroller to indicate that the jarfile is close . this way we can remove the jarfile from the cache.
void releaseobject ( long object , boolean dissociate ) { if ( dissociate ) { try { portdissociate ( port , port_source_file , object ) ; } catch ( unixexception x ) { } } long name = unsafe . getaddress ( object + offset_fo_name ) ; unsafe . freememory ( name ) ; unsafe . freememory ( object ) ; }	frees all resources for an file_obj object ; optionally remove association from port.
public static byte moveoneitemstack ( object atileentity1 , object atileentity2 , byte agrabfrom , byte aputto , list < itemstack > afilter , boolean ainvertfilter , byte amaxtargetstacksize , byte amintargetstacksize , byte amaxmoveatonce , byte aminmoveatonce ) { if ( atileentity1 instanceof iinventory ) return moveoneitemstack ( ( iinventory ) atileentity1 , atileentity2 , agrabfrom , aputto , afilter , ainvertfilter , amaxtargetstacksize , amintargetstacksize , amaxmoveatonce , aminmoveatonce , _bool ) ; return _num ; }	moves stack from inv - side to inv - side .
public void pop ( ) { int size = level . size ( ) - _num ; object ob = level . remove ( size ) ; if ( ob != null ) { symb = ( symbmap ) ob ; if ( size == _num ) { cloned = _bool ; } else { cloned = ( level . get ( size - _num ) != symb ) ; } } else { cloned = _bool ; } }	pop a frame . inclusive or exclusive .
public jspruntimecontext ( servletcontext context , options options ) { this . context = context ; this . options = options ; int hashsize = options . getinitialcapacity ( ) ; jsps = new concurrenthashmap < string , jspservletwrapper > ( hashsize ) ; bytecodes = new concurrenthashmap < string , byte [ ] > ( hashsize ) ; bytecodebirthtimes = new concurrenthashmap < string , long > ( hashsize ) ; packagemap = new concurrenthashmap < string , map < string , javafileobject > > ( ) ; if ( log . isloggable ( level . finest ) ) { classloader parentclassloader = getparentclassloader ( ) ; if ( parentclassloader != null ) { log . finest ( localizer . getmessage ( _str , parentclassloader . tostring ( ) ) ) ; } else { log . finest ( localizer . getmessage ( _str , _str ) ) ; } } initclasspath ( ) ; if ( context instanceof org . apache . jasper . servlet . jspcservletcontext ) { return ; } if ( constants . is_security_enabled ) { initsecurity ( ) ; } string appbase = context . getrealpath ( _str ) ; if ( ! options . getdevelopment ( ) && appbase != null && options . getcheckinterval ( ) > _num && ! options . getuseprecompiled ( ) ) { if ( appbase . endswith ( file . separator ) ) { appbase = appbase . substring ( _num , appbase . length ( ) - _num ) ; } string directory = appbase . substring ( appbase . lastindexof ( file . separator ) ) ; threadname = threadname + _str + directory + _str ; threadstart ( ) ; } }	create a jspruntimecontext for a web application context.
public static void loadexcludesresource ( string resourcename ) throws ioexception { excludes . clear ( ) ; excludes . putall ( loadpropertiesfromresource ( resourcename ) ) ; }	load excludes from resource in current class loader .
public static string displayinputs ( string name , map < string , object > map , localvariablemap symboltable ) { stringbuilder sb = new stringbuilder ( ) ; sb . append ( name ) ; sb . append ( _str ) ; set < string > keys = map . keyset ( ) ; if ( keys . isempty ( ) ) { sb . append ( _str ) ; } else { int count = _num ; for ( string key : keys ) { object object = map . get ( key ) ; @ suppresswarnings ( _str ) class clazz = object . getclass ( ) ; string type = clazz . getsimplename ( ) ; if ( object instanceof javardd < ? > ) { type = _str ; } else if ( object instanceof rdd < ? > ) { type = _str ; } sb . append ( _str ) ; sb . append ( ++ count ) ; sb . append ( _str ) ; sb . append ( _str ) ; sb . append ( type ) ; if ( doessymboltablecontainmatrixobject ( symboltable , key ) ) { sb . append ( _str ) ; } else if ( doessymboltablecontainframeobject ( symboltable , key ) ) { sb . append ( _str ) ; } sb . append ( _str ) ; sb . append ( key ) ; sb . append ( _str ) ; string str = object . tostring ( ) ; str = stringutils . abbreviate ( str , _num ) ; sb . append ( str ) ; sb . append ( _str ) ; } } return sb . tostring ( ) ; }	obtain a display of script inputs .
@ override public int compareto ( firewallrule rule ) { return this . priority - rule . priority ; }	comparison method for collections . sort method.
public boolean beginisrequireddisplay ( childdisplayevent event ) { boolean required = _bool ; if ( ( requiredlist != null ) && ! requiredlist . isempty ( ) ) { string s = ( string ) requiredlist . get ( curtile - _num ) ; if ( ( s != null ) && ( s . length ( ) > _num ) ) { required = _bool ; } } return required ; }	begins display of required marked element.
private static void sparseprobabilisticoverlaptest ( final ischemaversion schemaversion ) throws ioexception { final writer output = openoutput ( schemaversion , _str , testtype . union ) ; final random random = new random ( randomlong ( ) ) ; final hll hll = newhll ( hlltype . empty ) ; final hll emptyhll = newhll ( hlltype . empty ) ; cumulativeunionline ( output , hll , emptyhll , schemaversion ) ; for ( int i = _num ; i < sparse_threshold ; i ++ ) { final hll sparsehll = newhll ( hlltype . sparse ) ; final int registerindex = math . abs ( random . nextint ( ) ) % register_count ; final int registervalue = ( ( math . abs ( random . nextint ( ) ) % register_max_value ) + _num ) ; final long rawvalue = constructhllvalue ( log2m , registerindex , registervalue ) ; sparsehll . addraw ( rawvalue ) ; cumulativeunionline ( output , hll , sparsehll , schemaversion ) ; } output . flush ( ) ; output . close ( ) ; }	unions an empty accumulator with sparse hlls , each having a single register set , twice in a row to verify that the set properties are satisfied . format : cumulative union tests : - empty u sparse - sparse u sparse.
public throwable ( ) { super ( ) ; fillinstacktrace ( ) ; }	constructs a new instance of this class with its walkback filled in .
@ override public double calculatedistance ( double [ ] x1 , double [ ] x2 ) { double prod = a * innerproduct ( x1 , x2 ) + b ; double e1 = math . exp ( prod ) ; double e2 = math . exp ( - prod ) ; return ( ( e1 - e2 ) / ( e1 + e2 ) ) ; }	subclasses must implement this method .
public static byte [ ] downloadbitmaptomemory ( context context , string urlstring , int maxbytes ) { httpurlconnection urlconnection = null ; bytearrayoutputstream out = null ; inputstream in = null ; try { final url url = new url ( urlstring ) ; urlconnection = ( httpurlconnection ) url . openconnection ( ) ; if ( urlconnection . getresponsecode ( ) != httpurlconnection . http_ok ) { return null ; } in = new bufferedinputstream ( urlconnection . getinputstream ( ) , io_buffer_size_bytes ) ; out = new bytearrayoutputstream ( io_buffer_size_bytes ) ; final byte [ ] buffer = new byte [ _num ] ; int total = _num ; int bytesread ; while ( ( bytesread = in . read ( buffer ) ) != - _num ) { total += bytesread ; if ( total > maxbytes ) { return null ; } out . write ( buffer , _num , bytesread ) ; } return out . tobytearray ( ) ; } catch ( final ioexception e ) { log . e ( tag , _str + e ) ; } finally { if ( urlconnection != null ) { urlconnection . disconnect ( ) ; } try { if ( out != null ) { out . close ( ) ; } if ( in != null ) { in . close ( ) ; } } catch ( final ioexception e ) { log . e ( tag , _str + e ) ; } } return null ; }	download a bitmap from a url , write it to a disk and return the file pointer.
public static string vocabstring ( ) { stringwriter sw = new stringwriter ( vocabulary . systemsize ( ) * _num ) ; try { systemindex . savetowriter ( sw ) ; return sw . tostring ( ) ; } catch ( ioexception e ) { logger . error ( _str ) ; } return _str ; }	write the vocabulary to a string .
public multimodulescriptprovider ( iterable < ? extends modulescriptprovider > providers ) { final list < modulescriptprovider > l = new linkedlist < modulescriptprovider > ( ) ; for ( modulescriptprovider provider : providers ) { l . add ( provider ) ; } this . providers = l . toarray ( new modulescriptprovider [ l . size ( ) ] ) ; }	creates a new multiplexing module script provider tht gathers the specified providers.
private void insertsnapshot ( final cselectionsnapshot snapshot ) { final cselectionhistorytreenode selection = new cselectionhistorytreenode ( snapshot , m_stateindex ) ; for ( final navinode node : snapshot . getselection ( ) ) { selection . add ( new cnodenode ( node ) ) ; } m_stateindex ++ ; m_model . insertnodeinto ( selection , ( cselectionhistorytreenode ) m_model . getroot ( ) , _num ) ; }	adds a new selection state to the history chooser .
public final long decrementandget ( ) { for ( ; ; ) { long current = get ( ) ; long next = current - _num ; if ( compareandset ( current , next ) ) return next ; } }	atomically decrements by one the current value .
private static boolean issegmentexpression ( final string value ) { return ( value . endswith ( _str ) && issegment ( value . substring ( _num , value . length ( ) - _num ) ) ) ; }	this is needed to identify if a particular expression is a segment register .
public string tostring ( ) { return string . format ( _str , value ) ; }	return a hex representation of the byte .
@ override public resource createrelative ( string relativepath ) throws malformedurlexception { if ( relativepath . startswith ( _str ) ) { relativepath = relativepath . substring ( _num ) ; } return new urlresource ( new url ( this . url , relativepath ) ) ; }	this implementation creates a urlresource , applying the given path relative to the path of the underlying url of this resource descriptor .
private void drawchunk ( image image , graphics g , boolean stretch , int dx1 , int dy1 , int dx2 , int dy2 , int sx1 , int sy1 , int sx2 , int sy2 , boolean xdirection ) { if ( dx2 - dx1 <= _num || dy2 - dy1 <= _num || sx2 - sx1 <= _num || sy2 - sy1 <= _num ) { return ; } if ( stretch ) { g . drawimage ( image , dx1 , dy1 , dx2 , dy2 , sx1 , sy1 , sx2 , sy2 , null ) ; } else { int xsize = sx2 - sx1 ; int ysize = sy2 - sy1 ; int deltax ; int deltay ; if ( xdirection ) { deltax = xsize ; deltay = _num ; } else { deltax = _num ; deltay = ysize ; } while ( dx1 < dx2 && dy1 < dy2 ) { int newdx2 = math . min ( dx2 , dx1 + xsize ) ; int newdy2 = math . min ( dy2 , dy1 + ysize ) ; g . drawimage ( image , dx1 , dy1 , newdx2 , newdy2 , sx1 , sy1 , sx1 + newdx2 - dx1 , sy1 + newdy2 - dy1 , null ) ; dx1 += deltax ; dy1 += deltay ; } } }	draws a portion of an image , stretched or tiled .
public void testcargodaemonwelcomepage ( ) throws exception { pingutils . assertpingtrue ( _str , _str , cargodaemonbrowsertest . daemonurl , logger ) ; }	test the daemon welcome page .
public static document jsoup2dom ( org . jsoup . nodes . document jsoupdocument ) { document document = null ; try { documentbuilderfactory docbuilderfactory = documentbuilderfactory . newinstance ( ) ; documentbuilder docbuilder = docbuilderfactory . newdocumentbuilder ( ) ; document = docbuilder . newdocument ( ) ; map < string , string > nsmap = new hashmap < string , string > ( ) ; createdom ( jsoupdocument , document , document , nsmap ) ; } catch ( parserconfigurationexception pce ) { throw new runtimeexception ( pce ) ; } return document ; }	returns a w3c dom that exposes the same content as the supplied jsoup document into a w3c dom .
protected void assertbusinessobjectdata ( integer expecteddataversion , businessobjectdata actualbusinessobjectdata ) { assertbusinessobjectdata ( expecteddataversion , gettestattributes ( ) , gettestbusinessobjectdataparents ( ) , actualbusinessobjectdata ) ; }	validates actualbusinessobjectdata contents against specified arguments and expected ( hard coded ) test values .
private static kdbgroup deserializegroup ( kdbgroup lastgroup , datainput datainput ) throws ioexception { int fieldtype ; kdbgroup group = new kdbgroup ( ) ; while ( ( fieldtype = datainput . readunsignedshort ( ) ) != _num ) { switch ( fieldtype ) { case _num : readextdata ( datainput ) ; break ; case _num : uuid uuid = new uuid ( _num , readint ( datainput ) ) ; group . setuuid ( uuid ) ; break ; case _num : group . setname ( readstring ( datainput ) ) ; break ; case _num : group . setcreationtime ( readdate ( datainput ) ) ; break ; case _num : group . setlastmodificationtime ( readdate ( datainput ) ) ; break ; case _num : group . setlastaccesstime ( readdate ( datainput ) ) ; break ; case _num : group . setexpirytime ( readdate ( datainput ) ) ; break ; case _num : group . seticon ( new kdbicon ( readint ( datainput ) ) ) ; break ; case _num : int level = readshort ( datainput ) ; group . setparent ( computeparentgroup ( lastgroup , level ) ) ; break ; case _num : group . setflags ( readint ( datainput ) ) ; break ; default : throw new illegalstateexception ( _str ) ; } } datainput . readint ( ) ; return group ; }	deserialize a kdbgroup from a data source and attach it to the group structure of a database.
public int lastindexof ( string string ) { return lastindexof ( string , length ( ) ) ; }	searches in this string for the last index of the specified string.
public builder withtruststorepassword ( string truststorepassword ) { properties . setproperty ( nettyoptions . ssl_trust_store_password , assert . notnull ( truststorepassword , _str ) ) ; return this ; }	sets the ssl trust store password .
private void sendtapevent ( bitset bitset , shift shift , boolean decision ) { if ( msymboleventtap != null ) { symbolevent event = new symbolevent ( bitset . get ( _num , msymbollength ) , msymbollength , decision , shift ) ; msymboleventtap . receive ( event ) ; } }	sends instrumentation tap event to all registered listeners.
public final void addrequiredimports ( set < declaredtypename > imports ) { imports . add ( typeconstants . property ) ; imports . add ( typeconstants . values_storage ) ; imports . add ( getmodelsuperclass ( ) ) ; for ( propertygenerator generator : propertygenerators ) { generator . registerrequiredimports ( imports ) ; } addmodelspecificimports ( imports ) ; pluginbundle . addrequiredimports ( imports ) ; }	adds imports required by this model spec to the given accumulator set.
public void validatebusinessobjectdataavailability ( businessobjectdataavailabilityrequest request , list < businessobjectdatastatus > expectedavailablestatuses , list < businessobjectdatastatus > expectednotavailablestatuses , businessobjectdataavailability actualbusinessobjectdataavailability ) { assertnotnull ( actualbusinessobjectdataavailability ) ; assertequals ( request . getnamespace ( ) , actualbusinessobjectdataavailability . getnamespace ( ) ) ; assertequals ( request . getbusinessobjectdefinitionname ( ) , actualbusinessobjectdataavailability . getbusinessobjectdefinitionname ( ) ) ; assertequals ( request . getbusinessobjectformatusage ( ) , actualbusinessobjectdataavailability . getbusinessobjectformatusage ( ) ) ; assertequals ( request . getbusinessobjectformatfiletype ( ) , actualbusinessobjectdataavailability . getbusinessobjectformatfiletype ( ) ) ; assertequals ( request . getbusinessobjectformatversion ( ) , actualbusinessobjectdataavailability . getbusinessobjectformatversion ( ) ) ; assertequals ( request . getpartitionvaluefilter ( ) , actualbusinessobjectdataavailability . getpartitionvaluefilter ( ) ) ; assertequals ( request . getbusinessobjectdataversion ( ) , actualbusinessobjectdataavailability . getbusinessobjectdataversion ( ) ) ; assertequals ( request . getstoragename ( ) , actualbusinessobjectdataavailability . getstoragename ( ) ) ; assertequals ( expectedavailablestatuses , actualbusinessobjectdataavailability . getavailablestatuses ( ) ) ; assertequals ( expectednotavailablestatuses , actualbusinessobjectdataavailability . getnotavailablestatuses ( ) ) ; }	validates business object data availability against specified arguments and expected ( hard coded ) test values .
public void unlockui ( ) { generatecomplete ( ) ; }	unlock user interface . called from the worker when processing is done.
public void remove ( t object ) { int pos ; synchronized ( mlock ) { pos = getposition ( object ) ; if ( pos == - _num ) return ; mobjects . remove ( pos ) ; } if ( mnotifyonchange ) notifyitemremoved ( pos ) ; }	removes the specified object from the array .
private void prebufferaccess ( ) { _mostrecentuse = system . currenttimemillis ( ) ; _lock . lock ( ) ; try { while ( _flushpending ) { _flushcomplete . await ( ) ; } ensurebufferavailable ( this ) ; ensureloaded ( ) ; _bufferusecount ++ ; } catch ( exception e ) { throw throwables . propagate ( e ) ; } finally { _lock . unlock ( ) ; } }	called prior to reading from or writing to the block.
private void addmethod ( mappedclass clazz , string [ ] parts ) { string original = _str ; string newname = _str ; string desc = _str ; if ( parts . length == _num ) { original = parts [ _num ] ; newname = parts [ _num ] ; desc = parts [ _num ] ; } else if ( parts . length == _num ) { original = parts [ _num ] ; newname = parts [ _num ] ; desc = parts [ _num ] ; } else { return ; } if ( desc . contains ( _str ) ) { desc = desc . replace ( _str , _str ) ; } mappedmember mm = new mappedmember ( clazz , findmethod ( clazz . getnode ( ) , original , desc ) , - _num , desc , original ) ; mm . setnewname ( newname ) ; clazz . addmethod ( mm ) ; }	add a method to the given class .
public synchronized void animatepanandzoomto ( final point2d p , double scale , long duration ) { point2d pp = new point2d . double ( ) ; m_itransform . transform ( p , pp ) ; animatepanandzoomtoabs ( pp , scale , duration ) ; }	animate a pan to the specified location in screen ( pixel ) co - ordinates and zoom to the given scale using the provided duration .
private int modifyallcontacts ( iterator < string > contactsiter ) { int totalcontactsmodified = _num ; while ( contactsiter . hasnext ( ) ) totalcontactsmodified += modifycontact ( contactsiter . next ( ) , contactsiter . next ( ) ) ; return totalcontactsmodified ; }	synchronously modify all contacts designated by the iterator .
public consoleprintstream ( java . io . outputstream out ) { super ( out , _bool ) ; }	create a consoleprintstream on the specified outputstream , usually system.
void addchangesrecursively ( server server , list < materialrevision > outchanges ) throws malformedurlexception , ioexception { if ( ! changed ) { return ; } if ( ! ispipeline ( ) ) { if ( ! outchanges . contains ( this ) ) outchanges . add ( this ) ; } else { for ( modification m : modifications ) { matcher matcher = pipeline_revision_pattern . matcher ( m . revision ) ; if ( matcher . matches ( ) ) { string pipelinename = matcher . group ( _num ) ; int pipelinecounter = integer . parseint ( matcher . group ( _num ) ) ; pipeline pipeline = server . getpipelineinstance ( pipelinename , pipelinecounter ) ; pipeline . addchangesrecursively ( server , outchanges ) ; } else { log . error ( _str + m . revision ) ; } } } }	collect all changed materialrevision objects , walking changed " pipeline " objects recursively instead of including them directly .
public boolean addmember ( principal p ) { return _bool ; }	adds the specified member to the group .
private parsed currentparsed ( ) { return parsed . get ( parsed . size ( ) - _num ) ; }	gets the currently active temporal objects .
public void commit ( ) { activevalues . clear ( ) ; activevalues . addall ( pendingvalues ) ; }	makes the pending values active .
public void firepropertychange ( string propertyname , double oldvalue , double newvalue ) { if ( changesupport == null || oldvalue == newvalue ) { return ; } firepropertychange ( propertyname , double . valueof ( oldvalue ) , double . valueof ( newvalue ) ) ; }	reports a bound property change .
protected list < iresource > updatecache ( iresource parent , final isvnstatus [ ] statuses ) throws coreexception { final list < iresource > result = new arraylist < iresource > ( ) ; if ( statuses != null ) { for ( isvnstatus status : statuses ) { iresource resource = svnworkspaceroot . getresourcefor ( parent , status ) ; result . add ( updatecache ( resource , status ) ) ; } } return result ; }	update the cache using the given statuses.
private boolean finishline ( boolean sawnewline ) throws ioexception { handleline ( line . tostring ( ) , sawreturn ? ( sawnewline ? _str : _str ) : ( sawnewline ? _str : _str ) ) ; line = new stringbuilder ( ) ; sawreturn = _bool ; return sawnewline ; }	called when a line is complete .
public static set < string > putsetintomap ( string key , map < string , set < string > > map , string value ) { set < string > set = new hashset < string > ( ) ; set . add ( value ) ; map . put ( key , set ) ; return set ; }	returns set of string.
static string toc ( string identifier ) { return identifier . replace ( _str , _str ) ; }	get the c + + representation of this identifier .
public static selectmanagerjni create ( ) { try { if ( ! isenabled ( ) ) { return null ; } selectmanagerjni pollmanager = _jniselectmanager . get ( ) ; if ( pollmanager == null ) { pollmanager = new selectmanagerjni ( ) ; if ( pollmanager . start ( ) ) { _jniselectmanager . set ( pollmanager ) ; } } return _jniselectmanager . get ( ) ; } catch ( configexception e ) { log . finer ( e . tostring ( ) ) ; } catch ( throwable e ) { log . log ( level . finer , e . tostring ( ) , e ) ; } return null ; }	returns a jni select manager .
public listenablesocketchannel ( socketchannel channel , executor executor , asyncselector selectorthread ) throws ioexception { logger . debug ( _str , channel ) ; if ( channel == null || executor == null ) throw new illegalargumentexception ( ) ; if ( channel . isblocking ( ) ) throw new illegalargumentexception ( _str ) ; this . channel = channel ; this . executor = executor ; this . selector = selectorthread ; selector . register ( channel , _num , sellistener ) ; }	create async - socket wrapper over given socket channel , given listener handling thread , and given selector thread .
public static routingkey create ( object object ) { return new routingkey ( object . hashcode ( ) ) ; }	creates a routingkey by invoking hashcode on a given object.
private boolean runconfig ( ) { if ( lineseparator == null ) { logger . error ( _str ) ; return _bool ; } if ( categoryidentifers == null ) { logger . error ( _str ) ; return _bool ; } if ( languageidentifers == null ) { logger . error ( _str ) ; return _bool ; } if ( imageidentifers == null ) { logger . error ( _str ) ; return _bool ; } if ( templateparser == null ) { logger . error ( _str ) ; return _bool ; } return _bool ; }	checks if the configuration is runnable .
private void connect ( inetaddress anaddr , int aport , int timeout ) throws ioexception { inetaddress normaladdr = anaddr . isanylocaladdress ( ) ? inetaddress . getlocalhost ( ) : anaddr ; if ( streaming && usingsocks ( ) ) { socksconnect ( anaddr , aport , _num ) ; } else { iobridge . connect ( fd , normaladdr , aport , timeout ) ; } super . address = normaladdr ; super . port = aport ; }	connects this socket to the specified remote host address / port .
public double convertwalkdistancetowalktime ( double walkdistance ) { double walktime = null ; switch ( studyareacode ) { case _num : double a = _num ; double b = _num ; double c = - _num ; double d = _num ; double wt = a + b * walkdistance + c * math . pow ( walkdistance , _num ) + d * math . pow ( walkdistance , _num ) ; walktime = wt * _num ; break ; default : break ; } return walktime ; }	converts a given walking distance value ( in meters ) into a walking time value ( in sec ) .
@ override protected statement classblock ( runnotifier notifier ) { return childreninvoker ( notifier ) ; }	implements behavior from : org.
public static boolean [ ] convertstringtobooleanarr ( string nodictionarycolmapping ) { string [ ] splittedvalue = null != nodictionarycolmapping ? nodictionarycolmapping . split ( carboncommonconstants . coma_spc_character ) : new string [ _num ] ; boolean [ ] nodictionarymapping = new boolean [ splittedvalue . length ] ; int index = _num ; for ( string str : splittedvalue ) { nodictionarymapping [ index ++ ] = boolean . parseboolean ( str ) ; } return nodictionarymapping ; }	this will convert string to boolean [ ] .
@ deprecated protected void insertatboundry ( jeditorpane editor , htmldocument doc , int offset , element insertelement , string html , html . tag parenttag , html . tag addtag ) { element e ; element commonparent ; boolean isfirst = ( offset == _num ) ; if ( offset > _num || insertelement == null ) { e = doc . getdefaultrootelement ( ) ; while ( e != null && e . getstartoffset ( ) != offset && ! e . isleaf ( ) ) { e = e . getelement ( e . getelementindex ( offset ) ) ; } commonparent = ( e != null ) ? e . getparentelement ( ) : null ; } else { commonparent = insertelement ; } if ( commonparent != null ) { int pops = _num ; int pushes = _num ; if ( isfirst && insertelement != null ) { e = commonparent ; while ( e != null && ! e . isleaf ( ) ) { e = e . getelement ( e . getelementindex ( offset ) ) ; pops ++ ; } } else { e = commonparent ; offset -- ; while ( e != null && ! e . isleaf ( ) ) { e = e . getelement ( e . getelementindex ( offset ) ) ; pops ++ ; } e = commonparent ; offset ++ ; while ( e != null && e != insertelement ) { e = e . getelement ( e . getelementindex ( offset ) ) ; pushes ++ ; } } pops = math . max ( _num , pops - _num ) ; inserthtml ( editor , doc , offset , html , pops , pushes , addtag ) ; } }	this is invoked when inserting at a boundary.
protected genericcontainer deserializewithschemaandversion ( string topic , boolean iskey , byte [ ] payload ) throws serializationexception { return ( genericcontainer ) deserialize ( _bool , topic , iskey , payload , null ) ; }	deserializes the payload and includes schema information , with version information from the schema registry embedded in the schema .
public static boolean amfetcher ( ) { return isfetcher ( thread . currentthread ( ) ) ; }	checks to see if the current thread is one of the imagefetchers .
public static int readints ( final file f , final int fileoffset , final int fileend , final commonindex a , final long offset , final long addend ) throws ioexception { final int length = ( fileend - fileoffset ) * _num ; final byte [ ] b = new byte [ length ] ; try ( inputstream stream = new fileinputstream ( f ) ) { int remaining = fileoffset * _num ; long skipped ; while ( remaining > _num && ( skipped = fileutils . streamskip ( stream , remaining ) ) > _num ) { remaining -= ( int ) skipped ; } if ( remaining > _num ) { throw new ioexception ( ) ; } int sofar = _num ; int read ; while ( sofar < length && ( read = stream . read ( b , sofar , length - sofar ) ) > _num ) { sofar += read ; } if ( sofar < length ) { throw new ioexception ( ) ; } } for ( int i = _num ; i < b . length ; i += _num ) { a . set ( offset + i / _num , bytearrayioutils . bytestointbigendian ( b , i ) + addend ) ; } return b . length / _num ; }	read an array of longs from a file .
thread newstartedthread ( runnable runnable ) { thread t = new thread ( runnable ) ; t . setdaemon ( _bool ) ; t . start ( ) ; return t ; }	returns a new started daemon thread running the given runnable .
protected void connectionup ( ) { if ( connectedstatus != null ) { connectedstatus . settext ( status_connected ) ; connectedstatus . setbackground ( color . green ) ; } }	callback for the netmapreader to let it provide the connector with connection status .
public r paramstojsonentity ( ) { try { mhttpentity = createjsonstreamerentity ( null ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } return ( r ) this ; }	convert params to json entity .
public static void debug ( final throwable throwable ) { final stringwriter errors = new stringwriter ( ) ; throwable . printstacktrace ( new printwriter ( errors ) ) ; debuglogger . accept ( errors . tostring ( ) ) ; }	logs the stacktrace of the throwable to the debug logger .
bleachcomposer ( color c ) { int color = c . getrgb ( ) ; int [ ] components = new int [ _num ] ; splitrgb ( color , components ) ; red = math . max ( _num , components [ red ] ) ; green = math . max ( _num , components [ green ] ) ; blue = math . max ( _num , components [ blue ] ) ; }	create a new bleachcomposer for a color .
public boolean appliesto ( string line , string route ) { if ( ! lines . isempty ( ) && ! lines . contains ( line ) ) return _bool ; if ( ! routes . isempty ( ) && ! routes . contains ( route ) ) return _bool ; return _bool ; }	determines whether this pricing policy applies to a certain type of vehicle.
private void outputwarehouses ( properties ctx , printwriter out , int orgid , int warehouseid , boolean includeany ) { out . println ( _str + orgid + _str ) ; if ( includeany ) { out . println ( _str ) ; if ( warehouseid == _num ) out . println ( _str ) ; out . println ( _str ) ; } for ( mwarehouse warehouse : mwarehouse . getfororg ( ctx , orgid ) ) { out . print ( _str + warehouse . getm_warehouse_id ( ) + _str ) ; if ( warehouseid == warehouse . getm_warehouse_id ( ) ) out . print ( _str ) ; out . println ( _str + util . maskhtml ( warehouse . getname ( ) ) + _str ) ; } out . println ( _str ) ; }	output xml list of warehouses.
private static void usage ( string s ) { err . println ( _str + s + _str ) ; err . println ( _str ) ; err . println ( _str ) ; err . println ( _str ) ; err . println ( _str ) ; err . println ( _str ) ; system . exit ( _num ) ; }	prints usage information about this program.
static public uniquestring resolvesynonym ( uniquestring name ) { operator n = ( operator ) definitiontable . get ( name ) ; if ( n == null ) return name ; else return n . getidentifier ( ) ; }	resolvesynonym has the property that * resolvesynonym ( a ) = resolvesynonym ( b ) * iff either a = b or a and b are synonyms ( like ( + ) and \ oplus ).
public static void start ( string [ ] args ) { startedasservice = _bool ; startcmr ( ) ; }	start function . needed by procrun .
public static boolean recycle ( file file ) { if ( osutils . iswindows ( ) && isloaded ) { string path = null ; try { path = file . getcanonicalpath ( ) ; } catch ( ioexception err ) { log . error ( _str , err ) ; path = file . getabsolutepath ( ) ; } return recyclenative ( path ) ; } else { return _bool ; } }	moves a file to the platform - specific trash can or recycle bin .
public void update ( int from , int to ) { change . source < ? > source = idrangechangesource . foritems ( from , to , _num ) ; executorservice executorservice = new threadpoolexecutor ( _num , _num , _num , timeunit . seconds , new linkedblockingqueue < runnable > ( ) ) ; wikibaseuris uris = new wikibaseuris ( _str ) ; update < ? > update = new update < > ( source , wikibaserepository , rdfrepository ( ) , munger , executorservice , _num , uris , _bool ) ; update . run ( ) ; executorservice . shutdown ( ) ; }	update all ids from from to to .
public void write ( byte [ ] b , int o , int len ) { while ( len > _num ) { int n = len <= availlen ? len : availlen ; system . arraycopy ( b , o , buf , offset , n ) ; incrementoffset ( n ) ; len -= n ; o += n ; } }	this should rarely be used , the normal way ( to avoid double copying ) is to get the buffer and write directly to it.
public void writeupdate ( logoutputstream out , object value ) throws exception { marshaloutputstream s = new marshaloutputstream ( out ) ; s . writeobject ( value ) ; s . flush ( ) ; }	writes the representation ( a serializable object ) of an update to a stream.
public static symbol getbuiltinsymbol ( string str , boolean pcalmode ) { symbol sym ; if ( pcalmode ) { sym = ( symbol ) pcalbuiltinhashtable . get ( str ) ; } else { sym = ( symbol ) builtinhashtable . get ( str ) ; } if ( sym == null || ( sym . pcal && ! pcalmode ) ) { return null ; } return sym ; }	returns the built - in symbol with string str.
@ override public datatable sample ( int newsize ) { int rowcount = getrownumber ( ) ; if ( rowcount <= newsize ) { return this ; } int [ ] sampledselectedindices = new int [ rowcount ] ; for ( int i = _num ; i < rowcount ; ++ i ) { sampledselectedindices [ i ] = i ; } random rng = new random ( _num ) ; int swapidx ; int tmpvalue ; for ( int i = _num ; i < rowcount ; ++ i ) { swapidx = rng . nextint ( rowcount ) ; tmpvalue = sampledselectedindices [ swapidx ] ; sampledselectedindices [ swapidx ] = sampledselectedindices [ i ] ; sampledselectedindices [ i ] = tmpvalue ; } datatableview sampleddatatable = new datatableview ( this ) ; vector < integer > sampledselectedindicesvector = new vector < integer > ( newsize ) ; for ( int i = _num ; i < newsize ; ++ i ) { sampledselectedindicesvector . add ( sampledselectedindices [ i ] ) ; } sampleddatatable . setselectedindices ( sampledselectedindicesvector ) ; return new sorteddatatableview ( sampleddatatable , sortprovider ) ; }	performs a simple sampling without replacement.
public void updateconfiguration ( @ notnull configuration configuration ) { myconfiguration = configuration ; invalidategraphicsrenderer ( ) ; }	updates the current configuration.
protected void insert ( object [ ] row ) throws sqlexception { string key = getkey ( row ) ; int hash = key . hashcode ( ) ; prepinsertrow . setint ( _num , hash ) ; prepinsertrow . setint ( _num , index . id ) ; prepinsertrow . setstring ( _num , key ) ; prepinsertrow . execute ( ) ; resultset rs = prepinsertrow . getgeneratedkeys ( ) ; rs . next ( ) ; int rowid = rs . getint ( _num ) ; prepinsertmap . setint ( _num , rowid ) ; int [ ] wordids = getwordids ( row ) ; for ( int id : wordids ) { prepinsertmap . setint ( _num , id ) ; prepinsertmap . execute ( ) ; } }	add a row to the index .
public pair < pair < string , string [ ] > , list < string > > rewrite ( list < string > results ) { string commandid = null ; string [ ] args = null ; list < string > rewrittenresults = new arraylist < > ( ) ; for ( string result : results ) { triple triple = rewrite ( result ) ; rewrittenresults . add ( triple . mstr ) ; commandid = triple . mid ; args = triple . margs ; } return new pair < > ( new pair < > ( commandid , args ) , rewrittenresults ) ; }	rewrites and returns the given results . todo : improve this.
public reliablelog ( string dirpath , loghandler handler ) throws ioexception { dir = new file ( dirpath ) ; if ( ! ( dir . exists ( ) ? dir . isdirectory ( ) : dir . mkdirs ( ) ) ) { throw new logexception ( _str + dirpath ) ; } this . handler = handler ; try { datainputstream in = new datainputstream ( new fileinputstream ( fname ( versionfile ) ) ) ; try { version = in . readint ( ) ; } finally { in . close ( ) ; } } catch ( ioexception ex ) { writeversionfile ( ) ; } if ( version < _num ) { throw new logexception ( _str ) ; } }	creates a reliablelog to handle snapshots and logging in a stable storage directory , and sets up to recover any existing data from the stable storage directory.
public static long timetakenstringtoint ( string timetakenstring ) { raptorstringtokenizer tok = new raptorstringtokenizer ( timetakenstring , _str , _bool ) ; int minutes = integer . parseint ( tok . nexttoken ( ) ) ; int seconds = integer . parseint ( tok . nexttoken ( ) ) ; int millis = integer . parseint ( tok . nexttoken ( ) ) ; return ( minutes * _num + seconds ) * _num + millis ; }	parses a string in ( 0 : 00.
private asn1encodablevector buildunauthenticatedattributes ( byte [ ] timestamptoken ) throws ioexception { if ( timestamptoken == null ) return null ; string id_time_stamp_token = _str ; asn1inputstream tempstream = new asn1inputstream ( new bytearrayinputstream ( timestamptoken ) ) ; asn1encodablevector unauthattributes = new asn1encodablevector ( ) ; asn1encodablevector v = new asn1encodablevector ( ) ; v . add ( new asn1objectidentifier ( id_time_stamp_token ) ) ; asn1sequence seq = ( asn1sequence ) tempstream . readobject ( ) ; v . add ( new derset ( seq ) ) ; unauthattributes . add ( new dersequence ( v ) ) ; return unauthattributes ; }	added by aiken sam , 2006 - 11 - 15 , modifed by martin brunecky 07 / 12 / 2007 to start with the timestamptoken ( signeddata 1.
public boolean removeentry ( t e ) { if ( e == null ) return _bool ; boolean removed = myvals . remove ( e ) ; if ( removed ) { float val = e . getval ( ) ; myvaluesum -= val ; calcminmax ( ) ; } return removed ; }	removes an entry from the datasets entries array.
@ override public void onitemclick ( adapterview < ? > parent , view view , int position , long id ) { checkbox enablecomponentcheckbox = ( checkbox ) view . findviewbyid ( r . id . enable_component_checkbox ) ; enablecomponentcheckbox . performclick ( ) ; }	called when an entry of item is clicked .
public void testlongconversionandordering ( ) throws exception { bytesref previous = null ; bytesref current = new bytesref ( new byte [ long . bytes ] ) ; for ( long value = - _num ; value < _num ; value ++ ) { numericutils . longtosortablebytes ( value , current . bytes , current . offset ) ; if ( previous == null ) { previous = new bytesref ( new byte [ long . bytes ] ) ; } else { asserttrue ( _str , previous . compareto ( current ) < _num ) ; } assertequals ( _str , value , numericutils . sortablebytestolong ( current . bytes , current . offset ) ) ; system . arraycopy ( current . bytes , current . offset , previous . bytes , previous . offset , current . length ) ; } }	generate a series of encoded longs , each numerical one bigger than the one before.
private static boolean ispaymenttyperecurse ( genericvalue paymenttype , string inputtypeid ) throws genericentityexception { string parenttypeid = paymenttype . getstring ( _str ) ; if ( parenttypeid == null ) { return _bool ; } if ( parenttypeid . equals ( inputtypeid ) ) { return _bool ; } return ispaymenttyperecurse ( paymenttype . getrelatedone ( _str , _bool ) , inputtypeid ) ; }	recurses up payment type tree via parenttypeid to see if input payment type id is in tree .
public static double pdf ( double x , double k , double theta , double shift ) { if ( x <= shift || x == double . positive_infinity ) { return _num ; } x = ( x - shift ) * theta ; final double ex = math . exp ( x ) ; return ex < double . positive_infinity ? math . exp ( k * x - ex - gammadistribution . loggamma ( k ) ) * theta : _num ; }	expgamma distribution pdf ( with 0 . 0 for x & lt ; 0 ).
public address __rmul__ ( final object rhs ) { return new address ( m_value . multiply ( getbiginteger ( rhs ) ) ) ; }	used to support reverse mul operations on addresses in python scripts .
public rulename rulename ( ) { string labelstr = tostring ( ) ; int colonlocation = labelstr . lastindexof ( _str ) ; int rulenamestart = colonlocation + _num ; string rulenamestr = labelstr . substring ( rulenamestart ) ; return rulename . create ( rulenamestr ) ; }	extract the rule name from a label.
public void exception ( throwable e ) { final string msg = e . getmessage ( ) ; log ( level . severe , msg != null ? msg : _str , e ) ; }	log an exception at the ' severe ' level .
public static boolean containsmodifiedmessage ( tlscontext tlscontext ) { return ( getmodifiedmessageposition ( tlscontext ) != - _num ) ; }	returns true in case there is a message with a modification issued by our peer.
public void remove ( historyreference href ) { synchronized ( hreflist ) { int index = hreflist . indexof ( href ) ; if ( index >= _num ) { hreflist . remove ( index ) ; firetablerowsdeleted ( index , index ) ; } } }	removes the scan result for a particular uri and method.
private static boolean isassignablefrom ( type from , parameterizedtype to , map < string , type > typevarmap ) { if ( from == null ) { return _bool ; } if ( to . equals ( from ) ) { return _bool ; } class < ? > clazz = gson types . getrawtype ( from ) ; parameterizedtype ptype = null ; if ( from instanceof parameterizedtype ) { ptype = ( parameterizedtype ) from ; } if ( ptype != null ) { type [ ] targs = ptype . getactualtypearguments ( ) ; typevariable < ? > [ ] tparams = clazz . gettypeparameters ( ) ; for ( int i = _num ; i < targs . length ; i ++ ) { type arg = targs [ i ] ; typevariable < ? > var = tparams [ i ] ; while ( arg instanceof typevariable < ? > ) { typevariable < ? > v = ( typevariable < ? > ) arg ; arg = typevarmap . get ( v . getname ( ) ) ; } typevarmap . put ( var . getname ( ) , arg ) ; } if ( typeequals ( ptype , to , typevarmap ) ) { return _bool ; } } for ( type itype : clazz . getgenericinterfaces ( ) ) { if ( isassignablefrom ( itype , to , new hashmap < string , type > ( typevarmap ) ) ) { return _bool ; } } type stype = clazz . getgenericsuperclass ( ) ; return isassignablefrom ( stype , to , new hashmap < string , type > ( typevarmap ) ) ; }	private recursive helper function to actually do the type - safe checking of assignability .
public static int prefixcodedtoint ( final bytesref val ) { int sortablebits = _num ; for ( int i = val . offset + _num , limit = val . offset + val . length ; i < limit ; i ++ ) { sortablebits <<= _num ; final byte b = val . bytes [ i ] ; if ( b < _num ) { throw new numberformatexception ( _str + integer . tohexstring ( b & _num ) + _str + ( i - val . offset ) + _str ) ; } sortablebits |= b ; } return ( sortablebits << getprefixcodedintshift ( val ) ) ^ _num ; }	returns an int from prefixcoded bytes.
@ nullable public static string mergexml ( @ notnull renderingcontext context , string sourcexml , string targetxml , file targetfile ) { boolean ok ; string filename = targetfile . getname ( ) ; string contents ; if ( filename . equals ( sdkconstants . fn_android_manifest_xml ) ) { document currentdocument = xmlutils . parsedocumentsilently ( targetxml , _bool ) ; assert currentdocument != null : targetxml + _str ; document fragment = xmlutils . parsedocumentsilently ( sourcexml , _bool ) ; assert fragment != null : sourcexml + _str ; contents = mergemanifest ( targetfile , targetxml , sourcexml ) ; ok = contents != null ; } else { string parentfoldername = targetfile . getparentfile ( ) . getname ( ) ; resourcefoldertype foldertype = resourcefoldertype . getfoldertype ( parentfoldername ) ; contents = mergeresourcefile ( context , targetxml , sourcexml , filename , foldertype ) ; ok = contents != null ; } if ( ! ok ) { contents = wrapwithmergeconflict ( targetxml , sourcexml ) ; context . getwarnings ( ) . add ( string . format ( _str , targetfile . getname ( ) ) ) ; } return contents ; }	merges sourcexml into targetxml / targetfile ( targetxml is the contents of targetfile ).
synchronized pair < string , map < variantsettype , list < variant > > > nextset ( ) throws ioexception { final pair < string , map < variantsettype , list < variant > > > set = mvariantset . nextset ( ) ; if ( set == null ) { return null ; } final string name = set . geta ( ) ; synchronized ( mnames ) { mnames . add ( name ) ; } return set ; }	loads a set from the underlying variant set with synchronization .
public static stringbuilder leftshift ( stringbuilder self , object value ) { self . append ( value ) ; return self ; }	overloads the left shift operator to provide syntactic sugar for appending to a stringbuilder .
public boolean parsekmlfile ( file file ) { mlocalfile = file ; log . d ( bonuspackhelper . log_tag , _str + mlocalfile . getabsolutepath ( ) ) ; inputstream stream ; boolean ok ; try { stream = new bufferedinputstream ( new fileinputstream ( mlocalfile ) ) ; ok = parsekmlstream ( stream , null ) ; stream . close ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; ok = _bool ; } return ok ; }	parse a kml document from a file , to build the kml structure .
private boolean isredundant ( coordinate pt ) { if ( ptlist . size ( ) < _num ) return _bool ; coordinate lastpt = ( coordinate ) ptlist . get ( ptlist . size ( ) - _num ) ; double ptdist = pt . distance ( lastpt ) ; if ( ptdist < minimimvertexdistance ) return _bool ; return _bool ; }	tests whether the given point is redundant relative to the previous point in the list ( up to tolerance ) .
private void writeescutf16 ( string s , int start , int length , boolean isattval ) throws saxexception { string substring = s . substring ( start , start + length ) ; write ( stringescapeutils . escapehtml4 ( substring ) ) ; }	write an array of data characters with escaping .
public void runtest ( ) throws throwable { document doc ; nodelist elementlist ; node namenode ; characterdata child ; string childdata ; doc = ( document ) load ( _str , _bool ) ; elementlist = doc . getelementsbytagname ( _str ) ; namenode = elementlist . item ( _num ) ; child = ( characterdata ) namenode . getfirstchild ( ) ; child . appenddata ( _str ) ; childdata = child . getdata ( ) ; assertequals ( _str , _str , childdata ) ; }	runs the test case .
public void remove ( string key ) { iterator < pair < string , arraylist < string > > > it = store . iterator ( ) ; while ( it . hasnext ( ) ) { string thiskey = it . next ( ) . first ; if ( key . equals ( thiskey ) ) { it . remove ( ) ; break ; } } }	remove a given key from the file .
public string tostring ( ) { stringbuffer s = new stringbuffer ( ) ; boolean colon = _bool ; s . append ( _str ) ; for ( typenode typenode : typenodelist ) { if ( colon ) { s . append ( _str ) ; } else { colon = _bool ; } s . append ( typenode ) ; } s . append ( _str ) ; return s . tostring ( ) ; }	returns a string representation of this object.
public final assertsubscriber < t > await ( ) { if ( cdl . getcount ( ) == _num ) { return this ; } try { cdl . await ( ) ; } catch ( interruptedexception ex ) { throw new assertionerror ( _str , ex ) ; } return this ; }	blocking method that waits until a complete successfully or error signal is received .
public static float computediscardscale ( float amount , float range , boolean fromclick ) { if ( math . abs ( amount ) < _num ) return _num ; float t = amount / range ; float endscale = fromclick ? discard_end_scale_click : discard_end_scale_swipe ; return mathutils . interpolate ( _num , endscale , math . abs ( t ) ) ; }	computes the scale of the tab based on its discard status .
public boolean finish ( ) { if ( ! started ) return _bool ; boolean ok = _bool ; started = _bool ; try { out . write ( _num ) ; out . flush ( ) ; if ( closestream ) { out . close ( ) ; } } catch ( ioexception e ) { ok = _bool ; } return ok ; }	flushes any pending data and closes output file.
public dviewcertcsrpem ( jframe parent , string title , x509certificate cert ) throws cryptoexception { super ( parent , title , dialog . modalitytype . document_modal ) ; this . cert = cert ; initcomponents ( ) ; }	creates a new dviewcertcsrpem dialog .
public static bytestring valueofutf8 ( final charsequence s ) { if ( s . length ( ) == _num ) { return empty ; } return wrap ( staticutils . getbytes ( s ) ) ; }	returns a byte string containing the utf - 8 encoded bytes of the provided char sequence .
public advancedstatemap . builder ignore ( iproperty < ? > ... properties ) { collections . addall ( this . ignored , properties ) ; return this ; }	add properties that will not be used to compute all possible states of a block , used for block rendering to ignore some property that does not alter block ' s appearance.
private static void closesafe ( closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( ioexception ignored ) { } } }	close the given closeable object ( stream ) in a safe way : check if it is null and catch - log exception thrown .
@ override public double java2dtovalue ( double java2dvalue , rectangle2d plotarea , rectangleedge edge ) { range range = getrange ( ) ; double axismin = switchedlog10 ( range . getlowerbound ( ) ) ; double axismax = switchedlog10 ( range . getupperbound ( ) ) ; double plotmin = _num ; double plotmax = _num ; if ( rectangleedge . istoporbottom ( edge ) ) { plotmin = plotarea . getx ( ) ; plotmax = plotarea . getmaxx ( ) ; } else if ( rectangleedge . isleftorright ( edge ) ) { plotmin = plotarea . getmaxy ( ) ; plotmax = plotarea . getminy ( ) ; } if ( isinverted ( ) ) { return switchedpow10 ( axismax - ( ( java2dvalue - plotmin ) / ( plotmax - plotmin ) ) * ( axismax - axismin ) ) ; } else { return switchedpow10 ( axismin + ( ( java2dvalue - plotmin ) / ( plotmax - plotmin ) ) * ( axismax - axismin ) ) ; } }	converts a coordinate in java2d space to the corresponding data value , assuming that the axis runs along one edge of the specified plotarea .
private void dotest ( stepnormalizermode mode , stepnormalizerbounds bounds , double [ ] expected , boolean reverse ) throws mathillegalargumentexception , mathillegalstateexception { odeintegrator integ = new graggbulirschstoerintegrator ( _num , _num , _num , _num ) ; integ . addstephandler ( new stepnormalizer ( _num , this , mode , bounds ) ) ; double [ ] y = { _num } ; double start = reverse ? getend ( ) : getstart ( ) ; double end = reverse ? getstart ( ) : getend ( ) ; output = new arraylist < double > ( ) ; integ . integrate ( this , new odestate ( start , y ) , end ) ; double [ ] actual = new double [ output . size ( ) ] ; for ( int i = _num ; i < actual . length ; i ++ ) { actual [ i ] = output . get ( i ) ; } assert . assertarrayequals ( expected , actual , _num ) ; }	the actual step normalizer output test code , shared by all the unit tests .
public static void waitfororkill ( process self , long numberofmillis ) { processrunner runnable = new processrunner ( self ) ; thread thread = new thread ( runnable ) ; thread . start ( ) ; runnable . waitfororkill ( numberofmillis ) ; }	wait for the process to finish during a certain amount of time , otherwise stops the process .
public void writeto ( streamoutput out ) throws ioexception { out . writestring ( name ) ; out . writestring ( type ) ; settings . writesettingstostream ( settings , out ) ; }	writes repository metadata to stream output.
public string time2utcstr ( long time ) { date date = new date ( time ) ; return ( utcdateformat . format ( date ) ) ; }	convert unix time to the utc format recognized by spice .
public void testurldecoderignoresunnecessarycharset ( ) throws exception { try { assertequals ( _str , urldecoder . decode ( _str , _str ) ) ; } catch ( unsupportedcharsetexception expected ) { } }	the ri looks up the charset lazily ; android looks it up eagerly.
public element removeelementfromregistry ( element element ) { removeelementfromregistry ( integer . tostring ( element . hashcode ( ) ) ) ; return ( this ) ; }	removes an element from the element registry.
public final < t > collection < t > parsearrayandclose ( class < ? > destinationcollectionclass , class < t > destinationitemclass ) throws ioexception { return parsearrayandclose ( destinationcollectionclass , destinationitemclass , null ) ; }	parse a json array from the given json parser ( which is closed after parsing completes ) into the given destination collection .
public void testtimedinvokeany5 ( ) throws throwable { executorservice e = new forkjoinpool ( _num ) ; poolcleaner cleaner = null ; try { cleaner = cleaner ( e ) ; long starttime = system . nanotime ( ) ; list < callable < string > > l = new arraylist < callable < string > > ( ) ; l . add ( new stringtask ( ) ) ; l . add ( new stringtask ( ) ) ; string result = e . invokeany ( l , long_delay_ms , milliseconds ) ; assertsame ( test_string , result ) ; asserttrue ( milliselapsedsince ( starttime ) < long_delay_ms ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }	timed invokeany ( c ) returns result of some task in c.
public void finish ( ) throws ioexception { closeentry ( ) ; cdoffset = new ziplong ( written ) ; for ( int i = _num ; i < entries . size ( ) ; i ++ ) { writecentralfileheader ( entries . elementat ( i ) ) ; } cdlength = new ziplong ( written - cdoffset . getvalue ( ) ) ; writecentraldirectoryend ( ) ; offsets . clear ( ) ; entries . removeallelements ( ) ; }	finishs writing the contents and closes this as well as the underlying stream .
private calendar inutc ( calendar cal ) { calendar utc = calendar . getinstance ( timezone . gettimezone ( _str ) ) ; utc . settimeinmillis ( cal . gettimeinmillis ( ) ) ; return utc ; }	gets the calendar in utc time .
public static < t extends object & java . lang . comparable < ? super t > > t max ( collection < ? extends t > collection ) { iterator < ? extends t > it = collection . iterator ( ) ; t max = it . next ( ) ; if ( numbercomparator . isnumber ( max ) ) { return ( t ) max ( collection , numbercomparator . createcomparator ( max . getclass ( ) ) ) ; } while ( it . hasnext ( ) ) { t next = it . next ( ) ; if ( max . compareto ( next ) < _num ) { max = next ; } } return max ; }	searches the specified collection for the maximum element .
@ suppresswarnings ( _str ) @ override public void onrestoreinstancestate ( parcelable state ) { if ( state instanceof bundle ) { bundle bundle = ( bundle ) state ; autolabeluisettings autolabeluisettings = bundle . getparcelable ( key_instance_state_settings ) ; if ( autolabeluisettings != null ) { setsettings ( autolabeluisettings ) ; } resetlabelscounter ( ) ; list < labelvalues > labelsadded = ( list < labelvalues > ) bundle . getserializable ( key_instance_state_labels ) ; if ( labelsadded != null ) { for ( int i = _num ; i < labelsadded . size ( ) ; i ++ ) { labelvalues labelvalues = labelsadded . get ( i ) ; if ( labelvalues . getkey ( ) == - _num ) { addlabel ( labelvalues . getvalue ( ) ) ; } else { addlabel ( labelvalues . getvalue ( ) , labelvalues . getkey ( ) ) ; } } } state = bundle . getparcelable ( key_instance_state_general ) ; } super . onrestoreinstancestate ( state ) ; }	retrieve the state of the labels when orientation screen changed .
public static keystore createemptykeystore ( string keystoretype , string provider ) { if ( keystoretype == null ) { keystoretype = _str ; } keystore keystore ; try { if ( provider == null ) { keystore = keystore . getinstance ( keystoretype ) ; } else { keystore = keystore . getinstance ( keystoretype , provider ) ; } keystore . load ( null , null ) ; } catch ( keystoreexception | certificateexception | nosuchalgorithmexception | nosuchproviderexception | ioexception e ) { throw new keystoreaccessexception ( _str + keystoretype , e ) ; } return keystore ; }	creates and initializes an empty keystore using the specified keystoretype .
public boolean checkforstringattributes ( ) { return checkforattributetype ( attribute . string ) ; }	checks for string attributes in the dataset.
public void stop ( ) { write . lock ( ) ; try { sorted . clear ( ) ; for ( route route : routes . values ( ) ) { route . destroy ( ) ; } routes . clear ( ) ; } finally { write . unlock ( ) ; } }	stops this handler , shutting down and clearing all the managed routes .
public static void clear ( ) { long lock_stamp = lock . writelock ( ) ; try { idtostring = new arraylist < > ( ) ; stringtoid = new hashmap < > ( ) ; idtostring . add ( unknown_id , unknown_word ) ; stringtoid . put ( unknown_word , unknown_id ) ; } finally { lock . unlockwrite ( lock_stamp ) ; } }	clears the vocabulary and initializes it with an unknown word.
public static void decomposition ( image inputimg , image coarseimg , image horizontalimg , image verticalimg , image diagonalimg , filter filterg , filter filterh , int method ) { image tempimg = null ; tempimg = new image ( coarseimg . getwidth ( ) , inputimg . getheight ( ) ) ; convolutelines ( tempimg , inputimg , filterh , method ) ; convoluterows ( coarseimg , tempimg , filterh , method ) ; convoluterows ( horizontalimg , tempimg , filterg , method ) ; tempimg = new image ( verticalimg . getwidth ( ) , inputimg . getheight ( ) ) ; convolutelines ( tempimg , inputimg , filterg , method ) ; convoluterows ( verticalimg , tempimg , filterh , method ) ; convoluterows ( diagonalimg , tempimg , filterg , method ) ; }	method to decompose the image.
public void lognumberofwalletbusylisteners ( ) { log . debug ( _str + walletbusylisteners . size ( ) + _str ) ; }	log the number of wallet busy listeners.
protected void writestroke ( stroke stroke ) throws ioexception { if ( stroke instanceof basicstroke ) { basicstroke ns = ( basicstroke ) stroke ; int currentcap = - _num , currentjoin = - _num ; float currentwidth = - _num , currentlimit = - _num , currentdashphase = - _num ; float [ ] currentdasharray = null ; if ( ( currentstroke != null ) && ( currentstroke instanceof basicstroke ) ) { basicstroke cs = ( basicstroke ) currentstroke ; currentcap = cs . getendcap ( ) ; currentjoin = cs . getlinejoin ( ) ; currentwidth = cs . getlinewidth ( ) ; currentlimit = cs . getmiterlimit ( ) ; currentdasharray = cs . getdasharray ( ) ; currentdashphase = cs . getdashphase ( ) ; } float width = ns . getlinewidth ( ) ; writewidth ( width ) ; int cap = ns . getendcap ( ) ; if ( currentcap != cap ) { writecap ( cap ) ; } int join = ns . getlinejoin ( ) ; if ( currentjoin != join ) { writejoin ( join ) ; } float limit = ns . getmiterlimit ( ) ; if ( ( currentlimit != limit ) && ( limit >= _num ) ) { writemiterlimit ( limit ) ; } if ( ns . getdasharray ( ) != null ) { writedash ( ns . getdasharray ( ) , ns . getdashphase ( ) ) ; } else { writedash ( new float [ _num ] , ns . getdashphase ( ) ) ; } } }	writes the current stroke.
@ override public dragsourcecontextpeer createdragsourcecontextpeer ( draggestureevent dge ) throws invaliddndoperationexception { final lightweightframe f = suntoolkit . getlightweightframe ( dge . getcomponent ( ) ) ; if ( f != null ) { return f . createdragsourcecontextpeer ( dge ) ; } return wdragsourcecontextpeer . createdragsourcecontextpeer ( dge ) ; }	create the peer for a dragsourcecontext.
public boolean generate ( projection proj ) { proj . forward ( llp1 , pt1 ) ; proj . forward ( llp2 , pt2 ) ; double dx = pt2 . x - pt1 . x ; double dy = pt2 . y - pt1 . y ; at . settotranslation ( pt1 . x , pt1 . y ) ; at . rotate ( math . atan2 ( dy , dx ) - angle , _num , _num ) ; double sc = math . sqrt ( dx * dx + dy * dy ) ; badprojection = ( double . isnan ( sc ) || sc / distance * proj . getscale ( ) > _num ) ; if ( badprojection ) debug . message ( _str , _str + str ) ; else { sc /= w ; at . scale ( sc , sc ) ; } return _bool ; }	generate with a new projection.
public static double pdf ( double x , double lambda ) { if ( x < _num ) return _num ; return lambda * math . exp ( - lambda * x ) ; }	probability density function of the exponential distribution ( mean = 1 / lambda ).
public static bufferedwriter newwriter ( path self ) throws ioexception { return files . newbufferedwriter ( self , charset . defaultcharset ( ) ) ; }	create a buffered writer for this file .
public static boolean isstdio ( string filename ) { return stdio_name . equals ( filename ) ; }	returns true if the input file is the stdin / stdout indicator.
public string encryptpassword ( ) { string nonce = getnonce ( ) ; string timestamp = getutctime ( ) ; string beforeencryption = nonce + timestamp + password ; byte [ ] encryptedraw ; try { encryptedraw = sha1 ( beforeencryption ) ; } catch ( nosuchalgorithmexception e ) { e . printstacktrace ( ) ; return null ; } string encoded = base64 . encodebase64string ( encryptedraw ) ; return encoded ; }	returns encrypted version of given password like algorithm like in ws - usernametoken.
public string tostring ( ) { stringbuffer result = new stringbuffer ( ) ; result . append ( _str + utils . doubletostring ( m_coefficient , _num , _num ) ) ; for ( int i = _num ; i < m_fieldnames . length ; i ++ ) { result . append ( _str + m_fieldnames [ i ] ) ; } result . append ( _str ) ; return result . tostring ( ) ; }	return a textual description of this predictor term .
public string [ ] list ( ) throws remoteexception { if ( ! isrunning ( ) ) { throw new illegalstateexception ( _str ) ; } return registry . list ( ) ; }	returns an array of the names bound in the rmiregistry.
public string mergename ( string a , string b ) throws mergefailed { if ( qa . bothnullorequals ( a , b ) ) return a ; if ( emptynames . contains ( a ) && ! emptynames . contains ( b ) ) return b ; if ( emptynames . contains ( b ) && ! emptynames . contains ( a ) ) return a ; return a ; }	merge two identifiers : - if they ' re equal , return one.
public void add ( k key , v [ ] items ) { set < v > values = map . get ( key ) ; if ( values == null ) { values = ( sorted ? new treeset < v > ( ) : new hashset < v > ( ) ) ; map . put ( key , values ) ; } values . addall ( arrays . aslist ( items ) ) ; }	adds all items to the set of values associated with the key.
public static placemark createwithimage ( position position , imagesource imagesource ) { return new placemark ( position , placemarkattributes . createwithimage ( imagesource ) ) ; }	this factory method creates a placemark and an associated placemarkattributes bundle that draws the given image centered on the supplied position .
public boolean isinactive ( ) { return ( maudiooutput . getlastactivitytimestamp ( ) + audio_timeout ) < system . currenttimemillis ( ) ; }	indicates if audio output is current inactive , meaning that the audio output hasn ' t recently processed any audio packets .
public void println ( object o , boolean line ) { if ( o == null ) { ps ( _str ) ; return ; } if ( o instanceof object [ ] ) { print_array ( ( object [ ] ) o ) ; return ; } if ( o instanceof int [ ] ) { print_array ( ( int [ ] ) o ) ; } if ( o instanceof string ) { ps ( ( string ) o , line ) ; return ; } if ( o instanceof exception ) { ps ( stack_to_string ( ( exception ) o ) ) ; return ; } if ( o instanceof vector ) { print_vector ( ( vector ) o ) ; return ; } if ( o instanceof hashtable ) { print_hashtable ( ( hashtable ) o ) ; return ; } if ( o instanceof date ) { print_date ( ( date ) o ) ; return ; } if ( o instanceof calendar ) { print_calendar ( ( calendar ) o ) ; return ; } ps ( o . tostring ( ) , line ) ; }	description of the method.
public void addvalue ( ifitsheader key , boolean val ) throws headercardexception { addvalue ( key . key ( ) , val , key . comment ( ) ) ; }	add or replace a key with the given boolean value and comment .
public static list < testdiagnosticline > readdiagnosticsjfo ( javafileobject toread , boolean omitemptydiagnostics ) { list < testdiagnosticline > lines = new arraylist < > ( ) ; javadiagnosticreader reader = new javadiagnosticreader ( toread , java_comment_codec ) ; while ( reader . hasnext ( ) ) { testdiagnosticline line = reader . next ( ) ; if ( ! omitemptydiagnostics || line . hasdiagnostics ( ) ) { lines . add ( line ) ; } } reader . close ( ) ; return lines ; }	reads diagnostic lines from the comments of a set of java file .
public static void sinandcos ( double angle , doublewrapper sine , doublewrapper cosine ) { if ( use_jdk_math ) { sine . value = strict_math ? strictmath . sin ( angle ) : math . sin ( angle ) ; cosine . value = strict_math ? strictmath . cos ( angle ) : math . cos ( angle ) ; return ; } boolean negateresult ; if ( angle < _num ) { angle = - angle ; negateresult = _bool ; } else { negateresult = _bool ; } if ( angle > sin_cos_max_value_for_int_modulo ) { angle = remaindertwopi ( angle ) ; if ( angle < _num ) { angle += _num * math . pi ; } } int index = ( int ) ( angle * sin_cos_indexer + _num ) ; double delta = ( angle - index * sin_cos_delta_hi ) - index * sin_cos_delta_lo ; index &= ( sin_cos_tabs_size - _num ) ; double indexsin = sintab [ index ] ; double indexcos = costab [ index ] ; double result = indexsin + delta * ( indexcos + delta * ( - indexsin * one_div_f2 + delta * ( - indexcos * one_div_f3 + delta * indexsin * one_div_f4 ) ) ) ; sine . value = negateresult ? - result : result ; cosine . value = indexcos + delta * ( - indexsin + delta * ( - indexcos * one_div_f2 + delta * ( indexsin * one_div_f3 + delta * indexcos * one_div_f4 ) ) ) ; }	computes sine and cosine together , at the cost of.
public float [ ] generatetransformedvaluesline ( list < ? extends entry > entries , float phasex , float phasey , int from , int to ) { final int count = ( int ) math . ceil ( ( to - from ) * phasex ) * _num ; float [ ] valuepoints = new float [ count ] ; for ( int j = _num ; j < count ; j += _num ) { entry e = entries . get ( j / _num + from ) ; if ( e != null ) { valuepoints [ j ] = e . getxindex ( ) ; valuepoints [ j + _num ] = e . getval ( ) * phasey ; } } pointvaluestopixel ( valuepoints ) ; return valuepoints ; }	transforms an list of entry into a float array containing the x and y values transformed with all matrices for the linechart .
public long reset ( ) { long nowns = system . nanotime ( ) ; try { return timevalue . nsectomsec ( nowns - startns ) ; } finally { startns = nowns ; } }	resets and returns elapsed time in milliseconds .
public long addmeetingmemberremindtoroom ( string sid , long room_id , string firstname , string lastname , string email , string baseurl , long language_id ) throws axisfault { try { long users_id = sessionmanagement . checksession ( sid ) ; long user_level = usermanagement . getuserlevelbyid ( users_id ) ; if ( authlevelmanagement . checkwebservicelevel ( user_level ) ) { appointment appointment = appointmentdao . getappointmentbyroom ( room_id ) ; if ( appointment == null ) { return - _num ; } long memberid = meetingmemberlogic . addmeetingmember ( firstname , lastname , _str , _str , appointment . getappointmentid ( ) , null , email , baseurl , null , new boolean ( _bool ) , language_id , _bool , _str , null , null , _str ) ; return memberid ; } else { return - _num ; } } catch ( exception err ) { log . error ( _str , err ) ; throw new axisfault ( err . getmessage ( ) ) ; } }	add a meeting member to a certain room.
private void writeobject ( objectoutputstream s ) throws ioexception { s . defaultwriteobject ( ) ; for ( e e : this ) { if ( e instanceof serializable ) { s . writeobject ( e ) ; } } s . writeobject ( null ) ; }	write the listeners to a stream .
public static boolean issystemapplication ( packagemanager packagemanager , string packagename ) { if ( packagemanager == null || packagename == null || packagename . length ( ) == _num ) { return _bool ; } try { applicationinfo app = packagemanager . getapplicationinfo ( packagename , _num ) ; return ( app != null && ( app . flags & applicationinfo . flag_system ) > _num ) ; } catch ( namenotfoundexception e ) { logger . e ( e ) ; } return _bool ; }	whether packagename is system application.
private boolean isspurious ( tempcluster clus , boolean iscore ) { return clus != null ? clus . isspurious ( minclsize ) : ( minclsize > _num || ! iscore ) ; }	spurious , also for non - materialized clusters .
public static string extract ( string s ) { string result ; result = s ; result = result . replaceall ( _str , _str ) ; result = result . replaceall ( _str , _str ) ; result = result . replaceall ( _str , _str ) ; return result ; }	extracts the revision string .
protected set < resource > dofindmatchingfilesystemresources ( file rootdir , string subpattern ) throws ioexception { if ( logger . isdebugenabled ( ) ) { logger . debug ( _str + rootdir . getpath ( ) + _str ) ; } set < file > matchingfiles = retrievematchingfiles ( rootdir , subpattern ) ; set < resource > result = new linkedhashset < resource > ( matchingfiles . size ( ) ) ; for ( file file : matchingfiles ) { result . add ( new filesystemresource ( file ) ) ; } return result ; }	find all resources in the file system that match the given location pattern via the ant - style pathmatcher .
public void debugprint ( string name , printstream out ) throws adeexception { if ( name != null ) { out . println ( _str + name + _str + getllmax ( ) ) ; } if ( m_pointscores != null && ! m_pointscores . isempty ( ) ) { for ( entry < integer , double > pointscore : m_pointscores . entryset ( ) ) { out . println ( _str + pointscore . getkey ( ) + _str + pointscore . getvalue ( ) ) ; } out . println ( _str + - m_loghalf ) ; } }	print out the object state for debugging purposes .
public static void writecentroidstofile ( clusters clusters , flagconfig flagconfig ) { vectorstoreram centroidsoutput = new vectorstoreram ( flagconfig ) ; for ( int i = _num ; i < clusters . centroids . length ; ++ i ) { centroidsoutput . putvector ( integer . tostring ( i ) , clusters . centroids [ i ] ) ; } try { vectorstorewriter . writevectors ( _str , flagconfig , centroidsoutput ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }	utility method that writes cluster centroids to a file called " cluster_centroids.
protected associationrequest ( associationsessiontype type ) { this ( type , null ) ; }	creates an association request message with the specified association type and " no - encryption " session.
public void addsignaturetimestamp ( byte [ ] timestampder ) throws exception { element unsignedproperties = getfirstelementbytagname ( document , xadeselement ( unsigned_signature_props_tag ) ) ; element signaturetimestampelement = document . createelement ( xadeselement ( signature_timestamp_tag ) ) ; string timestampderbase64 = encodebase64 ( timestampder ) ; signaturetimestampelement . settextcontent ( timestampderbase64 ) ; unsignedproperties . insertbefore ( signaturetimestampelement , unsignedproperties . getfirstchild ( ) ) ; }	adds the signaturetimestamp element containing the base64 encoded timestamp der .
public static string hashmd5 ( string str ) { return hashmd5 ( str . getbytes ( ) ) ; }	returns the md5 hash of a string .
public smaliclassdetailloader ( zipfile apkfile , boolean translateinstructions ) { arraylist < zipentry > dexentries = new arraylist < zipentry > ( ) ; dexentries . add ( apkfile . getentry ( _str ) ) ; for ( int i = _num ; i < _num ; ++ i ) { final zipentry e = apkfile . getentry ( _str + i + _str ) ; if ( e != null ) { dexentries . add ( e ) ; } else { break ; } } final int n = dexentries . size ( ) ; if ( n == _num ) { log . err ( _str ) ; } this . translateinstructions = translateinstructions ; this . resolver = translateinstructions ? new invocationresolver ( ) : null ; final opcodes opcodes = opcodes . forapi ( settings . apilevel ) ; try { dexfiles = new dexfile [ n ] ; for ( int i = _num ; i < n ; ++ i ) { dexfiles [ i ] = dexbackeddexfile . frominputstream ( opcodes , new bufferedinputstream ( apkfile . getinputstream ( dexentries . get ( i ) ) ) ) ; } } catch ( ioexception e ) { log . err ( _str ) ; log . err ( e ) ; } }	create a loader that loads from an apk file ( could contain multiple dex files ) , optionally loading instructions.
protected void filtermembers ( collection < internaldistributedmember > mbrs , set < internaldistributedmember > matchingmembers , short requesttype ) { set < internaldistributedmember > requests = getpendingrequestids ( requesttype ) ; if ( ! requests . isempty ( ) ) { logger . debug ( _str + requests . size ( ) + _str + requesttype ) ; iterator < internaldistributedmember > itr = requests . iterator ( ) ; while ( itr . hasnext ( ) ) { internaldistributedmember memberid = itr . next ( ) ; if ( mbrs . contains ( memberid ) ) { testflagforremovalrequest = _bool ; matchingmembers . add ( memberid ) ; } } } }	this gets pending requests and returns the ids of any that are in the given collection.
public boolean free ( t obj ) { int top = _top . get ( ) ; if ( top < _freestack . length ( ) ) { boolean isfree = _freestack . compareandset ( top , null , obj ) ; _top . compareandset ( top , top + _num ) ; return isfree ; } else return _bool ; }	frees the object . if the free list is full , the object will be garbage collected .
public void updatesessionmanagement ( boolean sessionmanagement ) throws securityexception { checkwriteaccess ( ) ; boolean hasaccess = configwebutil . hasaccess ( config , securitymanager . type_setting ) ; if ( ! hasaccess ) throw new securityexception ( _str ) ; element scope = _getrootelement ( _str ) ; scope . setattribute ( _str , caster . tostring ( sessionmanagement , _str ) ) ; }	enable or desable session management.
private static void buildnameline ( final inavifunctionnode node , final zylabelcontent content , final boolean showfunctioninformation ) { final inavifunction function = node . getfunction ( ) ; string informationstring = _str ; if ( function . getbasicblockcount ( ) > _num ) { final stringbuilder builder = new stringbuilder ( ) ; builder . append ( _str ) ; builder . append ( function . getbasicblockcount ( ) ) ; builder . append ( _str ) ; if ( function . getbasicblockcount ( ) > _num ) { builder . append ( _str ) ; } if ( function . getedgecount ( ) > _num ) { builder . append ( _str ) ; builder . append ( function . getedgecount ( ) ) ; builder . append ( _str ) ; if ( function . getedgecount ( ) > _num ) { builder . append ( _str ) ; } } builder . append ( _str ) ; informationstring = builder . tostring ( ) ; } final zylinecontent nameline = new zylinecontent ( function . getname ( ) + informationstring , normal_font , null ) ; content . addlinecontent ( nameline ) ; }	builds the name line of a function node .
protected void rehash ( int newcapacity ) { int oldcapacity = _set . length ; k oldkeys [ ] = ( k [ ] ) _set ; int oldvals [ ] = _values ; _set = new object [ newcapacity ] ; arrays . fill ( _set , free ) ; _values = new int [ newcapacity ] ; for ( int i = oldcapacity ; i -- > _num ; ) { if ( oldkeys [ i ] != free && oldkeys [ i ] != removed ) { k o = oldkeys [ i ] ; int index = insertionindex ( o ) ; if ( index < _num ) { throwobjectcontractviolation ( _set [ ( - index - _num ) ] , o ) ; } _set [ index ] = o ; _values [ index ] = oldvals [ i ] ; } } }	rehashes the map to the new capacity .
public static void connectionaccepted ( ) { numconnections . getandincrement ( ) ; }	informs system metrics of a connection accepted event .
private static void mapresource ( workitem resource , map < iproject , list < workitem > > projectsmap , boolean checkjavaproject ) { iproject project = resource . getproject ( ) ; if ( checkjavaproject && ! projectutilities . isjavaproject ( project ) ) { return ; } list < workitem > resources = projectsmap . get ( project ) ; if ( resources == null ) { resources = new arraylist < workitem > ( ) ; projectsmap . put ( project , resources ) ; } if ( ! containsparents ( resources , resource ) ) { resources . add ( resource ) ; } }	maps the resource into its project.
@ suppresswarnings ( _str ) @ jsoncreator public static clientdetailresponsev2 fromparts ( @ jsonproperty ( _str ) string name , @ jsonproperty ( _str ) string description , @ jsonproperty ( _str ) long createdatseconds , @ jsonproperty ( _str ) long updatedatseconds , @ jsonproperty ( _str ) string createdby , @ jsonproperty ( _str ) string updatedby , @ jsonproperty ( _str ) optional < long > lastseenseconds ) { return new autovalue_clientdetailresponsev2 ( name , description , createdatseconds , updatedatseconds , createdby , updatedby , lastseenseconds ) ; }	static factory method used by jackson for deserialization.
private synchronized int _activitycount ( ) { return m_activities . size ( ) ; }	returns the number of scheduled activities.
double [ ] createrealdata ( final int n ) { final random random = new random ( seed ) ; final double [ ] data = new double [ n ] ; for ( int i = _num ; i < n ; i ++ ) { data [ i ] = _num * random . nextdouble ( ) - _num ; } return data ; }	returns a random array of doubles.
default properties asproperties ( ) { return asproperties ( null ) ; }	get a copy of these configuration properties as a properties object .
public string tostring ( ) { stringbuffer buf = new stringbuffer ( ) ; string indent = _str ; buf . append ( indent + _str + integer . tohexstring ( getversion ( ) ) + _str ) ; buf . append ( indent + _str + getascent ( ) + _str ) ; buf . append ( indent + _str + getdescent ( ) + _str ) ; buf . append ( indent + _str + getlinegap ( ) + _str ) ; buf . append ( indent + _str + getadvancewidthmax ( ) + _str ) ; buf . append ( indent + _str + getminleftsidebearing ( ) + _str ) ; buf . append ( indent + _str + getminrightsidebearing ( ) + _str ) ; buf . append ( indent + _str + getxmaxextent ( ) + _str ) ; buf . append ( indent + _str + getcaretsloperise ( ) + _str ) ; buf . append ( indent + _str + getcaretsloperun ( ) + _str ) ; buf . append ( indent + _str + getcaretoffset ( ) + _str ) ; buf . append ( indent + _str + getmetricdataformat ( ) + _str ) ; buf . append ( indent + _str + getnumoflonghormetrics ( ) + _str ) ; return buf . tostring ( ) ; }	create a pretty string.
private static int [ ] makepositive ( byte a [ ] ) { int keep , k ; int bytelength = a . length ; for ( keep = _num ; keep < bytelength && a [ keep ] == - _num ; keep ++ ) ; for ( k = keep ; k < bytelength && a [ k ] == _num ; k ++ ) ; int extrabyte = ( k == bytelength ) ? _num : _num ; int intlength = ( ( bytelength - keep + extrabyte ) + _num ) > > > _num ; int result [ ] = new int [ intlength ] ; int b = bytelength - _num ; for ( int i = intlength - _num ; i >= _num ; i -- ) { result [ i ] = a [ b -- ] & _num ; int numbytestotransfer = math . min ( _num , b - keep + _num ) ; if ( numbytestotransfer < _num ) numbytestotransfer = _num ; for ( int j = _num ; j <= _num * numbytestotransfer ; j += _num ) result [ i ] |= ( ( a [ b -- ] & _num ) << j ) ; int mask = - _num > > > ( _num * ( _num - numbytestotransfer ) ) ; result [ i ] = ~ result [ i ] & mask ; } for ( int i = result . length - _num ; i >= _num ; i -- ) { result [ i ] = ( int ) ( ( result [ i ] & long_mask ) + _num ) ; if ( result [ i ] != _num ) break ; } return result ; }	takes an array a representing a negative 2 ' s - complement number and returns the minimal ( no leading zero bytes ) unsigned whose value is - a .
private void calculatespheresize ( double scale , kstarwrapper params ) { int i ; double spheresize , minprob = _num ; double pstar ; double pstarsum = _num ; double pstarsquaresum = _num ; double inc ; for ( i = _num ; i < m_numinstances ; i ++ ) { if ( m_distances [ i ] < _num ) { continue ; } else { pstar = pstar ( m_distances [ i ] , scale ) ; if ( minprob > pstar ) { minprob = pstar ; } inc = pstar / m_actualcount ; pstarsum += inc ; pstarsquaresum += inc * inc ; } } spheresize = ( pstarsquaresum == _num ? _num : pstarsum * pstarsum / pstarsquaresum ) ; params . sphere = spheresize ; params . avgprob = pstarsum ; params . minprob = minprob ; }	calculates the size of the " sphere of influence " defined as : sphere = sum ( p ) ^ 2 / sum ( p ^ 2 ) where p ( i ) = root * exp ( - 2 * i * root ).
private void keepannotated ( path path ) throws filenotfoundexception { for ( classpathelement element : path . getelements ( ) ) { forclazz : for ( string name : element . list ( ) ) { if ( name . endswith ( class_extension ) ) { directclassfile clazz = path . getclass ( name ) ; if ( hasruntimevisibleannotation ( clazz ) ) { filestokeep . add ( name ) ; } else { methodlist methods = clazz . getmethods ( ) ; for ( int i = _num ; i < methods . size ( ) ; i ++ ) { if ( hasruntimevisibleannotation ( methods . get ( i ) ) ) { filestokeep . add ( name ) ; continue forclazz ; } } fieldlist fields = clazz . getfields ( ) ; for ( int i = _num ; i < fields . size ( ) ; i ++ ) { if ( hasruntimevisibleannotation ( fields . get ( i ) ) ) { filestokeep . add ( name ) ; continue forclazz ; } } } } } } }	keep classes annotated with runtime annotations .
private list < searchhit > limitlist ( int limit , list < searchhit > hitlist ) { if ( log . isdebugenabled ( ) ) { log . debug ( _str + hitlist . size ( ) + _str + limit + _str ) ; } searchhit [ ] limitedhits = new searchhit [ limit ] ; system . arraycopy ( hitlist . toarray ( new searchhit [ hitlist . size ( ) ] ) , _num , limitedhits , _num , limit ) ; return arrays . aslist ( limitedhits ) ; }	reduce size of hitlist to given limit ( cuts of all elements after position $ limit ).
public void addrule ( delphirule delphirule ) { delphirules . add ( delphirule ) ; }	adds rule to set.
private void preparedirectory ( string path ) { file dir = new file ( path ) ; if ( ! dir . exists ( ) ) { if ( ! dir . mkdirs ( ) ) { log . e ( tag , _str + path + _str ) ; } } else { log . i ( tag , _str + path ) ; } }	prepare directory on external storage.
void dropresource ( final r resource ) { final thread tx = thread . currentthread ( ) ; synchronized ( resourcequeues ) { final resourcequeue < r , thread > resourcequeue = resourcequeues . get ( resource ) ; if ( resourcequeue == null ) { throw new illegalargumentexception ( _str + resource ) ; } resourcequeue . clear ( tx ) ; resourcequeues . remove ( resource ) ; } }	drop a resource . the caller must have lock on the resource . all tasks blocked waiting for that resource will be aborted .
public static void putobjecttostream ( object obj , outputstream os ) throws ioexception { objectoutputstream oos = new objectoutputstream ( os ) ; oos . writeobject ( obj ) ; oos . flush ( ) ; oos . close ( ) ; }	serializes specified object to an output stream .
public static void writeimagetoppm ( int [ ] [ ] image , string ppmfilename ) throws ioexception { try ( bufferedwriter ppmout = new bufferedwriter ( new filewriter ( ppmfilename ) ) ) { int rows = image . length ; int cols = image [ _num ] . length ; ppmout . write ( _str ) ; ppmout . write ( _str + rows + _str + cols + _str ) ; for ( int [ ] animage : image ) { stringbuilder s = new stringbuilder ( ) ; for ( int j = _num ; j < cols ; j ++ ) { s . append ( animage [ j ] + _str + animage [ j ] + _str + animage [ j ] + _str ) ; } ppmout . write ( s . tostring ( ) ) ; } } }	writes the given image in the given file using the ppm data format .
public bitmap pop ( long timeout , timeunit unit ) throws interruptedexception { checknotmainthread ( ) ; ensurescheduled ( ) ; return finished . poll ( timeout , unit ) ; }	returns a previously drawn frame from this drawable or null , if no drawable can be popped right now . this function has a timeout.
default t call ( sourcesection source , t lhs ) { return call ( source , lhs , collections . emptylist ( ) ) ; }	helper function : create a call with no arguments .
static public string showtable ( final path [ ] a ) { return showtable ( a , null ) ; }	comma delimited table showing the estimated join hit ratio , the estimated cardinality , and the set of vertices for each of the specified join paths .
public unloadstrandedturn ( int [ ] ids ) { super ( iplayer . player_none ) ; if ( null == ids ) { throw new illegalargumentexception ( _str ) ; } if ( _num == ids . length ) { throw new illegalargumentexception ( _str ) ; } entityids = new int [ ids . length ] ; system . arraycopy ( ids , _num , entityids , _num , ids . length ) ; }	any player that owns an entity whose id is in the passed array should be given a chance to unload it .
@ override void checkafterunmarshalled ( ) { super . checkafterunmarshalled ( ) ; assertequals ( shortval . shortvalue ( ) , _num ) ; assertequals ( longval , _num ) ; assertnull ( aarr ) ; assertequals ( doubleval , _num ) ; }	checks correctness of the state after unmarshalling .
private void finishkbmode ( boolean updatedisplays ) { minkbmode = _bool ; if ( ! mtypedtimes . isempty ( ) ) { int values [ ] = getenteredtime ( null ) ; mtimepicker . settime ( new timepoint ( values [ _num ] , values [ _num ] , values [ _num ] ) ) ; if ( ! mis24hourmode ) { mtimepicker . setamorpm ( values [ _num ] ) ; } mtypedtimes . clear ( ) ; } if ( updatedisplays ) { updatedisplay ( _bool ) ; mtimepicker . trysettinginputenabled ( _bool ) ; } }	get out of keyboard mode.
public boolean isannotationpresent ( class javaclass , string property , class < ? extends annotation > annotationclass ) { field field ; try { field = javaclass . getdeclaredfield ( property ) ; return field . isannotationpresent ( annotationclass ) ; } catch ( nosuchfieldexception e ) { class superclass = javaclass . getsuperclass ( ) ; while ( superclass != null ) { try { field = superclass . getdeclaredfield ( property ) ; return field . isannotationpresent ( annotationclass ) ; } catch ( nosuchfieldexception e1 ) { superclass = superclass . getsuperclass ( ) ; } } throw new runtimeexception ( _str + property ) ; } }	determine whether the given annotation is present in the object ' s class or in any of its superclasses .
@ override public int read ( byte [ ] b , int off , int len ) throws ioexception { if ( closed ) { throw new fileuploadexception ( itemskippedexception ) ; } if ( len == _num ) { return _num ; } int res = available ( ) ; if ( res == _num ) { res = makeavailable ( ) ; if ( res == _num ) { return - _num ; } } res = math . min ( res , len ) ; system . arraycopy ( buffer , head , b , off , res ) ; head += res ; total += res ; return res ; }	reads bytes into the given buffer .
public void addrange ( double minvalue , double maxvalue ) { if ( ! double . isnan ( maxvalue ) && maxvalue > maxdata ) { maxdata = maxvalue ; } if ( ! double . isnan ( minvalue ) && minvalue < mindata ) { mindata = minvalue ; } iscalibrated = _bool ; }	adds the range to the existing range , widening if neccessary.
public boolean canget ( class type ) { if ( type == null ) return _bool ; if ( m_columntype . isprimitive ( ) ) { boolean primtypes = type . isassignablefrom ( m_columntype ) || ( typelib . isnumerictype ( m_columntype ) && typelib . isnumerictype ( type ) ) ; return primtypes || type . isassignablefrom ( typelib . getwrappertype ( m_columntype ) ) || type . isassignablefrom ( string . class ) ; } else { return type . isassignablefrom ( m_columntype ) ; } }	indicates if the get method can be called without an exception being thrown for the given type .
public vector3 floor ( ) { return new vector3 ( math . floor ( x ) , math . floor ( y ) , math . floor ( z ) ) ; }	rounds the x , y , and z values of this vector3 down to the nearest integer value .
public string checkkeyandgetdatabasename ( string db ) { if ( key == null ) { return db ; } if ( key . equals ( db ) ) { return keydatabase ; } throw dbexception . get ( errorcode . wrong_user_or_password ) ; }	if no key is set , return the original database name.
public boolean isempty ( ) { return activequeues . size ( ) == _num && inactivequeues . size ( ) == _num ; }	is the this empty.
private static double round ( double value , int decimalplaces ) { return math . round ( value * math . pow ( _num , decimalplaces ) ) / math . pow ( _num , decimalplaces ) ; }	rounds a decimal value to the given decimal place .
public void dontnotify ( final turnlistener turnlistener ) { for ( final map . entry < integer , set < turnlistener > > mapentry : register . entryset ( ) ) { final set < turnlistener > set = mapentry . getvalue ( ) ; final set < turnlistener > toberemoved = new hashset < turnlistener > ( ) ; if ( set . contains ( turnlistener ) ) { toberemoved . add ( turnlistener ) ; } for ( final turnlistener event : toberemoved ) { set . remove ( event ) ; } } }	forgets all registered notification entries for the given turnlistener where the entry ' s message equals the given one .
@ override public int hashcode ( ) { int code = super . hashcode ( ) ; if ( econditions != null ) { for ( entitlementcondition econdition : econditions ) { code = _num * code + econdition . hashcode ( ) ; } } if ( pconditionname != null ) { code = _num * code + pconditionname . hashcode ( ) ; } return code ; }	returns hash code of the object.
@ transactional public void delete ( t persistentobject ) { if ( ! entitymanager . contains ( persistentobject ) ) { persistentobject = entitymanager . merge ( persistentobject ) ; } entitymanager . remove ( persistentobject ) ; }	remove an object from persistent storage in the database.
public void addlocations ( collection < pblocation > locations ) { l_locations . addall ( locations ) ; }	adds the specific collection of locations to this argument .
@ reference ( title = _str , authors = _str , booktitle = _str , url = _str ) private static double devianceterm ( double x , double np ) { if ( math . abs ( x - np ) < _num * ( x + np ) ) { final double v = ( x - np ) / ( x + np ) ; double s = ( x - np ) * v ; double ej = _num * x * v ; for ( int j = _num ; ; j ++ ) { ej *= v * v ; final double s1 = s + ej / ( _num * j + _num ) ; if ( s1 == s ) { return s1 ; } s = s1 ; } } return x * math . log ( x / np ) + np - x ; }	evaluate the deviance term of the saddle point approximation . bd0 ( x , np ) = x * ln ( x / np ) + np - x.
void checkandremoveheaderrow ( int position ) { if ( isupdatelistempty ( ) ) { for ( iterator < displayable > it = displayablelist . iterator ( ) ; it . hasnext ( ) ; ) { displayable displayable = it . next ( ) ; if ( displayable instanceof updateheaderrow ) { it . remove ( ) ; notifyitemremoved ( position ) ; } } } }	check if there ' s any update on the displayablelist and if so , removes the update header.
public list < jsonvalue > values ( ) { return collections . unmodifiablelist ( values ) ; }	returns a list of the values in this array in document order.
public boolean isselectionuserdefinedrostergroup ( ) { return ( selectedrostergroup != null && ! selectedrostergroup . equals ( roster . allentries ) ) ; }	is the selected roster group user or system defined .
public void init ( actionlistener doneaction ) { _update = _bool ; _supressdragging = _bool ; _bottom1panel = new jpanel ( ) ; addshowbuttontobottom ( ) ; addupdatebuttontobottom ( doneaction ) ; initiconfamiliespanel ( ) ; add ( _iconfamilypanel ) ; add ( _bottom1panel ) ; }	init for conversion of plain track to indicator track.
private void updateentries ( cache < integer , integer > cache , int newval , boolean invoke , set < integer > keys ) { if ( invoke ) cache . invokeall ( keys , new integersetvalue ( newval ) ) ; else { final map < integer , integer > entries = new hashmap < > ( entry_count ) ; for ( final integer key : keys ) entries . put ( key , newval ) ; cache . putall ( entries ) ; } }	update the cache using either invokeall ( ) or putall ( ) .
void updatedays ( wheelview year , wheelview month , wheelview day ) { calendar calendar = calendar . getinstance ( ) ; calendar . set ( calendar . year , calendar . get ( calendar . year ) + year . getcurrentitem ( ) ) ; calendar . set ( calendar . month , month . getcurrentitem ( ) ) ; int maxdays = calendar . getactualmaximum ( calendar . day_of_month ) ; day . setviewadapter ( new datenumericadapter ( this , _num , maxdays , calendar . get ( calendar . day_of_month ) - _num ) ) ; int curday = math . min ( maxdays , day . getcurrentitem ( ) + _num ) ; day . setcurrentitem ( curday - _num , _bool ) ; }	updates day wheel . sets max days according to selected month and year.
private static boolean addtoevaluator ( arraydeque < filtervaluesetparam > remainingparameters , filterhandle filtercallback , eventevaluator eventevaluator , arraydeque < eventtypeindexbuilderindexlookupablepair > treepathinfo , filterservicegranularlockfactory lockfactory ) { if ( eventevaluator instanceof filterhandlesetnode ) { filterhandlesetnode node = ( filterhandlesetnode ) eventevaluator ; addtonode ( remainingparameters , filtercallback , node , treepathinfo , lockfactory ) ; return _bool ; } filterparamindexbase nextindex = ( filterparamindexbase ) eventevaluator ; filtervaluesetparam parameter = indexhelper . findparameter ( remainingparameters , nextindex ) ; if ( parameter != null ) { remainingparameters . remove ( parameter ) ; treepathinfo . add ( new eventtypeindexbuilderindexlookupablepair ( nextindex , parameter . getfilterforvalue ( ) ) ) ; addtoindex ( remainingparameters , filtercallback , nextindex , parameter . getfilterforvalue ( ) , treepathinfo , lockfactory ) ; return _bool ; } return _bool ; }	add filter callback to an event evaluator , which could be either an index node or a set node .
protected regexprompt ( string pattern ) { this ( pattern . compile ( pattern ) ) ; }	creates a new prompt with pattern , calls pattern . compile.
public void subscriber ( class < ? > api , @ pin servicerefamp serviceref , result < ? super cancel > result ) { string path = api . getname ( ) ; string address = address ( path ) ; eventnodeasset node = lookuppubsubnode ( address ) ; cancel cancel = node . subscribeimpl ( serviceref ) ; result . ok ( cancel ) ; }	subscribe a callback to a location .
int securehash ( int x ) { arrays . fill ( data , ( byte ) _num ) ; writeint ( data , _num , x ) ; aes . encrypt ( data , _num , _num ) ; return readint ( data , _num ) ; }	calculate a hash using aes .
public void writeto ( dexfile file , annotatedoutput out ) { finishprocessingifnecessary ( ) ; if ( out . annotates ( ) ) { annotateentries ( _str , null , out ) ; } int tablesize = table . size ( ) ; for ( int i = _num ; i < tablesize ; i ++ ) { catchtable . entry one = table . get ( i ) ; int start = one . getstart ( ) ; int end = one . getend ( ) ; int insncount = end - start ; if ( insncount >= _num ) { throw new unsupportedoperationexception ( _str + hex . u4 ( start ) + _str + hex . u4 ( end ) ) ; } out . writeint ( start ) ; out . writeshort ( insncount ) ; out . writeshort ( handleroffsets . get ( one . gethandlers ( ) ) ) ; } out . write ( encodedhandlers ) ; }	writes this instance to the given stream .
private virtualpoolchangeparam convertnewvirtualpoolchangeparamtooldparam ( volumevirtualpoolchangeparam newparam ) { virtualpoolchangeparam oldparam = new virtualpoolchangeparam ( ) ; oldparam . setvirtualpool ( newparam . getvirtualpool ( ) ) ; oldparam . setprotection ( newparam . getprotection ( ) ) ; oldparam . setconsistencygroup ( newparam . getconsistencygroup ( ) ) ; oldparam . settransferspeedparam ( newparam . gettransferspeedparam ( ) ) ; oldparam . setmigrationsuspendbeforecommit ( newparam . ismigrationsuspendbeforecommit ( ) ) ; oldparam . setmigrationsuspendbeforedeletesource ( newparam . ismigrationsuspendbeforedeletesource ( ) ) ; return oldparam ; }	copy the contents from new virtual pool change param to old param.
public boolean empty ( ) { return vstack . empty ( ) ; }	indicate whether the stack is empty .
public void addinputparam ( fbprocedureparam param ) { if ( inputparams . size ( ) < param . getposition ( ) + _num ) { inputparams . setsize ( param . getposition ( ) + _num ) ; } inputparams . set ( param . getposition ( ) , param ) ; }	add an input parameter to this procedure call .
public static float readfloat ( final jsonobject jsonobject , final string key , final boolean required , final boolean notnull ) throws jsonexception { if ( required ) { return ( float ) jsonobject . getdouble ( key ) ; } if ( notnull && jsonobject . isnull ( key ) ) { throw new jsonexception ( string . format ( locale . us , null_value_format_object , key ) ) ; } float value = _num ; if ( ! jsonobject . isnull ( key ) ) { value = ( float ) jsonobject . getdouble ( key ) ; } return value ; }	reads the float value from the json object for specified tag .
public void testcase22 ( ) { byte rbytes [ ] = { _num } ; biginteger anumber = biginteger . one ; biginteger bnumber = biginteger . one ; biginteger result = anumber . add ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	add one to one.
public void paint ( graphics2d g2d , int pageno , point2d pagestart , properties ctx , boolean isview ) { point2d . double location = getabsolutelocation ( pagestart ) ; rectangle allocation = m_renderer . getallocation ( ) ; g2d . translate ( location . x , location . y ) ; m_renderer . paint ( g2d , allocation ) ; g2d . translate ( - location . x , - location . y ) ; }	/ paint / print.
@ override public void handleclick ( int x , int y , plotrenderinginfo info ) { rectangle2d dataarea = info . getdataarea ( ) ; if ( dataarea . contains ( x , y ) ) { valueaxis xaxis = getdomainaxis ( ) ; if ( xaxis != null ) { double hvalue = xaxis . java2dtovalue ( x , info . getdataarea ( ) , getdomainaxisedge ( ) ) ; setdomaincrosshairvalue ( hvalue ) ; } valueaxis yaxis = getrangeaxis ( ) ; if ( yaxis != null ) { double vvalue = yaxis . java2dtovalue ( y , info . getdataarea ( ) , getrangeaxisedge ( ) ) ; setrangecrosshairvalue ( vvalue ) ; } } }	handles a ' click ' on the plot by updating the anchor values .
private static string converttoquotedstring ( string string ) { if ( string == null || string . length ( ) == _num ) { return null ; } if ( string . charat ( _num ) == _str && string . charat ( string . length ( ) - _num ) == _str ) { return string ; } return _str + string + _str ; }	encloses the incoming string inside double quotes , if it isn ' t already quoted .
public int edgeindex ( triangulationpoint p1 , triangulationpoint p2 ) { if ( points [ _num ] == p1 ) { if ( points [ _num ] == p2 ) { return _num ; } else if ( points [ _num ] == p2 ) { return _num ; } } else if ( points [ _num ] == p1 ) { if ( points [ _num ] == p2 ) { return _num ; } else if ( points [ _num ] == p2 ) { return _num ; } } else if ( points [ _num ] == p1 ) { if ( points [ _num ] == p2 ) { return _num ; } else if ( points [ _num ] == p2 ) { return _num ; } } return - _num ; }	get the neighbor that share this edge.
public void connectionclosed ( connectionevent event ) { if ( isactive ) { managedconnection conn = ( managedconnection ) event . getsource ( ) ; xaresource xar = null ; if ( xaresourcesmap . get ( conn ) != null ) xar = ( xaresource ) xaresourcesmap . get ( conn ) ; xaresourcesmap . remove ( conn ) ; try { transaction txn = transmanager . gettransaction ( ) ; if ( txn != null && xar != null ) { txn . delistresource ( xar , xaresource . tmsuccess ) ; } } catch ( exception se ) { string exception = _str + se ; if ( logger . isdebugenabled ( ) ) { logger . debug ( exception , se ) ; } } mannpoolcache . returnpooledconnectiontopool ( conn ) ; } }	callback for connection closed .
public void writetolucenestream ( indexoutput outputstream , int k ) { tocartesian ( ) ; for ( int i = _num ; i < k * _num ; ++ i ) { try { outputstream . writeint ( float . floattointbits ( coordinates [ i ] ) ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } }	transforms vector to cartesian form and writes vector out in dense format , truncating the vectors to the assigned dimensionality.
public static xmpmeta parse ( object input , parseoptions options ) throws xmpexception { parameterasserts . assertnotnull ( input ) ; options = options != null ? options : new parseoptions ( ) ; document document = parsexml ( input , options ) ; boolean xmpmetarequired = options . getrequirexmpmeta ( ) ; object [ ] result = new object [ _num ] ; result = findrootnode ( document , xmpmetarequired , result ) ; if ( result != null && result [ _num ] == xmp_rdf ) { xmpmetaimpl xmp = parserdf . parse ( ( node ) result [ _num ] ) ; xmp . setpacketheader ( ( string ) result [ _num ] ) ; if ( ! options . getomitnormalization ( ) ) { return xmpnormalizer . process ( xmp , options ) ; } else { return xmp ; } } else { return new xmpmetaimpl ( ) ; } }	parses the input source into an xmp metadata object , including de - aliasing and normalisation .
public static void disposegraphicsconfig ( long pconfiginfo ) { d3drenderqueue rq = getinstance ( ) ; rq . lock ( ) ; try { renderbuffer buf = rq . getbuffer ( ) ; rq . ensurecapacityandalignment ( _num , _num ) ; buf . putint ( dispose_config ) ; buf . putlong ( pconfiginfo ) ; rq . flushnow ( ) ; } finally { rq . unlock ( ) ; } }	disposes the native memory associated with the given native graphics config info pointer on the single queue flushing thread .
public static int objectequals ( object obj1 , object obj2 ) { return obj1 . equals ( obj2 ) ? true : false ; }	helper function that is called instead of object . equals.
public void addloop ( arraycomprehensionloop acl ) { assertnotnull ( acl ) ; loops . add ( acl ) ; acl . setparent ( this ) ; }	adds a child loop node , and sets its parent to this node .
void readsin ( ) throws ioexception { while ( _bool ) { string s = isr . readline ( ) ; if ( s == null ) return ; if ( s . startswith ( _str ) ) return ; } }	read sin records ( in fact does nothing ).
public static object deserialize ( string input ) throws ioexception , classnotfoundexception { byte [ ] decoded = base64 . decodebase64 ( input . getbytes ( _str ) ) ; return deserialize ( decoded ) ; }	base64 decodes a string into a decoded byte array , then deserializes the object .
public static string bind ( string message , object [ ] bindings ) { return messageformat . format ( message , bindings ) ; }	bind the given message ' s substitution locations with the given string values .
protected dbids computesubspaceforgene ( short [ ] gene , arraylist < arraylist < dbids > > ranges ) { hashsetmodifiabledbids m = null ; for ( int i = _num ; i < gene . length ; i ++ ) { if ( gene [ i ] != dont_care ) { dbids current = ranges . get ( i ) . get ( gene [ i ] - gene_offset ) ; if ( m == null ) { m = dbidutil . newhashset ( current ) ; } else { m . retainall ( current ) ; } } } assert ( m != null ) : _str ; return m ; }	get the dbids in the current subspace .
public final string tostring ( string codeset ) { stringbuffer sb = new stringbuffer ( ) ; if ( doctype != null ) sb . append ( doctype . tostring ( getcodeset ( ) ) ) ; sb . append ( html . tostring ( getcodeset ( ) ) ) ; return ( sb . tostring ( ) ) ; }	override the tostring ( ) method so that it prints something meaningful .
public list < pdfdocument > extractpageranges ( list < pagerange > pageranges ) { list < pdfdocument > splitdocuments = new arraylist < > ( ) ; for ( pagerange currentpagerange : pageranges ) { pdfdocument currentpdfdocument = createpdfdocument ( currentpagerange ) ; splitdocuments . add ( currentpdfdocument ) ; pdfdocument . copypagesto ( currentpagerange . getallpages ( ) , currentpdfdocument ) ; } return splitdocuments ; }	extracts the specified page ranges from a document .
public staxwriter ( final qnamemap qnamemap , final xmlstreamwriter out , final boolean writeenclosingdocument , final boolean namespacerepairingmode , final namecoder namecoder ) throws xmlstreamexception { super ( namecoder ) ; this . qnamemap = qnamemap ; this . out = out ; this . writeenclosingdocument = writeenclosingdocument ; this . namespacerepairingmode = namespacerepairingmode ; if ( writeenclosingdocument ) { out . writestartdocument ( ) ; } }	allows a staxwriter to be created for partial xml output.
void sleep ( long millis ) { try { thread . sleep ( millis ) ; } catch ( interruptedexception ie ) { assertionfailederror afe = new assertionfailederror ( _str ) ; afe . initcause ( ie ) ; throw afe ; } }	sleeps until the given time has elapsed.
private void copyattributes ( attributemap dest , attributemap source ) { for ( entry < attribute < ? > , ? > a : source . entryset ( ) ) { dest . put ( ( attribute < object > ) a . getkey ( ) , a . getvalue ( ) ) ; } }	copy attribute from source attributemap to destination attributemap .
protected void assertresult ( string expected , statement stat , string sql ) throws sqlexception { resultset rs = stat . executequery ( sql ) ; if ( rs . next ( ) ) { string actual = rs . getstring ( _num ) ; assertequals ( expected , actual ) ; } else { assertequals ( expected , null ) ; } }	check that the result set of a query is exactly this value .
public logfile ( string name , string mode ) throws filenotfoundexception , ioexception { super ( name , mode ) ; this . fd = getfd ( ) ; }	constructs a logfile and initializes the file descriptor .
public void removeurlchangelistener ( urlchangelistener urlchangelistener ) { urlchangelisteners . remove ( urlchangelistener ) ; }	un registers the listener.
@ suppresswarnings ( _str ) public list < product > read ( list < long > ids ) { if ( ( ids == null ) || ids . isempty ( ) ) return immutablelist . of ( ) ; string facet = _str ; string logic_op = _str ; for ( long id : ids ) { facet += _str + logic_op + _str + id ; logic_op = _str ; } return ( list < product > ) find ( _str + entityclass . getname ( ) + _str + facet ) ; }	retrieve a list of products to their ids.
public static double area ( coordinate a , coordinate b , coordinate c ) { return math . abs ( ( ( c . x - a . x ) * ( b . y - a . y ) - ( b . x - a . x ) * ( c . y - a . y ) ) / _num ) ; }	computes the 2d area of a triangle.
public void addtableheader ( final jtableheader newtableheader ) { if ( ! _registredtableheaders . contains ( newtableheader ) ) { if ( _tableheader == null ) { _tableheader = newtableheader ; } newtableheader . addmouselistener ( _mouselistener ) ; newtableheader . setdefaultrenderer ( new sortableheaderrenderer ( newtableheader . getdefaultrenderer ( ) ) ) ; _registredtableheaders . add ( newtableheader ) ; } }	for more than one table use this method to register the table header ' s .
public boolean performaction ( ) { return ! actions . isempty ( ) ; }	indicates if an action has to be performed or not .
public multierrorexception check ( boolean valid , string messagekey , object ... args ) { return check ( null , valid , messagekey , args ) ; }	adds a global - error if the given condition isn ' t true.
public void removesearchlistener ( searchlistener l ) { m_searchlisteners . remove ( l ) ; }	removes the specified listener from the internal list of listeners .
public emotecondition ( final string playeraction ) { this . playeraction = playeraction . trim ( ) ; }	creates a new admincondition for high level admins .
public boolean ishiddenfile ( file f ) { return f . ishidden ( ) ; }	returns whether a file is hidden or not .
private void validatenumcores ( ) { string numcoresstr = carbonproperties . getproperty ( carboncommonconstants . num_cores , carboncommonconstants . num_cores_default_val ) ; try { int numcores = integer . parseint ( numcoresstr ) ; if ( numcores < carboncommonconstants . num_cores_min_val || numcores > carboncommonconstants . num_cores_max_val ) { logger . info ( _str + numcoresstr + _str + carboncommonconstants . num_cores_default_val ) ; carbonproperties . setproperty ( carboncommonconstants . num_cores , carboncommonconstants . num_cores_default_val ) ; } } catch ( numberformatexception e ) { logger . info ( _str + numcoresstr + _str + carboncommonconstants . num_cores_default_val ) ; carbonproperties . setproperty ( carboncommonconstants . num_cores , carboncommonconstants . num_cores_default_val ) ; } }	this method validates the number cores specified.
public generator ( int basewidth , int beseheight ) { this . basewidth = basewidth ; this . beseheight = beseheight ; xstream . autodetectannotations ( _bool ) ; this . resfile = new file ( _str ) ; if ( ! resfile . exists ( ) ) { resfile . mkdir ( ) ; } }	using basewidth and baseheight to generator.
public repldbmsevent poll ( ) throws interruptedexception { return queue . poll ( ) ; }	removes and returns next event from the queue , returning null if empty.
public static category createcategory ( final string rawjson ) throws twitterexception { try { final jsonobject json = new jsonobject ( rawjson ) ; return categoryconstructor . newinstance ( json ) ; } catch ( final instantiationexception e ) { throw new twitterexception ( e ) ; } catch ( final illegalaccessexception e ) { throw new assertionerror ( e ) ; } catch ( final invocationtargetexception e ) { throw new twitterexception ( e ) ; } catch ( final jsonexception e ) { throw new twitterexception ( e ) ; } }	constructs a category object from rawjson string .
public void removeallplots ( ) { m_plot . removeallplots ( ) ; }	removes all the plots .
public synchronized void updatencharacterstream ( string columnname , java . io . reader reader , int length ) throws sqlexception { updatencharacterstream ( findcolumn ( columnname ) , reader , length ) ; }	jdbc 4 . 0 update a column with a character stream value . the updatexxx ( ) methods are used to update column values in the current row , or the insert row . the updatexxx ( ) methods do not update the underlying database , instead the updaterow ( ) or insertrow ( ) methods are called to update the database .
list < file > addcollectionfiles ( file newbasedir ) throws ioexception { final directoryscanner ds = new directoryscanner ( ) ; ds . setbasedir ( newbasedir ) ; if ( this . includes != null && this . includes . length > _num ) { ds . setincludes ( this . includes ) ; } else { ds . setincludes ( default_includes ) ; } ds . setexcludes ( this . excludes ) ; ds . adddefaultexcludes ( ) ; ds . setcasesensitive ( _bool ) ; ds . setfollowsymlinks ( _bool ) ; ds . scan ( ) ; list < file > foundfiles = new arraylist < > ( ) ; for ( string filename : ds . getincludedfiles ( ) ) { foundfiles . add ( new file ( newbasedir , filename ) ) ; } return foundfiles ; }	add source files to the files list .
static int readtyperef ( typereference typeref , datainputstream input , int [ ] constantpool ) throws ioexception , classformaterror { int mytypeindex = input . readunsignedshort ( ) ; typereference mytyperef = gettyperef ( constantpool , mytypeindex ) ; if ( mytyperef != typeref ) { if ( ! vm . verifyassertions ) { throw new classformaterror ( _str + typeref . getname ( ) + _str + mytyperef . getname ( ) + _str ) ; } else { throw new classformaterror ( _str + typeref . getname ( ) + _str + mytyperef . getname ( ) + _str + typeref + _str + mytyperef ) ; } } return mytypeindex ; }	read the class ' typereference.
private boolean doacquiresharednanos ( long arg , long nanostimeout ) throws interruptedexception { if ( nanostimeout <= _num ) return _bool ; final long deadline = system . nanotime ( ) + nanostimeout ; final node node = addwaiter ( node . shared ) ; boolean failed = _bool ; try { for ( ; ; ) { final node p = node . predecessor ( ) ; if ( p == head ) { long r = tryacquireshared ( arg ) ; if ( r >= _num ) { setheadandpropagate ( node , r ) ; p . next = null ; failed = _bool ; return _bool ; } } nanostimeout = deadline - system . nanotime ( ) ; if ( nanostimeout <= _num ) return _bool ; if ( shouldparkafterfailedacquire ( p , node ) && nanostimeout > spinfortimeoutthreshold ) locksupport . parknanos ( this , nanostimeout ) ; if ( thread . interrupted ( ) ) throw new interruptedexception ( ) ; } } finally { if ( failed ) cancelacquire ( node ) ; } }	acquires in shared timed mode .
public ctutorial ( final string name , final string description , final list < ctutorialstep > steps ) { m_name = preconditions . checknotnull ( name , _str ) ; m_description = preconditions . checknotnull ( description , _str ) ; m_steps = new arraylist < ctutorialstep > ( preconditions . checknotnull ( steps , _str ) ) ; preconditions . checkargument ( ! steps . isempty ( ) , _str ) ; }	creates a new tutorial object .
private file createnewformat ( int ad_table_id , httpservletrequest request , gridtab m_curtab , mquery m_query ) { websessionctx wsc = websessionctx . get ( request ) ; mprintformat pf = mprintformat . createfromtable ( wsc . ctx , ad_table_id ) ; file file = launchreport ( pf , request , m_curtab , m_query ) ; return file ; }	create and launch new format for table.
public void addall ( ruleset that ) { rules . addall ( that . rules ) ; rulearray = null ; }	adds all the rules to this ruleset from the given other rule set .
public synchronized boolean acquire ( ) throws replicatorexception { if ( islocked ( ) ) return _bool ; try { raf = new randomaccessfile ( lockfile , _str ) ; filechannel channel = raf . getchannel ( ) ; lock = channel . trylock ( ) ; } catch ( filenotfoundexception e ) { throw new replicatorexception ( _str + lockfile . getabsolutepath ( ) ) ; } catch ( exception e ) { throw new replicatorexception ( _str + lockfile . getabsolutepath ( ) , e ) ; } finally { if ( lock == null && raf != null ) { close ( raf ) ; } } if ( lock == null ) { if ( raf != null ) close ( raf ) ; return _bool ; } else if ( lock . isshared ( ) ) { release ( ) ; return _bool ; } else return _bool ; }	attempt to acquire write lock.
public void testwritebit ( ) throws exception { bytearrayoutputstream out = new bytearrayoutputstream ( ) ; bitoutputstream bout = new bitoutputstream ( out ) ; bout . writebit ( _bool ) ; byte [ ] bytes = out . tobytearray ( ) ; assert . assertequals ( _num , bytes . length ) ; bout . close ( ) ; bytes = out . tobytearray ( ) ; assert . assertequals ( _num , bytes [ _num ] ) ; }	test single bit write .
public static uri changescheme ( uri bindaddr , string scheme ) throws urisyntaxexception { return new uri ( scheme , bindaddr . getuserinfo ( ) , bindaddr . gethost ( ) , bindaddr . getport ( ) , bindaddr . getpath ( ) , bindaddr . getquery ( ) , bindaddr . getfragment ( ) ) ; }	given a uri value create and return a new uri that matches the target one but with the scheme value supplied to this method .
public session startsshsessionandobtainsession ( ) { session session = null ; try { jsch jsch = new jsch ( ) ; if ( sshmeta . getsshlogintype ( ) == sshlogintype . key ) { string workingdir = system . getproperty ( _str ) ; string privkeyabspath = workingdir + _str + sshmeta . getprivkeyrelativepath ( ) ; logger . debug ( _str + privkeyabspath ) ; if ( ! pcfilenetworkioutils . isfileexist ( privkeyabspath ) ) { throw new runtimeexception ( _str + privkeyabspath ) ; } if ( sshmeta . isprivkeyusepassphrase ( ) && sshmeta . getpassphrase ( ) != null ) { jsch . addidentity ( privkeyabspath , sshmeta . getpassphrase ( ) ) ; } else { jsch . addidentity ( privkeyabspath ) ; } } session = jsch . getsession ( sshmeta . getusername ( ) , targethost , sshmeta . getsshport ( ) ) ; if ( sshmeta . getsshlogintype ( ) == sshlogintype . password ) { session . setpassword ( sshmeta . getpassword ( ) ) ; } session . setconfig ( _str , _str ) ; } catch ( exception t ) { throw new runtimeexception ( t ) ; } return session ; }	start ssh session and obtain session .
public map < integer , integer > popmissing ( ) { hashmap < integer , integer > map = new hashmap < > ( ) ; for ( int i = _num ; i < missingblocks . length ; i ++ ) { int count = missingblocks [ i ] ; if ( count > _num ) { map . put ( i , count ) ; } } arrays . fill ( missingblocks , _num ) ; return map ; }	gets the list of missing blocks and clears the list for the next operation .
public static string interpolate ( string input , final map < string , string > namedargs , final map < string , string > defaultargs ) { if ( namedargs == null || input == null ) { return input ; } final map < string , string > interpolationargs = createfinalinterpolationmap ( namedargs , defaultargs ) ; return strsubstitutor . replace ( input , interpolationargs , prefix , suffix ) ; }	performs variable interpolation using the named arguments from an action on a single string.
public int max ( ) { return max ; }	the upper bound for the value .
public static void addtoinvokelater ( final runnable runnable ) { final application application = applicationmanager . getapplication ( ) ; final boolean unittestmode = application . isunittestmode ( ) ; if ( unittestmode ) { uiutil . invokelaterifneeded ( runnable ) ; } else if ( application . isheadlessenvironment ( ) || application . isdispatchthread ( ) ) { runnable . run ( ) ; } else { transfer_to_edt_queue . offer ( runnable ) ; } }	adds runnable to event dispatch queue if we aren ' t in unittest of headless environment mode.
public bytearraydatasource ( byte [ ] data , string type ) { m_data = data ; if ( type != null && type . length ( ) > _num ) m_type = type ; }	create a datasource from a byte array.
public static void checkoperationalpattern1acompliance ( list < partitionpack > partitionpacks ) { imferrorlogger imferrorlogger = new imferrorloggerimpl ( ) ; for ( partitionpack partitionpack : partitionpacks ) { byte [ ] bytes = partitionpack . getoperationalpattern ( ) ; for ( int i = _num ; i < bytes . length ; i ++ ) { if ( ( mxfoperationalpattern1a . operational_pattern1a_key_mask [ i ] != _num ) && ( mxfoperationalpattern1a . operational_pattern1a_key [ i ] != bytes [ i ] ) ) { imferrorlogger . adderror ( imferrorlogger . imferrors . errorcodes . imf_essence_component_error , imferrorlogger . imferrors . errorlevels . fatal , mxfoperationalpattern1a . op1a_exception_prefix + string . format ( _str , bytes [ i ] , i , mxfoperationalpattern1a . operational_pattern1a_key [ i ] ) ) ; } } if ( partitionpack . getnumberofessencecontaineruls ( ) < _num ) { imferrorlogger . adderror ( imferrorlogger . imferrors . errorcodes . imf_essence_component_error , imferrorlogger . imferrors . errorlevels . fatal , mxfoperationalpattern1a . op1a_exception_prefix + string . format ( _str , partitionpack . getnumberofessencecontaineruls ( ) ) ) ; } } if ( imferrorlogger . hasfatalerrors ( ) ) { throw new mxfexception ( string . format ( _str ) , imferrorlogger ) ; } }	checks the compliance of partition packs found in an mxf file with st378 : 2004 . a runtime exception is thrown in case of non - compliance.
public barabasialbertgenerator ( supplier < graph < v , e > > graphfactory , supplier < v > vertexfactory , supplier < e > edgefactory , int init_vertices , int numedgestoattach , set < v > seedvertices ) { this ( graphfactory , vertexfactory , edgefactory , init_vertices , numedgestoattach , ( int ) system . currenttimemillis ( ) , seedvertices ) ; }	constructs a new instance of the generator , whose output will be an undirected graph , and which will use the current time as a seed for the random number generation .
private boolean addhisoricalrecord ( historicalrecord historicalrecord ) { synchronized ( minstancelock ) { final boolean added = mhistoricalrecords . add ( historicalrecord ) ; if ( added ) { mhistoricalrecordschanged = _bool ; pruneexcessivehistoricalrecordslocked ( ) ; persisthistoricaldata ( ) ; sortactivities ( ) ; } return added ; } }	adds a historical record .
private static int toeven ( float value ) { int i = math . round ( value ) ; return ( i % _num == _num ) ? i - _num : i ; }	casts the value to an even integer .
private void writeobject ( objectoutputstream oos ) throws ioexception { oos . defaultwriteobject ( ) ; oos . writeint ( index . size ( ) ) ; for ( int i = _num , sz = index . size ( ) ; i < sz ; ++ i ) { oos . writeutf ( index . get ( i ) ) ; } }	custom serializer . this is possible since the index is guaranteed to assign contiguous values .
public static byte [ ] readfiletobytearray ( file file ) throws ioexception { inputstream in = null ; try { in = openinputstream ( file ) ; return ioutils . tobytearray ( in , file . length ( ) ) ; } finally { ioutils . closequietly ( in ) ; } }	reads the contents of a file into a byte array.
public void export ( dataoutputstream out ) throws ioexception { out . writeint ( seqid ) ; if ( info . isrowblockenabled ( ) ) out . writeint ( nrows ) ; export ( out , primarykey ) ; for ( bytearray cb : cellblocks ) { export ( out , cb ) ; } }	write data to given output stream , like serialize.
public boolean issealed ( url url ) { return sealbase != null && sealbase . samefile ( url ) ; }	indicates whether this package is sealed with respect to the specified url .
private boolean checkvalidation ( final sourcedatatag currentsourcedatatag , final valueupdate update ) { if ( ! istimestampvalid ( currentsourcedatatag , update ) ) { return _bool ; } if ( ! isconvertible ( currentsourcedatatag , update ) ) { return _bool ; } if ( isnumber ( currentsourcedatatag . getdatatype ( ) ) && ! isinrange ( currentsourcedatatag , update ) ) { return _bool ; } return _bool ; }	helper method which validates the new tag value and triggers an invalidation in case of a problem.
public deterministickey ( immutablelist < childnumber > childnumberpath , byte [ ] chaincode , biginteger priv , @ nullable deterministickey parent , int depth , int parentfingerprint ) { super ( priv , compresspoint ( eckey . publicpointfromprivate ( priv ) ) ) ; checkargument ( chaincode . length == _num ) ; this . parent = parent ; this . childnumberpath = checknotnull ( childnumberpath ) ; this . chaincode = arrays . copyof ( chaincode , chaincode . length ) ; this . depth = depth ; this . parentfingerprint = ascertainparentfingerprint ( parent , parentfingerprint ) ; }	constructs a key from its components , including its private key data and possibly - redundant information about its parent key.
static public boolean isequal ( float a , float b , float tolerance ) { return math . abs ( a - b ) <= tolerance ; }	returns true if a is nearly equal to b .
static private string touppercasefast ( final string s ) { boolean different = _bool ; final int mx = s . length ( ) ; char [ ] chars = new char [ mx ] ; for ( int i = _num ; i < mx ; i ++ ) { char ch = s . charat ( i ) ; if ( _str <= ch && ch <= _str ) { ch = ( char ) ( ch + ( _str - _str ) ) ; different = _bool ; } chars [ i ] = ch ; } final string upper ; if ( different ) upper = string . valueof ( chars ) ; else upper = s ; return upper ; }	a fast and cheap way to uppercase a string that is only made of printable ascii characters.
private static void encode ( int tag , int length , stringbuilder buffer ) { if ( tag == pattern_iso_zone && length >= _num ) { throw new illegalargumentexception ( _str + length ) ; } if ( length < _num ) { buffer . append ( ( char ) ( tag << _num | length ) ) ; } else { buffer . append ( ( char ) ( ( tag << _num ) | _num ) ) ; buffer . append ( ( char ) ( length > > > _num ) ) ; buffer . append ( ( char ) ( length & _num ) ) ; } }	encodes the given tag and length and puts encoded char ( s ) into buffer .
public independencetest indtestsubset ( list vars ) { if ( vars . isempty ( ) ) { throw new illegalargumentexception ( _str ) ; } int [ ] indices = new int [ vars . size ( ) ] ; int j = - _num ; for ( int i = _num ; i < variables . size ( ) ; i ++ ) { if ( ! vars . contains ( variables . get ( i ) ) ) { continue ; } indices [ ++ j ] = i ; } dataset newdataset = dataset . subsetcolumns ( indices ) ; return new indtestgsquare ( newdataset , alpha ) ; }	creates a new indtestgsquare for a subset of the variables .
public void start ( ) { if ( show_logs ) logger . v ( tag , _str ) ; synchronized ( mstate ) { if ( show_logs ) logger . v ( tag , _str + mstate ) ; switch ( mstate . get ( ) ) { case idle : case initialized : case preparing : case started : throw new illegalstateexception ( _str + mstate ) ; case stopped : case playback_completed : case prepared : case paused : if ( show_logs ) logger . v ( tag , _str + mstate + _str ) ; mmediaplayer . start ( ) ; startpositionupdatenotifier ( ) ; mstate . set ( state . started ) ; break ; case error : case end : throw new illegalstateexception ( _str + mstate ) ; } } if ( show_logs ) logger . v ( tag , _str ) ; }	play or resume video.
private static void dumpconfigurationproperties ( installlog installlog , map < string , object > properties ) { sortedmap < string , object > sortedproperties = new treemap < string , object > ( string . case_insensitive_order ) ; sortedproperties . putall ( properties ) ; for ( string key : sortedproperties . keyset ( ) ) { if ( config_items_to_hash_list . contains ( key ) ) { installlog . write ( key + _str + _str ) ; } else { installlog . write ( key + _str + sortedproperties . get ( key ) + _str ) ; } } }	iterate over the supplied properties ( sorted by property name ) and write them out to the passed install log.
public void updateusers ( ghpullrequest remotepr ) throws ioexception { pagediterable < ghissuecomment > ghissuecomments = remotepr . listcomments ( ) ; for ( ghissuecomment comment : ghissuecomments ) { if ( isnull ( whitelistuserpattern ) ) { whitelistuserpattern = pattern . compile ( whitelistusermsg ) ; } } }	add / remove users / orgs internal state.
public builder addhideableview ( int viewid ) { hideableviews . add ( viewid ) ; return this ; }	view id that is at the same hierarchy level as yt overlay . will be hidden while player is in landscape mode optional.
public static void showinformation ( final component parent , final string msg ) { joptionpane . showmessagedialog ( isiconified ( parent ) ? null : parent , msg , system . getproperty ( default_window_title_property ) , joptionpane . information_message ) ; }	shows an informational message .
private static boolean isvalidscheme ( final string scheme ) { final int length = scheme . length ( ) ; if ( length <= _num ) { return _bool ; } char c = scheme . charat ( _num ) ; if ( ! character . isletter ( c ) ) { return _bool ; } for ( int i = _num ; i < length ; i ++ ) { c = scheme . charat ( i ) ; if ( ! character . isletterordigit ( c ) && c != _str && c != _str && c != _str ) { return _bool ; } } return _bool ; }	checks if it is a valid scheme .
protected static modbusresponse readrequest ( int functioncode , int register , int count ) { modbustcptransport transport = null ; modbustcptransaction trans ; try { socket socket = new socket ( localhost , port ) ; transport = new modbustcptransport ( socket ) ; modbusrequest req = null ; switch ( functioncode ) { case modbus . read_coils : req = new readcoilsrequest ( register , count ) ; break ; case modbus . read_input_discretes : req = new readinputdiscretesrequest ( register , count ) ; break ; case modbus . read_input_registers : req = new readinputregistersrequest ( register , count ) ; break ; case modbus . read_holding_registers : req = new readmultipleregistersrequest ( register , count ) ; break ; default : fail ( string . format ( _str , functioncode ) ) ; } req . setunitid ( unit_id ) ; trans = ( modbustcptransaction ) transport . createtransaction ( ) ; trans . setrequest ( req ) ; trans . setreconnecting ( _bool ) ; trans . execute ( ) ; return trans . getresponse ( ) ; } catch ( exception e ) { logger . debug ( e . getmessage ( ) ) ; } finally { if ( transport != null ) { try { transport . close ( ) ; } catch ( ioexception e ) { logger . error ( e . getmessage ( ) ) ; } } } return null ; }	executes a read transaction using the function code , register and count.
public static string keepcartupdated ( httpservletrequest request , httpservletresponse response ) { localdispatcher dispatcher = ( localdispatcher ) request . getattribute ( _str ) ; httpsession session = request . getsession ( ) ; shoppingcart cart = getcartobject ( request ) ; if ( cart . getuserlogin ( ) == null ) { genericvalue userlogin = ( genericvalue ) session . getattribute ( _str ) ; if ( userlogin != null ) { try { cart . setuserlogin ( userlogin , dispatcher ) ; } catch ( cartitemmodifyexception e ) { debug . logwarning ( e , module ) ; } } } if ( cart . getautouserlogin ( ) == null ) { genericvalue autouserlogin = ( genericvalue ) session . getattribute ( _str ) ; if ( autouserlogin != null ) { if ( cart . getuserlogin ( ) == null ) { try { cart . setautouserlogin ( autouserlogin , dispatcher ) ; } catch ( cartitemmodifyexception e ) { debug . logwarning ( e , module ) ; } } else { cart . setautouserlogin ( autouserlogin ) ; } } } locale locale = utilhttp . getlocale ( request ) ; if ( cart . getlocale ( ) == null || ! locale . equals ( cart . getlocale ( ) ) ) { cart . setlocale ( locale ) ; } return _str ; }	update the cart ' s userlogin object if it isn ' t already set .
@ procedure @ performswrites @ description ( _str ) public stream < noderesult > mergenodes ( @ name ( _str ) list < node > nodes ) { if ( nodes . isempty ( ) ) return stream . empty ( ) ; iterator < node > it = nodes . iterator ( ) ; node first = it . next ( ) ; while ( it . hasnext ( ) ) { node other = it . next ( ) ; mergenodes ( other , first , _bool ) ; } return stream . of ( new noderesult ( first ) ) ; }	merges the nodes onto the first node.
protected void processspecialattributes ( node node ) { processstateattributes ( node , component ) ; }	process special attributes , like " id ".
@ override public void handlerequest ( requestcontext rc ) throws cliexception { super . handlerequest ( rc ) ; ldaplogin ( ) ; metaalias = getstringoptionvalue ( argument_metadata ) ; bulkfeddata = getstringoptionvalue ( argument_bulk_data ) ; spec = federationmanager . getidffsubcommandspecification ( rc ) ; string [ ] params = { metaalias , bulkfeddata , spec } ; writelog ( logwriter . log_access , level . info , _str , params ) ; try { if ( spec . equals ( federationmanager . default_specification ) ) { saml2getroleandentityid ( ) ; map nameids = new hashmap ( ) ; validatefile ( nameids ) ; handlesaml2request ( nameids ) ; writelog ( logwriter . log_access , level . info , _str , params ) ; } else if ( spec . equals ( fedcliconstants . idff_specification ) ) { idffgetroleandentityid ( ) ; map nameids = new hashmap ( ) ; validatefile ( nameids ) ; handleidffrequest ( nameids ) ; writelog ( logwriter . log_access , level . info , _str , params ) ; } else { throw new cliexception ( getresourcestring ( _str ) , exitcodes . request_cannot_be_processed ) ; } } catch ( cliexception e ) { string [ ] args = { metaalias , bulkfeddata , spec , e . getmessage ( ) } ; writelog ( logwriter . log_error , level . info , _str , args ) ; throw e ; } }	imports bulk federation data .
public void test_setkeyentryljava_lang_stringljava_security_key c ljava_security_cert_certificate ( ) throws exception { certificatefactory cf = certificatefactory . getinstance ( _str ) ; x509certificate cert [ ] = new x509certificate [ _num ] ; cert [ _num ] = ( x509certificate ) cf . generatecertificate ( certarray ) ; cert [ _num ] = ( x509certificate ) cf . generatecertificate ( certarray2 ) ; keystore keytest = keystore . getinstance ( keystore . getdefaulttype ( ) ) ; try { keytest . setkeyentry ( _str , getprivatekey ( ) , pssword , cert ) ; fail ( ) ; } catch ( keystoreexception expected ) { } keytest . load ( null , null ) ; keytest . setkeyentry ( _str , getprivatekey ( ) , pssword , cert ) ; asserttrue ( _str , keytest . iskeyentry ( _str ) ) ; try { keytest . setkeyentry ( _str , getprivatekey ( ) , pssword , new certificate [ ] { } ) ; fail ( ) ; } catch ( illegalargumentexception expected ) { } }	java . security . keystore # setkeyentry ( java . lang . string , java . security . key , char [ ] , java . security . cert . certificate [ ] ).
public static vec backsub ( matrix u , vec y ) { if ( y . length ( ) != u . rows ( ) ) throw new arithmeticexception ( _str ) ; vec x = y instanceof sparsevector ? new sparsevector ( u . cols ( ) ) : new densevector ( u . cols ( ) ) ; final int start = math . min ( u . rows ( ) , u . cols ( ) ) - _num ; for ( int i = start ; i >= _num ; i -- ) { double x_i = y . get ( i ) ; for ( int j = i + _num ; j <= start ; j ++ ) x_i -= u . get ( i , j ) * x . get ( j ) ; x_i /= u . get ( i , i ) ; if ( double . isinfinite ( x_i ) ) x_i = _num ; x . set ( i , x_i ) ; } return x ; }	solves for the vector x such that u x = y.
public static string incrementatindex ( final string s , final int index ) { final char [ ] chars = s . tochararray ( ) ; chars [ index ] = ( char ) ( chars [ index ] + _num ) ; return new string ( chars ) ; }	increments a single character in the specified string .
public void write ( final byte [ ] b ) throws ioexception { stream . write ( b ) ; }	writes to the stream .
public void disablecrashuploading ( ) { mcrashuploadingenabled = _bool ; }	provides a way to disable crash uploading entirely , regardless of the preferences.
public void createdatachannel ( ) { if ( null != callreference ) { respokecall call = callreference . get ( ) ; if ( null != call ) { peerconnection peerconnection = call . getpeerconnection ( ) ; datachannel = peerconnection . createdatachannel ( _str , new datachannel . init ( ) ) ; datachannel . registerobserver ( this ) ; } } }	establish a new direct connection instance with the peer connection for the call.
public static final void writebytearrayxml ( byte [ ] val , string name , xmlserializer out ) throws xmlpullparserexception , ioexception { if ( val == null ) { out . starttag ( null , _str ) ; out . endtag ( null , _str ) ; return ; } out . starttag ( null , _str ) ; if ( name != null ) { out . attribute ( null , _str , name ) ; } final int n = val . length ; out . attribute ( null , _str , integer . tostring ( n ) ) ; stringbuilder sb = new stringbuilder ( val . length * _num ) ; for ( int i = _num ; i < n ; i ++ ) { int b = val [ i ] ; int h = b > > _num ; sb . append ( h >= _num ? ( _str + h - _num ) : ( _str + h ) ) ; h = b & _num ; sb . append ( h >= _num ? ( _str + h - _num ) : ( _str + h ) ) ; } out . text ( sb . tostring ( ) ) ; out . endtag ( null , _str ) ; }	flatten a byte [ ] into an xmlserializer.
void startcustomexceptionhandler ( ) { list < crashreportingservice > services = getenabledservicesfortype ( crashreportingservice . class ) ; if ( services != null && ! services . isempty ( ) ) { if ( customexceptionhandler == null ) { customexceptionhandler = new customexceptionhandler ( context , services , foamapikeys . wifionly ( ) ) ; } if ( ! customexceptionhandler . isrunning ( ) ) { customexceptionhandler . start ( ) ; } } }	start foam custom exception handler class .
public string clusterertiptext ( ) { return _str ; }	returns the tip text for this property.
@ safevarargs public final assertsubscriber < t > assertvalues ( t ... expectedvalues ) { return assertvaluesequence ( arrays . aslist ( expectedvalues ) ) ; }	assert the specified values have been received in the declared order.
void reset ( ) { system . arraycopy ( iv , _num , counter , _num , blocksize ) ; used = blocksize ; }	resets the iv to its original value.
private void testequalsignorecase ( locale locale ) { locale defaultlocale = locale . getdefault ( ) ; locale . setdefault ( locale ) ; try { for ( string a : latin_i_variants ) { for ( string b : latin_i_variants ) { if ( ! a . equalsignorecase ( b ) ) { fail ( _str + a + _str + b + _str + locale ) ; } } } } finally { locale . setdefault ( defaultlocale ) ; } }	string . equalsignorecase should not depend on the locale .
public void testradixoutofrange ( ) { string value = _str ; int radix = _num ; biginteger anumber = new biginteger ( value , radix ) ; string result = anumber . tostring ( _num ) ; asserttrue ( result . equals ( value ) ) ; }	if 36 < radix < 2 it should be set to 10.
private void sendtrappdu ( inetaddress addr , snmppdupacket pdu ) throws snmpstatusexception , ioexception { snmpmessage msg = null ; try { msg = ( snmpmessage ) pdufactory . encodesnmppdu ( pdu , buffersize ) ; if ( msg == null ) { throw new snmpstatusexception ( snmpdefinitions . snmprspauthorizationerror ) ; } } catch ( snmptoobigexception x ) { if ( snmp_adaptor_logger . isloggable ( level . finest ) ) { snmp_adaptor_logger . logp ( level . finest , dbgtag , _str , _str + _str ) ; } throw new snmpstatusexception ( snmpdefinitions . snmprsptoobig ) ; } opentrapsocketifneeded ( ) ; if ( addr != null ) { msg . address = addr ; try { sendtrapmessage ( msg ) ; } catch ( snmptoobigexception x ) { if ( snmp_adaptor_logger . isloggable ( level . finest ) ) { snmp_adaptor_logger . logp ( level . finest , dbgtag , _str , _str + _str + msg . address ) ; } } } closetrapsocketifneeded ( ) ; }	send the specified trap pdu to the specified destination .
private void addstoragefileswithretry ( businessobjectdatakey businessobjectdatakey , uploaderinputmanifestdto manifest , s3filetransferrequestparamsdto params , string storagename , integer maxretryattempts , integer retrydelaysecs ) throws ioexception , jaxbexception , urisyntaxexception { int retrycount = _num ; while ( _bool ) { try { uploaderwebclient . addstoragefiles ( businessobjectdatakey , manifest , params , storagename ) ; break ; } catch ( ioexception | jaxbexception | urisyntaxexception e ) { if ( retrycount >= maxretryattempts ) { logger . warn ( _str + maxretryattempts + _str ) ; throw e ; } else { logger . warn ( _str , e . tostring ( ) , e ) ; logger . warn ( _str + retrydelaysecs + _str + ( maxretryattempts - retrycount ) + _str ) ; retrycount ++ ; herdthreadhelper . sleep ( retrydelaysecs * _num ) ; } } } }	add storage files to a business object data with a retry on error .
public stringdatatype ( byte [ ] buf ) { this . s = new string ( buf , charset . forname ( _str ) ) ; }	construct a stringdatatype from the bytes in buf .
public workflow . method zonerollbackmethod ( uri exportgroupuri , string contextkey ) { return new workflow . method ( _str , exportgroupuri , contextkey ) ; }	returns the workflow . method for a zonerollback operation .
public long nswap ( ) { return long . parselong ( fields [ _num ] ) ; }	number of pages swapped ( not maintained ) .
private datehelper ( ) { }	prevent initializing this class .
public static string tostring ( char [ ] [ ] c ) { stringbuffer sb = new stringbuffer ( ) ; for ( int i = _num , max = c . length ; i < max ; ++ i ) { if ( i != _num ) sb . append ( _str ) ; sb . append ( c [ i ] ) ; } return sb . tostring ( ) ; }	converts a char [ ] [ ] to string , where segments are separated by '.
private void createhosts ( testenvironment cloudstoreenvironment , list < hostservice . state > hosts ) throws throwable { for ( hostservice . state host : hosts ) { operation result = cloudstoreenvironment . sendpostandwait ( hostservicefactory . self_link , host ) ; assertthat ( result . getstatuscode ( ) , equalto ( _num ) ) ; } }	given the host descriptions created by createhostdescriptions , post them to cloudstore .
protected void autoscaleaxes ( ) { if ( data . isempty ( ) ) { return ; } for ( string axisname : getaxesnames ( ) ) { autoscaleaxis ( axisname ) ; } }	tries to automatically set the ranges of all axes that are set to auto - scale .
public string tostring ( ) { stringbuilder buf = new stringbuilder ( ) ; buf . append ( _str ) ; buf . append ( type ) ; int len = values . length ( ) ; if ( len > _num ) { buf . append ( _str ) ; boolean first = _bool ; for ( pair < methodsymbol , attribute > value : values ) { if ( ! first ) buf . append ( _str ) ; first = _bool ; name name = value . fst . name ; if ( len > _num || name != name . table . names . value ) { buf . append ( name ) ; buf . append ( _str ) ; } buf . append ( value . snd ) ; } buf . append ( _str ) ; } return buf . tostring ( ) ; }	returns a string representation of this annotation . string is of one of the forms :.
protected void addline ( printwriter file , string string ) { log . debug ( string ) ; if ( file != null ) { file . println ( string ) ; } }	writes string to file.
@ override public int countbyfield2 ( boolean field2 ) { finderpath finderpath = finder_path_count_by_field2 ; object [ ] finderargs = new object [ ] { field2 } ; long count = ( long ) findercache . getresult ( finderpath , finderargs , this ) ; if ( count == null ) { stringbundler query = new stringbundler ( _num ) ; query . append ( _sql_count_foo_where ) ; query . append ( _finder_column_field2_field2_2 ) ; string sql = query . tostring ( ) ; session session = null ; try { session = opensession ( ) ; query q = session . createquery ( sql ) ; querypos qpos = querypos . getinstance ( q ) ; qpos . add ( field2 ) ; count = ( long ) q . uniqueresult ( ) ; findercache . putresult ( finderpath , finderargs , count ) ; } catch ( exception e ) { findercache . removeresult ( finderpath , finderargs ) ; throw processexception ( e ) ; } finally { closesession ( session ) ; } } return count . intvalue ( ) ; }	returns the number of foos where field2 = & # 63 ; .
public static void fillrectange ( graphics2d g2d , jcomponent c , boolean round ) { compierecolor cc = null ; boolean stdcc = c . getclientproperty ( compierelookandfeel . background_fill ) != null ; try { cc = ( compierecolor ) c . getclientproperty ( compierelookandfeel . background ) ; } catch ( exception e ) { stdcc = _bool ; } if ( stdcc ) cc = compierecolor . getdefaultbackground ( ) ; if ( cc != null ) { cc . paint ( g2d , c ) ; } else { paint paint = c . getbackground ( ) ; g2d . setpaint ( paint ) ; rectangularshape rec = null ; if ( round ) rec = new roundrectangle2d . float ( _num , _num , c . getwidth ( ) , c . getheight ( ) , _num , _num ) ; else rec = new rectangle ( _num , _num , c . getwidth ( ) , c . getheight ( ) ) ; g2d . fill ( rec ) ; } }	fill background with color . ( ususlly called from update methods ).
public workflow . method updateconsistencygroupreadonlystatemethod ( list < uri > vplexvolumeuris , boolean isreadonly ) { return new workflow . method ( _str , vplexvolumeuris , isreadonly ) ; }	method to update consistencygroup read - only state , must match args of updateconsistencygroupreadonlystate ( except stepid ).
public void testcreatedocumenttype1 ( ) throws throwable { string publicid = _str ; string systemid = _str ; string malformedname = _str ; document doc ; domimplementation domimpl ; doc = ( document ) load ( _str , builder ) ; domimpl = doc . getimplementation ( ) ; { boolean success = _bool ; try { domimpl . createdocumenttype ( malformedname , publicid , systemid ) ; } catch ( domexception ex ) { success = ( ex . code == domexception . namespace_err ) ; } asserttrue ( _str , success ) ; } }	runs the test case .
protected boolean istemporarydestination ( ) { boolean result = _bool ; if ( m_queuename . startswith ( temp_queue_prefix ) ) { result = _bool ; } return result ; }	this method determines whether a particular destination instance refers to a temporary destination .
public double gaussianpotentialupside ( double percentile ) { ql . require ( percentile < _num && percentile >= _num , _str ) ; double result = gaussianpercentile ( percentile ) ; return math . max ( result , _num ) ; }	percentile must be in range [ 90 % - 100 % ).
void addrule ( int startyear , int endyear , int month , int dayofmonthindicator , int dayofweek , localtime time , boolean timeendofday , timedefinition timedefinition , int savingamountsecs ) { if ( fixedsavingamountsecs != null ) { throw new illegalstateexception ( _str ) ; } if ( rulelist . size ( ) >= _num ) { throw new illegalstateexception ( _str ) ; } boolean lastrule = _bool ; if ( endyear == year_max_value ) { lastrule = _bool ; endyear = startyear ; } int year = startyear ; while ( year <= endyear ) { tzrule rule = new tzrule ( year , month , dayofmonthindicator , dayofweek , time , timeendofday , timedefinition , savingamountsecs ) ; if ( lastrule ) { lastrulelist . add ( rule ) ; } else { rulelist . add ( rule ) ; } maxlastrulestartyear = math . max ( startyear , maxlastrulestartyear ) ; year ++ ; } }	adds a rule to the current window .
public void removemapping ( string virtual ) throws expressionexception , securityexception { checkwriteaccess ( ) ; _removemapping ( virtual ) ; }	delete a mapping on system.
protected boolean trackmessage ( functionstreamingreplymessage m ) { this . msgsprocessed ++ ; if ( m . islastmessage ( ) ) { this . nummsgs = m . getmessagenumber ( ) + _num ; } return this . msgsprocessed == this . nummsgs ; }	return true if this is the very last reply msg to process for this member.
protected < t > void registerservice ( class < t > clazz , t instance ) { applicationcontainer . registercomponentinstance ( clazz . getname ( ) , instance ) ; }	register your mock implementations here before executing your test cases .
@ suppresswarnings ( _str ) @ override public void run ( ) { synchronized ( threadmonitorobject ) { if ( incomingqueue . isempty ( ) ) { try { threadmonitorobject . wait ( ) ; } catch ( interruptedexception e ) { logger . error ( _str ) ; } } } while ( handlerenabled || ! incomingqueue . isempty ( ) ) { while ( ! incomingqueue . isempty ( ) ) { synchronized ( threadmonitorobject ) { incomingqueue . drainto ( copylist ) ; } while ( ! copylist . isempty ( ) ) { try { methodtocall . invoke ( objecttocall , copylist . pollfirst ( ) ) ; } catch ( illegalargumentexception e ) { logger . error ( _str , e . getmessage ( ) ) ; } catch ( illegalaccessexception e ) { logger . error ( _str , e . getmessage ( ) ) ; } catch ( invocationtargetexception e ) { logger . error ( _str , e . getmessage ( ) ) ; } catch ( exception e ) { logger . error ( _str , e . getmessage ( ) ) ; } } } synchronized ( threadmonitorobject ) { if ( incomingqueue . isempty ( ) ) { try { threadmonitorobject . wait ( ) ; } catch ( interruptedexception e ) { logger . error ( _str ) ; e . printstacktrace ( ) ; } } } } }	start the thread . expires once shutdown has been called .
static void mergesortnocopy ( final int [ ] x , final int [ ] y , final int [ ] auxx , final int [ ] auxy , final int toindex , final int insertionsortindex ) { if ( ( toindex > x . length ) || ( toindex > y . length ) || ( toindex > auxx . length ) || ( toindex > auxy . length ) ) { throw new arrayindexoutofboundsexception ( _str + toindex ) ; } mergesort ( x , y , x , auxx , y , auxy , insertionsortindex , toindex ) ; if ( ( insertionsortindex == _num ) || ( auxx [ insertionsortindex - _num ] <= auxx [ insertionsortindex ] ) ) { system . arraycopy ( auxx , _num , x , _num , toindex ) ; system . arraycopy ( auxy , _num , y , _num , toindex ) ; return ; } for ( int i = _num , p = _num , q = insertionsortindex ; i < toindex ; i ++ ) { if ( ( q >= toindex ) || ( ( p < insertionsortindex ) && ( auxx [ p ] <= auxx [ q ] ) ) ) { x [ i ] = auxx [ p ] ; y [ i ] = auxy [ p ] ; p ++ ; } else { x [ i ] = auxx [ q ] ; y [ i ] = auxy [ q ] ; q ++ ; } } }	modified merge sort : input arrays are in both auxx / auxy ( sorted : 0 to insertionsortindex ) and x / y ( unsorted : insertionsortindex to toindex ) outputs are stored in x / y arrays.
public scriptbuilder op ( int opcode ) { return op ( chunks . size ( ) , opcode ) ; }	adds the given opcode to the end of the program .
public void addflakes ( int quantity ) { for ( int i = _num ; i < quantity ; ++ i ) { flakes . add ( flake . createflake ( getwidth ( ) , droid , getcontext ( ) ) ) ; } setnumflakes ( numflakes + quantity ) ; }	add the specified number of droidflakes .
public void add ( component comp , object constraints ) { if ( comp == null ) { throw new runtimeexception ( _str ) ; } if ( comp instanceof dockwrapper ) { debug . error ( _str ) ; super . add ( comp , constraints ) ; } else { if ( constraints . equals ( background ) ) { background = ( jcomponent ) comp ; super . add ( comp , constraints ) ; setlayer ( comp , background_layer . intvalue ( ) ) ; } else if ( constraints instanceof dockconstraint ) { if ( comp instanceof jtoolbar ) { jtoolbar t = ( jtoolbar ) comp ; t . setfloatable ( _bool ) ; } setconstraint ( ( jcomponent ) comp , ( dockconstraint ) constraints ) ; if ( ! alreadyadded ( comp ) ) { createdockwrapper ( ( jcomponent ) comp ) ; } } else { debug . error ( _str + constraints ) ; } } }	we need to handle adding the component specially.
public shape createsliderthumbdiscrete ( final int x , final int y , final int w , final int h , final cornersize size ) { final double toparc = size . getradius ( w , h ) ; final double bottomarch = size == cornersize . interior ? _num : _num ; final double bottomarcw = _num ; path . reset ( ) ; path . moveto ( x , y + toparc ) ; path . quadto ( x , y , x + toparc , y ) ; path . lineto ( x + w - toparc , y ) ; path . quadto ( x + w , y , x + w , y + toparc ) ; path . lineto ( x + w , y + h / _num ) ; path . quadto ( x + w - bottomarcw , y + h - bottomarch , x + w / _num , y + h ) ; path . quadto ( x + bottomarcw , y + h - bottomarch , x , y + h / _num ) ; path . closepath ( ) ; return path ; }	return a path for a discrete slider thumb ' s concentric sections .
public smstextmessage ( string msg ) { if ( haswidthchar ( msg ) ) settext ( msg , smsdcs . getgeneraldatacodingdcs ( smsalphabet . ucs2 , smsmsgclass . class_unknown ) ) ; else settext ( msg , smsdcs . getgeneraldatacodingdcs ( smsalphabet . ascii , smsmsgclass . class_unknown ) ) ; }	creates an smstextmessage with default 7bit gsm alphabet.
protected < t > database makesimpledatabase ( string filename , int expectedsize ) { return makesimpledatabase ( filename , expectedsize , new listparameterization ( ) , null ) ; }	generate a simple doublevector database from a file .
private static boolean ispartitiontag ( string [ ] partitions , string tagname ) { if ( partitions != null ) { for ( string partition : partitions ) { if ( partition . equals ( tagname ) ) { return _bool ; } } } return _bool ; }	check if the tagname is one of the partition tags.
protected void onnoupdate ( ) { if ( logconfiguration . loggingisenabled ( ) ) { logger . log ( level . info , _str ) ; } uihandler . hidemessage ( ) ; updating = _bool ; fireapplicationcacheevent ( cacheevent . onnoupdate ) ; }	called when a noupdate event is triggered.
private boolean isnoiseword ( string term ) { int len = term . length ( ) ; if ( minwordlen > _num && len < minwordlen ) { return _bool ; } if ( maxwordlen > _num && len > maxwordlen ) { return _bool ; } return stopwords != null && stopwords . contains ( term ) ; }	determines if the passed term is likely to be of interest in " more queryfromdocuments " comparisons.
@ override public inetaddress addressremote ( ) { socketchannel s = _channel ; if ( s != null ) { try { inetsocketaddress addr = ( inetsocketaddress ) s . getremoteaddress ( ) ; return addr . getaddress ( ) ; } catch ( ioexception e ) { throw new runtimeexception ( e ) ; } } else { return null ; } }	returns the remote client ' s inet address .
public boolean isannotationpresent ( object object , string property , class < ? extends annotation > annotationclass ) { objects . requirenonnull ( object , _str ) ; return isannotationpresent ( object . getclass ( ) , property , annotationclass ) ; }	determine whether the given annotation is present in the object ' s class or in any of its superclasses .
public static matrix readlavmodelfile ( string filename , boolean ignorefirstline ) { linkedlist < string > filerows = generallib . readfilerows ( filename ) ; matrix stringmatrix = new matrix ( ) ; int maxnumberoftabs = _num ; for ( string row : filerows ) { int numberoftabs = row . split ( _str ) . length ; if ( numberoftabs > maxnumberoftabs ) { maxnumberoftabs = numberoftabs ; } } for ( string row : filerows ) { string [ ] columns = row . split ( _str ) ; int numberoftabs = columns . length ; if ( numberoftabs == maxnumberoftabs ) { if ( ignorefirstline ) { ignorefirstline = _bool ; } else { arraylist < string > rowlist = generallib . convertstringarraytoarraylist ( columns ) ; stringmatrix . addrow ( rowlist ) ; } } else { debuglib . emptyfunctionforsettingbreakpoint ( ) ; } } if ( stringmatrix . getnumberofrows ( ) == _num ) { debuglib . stopsystemandreportinconsistency ( _str + maxnumberoftabs ) ; } return stringmatrix ; }	todo : write test for this .
void loadimage ( string src , imageloadingspan loadingspan ) ;	a callback to load an image found in a markdown document .
private arraylist < string > splitvalues ( arraylist < string > values , presetitem preset , string key ) { arraylist < string > result = new arraylist < string > ( ) ; string delimiter = matcher . quotereplacement ( _str + preset . getdelimiter ( key ) + _str ) ; if ( values == null ) { return null ; } for ( string v : values ) { if ( v == null ) { return null ; } for ( string s : v . split ( delimiter ) ) { result . add ( s . trim ( ) ) ; } } return result ; }	split multi select values with the preset defined delimiter character.
public void clearaccountdisabledstate ( ) { operations . add ( passwordpolicystateoperationtype . clear_account_disabled_state ) ; }	clears the account disabled state .
public static < t > collection < t > intersection ( collection < t > c1 , collection < t > c2 ) { set < t > set1 = new hashset < > ( c1 ) ; set1 . retainall ( new hashset < > ( c2 ) ) ; return set1 ; }	returns the intersection of the given collections .
public boolean isprotected ( ) { return modifier . isprotected ( flags ) ; }	utility method to query the modifier flags of this member .
public void skipbytes ( long length ) throws ioexception { long skipped = _num ; while ( skipped < length ) { int val = in . read ( ) ; if ( val < _num ) { throw new ioexception ( _str ) ; } skipped ++ ; } bytesread += length ; }	skip a number of bytes from the input stream.
@ suppresswarnings ( _str ) public static collection < x509certificate > readcertificates ( string base64data ) throws exception { try ( inputstream is = new bytearrayinputstream ( decodebase64 ( base64data ) ) ) { return ( collection < x509certificate > ) cert_factory . generatecertificates ( is ) ; } }	reads x509certificate object from given base64 data .
public static void o ( double [ ] [ ] a ) { o ( a , parameters . outputfieldwidth , parameters . outputfracplaces ) ; }	prints a 2 - dimensional array of doubles in default e format .
@ override public list < eventobject > retrieveheadlessevents ( ) { return m_headlessevents ; }	get the list of events processed in headless mode . may return null or an empty list if not running in headless mode or no events were processed.
public version ( string version ) throws versionexception { this ( version , _str ) ; }	construct a version object from the supplied string assuming that the string delimiter used is '.
private void enlargecapacity ( int key ) { int diff = offcount - offset ; int mincapacity = math . max ( arr . length , key + offset + diff + _num ) ; if ( mincapacity > arr . length ) { int oldcapacity = arr . length ; int newcapacity = oldcapacity + ( oldcapacity > > _num ) ; if ( newcapacity - mincapacity < _num ) newcapacity = mincapacity ; if ( newcapacity - max_array_size > _num ) newcapacity = hugecapacity ( mincapacity ) ; arr = arrays . copyof ( arr , newcapacity ) ; } }	! ! ! all methods that use this method must be sync enlarge the inner array to given size.
public dnetscapecertificaterenewalurl ( jdialog parent ) { super ( parent ) ; settitle ( res . getstring ( _str ) ) ; initcomponents ( ) ; }	creates a new dnetscapecertificaterenewalurl dialog .
default < v > throwingbifunction < t1 , t2 , v , e > andthen ( final throwingfunction < ? super r , ? extends v , e > after ) { objects . requirenonnull ( after ) ; return null ; }	performs provided action on the result of this throwingbifunction instance.
public collection < solrinfombean > offermbeans ( ) { return collections . emptyset ( ) ; }	optionally allow the directoryfactory to request registration of some mbeans .
public boolean ispannable ( ) { return pannable ; }	returns whether the plot area in the panel can be panned .
private static string [ ] fracture ( string str , string sep ) { if ( str . length ( ) == _num ) { return new string [ _num ] ; } arraylist < string > res = new arraylist < string > ( ) ; int in = _num ; int curpos = _num ; int i = str . indexof ( sep ) ; int len = sep . length ( ) ; while ( i != - _num ) { string s = str . substring ( curpos , i ) ; res . add ( s ) ; in ++ ; curpos = i + len ; i = str . indexof ( sep , curpos ) ; } len = str . length ( ) ; if ( curpos <= len ) { string s = str . substring ( curpos , len ) ; in ++ ; res . add ( s ) ; } return res . toarray ( new string [ in ] ) ; }	helper method to avoid stringtokenizer using .
protected boolean synthesizedelement ( element elem ) { if ( matchnameattribute ( elem . getattributes ( ) , html . tag . implied ) ) { return _bool ; } return _bool ; }	returns true if the element is a synthesized element.
public static void writexmldocument ( document doc , string filename ) { try { transformerfactory transformerfactory = transformerfactory . newinstance ( ) ; transformer transformer ; transformer = transformerfactory . newtransformer ( ) ; transformer . setoutputproperty ( outputkeys . indent , _str ) ; domsource source = new domsource ( doc ) ; streamresult result = new streamresult ( new file ( filename ) ) ; transformer . transform ( source , result ) ; log . fine ( _str + filename + _str ) ; } catch ( transformerconfigurationexception e ) { log . warning ( e . getmessage ( ) ) ; } catch ( transformerexception e ) { log . warning ( e . getmessage ( ) ) ; } }	writes the xml document to the particular file specified as argument.
public set < string > subentries ( ssotoken token , string objname , string filter , int numofentries , boolean sortresults , boolean ascendingorder ) throws smsexception , ssoexception { if ( ( objname == null ) || ( objname . length ( ) == _num ) || ( filter == null ) || ( filter . length ( ) == _num ) || ( numofentries < _num ) ) { throw new illegalargumentexception ( _str + _str + _str + objname == null ? _str : objname + _str + filter == null ? _str : filter + _str ) ; } set < string > subentries = null ; try { subentries = getsubentries ( objname , filter , null , numofentries , sortresults , ascendingorder ) ; } catch ( servicenotfoundexception e ) { subentries = new caseinsensitivehashset ( ) ; } if ( mdebug . messageenabled ( ) ) { mdebug . message ( _str + _str + filter + _str + objname + _str + subentries . size ( ) + _str ) ; } return subentries ; }	returns a set of sub - entry names that match the given filter .
final public boolean endswithignorecase ( final string suffix ) { final int l = suffix . length ( ) ; int length = length ( ) ; if ( l > length ) return _bool ; int i = l ; final char [ ] a = array ; char c , d ; while ( i -- != _num ) { c = character . tolowercase ( character . touppercase ( suffix . charat ( i ) ) ) ; d = character . tolowercase ( character . touppercase ( a [ -- length ] ) ) ; if ( c != d ) return _bool ; } return _bool ; }	returns whether this mutable string ends with the given string disregarding case .
public klhandlergeneric ( string device ) { try { setdevicename ( device ) ; } catch ( exception ex ) { log . fatal ( ex ) ; } commtimer = new timer ( commtimeouttime , commtimeouthandler ) ; commtimer . setinitialdelay ( commtimeouttime ) ; commtimer . stop ( ) ; }	construct with connecting to device.
public static double gamma ( double z ) { if ( z < _num ) { return ( internalgamma ( z ) ) ; } else { double multiplier = math . floor ( z / _num ) ; double remainder = z / multiplier ; double coef1 = math . pow ( _num * math . pi , ( _num * ( _num - multiplier ) ) ) ; double coef2 = math . pow ( multiplier , ( ( multiplier * remainder ) - _num ) ) ; int n = ( int ) multiplier ; double prod = _num ; for ( int k = _num ; k < n ; k ++ ) { prod *= internalgamma ( remainder + ( ( double ) k / multiplier ) ) ; } return coef1 * coef2 * prod ; } }	gamma function ( from dstat , used by permission ).
public void addpage ( lexiconpage page ) { pages . add ( page ) ; }	adds a page to the list of pages .
public static numberformat makenumberformat ( int digits ) { switch ( digits ) { case _num : return nf0 ; case _num : return nf2 ; case _num : return nf3 ; case _num : return nf4 ; case _num : return nf6 ; case _num : return nf8 ; } final numberformat nf = numberformat . getinstance ( locale . us ) ; nf . setmaximumfractiondigits ( digits ) ; nf . setminimumfractiondigits ( digits ) ; nf . setgroupingused ( _bool ) ; return nf ; }	initialize a number format with elki standard options ( us locale , no grouping ) .
public static synchronized type tarray ( type elem ) { string sig = new string ( sig_array + elem . gettypesignature ( ) ) ; type t = ( type ) typehash . get ( sig ) ; if ( t == null ) { t = new arraytype ( sig , elem ) ; } return t ; }	create an array type .
@ override public void readexternal ( objectinput in ) throws ioexception , classnotfoundexception { super . readexternal ( in ) ; this . knndistance = in . readdouble ( ) ; }	calls the super method and reads the knn distance of this entry from the specified input stream .
public static boolean contains ( string s1 , string s2 ) { if ( s1 == null || s2 == null ) { return _bool ; } return s1 . contains ( s2 ) ; }	check if one string contains another string .
public static void main ( string [ ] args ) throws ioexception { list < byte > binbook = createbinbook ( ) ; fileoutputstream out = new fileoutputstream ( _str ) ; int booklen = binbook . size ( ) ; byte [ ] binbooka = new byte [ booklen ] ; for ( int i = _num ; i < booklen ; i ++ ) binbooka [ i ] = binbook . get ( i ) ; out . write ( binbooka ) ; out . close ( ) ; }	creates the book . bin file .
@ override public void draw ( graphics2d g2 , dialplot plot , rectangle2d frame , rectangle2d view ) { rectangle2d f = dialplot . rectanglebyradius ( frame , this . radius , this . radius ) ; arc2d arc = new arc2d . double ( f , this . angle , _num , arc2d . open ) ; point2d pt = arc . getstartpoint ( ) ; g2 . setpaint ( this . paint ) ; g2 . setfont ( this . font ) ; textutilities . drawalignedstring ( this . label , g2 , ( float ) pt . getx ( ) , ( float ) pt . gety ( ) , this . anchor ) ; }	draws the background to the specified graphics device.
public void remove ( t line ) { int idx = _list . indexof ( line ) ; if ( idx != - _num ) remove ( idx ) ; }	helper - function that resolves to remove ( int ).
public string pickupengine ( engine engine ) { stringbuilder builder = new stringbuilder ( ) ; for ( string attribute : setup . getpickupenginemessageformat ( ) ) { builder . append ( getengineattribute ( engine , attribute , pickup ) ) ; } return builder . tostring ( ) ; }	returns the pick up string for a loco.
public generatorpropertyiteratorpanel ( experiment exp ) { this ( ) ; setexperiment ( exp ) ; }	creates the property iterator panel and sets the experiment .
private void addglobalattributestointent ( intent intent ) { if ( ! intent . hasextra ( event . attribute_time ) ) { inserttimestamp ( intent ) ; } if ( ! intent . hasextra ( event . attribute_location ) ) { insertlocationdata ( intent ) ; } }	add global attributes of an event to the extra values of the intent .
public static string tostring ( localdatetime data , string modelo ) { return data == null ? _str : data . format ( formatter ( modelo ) ) ; }	converte localdatetime para string indicando o formato da tostring.
public dnsoutgoing addanswer ( dnsincoming in , inetaddress addr , int port , dnsoutgoing out , dnsrecord rec ) throws ioexception { dnsoutgoing newout = out ; if ( newout == null ) { newout = new dnsoutgoing ( dnsconstants . flags_qr_response | dnsconstants . flags_aa , _bool , in . getsenderudppayload ( ) ) ; } try { newout . addanswer ( in , rec ) ; } catch ( final ioexception e ) { newout . setflags ( newout . getflags ( ) | dnsconstants . flags_tc ) ; newout . setid ( in . getid ( ) ) ; send ( newout ) ; newout = new dnsoutgoing ( dnsconstants . flags_qr_response | dnsconstants . flags_aa , _bool , in . getsenderudppayload ( ) ) ; newout . addanswer ( in , rec ) ; } return newout ; }	add an answer to a question . deal with the case when the outgoing packet overflows.
public int dnsdomainlevels ( string host ) { int count = _num ; int startpos = _num ; while ( ( startpos = host . indexof ( _str , startpos + _num ) ) > - _num ) { count ++ ; } return count ; }	returns the number of dns domain levels ( number of dots ) in the host name .
public boolean isoverwrite ( ) { return overwrite ; }	checks if is overwrite .
private list < pair < sceneview , sceneview > > imageswithcommonfeatures ( double n , list < sceneview > imglist ) { list < pair < sceneview , sceneview > > images = new arraylist < > ( ) ; for ( int i = _num ; i < imglist . size ( ) ; i ++ ) { sceneview imgi = imglist . get ( i ) ; for ( int j = _num ; j < imglist . size ( ) ; j ++ ) { if ( j > i ) { sceneview imgj = imglist . get ( j ) ; collection < feature > f = imgj . getcommonfeatures ( imgi ) ; if ( f . size ( ) >= n ) { images . add ( new pair < > ( imgi , imgj ) ) ; } } } } return images ; }	returns list of pairs of images with common features.
@ override public boolean write ( byte [ ] data , int offset , int length ) throws ioexception { if ( mseqsize + length <= mlimit ) { mseqdata . write ( data , offset , length ) ; mseqsize += length ; mchecksumseq . update ( data , offset , length ) ; return _bool ; } return _bool ; }	writes sequence bytes to disk .
private static string readasstring ( inputstream stream ) throws ioexception { stringwriter writer = new stringwriter ( ) ; reader reader = new bufferedreader ( new inputstreamreader ( stream , _str ) ) ; while ( _bool ) { int c = reader . read ( ) ; if ( c < _num ) { break ; } writer . write ( c ) ; } return writer . tostring ( ) ; }	reads an inputstream and converts it to a string .
public final double squareddistance ( final int x , final int y ) { final double othermiddlex = x + _num ; final double othermiddley = y + _num ; final rectangle2d thisarea = getarea ( ) ; final double thismiddlex = thisarea . getcenterx ( ) ; final double thismiddley = thisarea . getcentery ( ) ; double xdistance = math . abs ( othermiddlex - thismiddlex ) - ( area . getwidth ( ) + _num ) / _num ; double ydistance = math . abs ( othermiddley - thismiddley ) - ( area . getheight ( ) + _num ) / _num ; if ( xdistance < _num ) { xdistance = _num ; } if ( ydistance < _num ) { ydistance = _num ; } return xdistance * xdistance + ydistance * ydistance ; }	this returns square of the distance from this entity to a specific point.
@ override public boolean equals ( object p_test ) { if ( p_test instanceof uri ) { uri testuri = ( uri ) p_test ; if ( ( ( m_scheme == null && testuri . m_scheme == null ) || ( m_scheme != null && testuri . m_scheme != null && m_scheme . equals ( testuri . m_scheme ) ) ) && ( ( m_userinfo == null && testuri . m_userinfo == null ) || ( m_userinfo != null && testuri . m_userinfo != null && m_userinfo . equals ( testuri . m_userinfo ) ) ) && ( ( m_host == null && testuri . m_host == null ) || ( m_host != null && testuri . m_host != null && m_host . equals ( testuri . m_host ) ) ) && m_port == testuri . m_port && ( ( m_path == null && testuri . m_path == null ) || ( m_path != null && testuri . m_path != null && m_path . equals ( testuri . m_path ) ) ) && ( ( m_querystring == null && testuri . m_querystring == null ) || ( m_querystring != null && testuri . m_querystring != null && m_querystring . equals ( testuri . m_querystring ) ) ) && ( ( m_fragment == null && testuri . m_fragment == null ) || ( m_fragment != null && testuri . m_fragment != null && m_fragment . equals ( testuri . m_fragment ) ) ) ) { return _bool ; } } return _bool ; }	determines if the passed - in object is equivalent to this uri .
public samregionrestriction ( regionrestriction restriction ) { super ( restriction . getsequencename ( ) , restriction . getstart ( ) , restriction . getend ( ) ) ; }	restriction to named template sequence , accepts restrictions of the form name , name : start - end or name : start + length .
public void restorefilesfromdirectory ( file directory ) throws ioexception { log . debug ( _str , directory . getabsolutepath ( ) ) ; copybackupset ( directory , getoperationsroot ( ) ) ; }	restores a backup set from the given directory .
protected boolean isempty ( bytebuffer bbuf ) { switch ( layertype ) { case none : case footprint : case viewshed : case derivative : break ; case elevation : case field : floatbuffer fbuf = bbuf . asfloatbuffer ( ) ; int fl = fbuf . limit ( ) ; for ( int i = _num ; i < fl ; ++ i ) { if ( ! float . isnan ( fbuf . get ( i ) ) ) { return ( _bool ) ; } } break ; case colorimage : intbuffer ibuf = bbuf . asintbuffer ( ) ; int il = ibuf . limit ( ) ; for ( int i = _num ; i < il ; ++ i ) { if ( ibuf . get ( i ) != _num ) { return ( _bool ) ; } } break ; case grayimage : int bl = bbuf . limit ( ) ; for ( int i = _num ; i < bl ; ++ i ) { if ( bbuf . get ( i ) != _num ) { return ( _bool ) ; } } break ; } return ( _bool ) ; }	determine if a tile is empty.
public void updateresults ( ) { mresultlist . clear ( ) ; int count = _num ; for ( int x = _num ; x < msearchablelist . size ( ) ; x ++ ) { searchresult searchable = msearchablelist . get ( x ) ; if ( msearchfilter . onfilter ( searchable , getsearchtext ( ) ) && count < _num ) { addresult ( searchable ) ; count ++ ; } } if ( mresultlist . size ( ) == _num ) { mresultslistview . setvisibility ( view . gone ) ; } else { mresultslistview . setvisibility ( view . visible ) ; } }	force an update of the results.
commarkersegment ( string comment ) { super ( jpeg . com ) ; data = comment . getbytes ( ) ; }	constructs a marker segment from a string.
@ override public domimplementation item ( int index ) { final int length = getlength ( ) ; if ( index >= _num && index < length ) { return ( domimplementation ) fimplementations . get ( index ) ; } return null ; }	returns the indexth item in the collection .
private boolean hasidleinvokers ( ) { for ( asynceventlistenerinvoker invoker : this . scheduledinvokers ) { if ( invoker . isidle ( ) ) { return _bool ; } } return _bool ; }	determine whether this listener container currently has any idle instances among its scheduled invokers .
public void addmessagelistener ( releasemessagelistener listener ) { if ( ! listeners . contains ( listener ) ) { listeners . add ( listener ) ; } }	add message listeners for release message.
public commandbuilder withlongswitchifpresent ( map < string , object > properties , unaryoperator < string > switchnamemapper , string ... keys ) { for ( string key : keys ) { withlongswitchifpresent ( properties , key , switchnamemapper . apply ( key ) ) ; } return this ; }	if the given key ( s ) is present in the map , create a long switch ( - - switch ) with the given transformation to create the switch name from the key.
public void generatepartition ( instances data ) throws exception { if ( m_classifier instanceof partitiongenerator ) buildclassifier ( data ) ; else throw new exception ( _str + getclassifierspec ( ) + _str ) ; }	builds the classifier to generate a partition .
protected object evaluatesingle ( structuredcontent element , string expr ) { return null ; }	override this element to handle testing a predicate expression with no comparator .
private segment createmappedsegment ( segmentdescriptor descriptor ) { file segmentfile = segmentfile . createsegmentfile ( name , storage . directory ( ) , descriptor . id ( ) , descriptor . version ( ) ) ; buffer buffer = mappedbuffer . allocate ( segmentfile , math . min ( default_buffer_size , descriptor . maxsegmentsize ( ) ) , integer . max_value ) ; descriptor . copyto ( buffer ) ; segment segment = new segment ( new segmentfile ( segmentfile ) , buffer . slice ( ) , descriptor , createindex ( descriptor ) , new offsetpredicate ( ) , serializer . clone ( ) , this ) ; logger . debug ( _str , segment ) ; return segment ; }	creates a new segment .
private static int limitedlevenshtein ( final string str1 , final string str2 , int idx1 , int idx2 , final int limit ) { while ( _bool ) { if ( idx1 == str1 . length ( ) ) { return str2 . length ( ) - idx2 ; } else if ( idx2 == str2 . length ( ) ) { return str1 . length ( ) - idx1 ; } else if ( str1 . charat ( idx1 ) != str2 . charat ( idx2 ) ) { if ( limit < _num ) { return _num ; } else { return _num + bestlimlev ( str1 , str2 , idx1 , idx2 , limit - _num ) ; } } ++ idx1 ; ++ idx2 ; } }	calculate the levenshtein distance of two strings using index arithmetic given a maximum distance value to terminate calculation.
protected managedresource ( string resourceid , solrresourceloader loader , storageio storageio ) throws solrexception { this . resourceid = resourceid ; this . solrresourceloader = loader ; this . storage = createstorage ( storageio , loader ) ; }	initializes this managed resource , including setting up json - based storage using the provided storageio implementation , such as zk .
@ dataprovider public object [ ] [ ] createrenametestdata ( ) { return new object [ ] [ ] { { _str , _str , _str , _str } , { _str , _str , _str , _str } , { _str , _str , _str , _str } , { _str , _str , _str , _str } , { _str , _str , _str , _str } , { _str , _str , _str , _str } , { _str , _str , _str , _str } } ; }	test data for testlocalname tests .
private static comparable casttocomparable ( object obj ) { try { return ( comparable ) obj ; } catch ( classcastexception cce ) { throw new illegalargumentexception ( _str + obj . getclass ( ) + _str + storagetype . object + _str , cce ) ; } }	cast the object to comparable otherwise throws an illegalargumentexception exception.
private void readobject ( final java . io . objectinputstream in ) throws ioexception , classnotfoundexception { useonoffswith = in . readboolean ( ) ; markercolors = ( markercolors ) in . readobject ( ) ; }	deserialize the state of the object .
public boolean readbool ( ) throws ioexception { return dis . readbyte ( ) > _num ; }	read a boolean from the input stream .
protected boolean [ ] canhandlemissing ( attrtypes attrtypes , int classtype , boolean attributemissing , boolean classmissing , int missinglevel ) { if ( missinglevel == _num ) { print ( _str ) ; } print ( _str ) ; if ( attributemissing ) { print ( _str ) ; if ( classmissing ) { print ( _str ) ; } } if ( classmissing ) { print ( _str ) ; } print ( _str ) ; printattributesummary ( attrtypes , classtype ) ; print ( _str ) ; arraylist < string > accepts = new arraylist < string > ( ) ; accepts . add ( _str ) ; accepts . add ( _str ) ; accepts . add ( _str ) ; int numtrain = getnuminstances ( ) , numtest = getnuminstances ( ) , numclasses = _num ; int numatts = _num , attrindex = _num ; return runbasictest ( attrtypes , numatts , attrindex , classtype , missinglevel , attributemissing , classmissing , numtrain , numtest , numclasses , accepts ) ; }	checks basic missing value handling of the scheme.
@ override public synchronized int lastindexof ( object object ) { return lastindexof ( object , elementcount - _num ) ; }	searches in this vector for the index of the specified object.
public colorfulsquare ( float r , float g , float b , float a ) { bytebuffer bb = bytebuffer . allocatedirect ( squarecoords . length * _num ) ; bb . order ( byteorder . nativeorder ( ) ) ; vertexbuffer = bb . asfloatbuffer ( ) ; vertexbuffer . put ( squarecoords ) ; vertexbuffer . position ( _num ) ; bytebuffer dlb = bytebuffer . allocatedirect ( draworder . length * _num ) ; dlb . order ( byteorder . nativeorder ( ) ) ; drawlistbuffer = dlb . asshortbuffer ( ) ; drawlistbuffer . put ( draworder ) ; drawlistbuffer . position ( _num ) ; color = new float [ ] { r , g , b , a } ; }	sets up the drawing object data for use in an opengl es context .
public static list < string > names ( collection < ? extends dataobjectrestrep > values ) { list < string > names = new arraylist < string > ( ) ; if ( values != null ) { for ( dataobjectrestrep value : values ) { names . add ( value . getname ( ) ) ; } } return names ; }	gets the names of the data objects , null safe.
public void start ( ) throws startupexception { }	start the startup class.
public fielddeclaration declarationof ( fieldbinding fieldbinding ) { if ( fieldbinding != null && this . fields != null ) { for ( int i = _num , max = this . fields . length ; i < max ; i ++ ) { fielddeclaration fielddecl ; if ( ( fielddecl = this . fields [ i ] ) . binding == fieldbinding ) return fielddecl ; } } return null ; }	find the matching parse node , answers null if nothing found.
public static string bytearraytohexstring ( byte in [ ] , int offset ) { if ( in == null || in . length <= _num || offset >= in . length ) return null ; stringbuffer out = new stringbuffer ( in . length * _num ) ; for ( int i = offset ; i < in . length ; i ++ ) { out . append ( bytetohexstring ( in [ i ] ) ) ; out . append ( _str ) ; } return out . tostring ( ) ; }	converts the given byte array into a readable hexa - decimal formatted string , starting from given offset < br > this code was originally taken from jeff boyle ' s article on devx . com.
public static int calccolumnwidth ( jtable table , int col ) { int result ; tablemodel data ; int rowcount ; int row ; int dec ; component c ; result = calcheaderwidth ( table , col ) ; if ( result == - _num ) return result ; data = table . getmodel ( ) ; rowcount = data . getrowcount ( ) ; dec = ( int ) math . ceil ( ( double ) rowcount / ( double ) max_rows ) ; try { for ( row = rowcount - _num ; row >= _num ; row -= dec ) { c = table . preparerenderer ( table . getcellrenderer ( row , col ) , row , col ) ; result = math . max ( result , c . getpreferredsize ( ) . width + _num ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; } return result ; }	calculates the optimal width for the column of the given table.
public void reply ( list < header > responseheaders , boolean out ) throws ioexception { assert ( ! thread . holdslock ( framedstream . this ) ) ; boolean outfinished = _bool ; synchronized ( this ) { if ( responseheaders == null ) { throw new nullpointerexception ( _str ) ; } if ( this . responseheaders != null ) { throw new illegalstateexception ( _str ) ; } this . responseheaders = responseheaders ; if ( ! out ) { this . sink . finished = _bool ; outfinished = _bool ; } } connection . writesynreply ( id , outfinished , responseheaders ) ; if ( outfinished ) { connection . flush ( ) ; } }	sends a reply to an incoming stream .
static boolean shouldreconfigure ( propertychangeevent e ) { if ( e . getpropertyname ( ) == null ) { synchronized ( abstractaction . class ) { if ( reconfigure_on_null == null ) { reconfigure_on_null = boolean . valueof ( accesscontroller . doprivileged ( new getpropertyaction ( _str , _str ) ) ) ; } return reconfigure_on_null ; } } return _bool ; }	whether or not to reconfigure all action properties from the specified event .
public static boolean isbanned ( string ip ) { for ( bannedip ipban : banlist ) { if ( ipban . isactive ( ) && networkutils . checkipmatching ( ipban . getmask ( ) , ip ) ) { return _bool ; } } return _bool ; }	checks if ip ( or mask ) is banned.
@ override public list < alarmmodeldescriptor > alarmmodels ( ) { list < alarmmodeldescriptor > descriptors = new arraylist < alarmmodeldescriptor > ( ) ; for ( servicereference < alarmmodel > model : models ) { descriptors . add ( model . metainfo ( alarmmodeldescriptor . class ) ) ; } return descriptors ; }	returns all the alarmmodels that has been installed .
public static object stringtovalue ( string string ) { double d ; if ( string . equals ( _str ) ) { return string ; } if ( string . equalsignorecase ( _str ) ) { return boolean . true ; } if ( string . equalsignorecase ( _str ) ) { return boolean . false ; } if ( string . equalsignorecase ( _str ) ) { return jsonobject . null ; } char b = string . charat ( _num ) ; if ( ( b >= _str && b <= _str ) || b == _str ) { try { if ( string . indexof ( _str ) > - _num || string . indexof ( _str ) > - _num || string . indexof ( _str ) > - _num ) { d = double . valueof ( string ) ; if ( ! d . isinfinite ( ) && ! d . isnan ( ) ) { return d ; } } else { long mylong = new long ( string ) ; if ( string . equals ( mylong . tostring ( ) ) ) { if ( mylong . longvalue ( ) == mylong . intvalue ( ) ) { return new integer ( mylong . intvalue ( ) ) ; } else { return mylong ; } } } } catch ( exception ignore ) { } } return string ; }	try to convert a string into a number , boolean , or null.
public static byte [ ] read ( inputstream in ) throws ioexception { bytearrayoutputstream out = new bytearrayoutputstream ( ) ; int read = _num ; byte [ ] buff = new byte [ _num ] ; while ( ( read = in . read ( buff ) ) > _num ) { out . write ( buff , _num , read ) ; } in . close ( ) ; out . flush ( ) ; out . close ( ) ; return out . tobytearray ( ) ; }	reads an input stream and writes it to a byte array.
public static string replaceall ( string source , string pattern , string replace ) { stringbuilder sb = new stringbuilder ( ) ; int idx = _num ; string workingsource = source ; idx = workingsource . indexof ( pattern ) ; if ( idx == - _num ) { return source ; } while ( idx != - _num ) { sb . append ( workingsource . substring ( _num , idx ) ) ; sb . append ( replace ) ; workingsource = workingsource . substring ( idx + pattern . length ( ) ) ; idx = workingsource . indexof ( pattern ) ; } sb . append ( workingsource ) ; return sb . tostring ( ) ; }	this method replaces all occurrences of the pattern with the replacement string.
public set < wordtoken > nearestwords ( final int distance , predicate < dependency > predicate , final wordtoken ... start ) { return nearestwords ( distance , predicate , arrays . aslist ( start ) ) ; }	find the nearest neighbours within dependency distance links of the provided start dependencies .
private void addexcludeclassnode ( documentnode inlinedocumentnode , node componentroot ) { metadatanode inlineexcludenode = new metadatanode ( componentroot . getnamespace ( ) , componentroot . getlocalpart ( ) , _num ) ; inlineexcludenode . image = componentroot . image ; cdatanode excludetextnode = new cdatanode ( ) ; excludetextnode . image = _str ; inlineexcludenode . addchild ( excludetextnode ) ; inlinedocumentnode . addchild ( inlineexcludenode ) ; }	adds excludeclass metadata to inline_component nodes .
protected void deletesunxmlkeyvalfiles ( file dirhandle ) throws smsexception { stringbuilder sb = new stringbuilder ( smsentry . attr_xml_keyval ) ; sb . append ( _str ) ; filenamefilter filter = new filenamefilter ( sb . tostring ( ) ) ; file [ ] deletefiles = dirhandle . listfiles ( filter ) ; for ( int i = _num ; deletefiles != null && i < deletefiles . length ; i ++ ) { file deletefile = deletefiles [ i ] ; deletefile . delete ( ) ; } }	delete sunxmlkeyvalue files under the given directory .
public static multistateanimation fromjsonresource ( context context , int resid ) { return multistateanimation . fromjsonresource ( context , null , resid ) ; }	create a multistateanimation from a json resource without a connected view .
showdialog ( jframe frame ) { innerframe = frame ; }	defining the dialog ' s owner jframe is highly recommended .
public void sort ( ) { arrays . sort ( data , _num , count ) ; }	sorts the array in place .
private list < string > arraytolist ( string [ ] array ) { return arrays . aslist ( array ) ; }	turns an array of strings into an list of strings .
public static void align ( bytebuffer blob ) { blob . position ( align ( blob . position ( ) ) ) ; }	aligns the supplied bytebuffer position to the next four byte boundary.
private void openlogfile ( ) throws ioexception { try { close ( ) ; } catch ( ioexception e ) { } logname = versionname ( logfileprefix ) ; log = new randomaccessfile ( logname , _str ) ; logfd = log . getfd ( ) ; if ( logbytes == _num ) { format = format_padded ; writeint ( log , magic ) ; writeint ( log , format ) ; logbytes = ( intbytes + intbytes ) ; } else { log . seek ( logbytes ) ; } log . setlength ( logbytes ) ; log . write ( zerobuf ) ; logfd . sync ( ) ; }	opens the incremental update log file in read / write mode.
public void add ( string key , string value ) { keys . add ( key ) ; values . add ( value ) ; }	add a key / value pair.
public variable [ ] findarraysincurrentscope ( ) { list < variable > arrays = new arraylist < variable > ( ) ; for ( listiterator < variable > iterator = flocalvariables . listiterator ( flocalvariables . size ( ) ) ; iterator . hasprevious ( ) ; ) { variable localvariable = iterator . previous ( ) ; if ( localvariable . isarray ( ) ) arrays . add ( localvariable ) ; } for ( listiterator < variable > iterator = ffields . listiterator ( ffields . size ( ) ) ; iterator . hasprevious ( ) ; ) { variable field = iterator . previous ( ) ; if ( field . isarray ( ) ) arrays . add ( field ) ; } return arrays . toarray ( new variable [ arrays . size ( ) ] ) ; }	returns all arrays , visible in the current context ' s scope , in the order that they appear .
public void writelinenumbertable ( environment env , dataoutputstream out , constantpool tab ) throws ioexception { long ln = - _num ; int count = _num ; for ( instruction inst = first ; inst != null ; inst = inst . next ) { long n = ( inst . where > > whereoffsetbits ) ; if ( ( n > _num ) && ( ln != n ) ) { ln = n ; count ++ ; } } ln = - _num ; out . writeshort ( count ) ; for ( instruction inst = first ; inst != null ; inst = inst . next ) { long n = ( inst . where > > whereoffsetbits ) ; if ( ( n > _num ) && ( ln != n ) ) { ln = n ; out . writeshort ( inst . pc ) ; out . writeshort ( ( int ) ln ) ; } } }	write the linenumber table.
public static string downloadstring ( url url , proxy proxy , int readtimeout , int sockettimeout , string encoding , int triescount ) { ioexception lastexception = null ; for ( int i = _num ; i < triescount ; i ++ ) { lastexception = null ; httpurlconnection connection = null ; inputstream inputstream = null ; try { connection = ( httpurlconnection ) ( proxy == null ? url . openconnection ( ) : url . openconnection ( proxy ) ) ; connection . setreadtimeout ( readtimeout ) ; connection . setconnecttimeout ( sockettimeout ) ; connection . connect ( ) ; inputstream = connection . getinputstream ( ) ; return ioutils . tostring ( inputstream , encoding ) ; } catch ( ioexception ex ) { if ( log . isdebugenabled ( ) ) { log . warn ( _str , url , triescount , ex ) ; } else { log . warn ( _str , url , triescount , ex . getmessage ( ) ) ; } lastexception = ex ; } finally { ioutils . closequietly ( inputstream ) ; if ( connection != null ) { connection . disconnect ( ) ; } } } if ( lastexception != null ) { log . error ( _str + url , lastexception ) ; } return null ; }	downloads content from the specified url using specified proxy ( or do not using it ) and timeouts.
private jaxbelement < errorresponse > createxmlparsingerrorresponse ( inputstream is , objectfactory objfactory , batchresponse batchresponse , string parsererrormessage ) { errorresponse errorresponse = objfactory . createerrorresponse ( ) ; dsmlcontenthandler contenthandler = new dsmlcontenthandler ( ) ; try { final xmlreader xmlreader = createsafexmlreader ( ) ; xmlreader . setcontenthandler ( contenthandler ) ; is . reset ( ) ; xmlreader . parse ( new inputsource ( is ) ) ; } catch ( parserconfigurationexception | saxexception | ioexception e ) { } if ( parsererrormessage != null ) { errorresponse . setmessage ( parsererrormessage ) ; } batchresponse . setrequestid ( contenthandler . requestid ) ; errorresponse . settype ( malformed_request ) ; return objfactory . createbatchresponseerrorresponse ( errorresponse ) ; }	returns an error response after a parsing error.
public static date convertdate ( value value , calendar calendar ) { if ( value == valuenull . instance ) { return null ; } valuedate d = ( valuedate ) value . convertto ( value . date ) ; calendar cal = ( calendar ) calendar . clone ( ) ; cal . clear ( ) ; cal . setlenient ( _bool ) ; long datevalue = d . getdatevalue ( ) ; setcalendarfields ( cal , yearfromdatevalue ( datevalue ) , monthfromdatevalue ( datevalue ) , dayfromdatevalue ( datevalue ) , _num , _num , _num , _num ) ; long ms = cal . gettimeinmillis ( ) ; return new date ( ms ) ; }	convert the date to the specified time zone .
private void queryandcompareuif ( object ... params ) throws exception { final queryresponse expect = query ( params ) ; final object [ ] newparams = arrays . copyof ( params , params . length + _num ) ; newparams [ newparams . length - _num ] = _str ; newparams [ newparams . length - _num ] = _str ; final queryresponse uifresult = query ( newparams ) ; compareresponses ( expect , uifresult ) ; }	comparing results with facet . method = uif.
protected datetimedata parse ( string str ) throws schemadatetimeexception { datetimedata date = new datetimedata ( str , this ) ; int len = str . length ( ) ; date . year = year ; if ( str . charat ( _num ) != _str || str . charat ( _num ) != _str ) { throw new schemadatetimeexception ( _str + str ) ; } date . month = parseint ( str , _num , _num ) ; int start = _num ; if ( str . charat ( start ++ ) != _str ) { throw new schemadatetimeexception ( _str + str ) ; } date . day = parseint ( str , start , start + _num ) ; if ( monthday_size < len ) { if ( ! isnextcharutcsign ( str , monthday_size , len ) ) { throw new schemadatetimeexception ( _str + str ) ; } else { gettimezone ( str , date , monthday_size , len ) ; } } validatedatetime ( date ) ; saveunnormalized ( date ) ; if ( date . utc != _num && date . utc != _str ) { normalize ( date ) ; } date . position = _num ; return date ; }	parses , validates and computes normalized version of gmonthday object.
void resume ( ) { paused . set ( _bool ) ; synchronized ( pauselock ) { pauselock . notifyall ( ) ; } }	resumes engine work . paused " load & display " tasks will continue its work .
private boolean isclosurecall ( object receiver , string method ) { return receiver instanceof closure && closure_call_method . equals ( method ) ; }	determines if this method call is a call to a closure ( anonymous method ) defined within the script itself .
public void updatewithclear ( list < gank > data ) { mganklist . clear ( ) ; update ( data ) ; }	before add data , it will remove history data.
private static byte findlongestexpansion ( string uristring , int pos ) { byte expansion = - _num ; int expansionlength = _num ; for ( int i = _num ; i < url_codes . size ( ) ; i ++ ) { int key = url_codes . keyat ( i ) ; string value = url_codes . valueat ( i ) ; if ( value . length ( ) > expansionlength && uristring . startswith ( value , pos ) ) { expansion = ( byte ) key ; expansionlength = value . length ( ) ; } } return expansion ; }	finds the longest expansion from the uri at the current position .
public void removetablemodellistener ( tablemodellistener l ) { listener . remove ( l ) ; }	removes a listener from the list that is notified each time a change to the data model occurs .
public void shutdown ( ) { logger . info ( _str ) ; executor . shutdown ( ) ; }	shuts down the executor.
public static command of ( aggregateid aggregateid , streamtimestamp commandtimestamp , versionedname commandname , tuple parameters , type resulttype ) { checknotnull ( aggregateid , _str ) ; checknotnull ( commandtimestamp , _str ) ; checknotnull ( commandname , _str ) ; checknotnull ( parameters , _str ) ; checknotnull ( resulttype , _str ) ; return new command ( aggregateid , commandtimestamp , optional . empty ( ) , commandname , parameters , resulttype ) ; }	create a new command with the specified properties .
public synchronized boolean remove ( file file ) { if ( value . remove ( file ) ) { setvalue ( value ) ; return _bool ; } else { return _bool ; } }	mutator for this setting .
private set < dtnhost > selecttrackedhosts ( list < dtnhost > allhosts ) { set < dtnhost > trackedhosts = new hashset < dtnhost > ( ) ; if ( this . nrofhosts > allhosts . size ( ) ) { throw new settingserror ( _str + _str ) ; } for ( int i = _num ; i < nrofhosts ; i ++ ) { dtnhost nexthost = allhosts . get ( rng . nextint ( allhosts . size ( ) ) ) ; if ( trackedhosts . contains ( nexthost ) ) { i -- ; } else { trackedhosts . add ( nexthost ) ; } } return trackedhosts ; }	randomly selects the hosts to track.
public static string joingt ( boolean phased , int ... gt ) { final char sep = phased ? phased_separator : unphased_separator ; switch ( gt . length ) { case _num : return missing_field ; case _num : return encodeid ( gt [ _num ] ) ; case _num : return encodeid ( gt [ _num ] ) + sep + encodeid ( gt [ _num ] ) ; default : final stringbuilder sb = new stringbuilder ( ) ; for ( final int c : gt ) { if ( sb . length ( ) > _num ) { sb . append ( sep ) ; } sb . append ( encodeid ( c ) ) ; } return sb . tostring ( ) ; } }	utility method for creating a vcf genotype subfield from an array of numeric allele identifiers .
private static boolean isincornertargetzone ( float x , float y , float handlex , float handley , float targetradius ) { if ( math . abs ( x - handlex ) <= targetradius && math . abs ( y - handley ) <= targetradius ) { return _bool ; } return _bool ; }	determines if the specified coordinate is in the target touch zone for a corner handle .
@ override public boolean equals ( object o ) { if ( this == o ) { return _bool ; } if ( o == null ) { return _bool ; } if ( ! ( o instanceof column ) ) { return _bool ; } column column = ( column ) o ; return objects . equals ( name , column . name ) ; }	allows comparison based solely on the name between objects of the base class and / or any of the derived classes .
public void truncate ( final long position ) { final int index = index ( position ) ; final int offset = offset ( position ) ; final block block = blocks . get ( index ) ; this . index = index ; block . limit = offset ; current = block ; }	resets the write buffer to a particular point .
public static double min ( final double a , final double b ) { if ( a > b ) { return b ; } if ( a < b ) { return a ; } if ( a != b ) { return double . nan ; } long bits = double . doubletorawlongbits ( a ) ; if ( bits == _num ) { return a ; } return b ; }	compute the minimum of two values.
@ override public void adddatasourcelistener ( datasourcelistener dsl ) { m_datalisteners . add ( dsl ) ; }	add a datasource listener.
public static void trainepochs ( regressiondataset dataset , updateableregressor totrain , int epochs ) { if ( epochs < _num ) throw new illegalargumentexception ( _str ) ; totrain . setup ( dataset . getcategories ( ) , dataset . getnumnumericalvars ( ) ) ; intlist randomorder = new intlist ( dataset . getsamplesize ( ) ) ; listutils . addrange ( randomorder , _num , dataset . getsamplesize ( ) , _num ) ; for ( int epoch = _num ; epoch < epochs ; epoch ++ ) { collections . shuffle ( randomorder ) ; for ( int i : randomorder ) totrain . update ( dataset . getdatapoint ( i ) , dataset . gettargetvalue ( i ) ) ; } }	performs training on an updateable classifier by going over the whole data set in random order one observation at a time , multiple times .
private static iterator < string > parse ( class < ? > service , url u , set < string > returned ) throws serviceconfigurationerror { inputstream in = null ; bufferedreader r = null ; arraylist < string > names = new arraylist < > ( ) ; try { in = u . openstream ( ) ; r = new bufferedreader ( new inputstreamreader ( in , _str ) ) ; int lc = _num ; while ( ( lc = parseline ( service , u , r , lc , names , returned ) ) >= _num ) ; } catch ( ioexception x ) { fail ( service , _str + x ) ; } finally { try { if ( r != null ) r . close ( ) ; if ( in != null ) in . close ( ) ; } catch ( ioexception y ) { fail ( service , _str + y ) ; } } return names . iterator ( ) ; }	parse the content of the given url as a provider - configuration file .
private static string roottestclassname ( string originalclassname ) { int periodindex = originalclassname . lastindexof ( _str ) ; if ( periodindex != - _num ) { return originalclassname . substring ( _num , periodindex ) + _str + originalclassname . substring ( periodindex ) ; } else { return _str ; } }	creates a unique test class name.
public void savefavoritestosettings ( settings settings ) { if ( ! loadedfavoritesfromsettings ) { logger . warning ( _str ) ; return ; } list < list > entriestosave = new arraylist < > ( ) ; for ( favorite f : favorites . keyset ( ) ) { entriestosave . add ( favoritetolist ( f , _bool ) ) ; } for ( favorite f : favoritesnotfound . values ( ) ) { if ( f . notfoundcount > _num ) { logger . warning ( _str + f + _str ) ; } else { entriestosave . add ( favoritetolist ( f , _bool ) ) ; } } settings . putlist ( _str , entriestosave ) ; }	saves the favorites to the settings , discarding any favorites that haven ' t been found several times already .
private void completescroll ( boolean postevents ) { boolean needpopulate = scrollstate == scroll_state_settling ; if ( needpopulate ) { scroller . abortanimation ( ) ; int oldx = getscrollx ( ) ; int oldy = getscrolly ( ) ; int x = scroller . getcurrx ( ) ; int y = scroller . getcurry ( ) ; if ( oldx != x || oldy != y ) { scrollto ( x , y ) ; if ( x != oldx ) { pagescrolled ( x ) ; } } } populatepending = _bool ; for ( int i = _num ; i < items . size ( ) ; i ++ ) { iteminfo ii = items . get ( i ) ; if ( ii . scrolling ) { needpopulate = _bool ; ii . scrolling = _bool ; } } if ( needpopulate ) { if ( postevents ) { viewcompat . postonanimation ( this , endscrollrunnable ) ; } else { endscrollrunnable . run ( ) ; } } }	complete a scroll in progress .
private void updateblockmirrorconsistencygroup ( ) { log . info ( _str ) ; dbclient dbclient = getdbclient ( ) ; list < uri > blockmirroruris = dbclient . querybytype ( blockmirror . class , _bool ) ; iterator < blockmirror > blockmirrors = dbclient . queryiterativeobjects ( blockmirror . class , blockmirroruris ) ; list < blockobject > blockobjects = new arraylist < blockobject > ( ) ; while ( blockmirrors . hasnext ( ) ) { blockobjects . add ( blockmirrors . next ( ) ) ; } migrate ( blockobjects ) ; }	update the blockmirror object to migrate the old consistencygroup field into the new consistencygroup list field .
public void add ( string text ) { if ( errors == null ) { errors = new arraylist < string > ( ) ; } errors . add ( text ) ; }	add the error to the list.
public static void fillrepolinks ( final channelinformation channel , final list < menuentry > links , final string basename , final int basepriority , final string prefix , final int priorityoffset , final function < string , linktarget > targetfunction ) { objects . requirenonnull ( channel , _str ) ; objects . requirenonnull ( links , _str ) ; objects . requirenonnull ( basename , _str ) ; objects . requirenonnull ( prefix , _str ) ; objects . requirenonnull ( targetfunction , _str ) ; links . add ( new menuentry ( basename , basepriority , prefix + _str , priorityoffset , targetfunction . apply ( channel . getid ( ) ) , modifier . link , null ) ) ; int i = _num ; for ( final string name : channel . getnames ( ) ) { final linktarget target = targetfunction . apply ( name ) ; if ( target != null ) { links . add ( new menuentry ( basename , basepriority , string . format ( _str , prefix , name ) , priorityoffset + i , target , modifier . link , null ) ) ; } i ++ ; } }	create a set of default repository links.
public static string elapsedtimedisplay ( date datestart , date dateend ) { long diff = dateend . gettime ( ) - datestart . gettime ( ) ; long diffminutes = diff / ( _num * _num ) % _num ; long diffhours = diff / ( _num * _num * _num ) ; string mins = long . tostring ( diffminutes ) ; if ( mins . length ( ) == _num ) { mins = _str + mins ; } return long . tostring ( diffhours ) + _str + mins ; }	elapsedtimedisplay get the elapsed time between two dates in readable format.
public int total ( ) { return counter . intvalue ( ) ; }	get the total number of events that have been handled by this listener .
@ override public void flush ( ) throws ioexception { synchronized ( lock ) { checknotclosed ( ) ; flushinternal ( ) ; out . flush ( ) ; } }	flushes this writer . the contents of the buffer are committed to the target writer and it is then flushed .
public hostmultipathinfologicalunitpolicy createmultipathpolicy ( string name ) { if ( stringutils . equalsignorecase ( name , vmw_psp_fixed ) ) { hostmultipathinfofixedlogicalunitpolicy policy = new hostmultipathinfofixedlogicalunitpolicy ( ) ; policy . setpolicy ( name ) ; policy . setprefer ( _str ) ; return policy ; } else { hostmultipathinfologicalunitpolicy policy = new hostmultipathinfologicalunitpolicy ( ) ; policy . setpolicy ( name ) ; return policy ; } }	create a multipath policy based on the passed policy name.
public trackeroperation createtrackeroperation ( string source , string description ) { preconditions . checkargument ( ! strings . isnullorempty ( source ) , source_is_empty_msg ) ; preconditions . checknotnull ( ! strings . isnullorempty ( description ) , _str ) ; trackeroperationimpl po = new trackeroperationimpl ( source . touppercase ( ) , description , this ) ; if ( savetrackeroperation ( source , po ) ) { return po ; } return null ; }	creates tracker operation and save it to db.
injector ( final map < class < ? > , object > map ) { notnull ( map ) ; this . map = map ; }	mapping of classes to be annotated and the corresponding injected object .
public static void writedatasource ( printstream writer , datasource ds ) { writer . print ( _str ) ; writer . print ( ds . getjndilocation ( ) ) ; writer . print ( _str ) ; writer . print ( ds . getid ( ) ) ; writer . println ( _str ) ; writer . print ( _str ) ; writer . print ( ds . getconnectiontype ( ) ) ; writer . print ( _str ) ; writer . print ( ds . getdriverclass ( ) ) ; writer . println ( _str ) ; writer . print ( _str ) ; string url = ds . geturl ( ) ; if ( url != null ) { writer . print ( _str ) ; writer . print ( ds . geturl ( ) ) ; writer . print ( _str ) ; } writeproperties ( writer , ds . getconnectionproperties ( ) ) ; writer . println ( _str ) ; string user = ds . getusername ( ) ; string pass = ds . getpassword ( ) ; if ( user != null && pass != null ) { writer . print ( _str ) ; writer . print ( user ) ; writer . print ( _str ) ; writer . print ( pass ) ; writer . println ( _str ) ; } writer . println ( _str ) ; }	writes a datasource to the write .
void downcase ( stringbuffer text , int leng ) { for ( int i = _num ; i < leng ; i ++ ) { if ( character . isuppercase ( text . charat ( i ) ) ) { text . setcharat ( i , character . tolowercase ( text . charat ( i ) ) ) ; } } }	lowercase the characters up to the given length.
private actionbutton createtoolbarbutton ( action action ) { return new actionbutton ( action , actionmanager , presentationfactory . getpresentation ( action ) , managerprovider . get ( ) , toolbarresources ) ; }	creates a toolbar button .
public void rearrangechildren ( int itemcount ) { arraylist < view > views = getitemsinreadingorder ( ) ; mcontent . arrangechildren ( views , math . max ( itemcount , views . size ( ) ) ) ; mitemsinvalidated = _bool ; }	rearranges the children based on their rank .
@ suppresswarnings ( _str ) public < u > lazyfuturestream < u > from ( final iterator < u > iterator ) { return fromstream ( streamsupport . stream ( spliterators . spliteratorunknownsize ( iterator , spliterator . ordered ) , _bool ) ) ; }	start a reactive flow from a jdk iterator.
public void addspecificdamage ( string s ) { int ewspot = s . indexof ( _str ) ; if ( s . isempty ( ) || ( ewspot < _num ) ) { return ; } int loc = integer . parseint ( s . substring ( _num , ewspot ) ) ; int setto = integer . parseint ( s . substring ( ewspot + _num ) ) ; boolean rear = ( s . charat ( _num ) == _str ) ; boolean internal = ( s . charat ( _num ) == _str ) ; specificdammage . add ( new specdam ( loc , setto , rear , internal ) ) ; }	converts n2 : 1 to nornam hit to location 2 set armor to 1 !.
private byte [ ] [ ] extractipsandsubnetmasks ( byte [ ] ipwithsubmask1 , byte [ ] ipwithsubmask2 ) { int iplength = ipwithsubmask1 . length / _num ; byte ip1 [ ] = new byte [ iplength ] ; byte subnetmask1 [ ] = new byte [ iplength ] ; system . arraycopy ( ipwithsubmask1 , _num , ip1 , _num , iplength ) ; system . arraycopy ( ipwithsubmask1 , iplength , subnetmask1 , _num , iplength ) ; byte ip2 [ ] = new byte [ iplength ] ; byte subnetmask2 [ ] = new byte [ iplength ] ; system . arraycopy ( ipwithsubmask2 , _num , ip2 , _num , iplength ) ; system . arraycopy ( ipwithsubmask2 , iplength , subnetmask2 , _num , iplength ) ; return new byte [ ] [ ] { ip1 , subnetmask1 , ip2 , subnetmask2 } ; }	splits the ip addresses and their subnet mask .
public string type ( ) { return type ; }	returns the high - level media type , such as " text " , " image " , " audio " , " video " , or " application " .
@ override public int onstartcommand ( intent intent , int flags , int startid ) { log_oc . d ( tag , _str + startid ) ; if ( action_sync_folder . equals ( intent . getaction ( ) ) ) { if ( ! intent . hasextra ( extra_account ) || ! intent . hasextra ( extra_remote_path ) ) { log_oc . e ( tag , _str ) ; return start_not_sticky ; } account account = intent . getparcelableextra ( extra_account ) ; string remotepath = intent . getstringextra ( extra_remote_path ) ; pair < account , string > itemsynckey = new pair < account , string > ( account , remotepath ) ; pair < target , remoteoperation > itemtoqueue = newoperation ( intent ) ; if ( itemtoqueue != null ) { msyncfolderhandler . add ( account , remotepath , ( synchronizefolderoperation ) itemtoqueue . second ) ; message msg = msyncfolderhandler . obtainmessage ( ) ; msg . arg1 = startid ; msg . obj = itemsynckey ; msyncfolderhandler . sendmessage ( msg ) ; } } else { message msg = moperationshandler . obtainmessage ( ) ; msg . arg1 = startid ; moperationshandler . sendmessage ( msg ) ; } return start_not_sticky ; }	entry point to add a new operation to the queue of operations.
private byte [ ] updatenodictionarystartandendkey ( byte [ ] key ) { if ( key . length == _num ) { return key ; } bytebuffer buffer = bytebuffer . wrap ( key , _num , key . length - _num ) ; bytebuffer output = bytebuffer . allocate ( key . length - _num ) ; short numberofbytetostorlength = _num ; for ( int i = _num ; i < numberofnodictionarycolumn ; i ++ ) { output . putshort ( ( short ) ( buffer . getshort ( ) - numberofbytetostorlength ) ) ; } while ( buffer . hasremaining ( ) ) { output . put ( buffer . get ( ) ) ; } output . rewind ( ) ; return output . array ( ) ; }	below method will be used to update the no dictionary start and end key.
public static void createtmpthumb ( final inputstream stream , final file file , final string filename , final iconfiguration conf ) throws ioexception { bufferedinputstream bufferedis = new bufferedinputstream ( stream ) ; bufferedis . mark ( integer . max_value ) ; bufferedimage image = imageio . read ( bufferedis ) ; if ( image == null ) { throw new ioexception ( _str ) ; } dimension dimension = createthumbdimension ( image , conf . getimgwidth ( ) , conf . getimgheight ( ) ) ; if ( image . getheight ( ) == dimension . height && image . getwidth ( ) == dimension . width ) { bufferedis . reset ( ) ; writeuntouchedimage ( bufferedis , file ) ; } else { resizeimage ( image , dimension . width , dimension . height , conf . getimgquality ( ) , file ) ; } stream . close ( ) ; }	uploads image and if the image size is larger than maximum allowed it resizes the image .
public static iclassfilereader createdefaultclassfilereader ( inputstream stream , int decodingflag ) { try { return new classfilereader ( util . getinputstreamasbytearray ( stream , - _num ) , decodingflag ) ; } catch ( classformatexception e ) { return null ; } catch ( ioexception e ) { return null ; } }	create a default classfile reader , able to expose the internal representation of a given classfile according to the decoding flag used to initialize the reader.
public static string replaceunderscores ( string origtext_ ) { return origtext_ . replaceall ( _str , _str ) ; }	replaces underscores with dashes ( many crawled news articles seem to have substituted em - or en - dashes with underscores ).
public static int abs ( number number ) { return math . abs ( number . intvalue ( ) ) ; }	get the absolute value.
public token ( tokentype type , tokenposition position , int length , string data ) { super ( position ) ; if ( length < _num ) throw new illegalargumentexception ( _str ) ; this . type = objects . requirenonnull ( type ) ; this . length = length ; this . data = data ; }	creates a new token with the given parameters .
public boolean isautoreducible ( ) { boolean b = ( boolean ) getclientproperty ( auto_reducible_property ) ; return ( b != null ) && b . booleanvalue ( ) ; }	is the combo box auto - reducible ?.
public dmslatlonpoint ( int lat_degrees , int lat_minutes , double lat_seconds , int lon_degrees , int lon_minutes , double lon_seconds ) { this ( lat_degrees < _num , math . abs ( lat_degrees ) , lat_minutes , lat_seconds , lon_degrees < _num , math . abs ( lon_degrees ) , lon_minutes , lon_seconds ) ; }	create dmslatlonpoint where lat_degrees and lon_degrees are signed , negative for south and west .
public synchronized int init5baud ( int address ) { int result = _num ; setcurraddress ( address ) ; try { commtimer . stop ( ) ; setdevicename ( devicename ) ; for ( int i = _num ; i < baudrates . length ; i ++ ) { setprotstat ( protstatus . connecting ) ; log . info ( string . format ( _str , devicename , address , baudrates [ i ] ) ) ; setcustombaudrate ( baudrates [ i ] ) ; setcurrbaudrate ( baudrates [ i ] ) ; send5baud ( address ) ; try { thread . sleep ( _num ) ; } catch ( interruptedexception e ) { log . error ( _str , e ) ; } if ( getprotstat ( ) != protstatus . connecting ) { log . info ( string . format ( _str , devicename , address , baudrates [ i ] ) ) ; result = getcurrbaudrate ( ) ; commtimer . restart ( ) ; break ; } } if ( result == _num ) { log . warn ( string . format ( _str , devicename , address ) ) ; close ( ) ; } } catch ( exception ex ) { log . error ( devicename + _str + ex . tostring ( ) ) ; close ( ) ; setprotstat ( protstatus . error ) ; result = _num ; } setcurrbaudrate ( result ) ; return ( result ) ; }	initialize communication by sending specified ecu address with 5 baud.
protected void deletebasis ( int selectedbasis ) { basisset . remove ( integer . valueof ( selectedbasis ) ) ; alpha [ selectedbasis ] = - _num ; }	delete a basis function from the model .
public void assertequals ( string assertid , collection expected , nodelist actual ) { collection actuallist = new arraylist ( ) ; int actuallen = actual . getlength ( ) ; for ( int i = _num ; i < actuallen ; i ++ ) { actuallist . add ( actual . item ( i ) ) ; } framework . assertequals ( this , assertid , expected , actuallist ) ; }	asserts that each entry in actual exactly matches with an entry in expected.
public collection < string > listtables ( ) throws databaseexception { collection < string > result = new arraylist < string > ( ) ; resultset rs = null ; try { databasemetadata dbm = connection . getmetadata ( ) ; string types [ ] = { _str } ; rs = dbm . gettables ( null , null , null , types ) ; while ( rs . next ( ) ) { string str = rs . getstring ( _str ) ; result . add ( str ) ; } } catch ( sqlexception e ) { throw ( new databaseexception ( e ) ) ; } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( sqlexception e ) { } } } return result ; }	get a list of all tables in the database .
public void testcharsequence ( ) throws ioexception { charsequence cs = mapper . readvalue ( _str , charsequence . class ) ; assertequals ( string . class , cs . getclass ( ) ) ; assertequals ( _str , cs . tostring ( ) ) ; }	test for [ jackson - 483 ] , allow handling of charsequence.
public namespacedproperties ( string prefix ) { this ( prefix , system . getproperties ( ) , _bool ) ; }	create new instance backed by system properties ( properties instance obtained by system . getproperties ( ).
public void clearcache ( ) { if ( mmemorycache != null ) { mmemorycache . evictall ( ) ; if ( buildconfig . debug ) { log . d ( tag , _str ) ; } } synchronized ( mdiskcachelock ) { mdiskcachestarting = _bool ; if ( mdisklrucache != null && ! mdisklrucache . isclosed ( ) ) { try { mdisklrucache . delete ( ) ; if ( buildconfig . debug ) { log . d ( tag , _str ) ; } } catch ( ioexception e ) { log . e ( tag , _str + e ) ; } mdisklrucache = null ; initdiskcache ( ) ; } } }	clears both the memory and disk cache associated with this imagecache object.
public static final void writestringarrayxml ( string [ ] val , string name , xmlserializer out ) throws xmlpullparserexception , ioexception { if ( val == null ) { out . starttag ( null , _str ) ; out . endtag ( null , _str ) ; return ; } out . starttag ( null , _str ) ; if ( name != null ) { out . attribute ( null , _str , name ) ; } final int n = val . length ; out . attribute ( null , _str , integer . tostring ( n ) ) ; for ( int i = _num ; i < n ; i ++ ) { out . starttag ( null , _str ) ; out . attribute ( null , _str , val [ i ] ) ; out . endtag ( null , _str ) ; } out . endtag ( null , _str ) ; }	flatten a string [ ] into an xmlserializer.
public void queryfunction2 ( bytebuffer bb , stringbuilder high , stringbuilder low ) { int basesec = ( int ) ( windowid > > _num ) ; bb . putint ( basesec ) ; short winid = ( short ) ( windowid & _num ) ; bb . putshort ( winid ) ; integer operid = operatorid ; for ( int i = _num ; i < _num ; i ++ ) { byte num = ( byte ) ( operid > > _num * ( _num - i ) ) ; bb . put ( num ) ; } bytebuffer lowbb = bb . duplicate ( ) ; lowbb . put ( ( byte ) _num ) ; lowbb . put ( ( byte ) _num ) ; lowbb . put ( ( byte ) _num ) ; for ( byte b : lowbb . array ( ) ) { low . append ( string . format ( _str , b & _num ) ) ; } bytebuffer highbb = bb . duplicate ( ) ; highbb . put ( ( byte ) _num ) ; highbb . put ( ( byte ) _num ) ; highbb . put ( ( byte ) _num ) ; for ( byte b : highbb . array ( ) ) { high . append ( string . format ( _str , b & _num ) ) ; } }	4b basesec | 2b windowid | 3b operatorid | 3b tupleid.
private static bytebuffer generatewavheader ( int samplecount ) { final int numdatabytes = samplecount * num_channels * bits_per_sample / _num ; bytebuffer buf = bytebuffer . allocate ( _num ) ; buf . order ( byteorder . little_endian ) ; buf . putint ( _num ) ; buf . putint ( _num + numdatabytes ) ; buf . putint ( _num ) ; buf . putint ( _num ) ; buf . putint ( _num ) ; buf . putshort ( ( short ) _num ) ; buf . putshort ( ( short ) num_channels ) ; buf . putint ( sample_rate ) ; buf . putint ( sample_rate * num_channels * bits_per_sample / _num ) ; buf . putshort ( ( short ) ( num_channels * bits_per_sample / _num ) ) ; buf . putshort ( ( short ) bits_per_sample ) ; buf . putint ( _num ) ; buf . putint ( numdatabytes ) ; buf . position ( _num ) ; return buf ; }	generates the 44 - byte wav file header .
protected final boolean init ( ) throws adeexception { boolean initialized ; final properties prop = new properties ( ) ; try ( fileinputstream fis = new fileinputstream ( propertiesfilename ) ) { prop . load ( fis ) ; initialized = _bool ; } catch ( filenotfoundexception e ) { throw new adeextusageexception ( _str + propertiesfilename + _str , e ) ; } catch ( ioexception e ) { throw new adeextusageexception ( _str + propertiesfilename + _str , e ) ; } catch ( exception e ) { throw new adeextusageexception ( _str + propertiesfilename + _str , e ) ; } return initialized ; }	initializes the db configuration properties and diagnostics directory name for the exported db files .
public void printstacktrace ( java . io . printstream ps ) { if ( rootcause != null ) { string superstring = super . tostring ( ) ; synchronized ( ps ) { ps . print ( superstring + ( superstring . endswith ( _str ) ? _str : _str ) + _str ) ; rootcause . printstacktrace ( ps ) ; } } else { super . printstacktrace ( ps ) ; } }	prints this exception ' s stack trace to a print stream.
public filedata ( byte [ ] bodyhash , file file ) { mbodyfile = file ; setbodyhash ( bodyhash ) ; setsize ( ( int ) file . length ( ) ) ; }	create a new filedata .
public void simulatemethod ( sootmethod method , referencevariable thisvar , referencevariable returnvar , referencevariable params [ ] ) { string subsignature = method . getsubsignature ( ) ; if ( subsignature . equals ( _str ) ) { java_lang_package_getsystempackage0 ( method , thisvar , returnvar , params ) ; return ; } else if ( subsignature . equals ( _str ) ) { java_lang_package_getsystempackages0 ( method , thisvar , returnvar , params ) ; return ; } else { defaultmethod ( method , thisvar , returnvar , params ) ; return ; } }	implements the abstract method simulatemethod.
void createedges ( integer [ ] v ) { graph . addedge ( new double ( math . random ( ) ) , v [ _num ] , v [ _num ] , edgetype . directed ) ; graph . addedge ( new double ( math . random ( ) ) , v [ _num ] , v [ _num ] , edgetype . directed ) ; graph . addedge ( new double ( math . random ( ) ) , v [ _num ] , v [ _num ] , edgetype . directed ) ; graph . addedge ( new double ( math . random ( ) ) , v [ _num ] , v [ _num ] , edgetype . directed ) ; graph . addedge ( new double ( math . random ( ) ) , v [ _num ] , v [ _num ] , edgetype . directed ) ; graph . addedge ( new double ( math . random ( ) ) , v [ _num ] , v [ _num ] ) ; graph . addedge ( new double ( math . random ( ) ) , v [ _num ] , v [ _num ] ) ; }	create edges for this demo graph.
static void checkinternalname ( final string name , final string msg ) { if ( name == null || name . length ( ) == _num ) { throw new illegalargumentexception ( _str + msg + _str ) ; } if ( name . charat ( _num ) == _str ) { checkdesc ( name , _bool ) ; } else { checkinternalname ( name , _num , - _num , msg ) ; } }	checks that the given string is a valid internal class name .
public static string cleanpath ( string path ) { if ( path == null ) { return null ; } string pathtouse = replace ( path , windows_folder_separator , folder_separator ) ; int prefixindex = pathtouse . indexof ( _str ) ; string prefix = _str ; if ( prefixindex != - _num ) { prefix = pathtouse . substring ( _num , prefixindex + _num ) ; if ( prefix . contains ( _str ) ) { prefix = _str ; } else { pathtouse = pathtouse . substring ( prefixindex + _num ) ; } } if ( pathtouse . startswith ( folder_separator ) ) { prefix = prefix + folder_separator ; pathtouse = pathtouse . substring ( _num ) ; } string [ ] patharray = delimitedlisttostringarray ( pathtouse , folder_separator ) ; list < string > pathelements = new linkedlist < string > ( ) ; int tops = _num ; for ( int i = patharray . length - _num ; i >= _num ; i -- ) { string element = patharray [ i ] ; if ( current_path . equals ( element ) ) { } else if ( top_path . equals ( element ) ) { tops ++ ; } else { if ( tops > _num ) { tops -- ; } else { pathelements . add ( _num , element ) ; } } } for ( int i = _num ; i < tops ; i ++ ) { pathelements . add ( _num , top_path ) ; } return prefix + collectiontodelimitedstring ( pathelements , folder_separator ) ; }	normalize the path by suppressing sequences like " path /.
public string encodebody ( ) { return text != null ? integer . tostring ( code ) + sp + agent + sp + double_quote + text + double_quote : integer . tostring ( code ) + sp + agent ; }	encode the body of the header ( return the stuff following name : ) .
@ override protected void inserttext ( final string text , final notificationtype type ) { final stringbuilder sbuf = new stringbuilder ( ) ; sbuf . append ( _str ) ; sbuf . append ( type . getmnemonic ( ) ) ; sbuf . append ( _str ) ; sbuf . append ( translatetohtml ( text ) ) ; sbuf . append ( _str ) ; appendstring ( sbuf . tostring ( ) ) ; }	insert the text portion of the line using a specified notification type for style .
private int count ( boolean [ ] arraysetted , byte [ ] [ ] array , byte [ ] value ) { if ( value != null ) { int counter = _num ; for ( int i = _num ; i < array . length ; i ++ ) { if ( arraysetted != null && arraysetted [ i ] && arrays . equals ( value , array [ i ] ) ) { counter ++ ; } } return counter ; } return _num ; }	counts how many times ' value ' occurs in ' array '.
private void assertwritelittleendian64 ( byte [ ] data , long value ) throws exception { bytearrayoutputstream rawoutput = new bytearrayoutputstream ( ) ; codedoutputstream output = codedoutputstream . newinstance ( rawoutput ) ; output . writerawlittleendian64 ( value ) ; output . flush ( ) ; assertequalbytes ( data , rawoutput . tobytearray ( ) ) ; for ( int blocksize = _num ; blocksize <= _num ; blocksize *= _num ) { rawoutput = new bytearrayoutputstream ( ) ; output = codedoutputstream . newinstance ( rawoutput , blocksize ) ; output . writerawlittleendian64 ( value ) ; output . flush ( ) ; assertequalbytes ( data , rawoutput . tobytearray ( ) ) ; } }	parses the given bytes using writerawlittleendian64 ( ) and checks that the result matches the given value .
private void enabledisablespacingfields ( ) { if ( manuallysetnumcolumns . isselected ( ) ) { tfnumcolumns . setenabled ( _bool ) ; } else { tfnumcolumns . setenabled ( _bool ) ; } }	enable or disable spacing fields depending on whether the layout is in manual columns mode .
protected void drawxlabels ( list < double > xlabels , double [ ] xtextlabellocations , canvas canvas , paint paint , int left , int top , int bottom , double xpixelsperunit , double minx , double maxx ) { int length = xlabels . size ( ) ; boolean showlabels = mrenderer . isshowlabels ( ) ; boolean showgridy = mrenderer . isshowgridy ( ) ; boolean showtickmarks = mrenderer . isshowtickmarks ( ) ; for ( int i = _num ; i < length ; i ++ ) { double label = xlabels . get ( i ) ; float xlabel = ( float ) ( left + xpixelsperunit * ( label - minx ) ) ; if ( showlabels ) { paint . setcolor ( mrenderer . getxlabelscolor ( ) ) ; if ( showtickmarks ) { canvas . drawline ( xlabel , bottom , xlabel , bottom + mrenderer . getlabelstextsize ( ) / _num , paint ) ; } drawtext ( canvas , getlabel ( mrenderer . getxlabelformat ( ) , label ) , xlabel , bottom + mrenderer . getlabelstextsize ( ) * _num / _num + mrenderer . getxlabelspadding ( ) , paint , mrenderer . getxlabelsangle ( ) ) ; } if ( showgridy ) { paint . setcolor ( mrenderer . getgridcolor ( _num ) ) ; canvas . drawline ( xlabel , bottom , xlabel , top , paint ) ; } } drawxtextlabels ( xtextlabellocations , canvas , paint , showlabels , left , top , bottom , xpixelsperunit , minx , maxx ) ; }	the graphical representation of the labels on the x axis .
static unixstream < string > echo ( final string input ) { objects . requirenonnull ( input , _str ) ; return new unixstreamimpl < > ( stream . of ( input ) ) ; }	create a new unixstream with the given input .
public aws4signerbase ( url endpointurl , string httpmethod , string servicename , string regionname ) { this . endpointurl = endpointurl ; this . httpmethod = httpmethod ; this . servicename = servicename ; this . regionname = regionname ; datetimeformat = new simpledateformat ( iso8601basicformat ) ; datetimeformat . settimezone ( new simpletimezone ( _num , _str ) ) ; datestampformat = new simpledateformat ( datestringformat ) ; datestampformat . settimezone ( new simpletimezone ( _num , _str ) ) ; }	create a new aws v4 signer .
public dviewasn1dump ( jdialog parent , x509ext extension ) throws asn1exception , ioexception { super ( res . getstring ( _str ) ) ; this . extension = extension ; initcomponents ( ) ; }	creates new dviewasn1dump dialog where the parent is a dialog .
public long arg_start ( ) { return long . parselong ( fields [ _num ] ) ; }	( since linux 3.
public static string genrandomstring ( ) { return genrandomstring ( _num ) ; }	generate a random string with fixed length.
static method findmethod ( class < ? > cls , string methodname , int argcount ) { return findmethod ( cls , methodname , argcount , null ) ; }	find a target methodname on a given class .
public taskresourcerep hostvcenterunassign ( uri hostid , uri eventid ) { return hostclusterchange ( hostid , nullcolumnvaluegetter . getnulluri ( ) , nullcolumnvaluegetter . getnulluri ( ) , _bool , eventid ) ; }	unassign host from a vcenter note : in order to maintain backwards compatibility , do not change the signature of this method .
public omdrawingtool ( ) { super ( ) ; setborder ( borderfactory . createemptyborder ( ) ) ; debug = debug . debugging ( _str ) ; selectionsupport = new selectionsupport ( this ) ; setattributes ( new graphicattributes ( ) ) ; setmousemode ( createmousemode ( ) ) ; undostack = new undostack ( ) ; undotrigger = new undomenuitemstacktrigger ( ) ; undostack . addundostacktrigger ( undotrigger ) ; setuseastool ( _bool ) ; }	create a openmap drawing tool .
public static string javaencode ( string s ) { int length = s . length ( ) ; stringbuilder buff = new stringbuilder ( length ) ; for ( int i = _num ; i < length ; i ++ ) { char c = s . charat ( i ) ; switch ( c ) { case _str : buff . append ( _str ) ; break ; case _str : buff . append ( _str ) ; break ; case _str : buff . append ( _str ) ; break ; case _str : buff . append ( _str ) ; break ; case _str : buff . append ( _str ) ; break ; case _str : buff . append ( _str ) ; break ; default : int ch = c & _num ; if ( ch >= _str && ( ch < _num ) ) { buff . append ( c ) ; } else { buff . append ( _str ) ; string hex = integer . tohexstring ( ch ) ; for ( int len = hex . length ( ) ; len < _num ; len ++ ) { buff . append ( _str ) ; } buff . append ( hex ) ; } } } return buff . tostring ( ) ; }	convert a string to a java literal using the correct escape sequences.
private void readexternaldata ( externalizable obj , objectstreamclass desc ) throws ioexception { serialcallbackcontext oldcontext = curcontext ; if ( oldcontext != null ) oldcontext . check ( ) ; curcontext = null ; try { boolean blocked = desc . hasblockexternaldata ( ) ; if ( blocked ) { bin . setblockdatamode ( _bool ) ; } if ( obj != null ) { try { obj . readexternal ( this ) ; } catch ( classnotfoundexception ex ) { handles . markexception ( passhandle , ex ) ; } } if ( blocked ) { skipcustomdata ( ) ; } } finally { if ( oldcontext != null ) oldcontext . check ( ) ; curcontext = oldcontext ; } }	if obj is non - null , reads externalizable data by invoking readexternal ( ) method of obj ; otherwise , attempts to skip over externalizable data.
@ nullable private string readattribute ( ixmlelement elem , string attributename , @ nullable string defaultvalue ) { if ( elem . hasattribute ( attributename , svg_namespace ) ) { string value = elem . getattribute ( attributename , svg_namespace , null ) ; if ( value . equals ( _str ) ) { return readattribute ( elem . getparent ( ) , attributename , defaultvalue ) ; } else { return value ; } } else if ( elem . hasattribute ( attributename ) ) { string value = elem . getattribute ( attributename , null ) ; if ( value . equals ( _str ) ) { return readattribute ( elem . getparent ( ) , attributename , defaultvalue ) ; } else { return value ; } } else { return defaultvalue ; } }	reads an attribute that is not inherited , unless its value is " inherit " .
public set < string > addincrementalcontent ( independentdistribution content , boolean followprevious ) { if ( ! paused ) { curstate . addtostate_incremental ( content . todiscrete ( ) , followprevious ) ; return update ( ) ; } else { log . info ( _str + content ) ; return collections . emptyset ( ) ; } }	adds the incremental content ( expressed as a distribution over variables ) to the current dialogue state , and subsequently updates it.
private void showsearchview ( ) { if ( msearchview != null && ! oldquery . isempty ( ) ) { msearchview . seticonified ( _bool ) ; msearchview . setquery ( oldquery , _bool ) ; showsearchview = _bool ; } }	sets searchview iconifed to false and sets oldquery as searchquery.
public static void check ( boolean cond , int value ) { if ( ! cond ) error ( string . valueof ( value ) ) ; }	equivalent to assert cond : value ;.
public string printinsts ( int startidx , int endidx ) { stringbuffer bf = new stringbuffer ( ) ; try { bf . append ( _str ) ; for ( int i = startidx ; i <= endidx ; i ++ ) { if ( i == startidx ) { bf . append ( _str + m_instlist [ i ] ) ; } else { bf . append ( _str + m_instlist [ i ] ) ; } } } catch ( exception ex ) { ex . printstacktrace ( ) ; } return bf . tostring ( ) ; }	for printing indices in some given portion of the master index array .
public float computedistanceto ( float x , float y ) { final rectf bounds = getclicktargetbounds ( ) ; float dx = math . max ( bounds . left - x , x - bounds . right ) ; float dy = math . max ( bounds . top - y , y - bounds . bottom ) ; return math . max ( _num , math . max ( dx , dy ) ) ; }	computes the manhattan - ish distance to the edge of the tab.
public static byte [ ] asbytes ( string basicstring ) { final byte [ ] b = new byte [ basicstring . length ( ) ] ; for ( int i = _num ; i < b . length ; ++ i ) { b [ i ] = ( byte ) basicstring . charat ( i ) ; } return b ; }	get the corresponding byte array for a basic string.
private double angleto ( point2d that ) { double dx = that . x - this . x ; double dy = that . y - this . y ; return math . atan2 ( dy , dx ) ; }	returns the angle between this point and that point .
private static list < string > crosscatenate ( list < list < string > > allwordslist ) { list < string > crosslist = new arraylist < string > ( allwordslist . get ( _num ) ) ; for ( list < string > wordlist : allwordslist . sublist ( _num , allwordslist . size ( ) ) ) { int priorcrosslistlength = crosslist . size ( ) ; crosslist = replicate ( crosslist , wordlist . size ( ) ) ; for ( int i = _num ; i < wordlist . size ( ) ; i ++ ) { for ( int j = _num ; j < priorcrosslistlength ; j ++ ) { int index = i * priorcrosslistlength + j ; crosslist . set ( index , crosslist . get ( index ) + _str + wordlist . get ( i ) ) ; } } } return crosslist ; }	function to perform a cross product concatenation of separate rewritten term lists for example if there are k lists : < l1 > , < l2 > , < l3 > ,.
public static < k , v > map < k , v > of ( k k1 , v v1 ) { map map = of ( ) ; map . put ( k1 , v1 ) ; return map ; }	returns map containing a single entry .
public void log ( final string id ) { if ( id . contains ( _str ) ) { throw new illegalargumentexception ( id ) ; } final stringbuilder sb = new stringbuilder ( ) ; localtostring ( sb , id ) ; diagnostic . developerlog ( sb . tostring ( ) ) ; }	write the accumulated time and average time to the log .
public generalpath draw ( graphics2d g2 , rectangle2d dataarea , valueaxis horizontalaxis , valueaxis verticalaxis ) { generalpath generalpath = generateclippath ( dataarea , horizontalaxis , verticalaxis ) ; if ( this . fillpath || this . drawpath ) { composite savecomposite = g2 . getcomposite ( ) ; paint savepaint = g2 . getpaint ( ) ; stroke savestroke = g2 . getstroke ( ) ; if ( this . fillpaint != null ) { g2 . setpaint ( this . fillpaint ) ; } if ( this . composite != null ) { g2 . setcomposite ( this . composite ) ; } if ( this . fillpath ) { g2 . fill ( generalpath ) ; } if ( this . drawstroke != null ) { g2 . setstroke ( this . drawstroke ) ; } if ( this . drawpath ) { g2 . draw ( generalpath ) ; } g2 . setpaint ( savepaint ) ; g2 . setcomposite ( savecomposite ) ; g2 . setstroke ( savestroke ) ; } return generalpath ; }	draws the clip path .
private list < processchange > updatecontroltaginformation ( final configurationelement element , final process process ) { list < processchange > changes = new arraylist < processchange > ( _num ) ; long processid = process . getid ( ) ; controltag alivetagcopy = controlcache . getcopy ( process . getalivetagid ( ) ) ; if ( alivetagcopy != null ) { setprocessid ( ( controltagcacheobject ) alivetagcopy , processid ) ; } else { throw new configurationexception ( configurationexception . invalid_parameter_value , string . format ( _str , process . getalivetagid ( ) , process . getid ( ) , process . getname ( ) ) ) ; } controltag statustagcopy = controlcache . getcopy ( process . getstatetagid ( ) ) ; if ( statustagcopy != null ) { setprocessid ( ( controltagcacheobject ) statustagcopy , processid ) ; } else { throw new configurationexception ( configurationexception . invalid_parameter_value , string . format ( _str , process . getstatetagid ( ) , process . getid ( ) , process . getname ( ) ) ) ; } return changes ; }	ensures that the alive - , status - and commfault tags have appropriately the process id set .
@ override public xyitemrendererstate initialise ( graphics2d g2 , rectangle2d dataarea , xyplot plot , xydataset dataset , plotrenderinginfo info ) { valueaxis axis = plot . getdomainaxis ( ) ; double x1 = axis . getlowerbound ( ) ; double x2 = x1 + this . maxcandlewidthinmilliseconds ; rectangleedge edge = plot . getdomainaxisedge ( ) ; double xx1 = axis . valuetojava2d ( x1 , dataarea , edge ) ; double xx2 = axis . valuetojava2d ( x2 , dataarea , edge ) ; this . maxcandlewidth = math . abs ( xx2 - xx1 ) ; if ( this . drawvolume ) { ohlcdataset highlowdataset = ( ohlcdataset ) dataset ; this . maxvolume = _num ; for ( int series = _num ; series < highlowdataset . getseriescount ( ) ; series ++ ) { for ( int item = _num ; item < highlowdataset . getitemcount ( series ) ; item ++ ) { double volume = highlowdataset . getvolumevalue ( series , item ) ; if ( volume > this . maxvolume ) { this . maxvolume = volume ; } } } } return new xyitemrendererstate ( info ) ; }	initialises the renderer then returns the number of ' passes ' through the data that the renderer will require ( usually just one ).
public static string keyforimage ( string imagepath ) { string key = null ; try { messagedigest messagedigest = messagedigest . getinstance ( _str ) ; messagedigest . update ( imagepath . getbytes ( ) ) ; key = bytetohex ( messagedigest . digest ( ) ) ; } catch ( nosuchalgorithmexception e ) { e . printstacktrace ( ) ; } return key ; }	generate md5 key for picture.
static boolean isavailableforconnection ( ) { boolean available ; if ( _connectioninprogress . get ( ) ) { available = _bool ; } else { requestreceiver receiver = _receiverref . get ( ) ; boolean connected = _bool ; if ( receiver != null ) { try { receiver . getreceiverid ( ) ; connected = _bool ; } catch ( remoteexception e ) { } } available = ! connected ; } return available ; }	if this session of matlab is available to be connected to from an external java program.
public boolean addvalue ( value v ) { return values . add ( v ) ; }	add " hasvalue v " information .
public select < t > sortasc ( string ... columns ) { for ( string column : columns ) { msortingorderlist . add ( column + _str ) ; } return this ; }	sorts the specified columns in asc order.
public void error ( final string msg ) { try { merr . append ( msg ) ; merr . append ( ls ) ; } catch ( final ioexception e ) { throw new runtimeexception ( e ) ; } }	prints message to the specified error output .
public void cleanup ( boolean deleteall ) { long currenttime = system . currenttimemillis ( ) ; file file = new file ( getoutputdirectorystring ( ) ) ; if ( file . isdirectory ( ) ) { file [ ] files = file . listfiles ( ) ; for ( int i = _num ; i < files . length ; i ++ ) { file f = files [ i ] ; if ( ! deleteall ) { try { long ft = gettimeforfilename ( f . getname ( ) ) ; long tdiff = currenttime - ft ; if ( debug ) { debug . output ( _str + f . getname ( ) + _str + ft + _str + currenttime + _str + getcleanupinterval ( ) + _str + tdiff ) ; } if ( tdiff > getcleanupinterval ( ) ) { if ( debug ) debug . output ( _str ) ; f . delete ( ) ; } } catch ( numberformatexception nfe ) { } } else { f . delete ( ) ; } } } }	remove old files . checks the current time against the timestamps decoded by the names of files found in the output directory , and deletes them if the difference between those times is greater than the cleanupinterval .
public static boolean isemptyorblanks ( string string ) { if ( string == null || string . length ( ) == _num ) { return _bool ; } for ( int i = _num ; i < string . length ( ) ; i ++ ) { char c = string . charat ( i ) ; if ( ! character . iswhitespace ( c ) ) { return _bool ; } } return _bool ; }	checks if the given string is null , empty or contains whitespace only.
@ override public void fillassignedkeys ( set < string > keys ) { treeset < string > subkeys = new treeset < > ( ) ; for ( exprkraken expr : _exprs ) { subkeys . clear ( ) ; expr . fillassignedkeys ( subkeys ) ; keys . addall ( subkeys ) ; } }	returns all the keys assigned statically , e.
@ category ( flakytest . class ) @ test public void testmissingmemberredundancy1 ( ) { host host = host . gethost ( _num ) ; vm vm0 = host . getvm ( _num ) ; vm vm1 = host . getvm ( _num ) ; vm vm2 = host . getvm ( _num ) ; createpr ( vm0 , _num ) ; createpr ( vm1 , _num ) ; createdata ( vm0 , _num , num_buckets , _str ) ; set < integer > vm0buckets = getbucketlist ( vm0 ) ; set < integer > vm1buckets = getbucketlist ( vm1 ) ; closecache ( vm1 ) ; checkdata ( vm0 , _num , num_buckets , _str ) ; removedata ( vm0 , _num , num_buckets / _num ) ; createdata ( vm0 , num_buckets / _num , num_buckets , _str ) ; createpr ( vm2 , _num ) ; set < integer > vm2buckets = getbucketlist ( vm2 ) ; assertequals ( collections . emptyset ( ) , vm2buckets ) ; createpr ( vm1 , _num ) ; checkdata ( vm1 , _num , num_buckets / _num , null ) ; checkdata ( vm1 , num_buckets / _num , num_buckets , _str ) ; assertequals ( vm0buckets , getbucketlist ( vm0 ) ) ; assertequals ( vm1buckets , getbucketlist ( vm1 ) ) ; assertequals ( collections . emptyset ( ) , getbucketlist ( vm2 ) ) ; }	test the with redundancy 1 , we restore the same buckets when the missing member comes back online .
public tfsrepository connectifnecessary ( final iproject project ) { check . notnull ( project , _str ) ; waitformanagerstartup ( ) ; projectrepositorydata projectdata ; synchronized ( projectdatalock ) { projectdata = projectdatamap . get ( project ) ; if ( projectdata == null ) { boolean shouldconnect = shouldconnect ( project ) ; if ( shouldconnect == null ) { return null ; } projectdata = new projectrepositorydata ( ) ; projectdatamap . put ( project , projectdata ) ; projectclosedset . remove ( project ) ; if ( shouldconnect . equals ( boolean . false ) && isanyprojectofstatus ( projectrepositorystatus . online ) ) { shouldconnect = boolean . true ; } else if ( shouldconnect . equals ( boolean . true ) && isanyprojectofstatus ( projectrepositorystatus . offline ) ) { shouldconnect = boolean . false ; } if ( shouldconnect == boolean . false ) { projectdata . setstatus ( projectrepositorystatus . offline ) ; return null ; } projectdata . setstatus ( projectrepositorystatus . connecting ) ; } else { synchronized ( projectdata ) { if ( projectdata . getstatus ( ) == projectrepositorystatus . initializing ) { return null ; } else if ( projectdata . getstatus ( ) != projectrepositorystatus . connecting ) { return projectdata . getrepository ( ) ; } } } } return connectinternal ( project , _bool , projectdata ) ; }	connects the given iproject to its team foundation server if and only if it is not marked offline.
public void load ( t entity , compoundtag tag ) { if ( tag . islist ( _str , tagtype . double ) ) { entity . setvelocity ( nbtserialization . listtovector ( tag . getlist ( _str , tagtype . double ) ) ) ; } if ( tag . isfloat ( _str ) ) { entity . setfalldistance ( tag . getfloat ( _str ) ) ; } if ( tag . isshort ( _str ) ) { entity . setfireticks ( tag . getshort ( _str ) ) ; } if ( tag . isbyte ( _str ) ) { entity . setonground ( tag . getbool ( _str ) ) ; } if ( tag . isbyte ( _str ) ) { entity . setgravity ( ! tag . getbool ( _str ) ) ; } if ( tag . isbyte ( _str ) ) { entity . setsilent ( tag . getbool ( _str ) ) ; } if ( tag . islong ( _str ) && tag . islong ( _str ) ) { uuid uuid = new uuid ( tag . getlong ( _str ) , tag . getlong ( _str ) ) ; entity . setuniqueid ( uuid ) ; } else if ( tag . isstring ( _str ) ) { uuid uuid = uuid . fromstring ( tag . getstring ( _str ) ) ; entity . setuniqueid ( uuid ) ; } }	load data into an existing entity of the appropriate type from the given compound tag .
public static string quoteidentifier ( string s ) { if ( s == null || s . length ( ) == _num ) { return _str ; } char c = s . charat ( _num ) ; if ( ( ! character . isletter ( c ) && c != _str ) || character . islowercase ( c ) ) { return stringutils . quoteidentifier ( s ) ; } for ( int i = _num , length = s . length ( ) ; i < length ; i ++ ) { c = s . charat ( i ) ; if ( ( ! character . isletterordigit ( c ) && c != _str ) || character . islowercase ( c ) ) { return stringutils . quoteidentifier ( s ) ; } } if ( iskeyword ( s , _bool ) ) { return stringutils . quoteidentifier ( s ) ; } return s ; }	add double quotes around an identifier if required .
public static int count ( string string , string mark ) { if ( ! textutils . isempty ( string ) && ! textutils . isempty ( mark ) ) { int count = _num ; int index = string . indexof ( mark ) ; while ( index != - _num ) { count ++ ; string = string . substring ( index + mark . length ( ) ) ; index = string . indexof ( mark ) ; } return count ; } return _num ; }	count how many marks existed in string .
final void putdouble ( int offset , double value ) { unsafe . putdouble ( offset + address , value ) ; }	writes a double at the specified offset from this native object ' s base address .
public double eval ( double i , double j ) { double evalkernel = math . exp ( - _num * ( math . pow ( ( i - j ) , _num ) / math . pow ( sigma , _num ) ) ) ; return evalkernel ; }	evaluates the kernel at two given points.
public void removeall ( ) { recentsearches . clear ( ) ; save ( ) ; firechangeevent ( ) ; }	remove all recent searches .
protected void reinit ( ) { if ( isloggingenabled ( ) ) stacklogger . logdebug ( _str ) ; messageprocessors = new arraylist < messageprocessor > ( ) ; this . iohandler = new iohandler ( this ) ; pendingtransactions = new concurrenthashmap < string , sipservertransaction > ( ) ; clienttransactiontable = new concurrenthashmap < string , sipclienttransaction > ( ) ; servertransactiontable = new concurrenthashmap < string , sipservertransaction > ( ) ; retransmissionalerttransactions = new concurrenthashmap < string , sipservertransaction > ( ) ; mergetable = new concurrenthashmap < string , sipservertransaction > ( ) ; this . dialogtable = new concurrenthashmap < string , sipdialog > ( ) ; this . earlydialogtable = new concurrenthashmap < string , sipdialog > ( ) ; this . terminatedservertransactionspendingack = new concurrenthashmap < string , sipservertransaction > ( ) ; this . forkedclienttransactiontable = new concurrenthashmap < string , sipclienttransaction > ( ) ; this . timer = new timer ( ) ; this . activeclienttransactioncount = new atomicinteger ( _num ) ; }	re initialize the stack instance .
public static boolean isenclosedbetween ( final string input , final string encloser ) { return isenclosedbetween ( input , encloser , encloser ) ; }	verifies whether string is enclosed by encloser.
public requestparams ( object ... keysandvalues ) { init ( ) ; int len = keysandvalues . length ; if ( len % _num != _num ) throw new illegalargumentexception ( _str ) ; for ( int i = _num ; i < len ; i += _num ) { string key = string . valueof ( keysandvalues [ i ] ) ; string val = string . valueof ( keysandvalues [ i + _num ] ) ; put ( key , val ) ; } }	constructs a new requestparams instance and populate it with multiple initial key / value string param .
private void contextmenu ( logicalvisualizationex visualization , mouseevent mouseevent ) { jcomponent menu = new jpopupmenu ( ) ; jmenuitem restore = new jmenuitem ( _str ) ; restore . addactionlistener ( null ) ; jmenuitem collapse = new jmenuitem ( _str ) ; collapse . addactionlistener ( null ) ; jmenuitem expand = new jmenuitem ( _str ) ; expand . addactionlistener ( null ) ; menu . add ( restore ) ; menu . add ( collapse ) ; menu . add ( expand ) ; getvisibilitymenuitems ( menu , visualization ) ; if ( menu instanceof jpopupmenu ) { jpopupmenu popup = ( jpopupmenu ) menu ; popup . setlocation ( mouseevent . getlocationonscreen ( ) ) ; popup . setinvoker ( getdisplay ( ) ) ; popup . setvisible ( _bool ) ; popup . requestfocus ( ) ; } }	creates and displays a context menu for the blank space on the graph .
public final void translate ( final charsequence input , final writer out ) throws ioexception { if ( out == null ) { throw new illegalargumentexception ( _str ) ; } if ( input == null ) { return ; } int pos = _num ; final int len = input . length ( ) ; while ( pos < len ) { final int consumed = translate ( input , pos , out ) ; if ( consumed == _num ) { final char [ ] c = character . tochars ( character . codepointat ( input , pos ) ) ; out . write ( c ) ; pos += c . length ; continue ; } for ( int pt = _num ; pt < consumed ; pt ++ ) { pos += character . charcount ( character . codepointat ( input , pos ) ) ; } } }	translate an input onto a writer.
public void removevariable ( string varid ) { variables . remove ( varid ) ; discretecache = null ; continuouscache = null ; for ( assignment s : samples ) { s . removepair ( varid ) ; } }	removes a particular variable from the sampled assignments.
public static uuid parsestringasuuid ( string in ) throws indexparsefieldexception { try { return uuid . fromstring ( in ) ; } catch ( illegalargumentexception e ) { throw new indexparsefieldexception ( in , e ) ; } }	parses a string as a uuid .
public void add ( t object ) { if ( moriginalvalues != null ) { synchronized ( mlock ) { moriginalvalues . add ( object ) ; if ( mnotifyonchange ) notifydatasetchanged ( ) ; } } else { mobjects . add ( object ) ; if ( mnotifyonchange ) notifydatasetchanged ( ) ; } }	adds the specified object at the end of the array .
public boolean isconnected ( final synapse s ) { return ( fanin . contains ( s ) || fanout . get ( s . gettarget ( ) ) != null ) ; }	true if the synapse is connected to this neuron , false otherwise .
@ override public void resetlearning ( ) { this . instancesseen = _num ; this . classinstances = new hashmap < > ( ) ; this . classprototypes = new hashmap < > ( ) ; this . attributeobservers = new hashmap < > ( ) ; }	resets this classifier . it must be similar to starting a new classifier from scratch .
@ override public void put ( int index , byte [ ] value ) { system . arraycopy ( value , _num , datastore , ( ( index ) * sizeofeachelement ) , sizeofeachelement ) ; }	this method will be used to insert key to store.
public final void init ( ir ir ) { liveinterval livenessinformation = ir . getlivenessinformation ( ) ; this . regallocstate = ir . mirinfo . regallocstate ; for ( enumeration < basicblock > e = ir . getbasicblocks ( ) ; e . hasmoreelements ( ) ; ) { basicblock b = e . nextelement ( ) ; processblock ( b , livenessinformation ) ; } }	records all the register restrictions dictated by an ir.
private void installnodeselectortab ( string label , nodeselectorpart selectorpart ) { composite selectioncontrol = selectorpart . createcontrol ( selectortab , swt . none , geteditor ( ) ) ; selectioncontrol . setlayoutdata ( new griddata ( swt . fill , swt . fill , _bool , _bool ) ) ; selectortabparts . add ( selectorpart ) ; tabitem tabitem = new tabitem ( selectortab , swt . none ) ; tabitem . settext ( label ) ; tabitem . setcontrol ( selectioncontrol ) ; }	install a new node selector part into the selectors tab .
protected boolean isinlinealertmessageset ( ) { ccalertinline alert = ( ccalertinline ) getchild ( ialert_common ) ; string detail = alert . getdetail ( ) ; return ( detail != null ) && ( detail . length ( ) > _num ) ; }	returns true if inline alert message is set .
public jhyperlink ( ) { super ( ) ; normalforeground = uimanager . getcolor ( _str ) ; activeforeground = uimanager . getcolor ( _str ) ; visitedforeground = uimanager . getcolor ( _str ) ; setborderpainted ( _bool ) ; setcontentareafilled ( _bool ) ; setforeground ( normalforeground ) ; setcursor ( cursor . getpredefinedcursor ( cursor . hand_cursor ) ) ; setmargin ( new insets ( _num , _num , _num , _num ) ) ; setaction ( defaultbrowseaction ) ; }	creates a new instance of jhyperlink.
public static string removecrossreference ( string text ) { if ( strings . isnullorempty ( text ) ) { return _str ; } pattern pattern = pattern . compile ( _str + _str ) ; matcher matcher = pattern . matcher ( text ) ; stringbuffer result = new stringbuffer ( ) ; while ( matcher . find ( ) ) { string replacementtext = matcher . group ( _str ) ; replacementtext = matcher . quotereplacement ( replacementtext ) ; matcher . appendreplacement ( result , replacementtext ) ; } matcher . appendtail ( result ) ; return result . tostring ( ) ; }	given a documentation string , replace the cross reference links with reference text .
@ guardedby ( _str ) void drainwritebuffer ( ) { for ( int i = _num ; i < write_buffer_drain_threshold ; i ++ ) { final runnable task = writebuffer . poll ( ) ; if ( task == null ) { break ; } task . run ( ) ; } }	drains the read buffer up to an amortized threshold .
private string picklowerorupper ( string inputmode ) { int pos = getcursorposition ( ) - _num ; if ( pendingcommit ) { pos -- ; } string text = gettext ( ) ; if ( pos >= text . length ( ) ) { pos = text . length ( ) - _num ; } while ( pos > - _num ) { if ( text . charat ( pos ) == _str ) { return inputmode . touppercase ( ) ; } if ( text . charat ( pos ) != _str ) { return inputmode . tolowercase ( ) ; } pos -- ; } return inputmode . touppercase ( ) ; }	used for the case of first sentence character should be upper case.
private static charhandler parsesimplecodes ( string [ ] codestrings ) { if ( codestrings . length != _num ) { throw new illegalstateexception ( _str + arrays . aslist ( codestrings ) ) ; } return new simplecharhandler ( codestobytes ( codestrings [ _num ] , _bool ) ) ; }	returns a simplecharhandler parsed from the given index code strings .
protected double calculatecategorysize ( int categorycount , rectangle2d area , rectangleedge edge ) { double result ; double available = _num ; if ( ( edge == rectangleedge . top ) || ( edge == rectangleedge . bottom ) ) { available = area . getwidth ( ) ; } else if ( ( edge == rectangleedge . left ) || ( edge == rectangleedge . right ) ) { available = area . getheight ( ) ; } if ( categorycount > _num ) { result = available * ( _num - getlowermargin ( ) - getuppermargin ( ) - getcategorymargin ( ) ) ; result = result / categorycount ; } else { result = available * ( _num - getlowermargin ( ) - getuppermargin ( ) ) ; } return result ; }	calculates the size ( width or height , depending on the location of the axis ) of a category .
@ override public void createbuffers ( int numbuffers , buffercapabilities caps ) throws awtexception { win32graphicsconfig gc = ( win32graphicsconfig ) getgraphicsconfiguration ( ) ; gc . assertoperationsupported ( ( component ) target , numbuffers , caps ) ; try { replacesurfacedata ( numbuffers - _num , caps ) ; } catch ( invalidpipeexception e ) { throw new awtexception ( e . getmessage ( ) ) ; } }	the following multibuffering - related methods delegate to our associated graphicsconfig ( win or wgl ) to handle the appropriate native windowing system specific actions .
public businessobjectformatcreaterequest createbusinessobjectformatcreaterequest ( string namespacecode , string businessobjectdefinitionname , string businessobjectformatusage , string businessobjectformatfiletype , string partitionkey , string description , list < attribute > attributes , list < attributedefinition > attributedefinitions , schema schema ) { businessobjectformatcreaterequest businessobjectformatcreaterequest = new businessobjectformatcreaterequest ( ) ; businessobjectformatcreaterequest . setnamespace ( namespacecode ) ; businessobjectformatcreaterequest . setbusinessobjectdefinitionname ( businessobjectdefinitionname ) ; businessobjectformatcreaterequest . setbusinessobjectformatusage ( businessobjectformatusage ) ; businessobjectformatcreaterequest . setbusinessobjectformatfiletype ( businessobjectformatfiletype ) ; businessobjectformatcreaterequest . setpartitionkey ( partitionkey ) ; businessobjectformatcreaterequest . setdescription ( description ) ; businessobjectformatcreaterequest . setattributes ( attributes ) ; businessobjectformatcreaterequest . setattributedefinitions ( attributedefinitions ) ; businessobjectformatcreaterequest . setschema ( schema ) ; return businessobjectformatcreaterequest ; }	creates a business object format create request .
public void removeobserver ( final filealterationobserver observer ) { if ( observer != null ) { while ( observers . remove ( observer ) ) { } } }	remove a file system observer from this monitor .
public void randomizeweights ( random random ) { for ( int i = _num ; i < weights . length ; i ++ ) weights [ i ] = random . nextdouble ( ) * _num ; }	generates a new weight.
private static method findoverloadedmethod ( class baseclass , string methodname , class [ ] types , boolean publiconly ) { if ( interpreter . debug ) interpreter . debug ( _str + stringutil . methodstring ( methodname , types ) + _str + baseclass . getname ( ) + _str ) ; method [ ] methods = getcandidatemethods ( baseclass , methodname , types . length , publiconly ) ; if ( interpreter . debug ) interpreter . debug ( _str + methodname ) ; method method = findmostspecificmethod ( types , methods ) ; return method ; }	get the candidate methods by searching the class and interface graph of baseclass and resolve the most specific .
private serviceid newserviceid ( ) { uuid uuid = serviceidgenerator . generate ( ) ; return new serviceid ( uuid . getmostsignificantbits ( ) , uuid . getleastsignificantbits ( ) ) ; }	generate a new service id.
public void childrenadded ( beancontextmembershipevent bcme ) { findandinit ( bcme . iterator ( ) ) ; }	method for beancontextmembership interface .
public void testconstrcharintintmathcontextexception1 ( ) { char value [ ] = { _str , _str , _str , _str , _str , _str , _str , _str , _str , _str , _str , _str , _str , _str , _str , _str } ; int offset = _num ; int len = _num ; int precision = _num ; roundingmode rm = roundingmode . ceiling ; mathcontext mc = new mathcontext ( precision , rm ) ; try { new bigdecimal ( value , offset , len , mc ) ; fail ( _str ) ; } catch ( numberformatexception e ) { } }	new bigdecimal ( char [ ] value , int offset , int len , mathcontext mc ) ;.
public void moveto ( float x , float y ) { mpoints . add ( pathpoint . moveto ( x , y ) ) ; }	move from the current path point to the new one specified by x and y.
public dom2dtm ( dtmmanager mgr , domsource domsource , int dtmidentity , dtmwsfilter whitespacefilter , xmlstringfactory xstringfactory , boolean doindexing ) { super ( mgr , domsource , dtmidentity , whitespacefilter , xstringfactory , doindexing ) ; m_pos = m_root = domsource . getnode ( ) ; m_last_parent = m_last_kid = null ; m_last_kid = addnode ( m_root , m_last_parent , m_last_kid , null ) ; if ( element_node == m_root . getnodetype ( ) ) { namednodemap attrs = m_root . getattributes ( ) ; int attrsize = ( attrs == null ) ? _num : attrs . getlength ( ) ; if ( attrsize > _num ) { int attrindex = null ; for ( int i = _num ; i < attrsize ; ++ i ) { attrindex = addnode ( attrs . item ( i ) , _num , attrindex , null ) ; m_firstch . setelementat ( dtm . null , attrindex ) ; } m_nextsib . setelementat ( dtm . null , attrindex ) ; } } m_nodesareprocessed = _bool ; }	construct a dom2dtm object from a dom node .
private void rebuildnode ( ) { m_realizer . regenerate ( ) ; m_graph . updateviews ( ) ; }	regenerates the content of the node and updates the graph view .
public static long secondssincemillis ( long timeinmillis ) { return ( system . currenttimemillis ( ) - timeinmillis ) / _num ; }	computes the number of seconds elapsed since the given time in milliseconds .
public final void test_chooseengineclientalias ( ) { x509extendedkeymanager km = new myx509extendedkeymanager ( ) ; if ( km . chooseengineclientalias ( null , null , null ) != null ) { fail ( _str ) ; } }	javax . net . ssl . x509extendedkeymanager # chooseengineclientalias ( java . lang . string [ ] , java . security . principal [ ] , javax . net . ssl . sslengine ).
public void printstring ( char [ ] v , int offset , int length ) throws ioexception { for ( int i = _num ; i < length ; i ++ ) { char ch = v [ i + offset ] ; if ( ch < _num ) os . write ( ch ) ; else if ( ch < _num ) { os . write ( _num + ( ( ch > > _num ) & _num ) ) ; os . write ( _num + ( ch & _num ) ) ; } else { os . write ( _num + ( ( ch > > _num ) & _num ) ) ; os . write ( _num + ( ( ch > > _num ) & _num ) ) ; os . write ( _num + ( ch & _num ) ) ; } } }	prints a string to the stream , encoded as utf - 8.
public static string trimleadingtabsandspaces ( string line ) { int size = line . length ( ) ; int start = size ; for ( int i = _num ; i < size ; i ++ ) { char c = line . charat ( i ) ; if ( ! indentmanipulation . isindentchar ( c ) ) { start = i ; break ; } } if ( start == _num ) return line ; else if ( start == size ) return _str ; else return line . substring ( start ) ; }	removes leading tabs and spaces from the given string.
public static object mimicarray ( object array , class < ? > newtype ) { int dims = _num ; class < ? > arrayclass = array . getclass ( ) ; while ( arrayclass != null && arrayclass . isarray ( ) ) { arrayclass = arrayclass . getcomponenttype ( ) ; dims += _num ; } object mimic ; if ( dims > _num ) { object [ ] xarray = ( object [ ] ) array ; int [ ] dimens = new int [ dims ] ; dimens [ _num ] = xarray . length ; mimic = arrayfuncs . newinstance ( newtype , dimens ) ; for ( int i = _num ; i < xarray . length ; i += _num ) { object temp = mimicarray ( xarray [ i ] , newtype ) ; ( ( object [ ] ) mimic ) [ i ] = temp ; } } else { mimic = arrayfuncs . newinstance ( newtype , array . getlength ( array ) ) ; } return mimic ; }	create an array of a type given by new type with the dimensionality given in array .
public concurrentskiplistset ( sortedset < e > s ) { m = new concurrentskiplistmap < e , object > ( s . comparator ( ) ) ; addall ( s ) ; }	constructs a new set containing the same elements and using the same ordering as the specified sorted set .
protected abstract byte [ ] readoptionalbytesimpl ( final string label ) ;	reads a byte array value ( allowing null values ) .
public static void deinitialize ( ) { instance . codenameonerunning = _bool ; synchronized ( lock ) { lock . notifyall ( ) ; } }	closes down the edt and codename one , under normal conditions this method is completely unnecessary since exiting the application will shut down codename one.
public void init ( iterator iter , comparator c ) { m_tuples . clear ( ) ; m_cmp = c ; while ( iter . hasnext ( ) ) { tuple t = ( tuple ) iter . next ( ) ; m_tuples . add ( t ) ; } collections . sort ( m_tuples , m_cmp ) ; m_iter = m_tuples . iterator ( ) ; }	initialize this iterator for the given source iterator and comparator .
@ override public void mouseclicked ( mouseevent e ) { if ( swingutilities . isleftmousebutton ( e ) ) { if ( e . getclickcount ( ) == _num ) { fixedhoverentry = _bool ; setfixedstartat ( hoverentry ) ; } else { long actualhoverentry = findhoverentry ( e . getpoint ( ) ) ; fixedhoverentry = actualhoverentry != - _num ; if ( hoverentry != actualhoverentry ) { updatehoverentry ( e . getpoint ( ) ) ; } } } }	toggle displaying stuff on mouse - click . left - click : keep info displayed even when outside the component right - click : switch between 0 - max and min - max rendering.
public boolean isalterdrop ( ) { return columnstodrop . size ( ) > _num ; }	true if the table has columns to remove .
public void distributeandupdatemapobjectsinintervalset ( ) { for ( internalmapobject mapobject : mapobjects ) { for ( interval interval : intervalset . getintervals ( ) ) { if ( mapobject . getvalue ( ) >= interval . getvaluelow ( ) && mapobject . getvalue ( ) <= interval . getvaluehigh ( ) ) { interval . addmember ( mapobject ) ; mapobject . setinterval ( interval ) ; break ; } } } }	distribute this map layer ' s map objects into the given interval set and update each map object with its interval .
public void deleterows ( int row , int length ) throws tableexception { if ( row < _num || length < _num || row + length > this . nrow ) { throw new tableexception ( _str + row + _str + length + _str + this . nrow + _str ) ; } if ( length == _num ) { return ; } for ( int col = _num ; col < this . arrays . length ; col += _num ) { int sz = this . sizes [ col ] ; int newsize = sz * ( this . nrow - length ) ; object newarr = arrayfuncs . newinstance ( this . bases [ col ] , newsize ) ; system . arraycopy ( this . arrays [ col ] , _num , newarr , _num , row * sz ) ; system . arraycopy ( this . arrays [ col ] , ( row + length ) * sz , newarr , row * sz , ( this . nrow - row - length ) * sz ) ; this . arrays [ col ] = newarr ; } this . nrow -= length ; initializepointers ( ) ; }	delete a contiguous set of rows from the table .
public fileinputreader ( string f ) throws ioexception { if ( debug . debugging ( _str ) ) { debug . output ( _str + f ) ; } file file = new file ( f ) ; name = file . getname ( ) ; absolutepath = file . getabsolutepath ( ) ; inputfile = init ( file ) ; }	constructs a new binaryfile with the specified file as the input.
public instances transform ( instances d ) throws exception { int l = d . classindex ( ) ; d = d . numattributes ( ) - l ; int keep [ ] = a . append ( this . pay , j ) ; arrays . sort ( keep ) ; int remv [ ] = a . invert ( keep , l ) ; arrays . sort ( remv ) ; map = new int [ l ] ; for ( int j = _num ; j < l ; j ++ ) { map [ j ] = arrays . binarysearch ( keep , j ) ; } instances d_ = f . remove ( new instances ( d ) , remv , _bool ) ; d_ . setclassindex ( map [ this . j ] ) ; return d_ ; }	transform - transform dataset d for this node.
public void testclearbitnegativeinside5 ( ) { string as = _str ; string res = _str ; int number = _num ; biginteger anumber = new biginteger ( as ) ; biginteger result = anumber . clearbit ( number ) ; assertequals ( res , result . tostring ( ) ) ; }	clearbit ( 0 ) in the negative number of length 2 with all ones in bit representation.
public final void add ( v value ) { if ( gwt . isscript ( ) ) { jsarray . add ( value ) ; } else { javaarray . add ( value ) ; } }	insert the given element at the end of the list .
public void testconstructorsignbytesnegative2 ( ) { byte abytes [ ] = { - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num } ; int asign = - _num ; byte rbytes [ ] = { - _num , _num , - _num , - _num , _num , _num , - _num , - _num , - _num , - _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = anumber . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , - _num , anumber . signum ( ) ) ; }	create a negative number from a sign and an array of bytes.
public void writeexif ( byte [ ] jpeg , string exifoutfilename ) throws filenotfoundexception , ioexception { if ( jpeg == null || exifoutfilename == null ) { throw new illegalargumentexception ( null_argument_string ) ; } outputstream s = null ; s = getexifwriterstream ( exifoutfilename ) ; s . write ( jpeg , _num , jpeg . length ) ; s . flush ( ) ; s . close ( ) ; }	writes the tags from this exifinterface object into a jpeg image , removing prior exif tags .
private void converttoarraytype ( char [ ] [ ] parametertypes , int counter , int arraydim ) { int length = parametertypes [ counter ] . length ; char [ ] arraytype = new char [ length + arraydim * _num ] ; system . arraycopy ( parametertypes [ counter ] , _num , arraytype , _num , length ) ; for ( int i = _num ; i < arraydim ; i ++ ) { arraytype [ length + ( i * _num ) ] = _str ; arraytype [ length + ( i * _num ) + _num ] = _str ; } parametertypes [ counter ] = arraytype ; }	for example : - int foo ( string [ ] ) is ( [ ljava / lang / string ; ) i = > java.
public type3message ( type2message type2 ) { setflags ( getdefaultflags ( type2 ) ) ; setworkstation ( getdefaultworkstation ( ) ) ; string domain = getdefaultdomain ( ) ; setdomain ( domain ) ; string user = getdefaultuser ( ) ; setuser ( user ) ; string password = getdefaultpassword ( ) ; switch ( lm_compatibility ) { case _num : case _num : setlmresponse ( getlmresponse ( type2 , password ) ) ; setntresponse ( getntresponse ( type2 , password ) ) ; break ; case _num : byte [ ] nt = getntresponse ( type2 , password ) ; setlmresponse ( nt ) ; setntresponse ( nt ) ; break ; case _num : case _num : case _num : byte [ ] clientchallenge = new byte [ _num ] ; random . nextbytes ( clientchallenge ) ; setlmresponse ( getlmv2response ( type2 , domain , user , password , clientchallenge ) ) ; break ; default : setlmresponse ( getlmresponse ( type2 , password ) ) ; setntresponse ( getntresponse ( type2 , password ) ) ; } }	creates a type - 3 message in response to the given type - 2 message using default values from the current environment .
public static value parsevalue ( string ntriplesvalue , valuefactory valuefactory ) throws illegalargumentexception { if ( ntriplesvalue . startswith ( _str ) ) { return parseuri ( ntriplesvalue , valuefactory ) ; } else if ( ntriplesvalue . startswith ( _str ) ) { return parsebnode ( ntriplesvalue , valuefactory ) ; } else if ( ntriplesvalue . startswith ( _str ) ) { return parseliteral ( ntriplesvalue , valuefactory ) ; } else { throw new illegalargumentexception ( _str + ntriplesvalue ) ; } }	parses an n - triples value , creates an object for it using the supplied valuefactory and returns this object .
private pipewriter ( inputstream in , outputstream out , string tag , int nexecs ) { this . in = in ; this . out = new printwriter ( out ) ; bufout = new bytearrayoutputstream ( ) ; currsep = new byte [ lineseparatorlength ] ; execstring = _str + integer . tostring ( nexecs ) + _str + tag + _str ; }	create a new pipewriter object.
private void validatemaskandplacevolumes ( storagesystem array , uri varrayuri , map < uri , exportmask > maskset , set < uri > invalidmasks , exportmask mask , exportmaskplacementdescriptor placementdescriptor , map < uri , volume > volumemap , string logmsg ) { if ( ! isopenstack ( array ) ) { _log . info ( logmsg ) ; if ( vplexbackendorchestratorutil . validateexportmask ( varrayuri , _initiatorportmap , mask , invalidmasks , _directortoinitiatorids , _idtoinitiatormap , _dbclient , _coordinator , _portwwntoclustermap ) ) { maskset . put ( mask . getid ( ) , mask ) ; placementdescriptor . placevolumes ( mask . getid ( ) , volumemap ) ; } for ( uri invalidmask : invalidmasks ) { placementdescriptor . invalidateexportmask ( invalidmask ) ; } } else { maskset . put ( mask . getid ( ) , mask ) ; placementdescriptor . placevolumes ( mask . getid ( ) , volumemap ) ; } }	validate the mask for only non openstack storage systems now . for openstack , export mask will get validated later before the zoning step.
@ override public void emittuple ( object tuple ) { outputport . emit ( tuple ) ; }	emit the given tuple through the outputport.
protected void checkparams ( xcreatewindowparams params ) { if ( params == null ) { throw new illegalargumentexception ( _str ) ; } params . putifnull ( parent_window , long . valueof ( xtoolkit . getdefaultrootwindow ( ) ) ) ; params . putifnull ( bounds , new rectangle ( def_location , def_location , min_size , min_size ) ) ; params . putifnull ( depth , integer . valueof ( ( int ) xconstants . copyfromparent ) ) ; params . putifnull ( visual , long . valueof ( xconstants . copyfromparent ) ) ; params . putifnull ( visual_class , integer . valueof ( ( int ) xconstants . inputonly ) ) ; params . putifnull ( value_mask , long . valueof ( xconstants . cweventmask ) ) ; rectangle bounds = ( rectangle ) params . get ( bounds ) ; bounds . width = math . max ( min_size , bounds . width ) ; bounds . height = math . max ( min_size , bounds . height ) ; long eventmaskobj = ( long ) params . get ( event_mask ) ; long eventmask = eventmaskobj != null ? eventmaskobj . longvalue ( ) : _num ; eventmask |= xconstants . propertychangemask | xconstants . ownergrabbuttonmask ; params . put ( event_mask , long . valueof ( eventmask ) ) ; }	verifies that all required parameters are set.
public static integer tointeger ( object o , integer defaultvalue ) { if ( defaultvalue != null ) return integer . valueof ( tointvalue ( o , defaultvalue . intvalue ( ) ) ) ; int res = tointvalue ( o , integer . min_value ) ; if ( res == integer . min_value ) return defaultvalue ; return integer . valueof ( res ) ; }	casts a object to a integer.
protected boolean isindexselected ( istructuredselection selection , int index ) { if ( selection . isempty ( ) ) { return _bool ; } iterator < ? > entries = selection . iterator ( ) ; list < iruntimeclasspathentry > list = getcustomentriesaslist ( ) ; while ( entries . hasnext ( ) ) { object next = entries . next ( ) ; if ( list . indexof ( next ) == index ) { return _bool ; } } return _bool ; }	returns whether the item at the given index in the list ( visually ) is selected .
private boolean isprimalfeasible ( ) { double [ ] x = row ( ) ; double sum = _num ; for ( int j = _num ; j < n ; j ++ ) { if ( x [ j ] < _num ) { stdout . println ( _str ) ; stdout . printf ( _str , j , x [ j ] ) ; return _bool ; } sum += x [ j ] ; } if ( math . abs ( sum - _num ) > epsilon ) { stdout . println ( _str ) ; stdout . println ( _str + sum ) ; return _bool ; } return _bool ; }	the code below is solely for testing correctness of the data type .
public inputstream download ( string artifact , string version ) throws ioexception { path path = getartifact ( artifact , version ) ; if ( ! files . exists ( path ) ) { throw new artifactnotfoundexception ( artifact , version ) ; } return new bufferedinputstream ( files . newinputstream ( path ) ) ; }	downloads artifact from the repository .
public dmlframe popframe ( ) { if ( callstack . isempty ( ) ) return null ; return callstack . pop ( ) ; }	pop frame from stack as function call is done.
public static int lastindexofignorecase ( string src , char c , int startindex , int endindex ) { int total = src . length ( ) - _num ; if ( total < _num ) { return - _num ; } if ( startindex >= total ) { startindex = total ; } if ( endindex < _num ) { endindex = _num ; } c = character . tolowercase ( c ) ; for ( int i = startindex ; i >= endindex ; i -- ) { if ( character . tolowercase ( src . charat ( i ) ) == c ) { return i ; } } return - _num ; }	finds last index of a character in the given source string in specified range [ end , start ].
private void prepareforencoding ( ) { attribute msgintattr = removeattribute ( attribute . message_integrity ) ; attribute fingerprint = removeattribute ( attribute . fingerprint ) ; string software = system . getproperty ( stackproperties . software ) ; if ( getattribute ( attribute . software ) == null && software != null && software . length ( ) > _num ) { putattribute ( attributefactory . createsoftwareattribute ( software . getbytes ( ) ) ) ; } if ( msgintattr != null ) { putattribute ( msgintattr ) ; } if ( fingerprint == null && boolean . getboolean ( stackproperties . always_sign ) ) { fingerprint = attributefactory . createfingerprintattribute ( ) ; } if ( fingerprint != null ) { putattribute ( fingerprint ) ; } }	adds attributes that have been requested vis configuration properties.
public static double quantile ( double x , double mu , double sigma , double skew ) { x = normaldistribution . standardnormalquantile ( x ) ; if ( math . abs ( skew ) > _num ) { x = ( _num - math . exp ( - skew * x ) ) / skew ; } return mu + sigma * x ; }	inverse cumulative probability density function ( probit ) of a normal distribution .
public static map < uuid , collection < clusternode > > neighbors ( collection < clusternode > topsnapshot ) { map < string , collection < clusternode > > macmap = new hashmap < > ( topsnapshot . size ( ) , _num ) ; for ( clusternode node : topsnapshot ) { string macs = node . attribute ( ignitenodeattributes . attr_macs ) ; collection < clusternode > nodes = macmap . get ( macs ) ; if ( nodes == null ) macmap . put ( macs , nodes = new hashset < > ( ) ) ; nodes . add ( node ) ; } map < uuid , collection < clusternode > > neighbors = new hashmap < > ( topsnapshot . size ( ) , _num ) ; for ( collection < clusternode > group : macmap . values ( ) ) for ( clusternode node : group ) neighbors . put ( node . id ( ) , group ) ; return neighbors ; }	builds neighborhood map for all nodes in snapshot .
public void close ( ) { msocket . close ( ) ; }	closes the underlying socket .
public void testbug68763 ( ) throws exception { replicationconnection replconn = null ; replconn = ( replicationconnection ) getmasterslavereplicationconnection ( ) ; replconn . setreadonly ( _bool ) ; assertfalse ( _str , replconn . ismasterconnection ( ) ) ; replconn . setreadonly ( _bool ) ; asserttrue ( _str , replconn . ismasterconnection ( ) ) ; }	tests fix for bug # 68763 , replicationconnection . ismasterconnection ( ) returns false always.
public boolean endswith ( java . lang . charsequence suffix ) { return startswith ( suffix , length ( ) - suffix . length ( ) ) ; }	indicates if this text ends with the specified suffix .
public boolean isfixedview ( view v ) { { arraylist < fixedviewinfo > where = mheaderviewinfos ; int len = where . size ( ) ; for ( int i = _num ; i < len ; ++ i ) { fixedviewinfo info = where . get ( i ) ; if ( info . view == v ) { return _bool ; } } } { arraylist < fixedviewinfo > where = mfooterviewinfos ; int len = where . size ( ) ; for ( int i = _num ; i < len ; ++ i ) { fixedviewinfo info = where . get ( i ) ; if ( info . view == v ) { return _bool ; } } } return _bool ; }	check this view is fixed view ( ex > header & footer ) or not .
@ override public void handlerequest ( requestcontext rc ) throws cliexception { super . handlerequest ( rc ) ; ldaplogin ( ) ; getoptions ( rc ) ; validateoptions ( ) ; normalizeoptions ( ) ; string spec = federationmanager . getidffsubcommandspecification ( rc ) ; string [ ] params = { entityid , metadata , extendeddata , idpalias , spalias , attraalias , attrqalias , authnaalias , pdpalias , pepalias , affialias , spec } ; writelog ( logwriter . log_access , level . info , _str , params ) ; try { if ( spec . equals ( federationmanager . default_specification ) ) { handlesaml2request ( rc ) ; writelog ( logwriter . log_access , level . info , _str , params ) ; } else if ( spec . equals ( fedcliconstants . idff_specification ) ) { handleidffrequest ( rc ) ; writelog ( logwriter . log_access , level . info , _str , params ) ; } else if ( spec . equals ( fedcliconstants . wsfed_specification ) ) { handlewsfedrequest ( rc ) ; writelog ( logwriter . log_access , level . info , _str , params ) ; } else { throw new cliexception ( getresourcestring ( _str ) , exitcodes . request_cannot_be_processed ) ; } } catch ( cliexception e ) { string [ ] args = { entityid , spec , e . getmessage ( ) } ; writelog ( logwriter . log_error , level . info , _str , args ) ; throw e ; } }	creates meta data template .
public void export ( string filename , int samplerate , short [ ] samples ) throws ioexception { nbytespersample = _num ; buf = new byte [ samples . length * _num ] ; for ( int i = _num ; i < samples . length ; i ++ ) { buf [ _num * i ] = ( byte ) ( ( samples [ i ] & _num ) > > > _num ) ; buf [ _num * i + _num ] = ( byte ) ( ( samples [ i ] & _num ) ) ; } dowrite ( filename , samplerate ) ; }	export an array of shorts to a wav file .
public byte [ ] asn1encode ( ) throws ioexception { deroutputstream out = new deroutputstream ( ) ; out . putunalignedbitstring ( bits ) ; return out . tobytearray ( ) ; }	writes the encoded data .
public void lockrowadd ( arraylist < row > rows ) { if ( state == found ) { rows . add ( get ( ) ) ; } }	add the current row to the array , if there is a current row .
public static classificationdataset readc ( int classification_target , path path , char delimiter , int lines_to_skip , char comment , set < integer > cat_cols ) throws ioexception { bufferedreader br = files . newbufferedreader ( path , charset . defaultcharset ( ) ) ; classificationdataset ret = readc ( classification_target , br , delimiter , lines_to_skip , comment , cat_cols ) ; br . close ( ) ; return ret ; }	reads in a csv dataset as a classification dataset .
public pdfindirectreference add ( pdfindirectreference reference ) { if ( reference == null ) { return null ; } int objnr = reference . getobjnumber ( ) ; this . count = math . max ( this . count , objnr ) ; ensurecount ( objnr ) ; xref [ objnr ] = reference ; return reference ; }	adds indirect reference to list of indirect objects .
public int doendtag ( ) throws jspexception { stringbuffer results = new stringbuffer ( ) ; results . append ( _str ) ; responseutils . write ( pagecontext , results . tostring ( ) ) ; return ( eval_page ) ; }	ignore the end of this tag .
public void testcreateattributens1 ( ) throws throwable { string namespaceuri = _str ; string malformedname = _str ; document doc ; doc = ( document ) load ( _str , builder ) ; { boolean success = _bool ; try { doc . createattributens ( namespaceuri , malformedname ) ; } catch ( domexception ex ) { success = ( ex . code == domexception . namespace_err ) ; } asserttrue ( _str , success ) ; } }	runs the test case .
public void appendbytes ( byte [ ] bs , int start , int len ) { elems = arrayutils . ensurecapacity ( elems , length + len ) ; system . arraycopy ( bs , start , elems , length , len ) ; length += len ; }	append ` len ' bytes from byte array , starting at given ` start ' offset .
public static string primitivetypelabel ( char typechar ) { switch ( typechar ) { case _str : return _str ; case _str : return _str ; case _str : return _str ; case _str : return _str ; case _str : return _str ; case _str : return _str ; case _str : return _str ; case _str : return _str ; case _str : return _str ; default : system . err . println ( _str + typechar ) ; assert _bool ; return _str ; } }	converts a single - character primitive type into its human - readable equivalent .
public void exportaskml ( xmlstreamwriter xmlwriter ) throws ioexception , xmlstreamexception { }	export the record as kml.
public urbansimcellbasedaccessibilitycsvwriterv2 ( string matsimoutputdirectory ) { log . info ( _str ) ; try { accessibilitydatawriter = ioutils . getbufferedwriter ( matsimoutputdirectory + _str + accessibility_indicators ) ; } catch ( exception ee ) { ee . printstacktrace ( ) ; throw new runtimeexception ( _str ) ; } if ( accessibilitydatawriter == null ) { throw new runtimeexception ( _str ) ; } try { accessibilitydatawriter . write ( labels . zone_id + _str + labels . x_coordinate + _str + labels . y_coordinate + _str + labels . accessibility_by_freespeed + _str + labels . accessibility_by_car + _str + labels . accessibility_by_bike + _str + labels . accessibility_by_walk + _str + labels . accessibility_by_pt ) ; accessibilitydatawriter . newline ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; throw new runtimeexception ( _str ) ; } log . info ( _str ) ; }	writes the header of accessibility data csv file.
protected point2d . double constrainpoint ( point2d . double p , translationdirection dir ) { point2d . double p0 = constrainpoint ( ( point2d . double ) p . clone ( ) ) ; switch ( dir ) { case north : case north_west : case north_east : if ( p0 . y < p . y ) { p . y = p0 . y ; } else if ( p0 . y > p . y ) { p . y = p0 . y - height ; } break ; case south : case south_west : case south_east : if ( p0 . y < p . y ) { p . y = p0 . y + height ; } else if ( p0 . y > p . y ) { p . y = p0 . y ; } break ; } switch ( dir ) { case west : case north_west : case south_west : if ( p0 . x < p . x ) { p . x = p0 . x ; } else if ( p0 . x > p . x ) { p . x = p0 . x - width ; } break ; case east : case north_east : case south_east : if ( p0 . x < p . x ) { p . x = p0 . x + width ; } else if ( p0 . x > p . x ) { p . x = p0 . x ; } break ; } return p ; }	constrains the placement of a point towards a direction.
protected boolean requiresnotificationfrompr ( partitionedregion r ) { synchronized ( gemfirecacheimpl . class ) { boolean hasserialsenders = hasserialsenders ( r ) ; boolean result = hasserialsenders ; if ( ! result ) { iterator allcacheserversiterator = allcacheservers . iterator ( ) ; while ( allcacheserversiterator . hasnext ( ) ) { cacheserverimpl server = ( cacheserverimpl ) allcacheserversiterator . next ( ) ; if ( ! server . getnotifybysubscription ( ) ) { result = _bool ; break ; } } } return result ; } }	check to see if any cache components require notification from a partitioned region . notification adds to the messaging a pr must do on each put / destroy / invalidate operation and should be kept to a minimum.
public graphrequest ( ) { this ( null , null , null , null , null ) ; }	constructs a request without an access token , graph path , or any other parameters .
public boolean isobscuredrecipient ( string playername ) { for ( int i = _num ; i < obscuredrecipients . size ( ) ; i ++ ) { string s = obscuredrecipients . elementat ( i ) ; if ( s . equals ( playername ) ) { return _bool ; } } return _bool ; }	internal method . not for typical use . < p > tests whether the given player name is on the report ' s list of players who received an obscured version of this report from the server at some time in the past .
private void clearexceptionalcompletion ( ) { int h = system . identityhashcode ( this ) ; final reentrantlock lock = exceptiontablelock ; lock . lock ( ) ; try { exceptionnode [ ] t = exceptiontable ; int i = h & ( t . length - _num ) ; exceptionnode e = t [ i ] ; exceptionnode pred = null ; while ( e != null ) { exceptionnode next = e . next ; if ( e . get ( ) == this ) { if ( pred == null ) t [ i ] = next ; else pred . next = next ; break ; } pred = e ; e = next ; } expungestaleexceptions ( ) ; status = _num ; } finally { lock . unlock ( ) ; } }	removes exception node and clears status .
public synchronized void createfile ( jdbcsequentialfile file ) throws sqlexception { try { connection . setautocommit ( _bool ) ; createfile . setstring ( _num , file . getfilename ( ) ) ; createfile . setstring ( _num , file . getextension ( ) ) ; createfile . setbytes ( _num , new byte [ _num ] ) ; createfile . executeupdate ( ) ; try ( resultset keys = createfile . getgeneratedkeys ( ) ) { keys . next ( ) ; file . setid ( keys . getint ( _num ) ) ; } connection . commit ( ) ; } catch ( sqlexception e ) { connection . rollback ( ) ; throw e ; } }	creates a new database row representing the supplied file .
public < t > t withfeature ( final feature feature , final supplier < t > isset , final supplier < t > isnotset ) { return hasfeature ( feature ) ? isset . get ( ) : isnotset . get ( ) ; }	run the given operation if feature is set , or another operation if it is not .
public intentbuilder addemailbcc ( string address ) { if ( mbccaddresses == null ) { mbccaddresses = new arraylist < string > ( ) ; } mbccaddresses . add ( address ) ; return this ; }	add an email address to be used in the " bcc " field of the final intent .
public void println ( object x ) { out . println ( x ) ; }	prints an object to this output stream and then terminates the line .
public void insertlastfocused ( string symbol , boolean append ) { if ( this . variable == lastfocused ) { setvariable ( symbol , append ) ; } else { setexpression ( symbol , append ) ; } }	inserts the given symbol into the last focused field , of if there isn ' t one the expression field .
@ override public void call ( ) throws exception { while ( ! processingcomplete || blockletprocessingcount . get ( ) > _num ) { nodeholder nodeholder = null ; try { nodeholder = blockletdataholder . get ( ) ; if ( null != nodeholder ) { datawriter . writeblockletdata ( nodeholder ) ; } blockletprocessingcount . decrementandget ( ) ; } catch ( throwable throwable ) { if ( ! processingcomplete || blockletprocessingcount . get ( ) > _num ) { producerexecutorservice . shutdownnow ( ) ; resetblockletprocessingcount ( ) ; throw new carbondatawriterexception ( throwable . getmessage ( ) ) ; } } finally { semaphore . release ( ) ; } } return null ; }	computes a result , or throws an exception if unable to do so .
public lexer ( string s ) { initkeywords ( ) ; tok = new streamtokenizer ( new stringreader ( s ) ) ; tok . wordchars ( _str , _str ) ; tok . ordinarychar ( _str ) ; tok . lowercasemode ( _bool ) ; nexttoken ( ) ; }	creates a new lexical analyzer for the specified sql statement .
@ override public object remove ( object key ) { entry tab [ ] = table ; if ( key != null ) { int hash = system . identityhashcode ( key ) ; int index = ( hash & _num ) % tab . length ; for ( entry e = tab [ index ] , prev = null ; e != null ; prev = e , e = e . next ) { if ( ( e . hash == hash ) && key == e . key ) { modcount ++ ; if ( prev != null ) prev . next = e . next ; else tab [ index ] = e . next ; count -- ; object oldvalue = e . value ; e . value = null ; return oldvalue ; } } } else { for ( entry e = tab [ _num ] , prev = null ; e != null ; prev = e , e = e . next ) { if ( e . key == null ) { modcount ++ ; if ( prev != null ) prev . next = e . next ; else tab [ _num ] = e . next ; count -- ; object oldvalue = e . value ; e . value = null ; return oldvalue ; } } } return null ; }	removes the mapping for this key from this map if present .
public static object read ( inputstream stream ) throws exception { class < ? > xstreamclass ; java . lang . reflect . constructor < ? > constructor ; object xstream ; class < ? > [ ] deserializeargsclasses = new class [ _num ] ; object [ ] deserializeargs = new object [ _num ] ; java . lang . reflect . method methoddeserialize ; object result ; xstreamclass = class . forname ( _str ) ; constructor = xstreamclass . getconstructor ( ) ; xstream = constructor . newinstance ( ) ; deserializeargsclasses [ _num ] = inputstream . class ; deserializeargs [ _num ] = stream ; methoddeserialize = xstreamclass . getmethod ( _str , deserializeargsclasses ) ; try { result = methoddeserialize . invoke ( xstream , deserializeargs ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; result = null ; } return result ; }	reads the xml - serialized object from the given input stream.
private static boolean comparestringcase ( final string val , final int comparator , final string attr ) { final string value = comparator == approx ? stripwhitespaces ( val ) : val ; final string attribute = comparator == approx ? stripwhitespaces ( attr ) : attr ; switch ( comparator ) { case approx : case equals : return rfc1960filter . stringcompare ( value . tochararray ( ) , _num , attribute . tochararray ( ) , _num ) == _num ; case greater : return rfc1960filter . stringcompare ( value . tochararray ( ) , _num , attribute . tochararray ( ) , _num ) <= _num ; case less : return rfc1960filter . stringcompare ( value . tochararray ( ) , _num , attribute . tochararray ( ) , _num ) >= _num ; default : throw new illegalstateexception ( _str ) ; } }	compare a string . case sensitive.
protected string buildcachekey ( int x , int y , int z , string fileext ) { return buildfilepath ( x , y , z , fileext ) ; }	creates a unique cache key for this tile based on zoom , x , y.
public int partition ( int left , int right , int pivotindex ) { e pivot = ar [ pivotindex ] ; e tmp = ar [ right ] ; ar [ right ] = ar [ pivotindex ] ; ar [ pivotindex ] = tmp ; int store = left ; for ( int idx = left ; idx < right ; idx ++ ) { if ( comparator . compare ( ar [ idx ] , pivot ) <= _num ) { tmp = ar [ idx ] ; ar [ idx ] = ar [ store ] ; ar [ store ] = tmp ; store ++ ; } } tmp = ar [ right ] ; ar [ right ] = ar [ store ] ; ar [ store ] = tmp ; return store ; }	in linear time , group an array into two parts , those less than or equal to a certain value ( left ) , and those greater than a certain value ( right ) .
public static string reordermodifiers ( string text ) throws formatterexception { return reordermodifiers ( text , collections . singleton ( range . closedopen ( _num , text . length ( ) ) ) ) ; }	reorders all modifiers in the given text to be in jls order .
public void addfiles ( collection < string > files ) { checkfilenames ( files ) ; for ( string f : files ) { setfiles . add ( namedforthissegment ( f ) ) ; } }	add these files to the set of files written for this segment .
public void testisweak ( ) { try { deskeyspec . isweak ( null , _num ) ; fail ( _str + _str ) ; } catch ( nullpointerexception e ) { fail ( _str ) ; } catch ( invalidkeyexception e ) { } byte [ ] key = { _num , _num , _num , _num , _num , _num , _num , _num } ; try { deskeyspec . isweak ( key , _num ) ; fail ( _str + _str ) ; } catch ( nullpointerexception e ) { fail ( _str ) ; } catch ( invalidkeyexception e ) { } for ( int i = _num ; i < semiweaks . length ; i ++ ) { try { asserttrue ( _str , deskeyspec . isweak ( semiweaks [ i ] , _num ) ) ; } catch ( invalidkeyexception e ) { fail ( _str ) ; } } for ( int i = _num ; i < notsemiweaks . length ; i ++ ) { try { assertfalse ( _str , deskeyspec . isweak ( notsemiweaks [ i ] , _num ) ) ; } catch ( invalidkeyexception e ) { fail ( _str ) ; } } }	isweak ( byte [ ] key , int offset ) method testing.
public response oncommand ( smtpsession session , request request ) { return not_supported ; }	handler method called upon receipt of a expn command.
protected final void computeminmaxfromtile ( datatype datatype , int n , int size ) { minimum = new double [ samplesperpixel ] ; maximum = new double [ samplesperpixel ] ; arrays . fill ( minimum , double . max_value ) ; arrays . fill ( maximum , - double . max_value ) ; bytebuffer bbuf = bytebuffer . allocatedirect ( size ) ; bbuf . order ( byteorder ) ; for ( int i = _num ; i < n ; ++ i ) { bbuf . rewind ( ) ; long len = readtile ( i , bbuf , size ) ; if ( len == - _num ) { throw new illegalstateexception ( gettifferror ( ) ) ; } bbuf . rewind ( ) ; computeminmax ( bbuf ) ; thread . yield ( ) ; } }	compute the minimum and maximum of an entire file .
public synchronized void notifyconnected ( string title ) { connectedservertitles . add ( title ) ; updatenotification ( getstring ( r . string . notification_connected , title ) , null , _bool , _bool , _bool ) ; }	notify the service of connection to a server ( updates the status bar notification ).
public static boolean ispaymenttype ( genericvalue payment , string inputtypeid ) throws genericentityexception { if ( payment == null ) { return _bool ; } genericvalue paymenttype = payment . getrelatedone ( _str , _bool ) ; if ( paymenttype == null ) { throw new genericentityexception ( _str + payment . getstring ( _str ) ) ; } string paymenttypeid = paymenttype . getstring ( _str ) ; if ( inputtypeid . equals ( paymenttypeid ) ) { return _bool ; } return ispaymenttyperecurse ( paymenttype , inputtypeid ) ; }	checks if a payment is of a specified paymenttype.
private list < string > missingfish ( final player player , final boolean hash ) { final list < string > result = new linkedlist < string > ( ) ; string donetext = player . getquest ( quest_slot ) ; if ( donetext == null ) { donetext = _str ; } final list < string > done = arrays . aslist ( donetext . split ( _str ) ) ; for ( final string fish : neededfish ) { if ( ! done . contains ( fish ) ) { if ( hash ) { result . add ( _str + fish ) ; } else { result . add ( fish ) ; } } } return result ; }	returns a list of the names of all fish that the given player still has to bring to fulfill the quest .
static long readmillis ( datainput in ) throws ioexception { int v = in . readunsignedbyte ( ) ; switch ( v > > _num ) { case _num : default : v = ( v << ( _num - _num ) ) > > ( _num - _num ) ; return v * ( _num * _num ) ; case _num : v = ( v << ( _num - _num ) ) > > ( _num - _num ) ; v |= ( in . readunsignedbyte ( ) ) << _num ; v |= ( in . readunsignedbyte ( ) ) << _num ; v |= ( in . readunsignedbyte ( ) ) ; return v * _num ; case _num : long w = ( ( ( long ) v ) << ( _num - _num ) ) > > ( _num - _num ) ; w |= ( in . readunsignedbyte ( ) ) << _num ; w |= ( in . readunsignedbyte ( ) ) << _num ; w |= ( in . readunsignedbyte ( ) ) << _num ; w |= ( in . readunsignedbyte ( ) ) ; return w * _num ; case _num : return in . readlong ( ) ; } }	reads encoding generated by writemillis .
protected string draininboundmessagebuffer ( stringbuilder builder ) { return draininboundmessagebuffer ( builder , builder . length ( ) ) ; }	removes all of the characters from inboundmessagebuffer and returns the string removed .
public void endfakedrag ( ) { if ( ! mfakedragging ) { throw new illegalstateexception ( _str ) ; } final velocitytracker velocitytracker = mvelocitytracker ; velocitytracker . computecurrentvelocity ( _num , mmaximumvelocity ) ; int initialvelocity = ( int ) velocitytrackercompat . getyvelocity ( velocitytracker , mactivepointerid ) ; mpopulatepending = _bool ; if ( ( math . abs ( initialvelocity ) > mminimumvelocity ) || math . abs ( minitialmotionx - mlastmotionx ) >= ( getwidth ( ) / _num ) ) { if ( mlastmotionx > minitialmotionx ) { setcurrentiteminternal ( mcuritem - _num , _bool , _bool ) ; } else { setcurrentiteminternal ( mcuritem + _num , _bool , _bool ) ; } } else { setcurrentiteminternal ( mcuritem , _bool , _bool ) ; } enddrag ( ) ; mfakedragging = _bool ; }	end a fake drag of the pager .
public static string indent ( string str ) { curindent [ indentdepth + _num ] = curindent [ indentdepth ] + str . length ( ) ; indentdepth = indentdepth + _num ; return str ; }	there must be an easier way .
private static string loadcontents ( object filedata ) throws ioexception { string path = draft3filevaluehelper . getpath ( filedata ) ; inputstream is = null ; try { file file = new file ( path ) ; is = new fileinputstream ( file ) ; byte [ ] buffer = new byte [ math . min ( contents_number_of_bytes , ( int ) file . length ( ) ) ] ; is . read ( buffer ) ; return new string ( buffer , _str ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( ioexception e ) { } } } }	load first contents_number_of_bytes bytes from file.
@ override public void writetoparcel ( parcel dest , int flags ) { dest . writestring ( mname ) ; dest . writelong ( mdate ) ; dest . writelong ( mcod ) ; final weather weather = mweathers . get ( _num ) ; dest . writelong ( weather . getid ( ) ) ; dest . writestring ( weather . getmain ( ) ) ; dest . writestring ( weather . getdescription ( ) ) ; dest . writestring ( weather . geticon ( ) ) ; dest . writelong ( msys . getsunrise ( ) ) ; dest . writelong ( msys . getsunset ( ) ) ; dest . writestring ( msys . getcountry ( ) ) ; dest . writedouble ( mmain . gettemp ( ) ) ; dest . writelong ( mmain . gethumidity ( ) ) ; dest . writedouble ( mmain . getpressure ( ) ) ; dest . writedouble ( mwind . getspeed ( ) ) ; dest . writedouble ( mwind . getdeg ( ) ) ; }	write this instance out to byte contiguous memory .
public static char [ ] deobfuscate ( string epassword ) { if ( epassword == null ) return null ; byte [ ] bytes = null ; try { bytes = simplebase64encoder . decode ( epassword . substring ( xortag . length ( ) ) ) ; } catch ( exception e ) { return null ; } for ( int i = _num ; i < bytes . length ; i ++ ) { bytes [ i ] = ( byte ) ( ( bytes [ i ] ^ key [ i % key . length ] ) & _num ) ; } return tochar ( bytes ) ; }	the inverse operation of obfuscate : returns a cleartext password that was previously obfuscated using the xor scrambler .
public void addcustomparameter ( customparameter customparameter ) { if ( customparameter == null ) { throw new nullpointerexception ( _str ) ; } customparameters . add ( customparameter ) ; }	adds a new customparameter .
public static boolean validsystemnameconfig ( string systemname , char type ) { if ( ! validsystemnameformat ( systemname , type ) ) { log . warn ( systemname + _str ) ; return _bool ; } serialnode node = getnodefromsystemname ( systemname ) ; if ( node == null ) { log . warn ( systemname + _str ) ; return _bool ; } int bit = getbitfromsystemname ( systemname ) ; if ( ( type == _str ) || ( type == _str ) ) { if ( ( bit <= _num ) || ( bit > serialnode . outputbits [ node . nodetype ] ) ) { log . warn ( systemname + _str ) ; return _bool ; } } else if ( type == _str ) { if ( ( bit <= _num ) || ( bit > serialnode . inputbits [ node . nodetype ] ) ) { log . warn ( systemname + _str ) ; return _bool ; } } else { log . error ( _str ) ; return _bool ; } return _bool ; }	public static method to validate system name for configuration returns ' true ' if system name has a valid meaning in current configuration , else returns ' false '.
public builder timeout ( long timeout , timeunit timeunit ) { this . timeout = timeunit . tomillis ( timeout ) ; return this ; }	set the maximal timeout for waiting until the command comes back with either a job or an empty result .
private void addvertex ( object start , set < dependency > set ) { vertices . put ( start , set ) ; edges . addall ( set ) ; }	add a vertex to the graph .
public void run ( ) throws serializationexception , sqlexception { final string query = string . format ( _str + _str + _str + _str + _str + _str + _str + _str , tablename ) ; map < string , mapredstats > statsperstage = sessionstatelite . getmapredstats ( ) ; for ( string stage : statsperstage . keyset ( ) ) { mapredstats stats = statsperstage . get ( stage ) ; preparedstatement ps = connection . preparestatement ( query ) ; int psindex = _num ; ps . setlong ( psindex ++ , auditlogid ) ; ps . setstring ( psindex ++ , stage ) ; ps . setlong ( psindex ++ , stats . getnummap ( ) ) ; ps . setlong ( psindex ++ , stats . getnumreduce ( ) ) ; ps . setlong ( psindex ++ , stats . getcpumsec ( ) ) ; ps . setstring ( psindex , tojson ( stats . getcounters ( ) ) ) ; ps . executeupdate ( ) ; } }	runs the log module , writing the relevant audit data to the db .
public void addmapping ( matcher < request > requestmatcher , responsesource responsesource ) { mappings . addfirst ( new matcherresponsesourcepair ( requestmatcher , responsesource ) ) ; }	configure a response for matching requests.
private inputstream dopost ( ) throws ioexception { boundary ( ) ; writeln ( _str ) ; os . close ( ) ; return connection . getinputstream ( ) ; }	posts the requests to the server , with all the cookies and parameters that were added.
public void waitforsignal ( ) { synchronized ( minternallock ) { if ( this . mtriggerstate ) { return ; } try { minternallock . wait ( ) ; } catch ( final interruptedexception e ) { throw new runtimeexception ( e ) ; } } }	blocking : waits for the signal to be triggered , or returns immediately if it has already been triggered .
private void uninstall ( string identifier ) { if ( vocabulariesbyid . containskey ( identifier ) ) { vocabulary touninstall = vocabulariesbyid . get ( identifier ) ; file f = getvocabfile ( touninstall . geturiresolvable ( ) ) ; if ( f . exists ( ) ) { f . delete ( ) ; log . debug ( _str + f . getabsolutepath ( ) ) ; } else { log . warn ( _str + f . getabsolutepath ( ) ) ; } vocabulariesbyid . remove ( identifier ) ; } else { log . warn ( _str + identifier ) ; } }	uninstall vocabulary by its unique identifier .
public void addconversation ( conversation conversation ) { conversations . add ( new conversationinfo ( conversation ) ) ; notifydatasetchanged ( ) ; }	add a conversation to the adapter .
protected static string trimattributename ( string attname ) { return attname . substring ( _num , attname . length ( ) - _num ) ; }	removes the last character of the input string and returns the trimmed name.
public synchronized void addobject ( object obj ) { fifo . addelement ( obj ) ; nbobjects ++ ; notifyall ( ) ; }	add an object in the buffer.
private void queuealarm ( alarm alarm , transactionbuilder builder , bluetoothgattcharacteristic characteristic ) { calendar calendar = alarm . getalarmcal ( ) ; int daysmask = _num ; int maxalarms = _num ; if ( alarm . getindex ( ) >= maxalarms ) { if ( alarm . isenabled ( ) ) { gb . toast ( getcontext ( ) , _str , toast . length_long , gb . warn ) ; } return ; } if ( alarm . isenabled ( ) ) { daysmask = alarm . getrepetitionmask ( ) ; } byte [ ] alarmmessage = new byte [ ] { ( byte ) _num , ( byte ) ( _num + alarm . getindex ( ) ) , ( byte ) calendar . get ( calendar . hour_of_day ) , ( byte ) calendar . get ( calendar . minute ) , ( byte ) daysmask } ; builder . write ( characteristic , alarmmessage ) ; }	convert an alarm from the gb internal structure to a mi band message and put on the specified builder queue as a write message for the passed characteristic.
outputstream writechannel ( int channel ) throws ioexception { while ( os != null ) { boolean canwrite = _bool ; synchronized ( write_lock ) { if ( ! iswritelocked ) { iswritelocked = _bool ; canwrite = _bool ; } else { try { write_lock . wait ( _num ) ; } catch ( exception e ) { } } } if ( canwrite ) { os . write ( _str ) ; os . write ( channel > > _num ) ; os . write ( channel ) ; return os ; } } return null ; }	grabs the channel for writing .
public void reconfigzktowritable ( list < string > observernodes , list < string > readonlynodes ) { log . info ( _str + _str ) ; try { boolean reconfiglocal = _bool ; for ( string node : observernodes ) { if ( node . equals ( coordinatorext . getmynodeid ( ) ) ) { reconfiglocal = _bool ; continue ; } localrepository localrepository = localrepository . getinstance ( ) ; localrepository . remotereconfigcoordinator ( node , _str ) ; localrepository . remoterestartcoordinator ( node , _str ) ; } for ( string node : readonlynodes ) { if ( node . equals ( coordinatorext . getmynodeid ( ) ) ) { reconfiglocal = _bool ; continue ; } localrepository localrepository = localrepository . getinstance ( ) ; localrepository . remotereconfigcoordinator ( node , _str ) ; localrepository . remoterestartcoordinator ( node , _str ) ; } if ( reconfiglocal ) { coordinatorext . reconfigzktowritable ( ) ; } } catch ( exception ex ) { log . warn ( _str , ex . tostring ( ) ) ; } }	reconfigure zookeeper to participant mode within the local site.
public sootmethod ( string name , list < type > parametertypes , type returntype ) { this ( name , parametertypes , returntype , _num , collections . < sootclass > emptylist ( ) ) ; }	constructs a sootmethod with the given name , parameter types and return type .
public javaclass readfromclasspath ( string classfile ) throws ioexception { thread thread = thread . currentthread ( ) ; classloader loader = thread . getcontextclassloader ( ) ; inputstream is = loader . getresourceasstream ( classfile ) ; try { return parse ( is ) ; } finally { is . close ( ) ; } }	reads the class from the classpath .
private byte [ ] convertpasswordtokey ( byte [ ] password ) { try { messagedigest md = messagedigest . getinstance ( _str ) ; byte [ ] seed = md . digest ( password ) ; securerandom random = securerandom . getinstance ( _str ) ; random . setseed ( seed ) ; byte [ ] rawkey = new byte [ keylength ] ; random . nextbytes ( rawkey ) ; return rawkey ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } }	this method converts the specified password into a key in a deterministic manner.
public static string escapetext ( string text ) { string result = text . replace ( _str , _str ) ; return _str + result + _str ; }	escapes a given string for use in a java.
private static boolean usable ( method m , class c , class base ) { int mods = m . getmodifiers ( ) ; return ( m . getreturntype ( ) == proxytrustiterator . class && m . getexceptiontypes ( ) . length == _num && ( mods & modifier . static ) == _num && ( ( mods & ( modifier . public | modifier . protected ) ) != _num || ( ( mods & modifier . private ) != _num ? c == base : samepackage ( c , base ) ) ) ) ; }	returns true if the method returns proxytrustiterator , has no declared exceptions , and is a non - static member of the base class .
private void digitsdashtowords ( wordrelation wordrelation , item tokenitem , string tokenval ) { int tokenlength = tokenval . length ( ) ; int a = _num ; for ( int p = _num ; p <= tokenlength ; p ++ ) { if ( p == tokenlength || tokenval . charat ( p ) == _str ) { string aaa = tokenval . substring ( a , p ) ; numberexpander . expanddigits ( aaa , wordrelation , tokenitem ) ; wordrelation . addbreak ( ) ; a = p + _num ; } } }	convert the given digit token with dashes ( e.
private void checkrelease ( ) { list < partitionreader > torelease = new arraylist < partitionreader > ( ) ; for ( partitionreader p : hold ) { if ( ! p . istaken ( ) ) { torelease . add ( p ) ; finish ( p ) ; } } hold . removeall ( torelease ) ; }	check whether to release the hold partitions.
public void testmergeoneservletintoemptydocument ( ) throws exception { string srcxml = _str ; webxml srcwebxml = webxmlio . parsewebxml ( new bytearrayinputstream ( srcxml . getbytes ( _str ) ) , null ) ; string mergexml = _str + _str + _str + _str + _str + _str ; webxml mergewebxml = webxmlio . parsewebxml ( new bytearrayinputstream ( mergexml . getbytes ( _str ) ) , null ) ; webxmlmerger merger = new webxmlmerger ( srcwebxml ) ; merger . merge ( mergewebxml ) ; asserttrue ( webxmlutils . hasservlet ( srcwebxml , _str ) ) ; }	tests whether a single servlet is correctly merged into an empty descriptor .
public string tostring ( ) { return _str + _source + _str ; }	returns a printable representation of the read stream .
protected string normalizeversion ( string version ) { pattern regex = pattern . compile ( _str ) ; matcher m = regex . matcher ( version ) ; if ( m != null && m . lookingat ( ) ) { stringbuilder normal = new stringbuilder ( ) ; for ( int i = _num ; i <= _num ; i ++ ) { int v = _num ; if ( i == _num && i < m . groupcount ( ) && m . group ( i ) == null && m . group ( i + _num ) != null ) { i ++ ; } if ( m . group ( i ) != null ) { try { v = integer . parseint ( m . group ( i ) ) ; } catch ( exception ignore ) { } } if ( i > _num ) { normal . append ( _str ) ; } normal . append ( v ) ; } return normal . tostring ( ) ; } throw new illegalargumentexception ( _str + version ) ; }	validate the supplied application version , and normalize the version .
public static boolean isextension ( string filename , string extension ) { if ( filename == null ) return _bool ; if ( extension == null || extension . length ( ) == _num ) return indexofextension ( filename ) == - _num ; string fileext = getextension ( filename ) ; return fileext . equals ( extension ) ; }	checks whether the extension of the filename is that specified.
private synchronized void block ( boolean tf ) { if ( tf ) { try { if ( m_evaluatethread != null && m_evaluatethread . isalive ( ) ) { wait ( ) ; } } catch ( interruptedexception ex ) { } } else { notifyall ( ) ; } }	function used to stop code that calls acceptclusterer.
public static boolean sameweek ( calendar cal , iweekitem week ) { return ( cal . get ( calendar . week_of_year ) == week . getweekinyear ( ) && cal . get ( calendar . year ) == week . getyear ( ) ) ; }	check if calendar instance ' s date is in the same week , as the weekitem instance .
public static imageicon createoverlayicon ( final imageicon baseicon , final imageicon overlayicon ) { if ( baseicon == null ) { throw new illegalargumentexception ( _str ) ; } if ( overlayicon == null ) { throw new illegalargumentexception ( _str ) ; } bufferedimage bufferedimg = new bufferedimage ( baseicon . geticonwidth ( ) , baseicon . geticonheight ( ) , bufferedimage . type_int_argb ) ; graphics2d g2 = ( graphics2d ) bufferedimg . getgraphics ( ) ; g2 . setrenderinghint ( renderinghints . key_antialiasing , renderinghints . value_antialias_on ) ; affinetransform identityat = new affinetransform ( ) ; g2 . drawimage ( baseicon . getimage ( ) , identityat , null ) ; g2 . setcomposite ( alphacomposite . getinstance ( alphacomposite . src_over , _num ) ) ; g2 . drawimage ( overlayicon . getimage ( ) , identityat , null ) ; g2 . dispose ( ) ; return new imageicon ( bufferedimg ) ; }	paints the given overlay icon over the base icon.
public list < estratigrafia > listar ( ) { list < estratigrafia > dadosestratigrafia = new arraylist < > ( ) ; try { string sql = _str ; stm = conector . preparestatement ( sql ) ; rs = stm . executequery ( sql ) ; while ( rs . next ( ) ) { estratigrafia estratigrafia = new estratigrafia ( rs . getint ( _num ) , rs . getstring ( _num ) , rs . getstring ( _num ) , rs . getstring ( _num ) ) ; dadosestratigrafia . add ( estratigrafia ) ; } stm . close ( ) ; rs . close ( ) ; } catch ( sqlexception ex ) { mensagem . erro ( _str + ex ) ; } return dadosestratigrafia ; }	consultar todas estratigrafia cadastradas na base de dados.
public void run ( ) { int numberoflines = highlighter . getnumberoflines ( ) ; cachedlinedone = new boolean [ numberoflines ] ; parser . clearcache ( numberoflines ) ; boolean skipbreakpoint = _bool ; if ( isbreakpoint ( data . getinstructionpointer ( ) ) ) { skipbreakpoint = _bool ; } int linenumber = data . getinstructionpointer ( ) ; while ( ( linenumber < numberoflines ) ) { if ( ! running ) { break ; } if ( isbreakpoint ( linenumber ) && ! skipbreakpoint ) { break ; } else if ( isbreakpoint ( linenumber ) && skipbreakpoint ) { skipbreakpoint = _bool ; } if ( ( linenumber < numberoflines ) ) { data . setinstructionpointer ( linenumber + _num ) ; try { executelinenumber ( linenumber , _bool ) ; } catch ( exception ex ) { updateexecutionmark ( ) ; scrolltoexecutionmark ( ) ; errorlabel . settext ( ex . tostring ( ) + _str ) ; ex . printstacktrace ( ) ; break ; } } linenumber = data . getinstructionpointer ( ) ; } data . updatedirty ( ) ; running = _bool ; thread . yield ( ) ; updateall ( ) ; frame . checkbuttonstates ( ) ; runningthread = null ; }	this method is used to execute the assembler by the new thread .
public boolean equals ( object obj ) { if ( obj == null ) { return _bool ; } if ( getclass ( ) != obj . getclass ( ) ) { return _bool ; } final temporalpoint other = ( temporalpoint ) obj ; return other . time == time ; }	indicates whether some other object is " equal to " this comparator.
protected void assertstartswith ( string text , string expectedstart ) { if ( ! text . startswith ( expectedstart ) ) { fail ( _str + text + _str + expectedstart + _str ) ; } }	check that a text starts with the expected characters.
public static classsignature toclasssignature ( string sig ) throws badbytecode { try { return parsesig ( sig ) ; } catch ( indexoutofboundsexception e ) { throw error ( sig ) ; } }	parses the given signature string as a class signature .
public static string formatdistancebetween ( latlng point1 , latlng point2 ) { if ( point1 == null || point2 == null ) { return null ; } numberformat numberformat = numberformat . getnumberinstance ( ) ; double distance = math . round ( sphericalutil . computedistancebetween ( point1 , point2 ) ) ; if ( distance >= _num ) { numberformat . setmaximumfractiondigits ( _num ) ; return numberformat . format ( distance / _num ) + distance_km_postfix ; } return numberformat . format ( distance ) + distance_m_postfix ; }	calculate distance between two latlng points and format it nicely for display.
@ override public void mark ( int readaheadlimit ) throws ioexception { finputstream . mark ( readaheadlimit ) ; }	mark the present position in the stream.
@ override protected void addconvert ( convertmetadata convert ) { if ( m_converts == null ) { m_converts = new arraylist < convertmetadata > ( ) ; } m_converts . add ( convert ) ; }	internal : subclasses that support key converts need to override this method .
public static blocksnapshot validatesnapshot ( uri snapshoturi , uriinfo uriinfo , dbclient dbclient ) { argvalidator . checkuri ( snapshoturi ) ; blocksnapshot snapshot = dbclient . queryobject ( blocksnapshot . class , snapshoturi ) ; argvalidator . checkentity ( snapshot , snapshoturi , blockserviceutils . isidembeddedinurl ( snapshoturi , uriinfo ) , _bool ) ; return snapshot ; }	validate the blocksnapshot instance with the passed uri .
public boolean match ( uri uri ) { return matchnormalized ( uri . normalize ( ) ) ; }	returns true if the given uri matches the pattern.
public void addallowed ( class < ? > c , string displayname ) { hashset < string > list ; list = m_allowed . get ( c ) ; if ( list == null ) { list = new hashset < string > ( ) ; m_allowed . put ( c , list ) ; } list . add ( displayname ) ; }	adds the given property ( display name ) to the list of allowed properties for the specified class .
public properties findtemplatetags ( ) { properties tags = new properties ( ) ; m_errormessages . setlength ( _num ) ; m_missingkeys . removeallelements ( ) ; while ( _bool ) { nexttoken result = getnexttoken ( ) ; if ( ! result . finishedparsing ( ) ) { if ( result . foundtoken ( ) && ! begin_for_each . equals ( result . getkey ( ) ) && ! end_for_each . equals ( result . getkey ( ) ) ) { tags . put ( result . getkey ( ) , result . getkey ( ) ) ; } } else { break ; } } return ( tags ) ; }	this method parses the template substituting keys with values supplied in tags dictionary .
public static containerstats calculatestatsvalues ( string statsjson ) { containerstats state = new containerstats ( ) ; if ( statsjson == null || statsjson . isempty ( ) ) { return state ; } map < string , jsonelement > stats = parsestats ( statsjson ) ; calculatecpuusage ( state , stats ) ; setmemoryusage ( state , stats ) ; setnetworkusage ( state , stats ) ; setcontainerstopped ( state , stats ) ; return state ; }	parse the json stats value and return containerstats state with the calculated values from the json field .
public boolean beforewriting ( ) { if ( filelockmethod != filelock . lock_serialized ) { return _bool ; } while ( checkpointrunning ) { try { thread . sleep ( _num + ( int ) ( math . random ( ) * _num ) ) ; } catch ( exception e ) { } } synchronized ( reconnectsync ) { if ( reconnectmodified ( _bool ) ) { checkpointallowed ++ ; if ( sysproperties . check && checkpointallowed > _num ) { throw dbexception . throwinternalerror ( ) ; } return _bool ; } } reconnectchecknext = system . currenttimemillis ( ) - _num ; reconnectlastlock = null ; return _bool ; }	this method is called before writing to the transaction log .
private void startmonitorthread ( ) { monitorthread = new thread ( new queuemonitor ( resourcemanager ) ) ; monitorthread . start ( ) ; log . debug ( _str ) ; }	start the publishing monitor thread itself .
public void centeronpointrel ( double xrel , double yrel ) { xrel = math . max ( _num , xrel ) ; xrel = math . min ( _num , xrel ) ; yrel = math . max ( _num , yrel ) ; yrel = math . min ( _num , yrel ) ; point p = new point ( ( int ) ( ( double ) boardsize . getwidth ( ) * xrel ) + hex_w , ( int ) ( ( double ) boardsize . getheight ( ) * yrel ) + hex_h ) ; jscrollbar vscroll = scrollpane . getverticalscrollbar ( ) ; vscroll . setvalue ( p . y - ( vscroll . getvisibleamount ( ) / _num ) ) ; jscrollbar hscroll = scrollpane . gethorizontalscrollbar ( ) ; hscroll . setvalue ( p . x - ( hscroll . getvisibleamount ( ) / _num ) ) ; repaint ( ) ; }	centers the board to a point.
public object pop ( ) { return stack . pop ( ) ; }	returns the latest element from the stack , removes it .
public boolean connectionallowed ( eventsetdescriptor esd ) { return connectionallowed ( esd . getname ( ) ) ; }	returns true if , at this time , the object will accept a connection according to the supplied eventsetdescriptor.
protected void validatestate ( state current ) { validationutils . validatestate ( current ) ; checknotnull ( current . executionstate , _str ) ; checkispositivenumber ( current . triggerssuccess , _str ) ; checkispositivenumber ( current . triggerserror , _str ) ; }	validate the service state for coherence .
protected void assertequals ( float expected , float actual ) { if ( expected != actual ) { if ( float . isnan ( expected ) && float . isnan ( actual ) ) { } else { fail ( _str + expected + _str + actual ) ; } } }	check if two values are equal , and if not throw an exception .
protected static void addvolume ( list < blockobjectrestrep > blockobjects , volumerestrep volume , list < blocksnapshotrestrep > snapshots ) { blockobjects . add ( volume ) ; if ( collectionutils . isnotempty ( snapshots ) ) { iterator < blocksnapshotrestrep > snapshotiter = snapshots . iterator ( ) ; while ( snapshotiter . hasnext ( ) ) { blocksnapshotrestrep snap = snapshotiter . next ( ) ; if ( resourceutils . idequals ( snap . getparent ( ) , volume ) ) { blockobjects . add ( snap ) ; snapshotiter . remove ( ) ; } } } }	add the volume and its snapshots to the ' blockobjects ' list.
private fixedallocator findallocator ( final int block ) { if ( block > csmallslot ) { return null ; } final bucket stats = m_storagestats . findbucket ( block ) ; if ( stats == null ) { return null ; } if ( stats . m_allocators < csmallslotwastecheckallocators ) { return null ; } final float slotwaste = stats . slotsunused ( ) ; if ( slotwaste < csmallslothighwaste ) { return null ; } fixedallocator candidate = null ; int candidatefreebits = csmallslotthresholdhighwaste ; for ( int i = _num ; i < m_allocs . size ( ) ; i ++ ) { final fixedallocator tst = m_allocs . get ( i ) ; if ( tst . getblocksize ( ) == block ) { if ( tst . m_freebits > candidatefreebits ) { candidate = tst ; candidatefreebits = candidate . m_freebits ; } } } if ( candidate != null ) { candidate . m_smallslothighwaste = _bool ; if ( log . isdebugenabled ( ) ) { log . debug ( _str ) ; } } return candidate ; }	for a small slot size only , look for an existing allocator that has a sufficient percentage of free bits and add it to the free list.
public static byte [ ] buildspeexcomment ( string comment ) { byte [ ] data = new byte [ comment . length ( ) + _num ] ; writespeexcomment ( data , _num , comment ) ; return data ; }	builds and returns a speex comment .
public void addedge ( final edgetype edge ) { preconditions . checknotnull ( edge , _str ) ; m_edges . add ( edge ) ; updatenodetoedgemapping ( edge ) ; }	adds an edge to the graph .
public collection < extension > build ( collection < string > urls ) { list < extension > extensions = new linkedlist < extension > ( ) ; for ( string urlasstring : urls ) { try { extension e = build ( urlasstring ) ; if ( e != null ) { extensions . add ( e ) ; } } catch ( ioexception e ) { log . error ( _str + urlasstring , e ) ; } catch ( saxexception e ) { log . error ( _str + urlasstring , e ) ; } } return extensions ; }	builds extensions from the supplied strings which should be urls .
private void parseandadd ( string line ) { stringtokenizer tokenizer = new stringtokenizer ( line , _str ) ; try { string phoneme = tokenizer . nexttoken ( ) ; string feature = tokenizer . nexttoken ( ) ; string value = tokenizer . nexttoken ( ) ; phonesetmap . put ( getkey ( phoneme , feature ) , value ) ; } catch ( nosuchelementexception nse ) { throw new error ( _str + linecount ) ; } }	creates a word from the given input line and add it to the map .
public locale read ( string locale ) throws exception { string [ ] list = pattern . split ( locale ) ; if ( list . length < _num ) { throw new invalidformatexception ( _str , locale ) ; } return read ( list ) ; }	this method is used to convert the string value given to an appropriate representation.
private string [ ] retrieveenumeration ( string schematable , string column ) throws sqlexception { string [ ] enumelements = null ; string query = _str + schematable + _str + column + _str ; statement st = null ; resultset rs = null ; try { st = conn . createstatement ( ) ; rs = st . executequery ( query ) ; if ( rs . next ( ) ) { string enumdefinition = rs . getstring ( _str ) ; if ( logger . isdebugenabled ( ) ) logger . debug ( enumdefinition ) ; enumelements = parselisttype ( enumdefinition ) ; } } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( sqlexception e ) { } } if ( st != null ) { try { st . close ( ) ; } catch ( sqlexception e ) { } } } return enumelements ; }	connects to the mysql database , executes show columns for a defined table and parses out allowed enum values to their corresponding string representations .
public void adddataline ( string [ ] values ) { assert ( headers != null && ! headers . isempty ( ) && headers . size ( ) == values . length ) ; if ( data == null ) { data = new arraylist < > ( totallines ) ; timetodataindex = new hashmap < > ( ) ; } map < string , string > datamap = new hashmap < > ( ) ; int numheaders = headers . size ( ) ; int currentdataindex = data . size ( ) ; for ( int index = _num ; index < numheaders ; index ++ ) { string header = headers . get ( index ) ; string value = values [ index ] ; if ( value . equals ( zero ) ) { value = zero ; } else if ( value . equals ( no_data ) ) { value = no_data ; } datamap . put ( header , value ) ; if ( header . equals ( time_utc ) ) { timetodataindex . put ( value , currentdataindex ) ; } } data . add ( datamap ) ; }	add the data values.
@ requestmapping ( value = _str , method = requestmethod . delete , produces = mediatype . application_json_value ) @ timed @ secured ( authoritiesconstants . admin ) public responseentity < void > deleteuser ( @ pathvariable string login ) { }	delete user : login : delete the " login " user .
@ override public boolean equals ( object object ) { if ( this == object ) { return _bool ; } if ( object instanceof set ) { set < ? > s = ( set < ? > ) object ; try { return size ( ) == s . size ( ) && containsall ( s ) ; } catch ( nullpointerexception ignored ) { return _bool ; } catch ( classcastexception ignored ) { return _bool ; } } return _bool ; }	compares the specified object to this set and returns true if they are equal.
@ override public double java2dtovalue ( double java2dvalue , rectangle2d dataarea , rectangleedge edge ) { range range = getrange ( ) ; double vmax = range . getupperbound ( ) ; double vp = getcyclebound ( ) ; double jmin = _num ; double jmax = _num ; if ( rectangleedge . istoporbottom ( edge ) ) { jmin = dataarea . getminx ( ) ; jmax = dataarea . getmaxx ( ) ; } else if ( rectangleedge . isleftorright ( edge ) ) { jmin = dataarea . getmaxy ( ) ; jmax = dataarea . getminy ( ) ; } if ( isinverted ( ) ) { double jbreak = jmax - ( vmax - vp ) * ( jmax - jmin ) / this . period ; if ( java2dvalue >= jbreak ) { return vp + ( jmax - java2dvalue ) * this . period / ( jmax - jmin ) ; } else { return vp - ( java2dvalue - jmin ) * this . period / ( jmax - jmin ) ; } } else { double jbreak = ( vmax - vp ) * ( jmax - jmin ) / this . period + jmin ; if ( java2dvalue <= jbreak ) { return vp + ( java2dvalue - jmin ) * this . period / ( jmax - jmin ) ; } else { return vp - ( jmax - java2dvalue ) * this . period / ( jmax - jmin ) ; } } }	converts a coordinate from java 2d space to data space .
static public document converttoclusterconfiguration ( document clusterxmldomelement , inputstream clusterxslpolicy ) throws ioexception , transformerconfigurationexception , transformerexception , parserconfigurationexception , saxexception { document rootdoc = ( document ) xsltconverter . transformdom2dom ( clusterxmldomelement , clusterxslpolicy ) ; return rootdoc ; }	method which gets cluster xml dom element and cluster xsl schema input stream.
public static string findedittable ( string tables ) { if ( ! textutils . isempty ( tables ) ) { int spacepos = tables . indexof ( _str ) ; int commapos = tables . indexof ( _str ) ; if ( spacepos > _num && ( spacepos < commapos || commapos < _num ) ) { return tables . substring ( _num , spacepos ) ; } else if ( commapos > _num && ( commapos < spacepos || spacepos < _num ) ) { return tables . substring ( _num , commapos ) ; } return tables ; } else { throw new illegalstateexception ( _str ) ; } }	finds the name of the first table , which is editable .
public charbuffer append ( double d ) { return append ( string . valueof ( d ) ) ; }	add a double to the buffer .
void doconnect ( ) throws ioexception { int port = _num ; if ( hasmoretokens ( ) ) { try { port = nextinttoken ( ) ; } catch ( numberformatexception ex ) { err ( ex . getlocalizedmessage ( ) ) ; } } else { port = dprotocol . debug_connect_port ; } if ( port > _num ) { m_connectport = string . valueof ( port ) ; dorun ( ) ; } }	fire up a session or await a connection from the socket if no uri was specified .
public void testremovenameditemns1 ( ) throws throwable { document doc ; nodelist elementlist ; node testaddress ; namednodemap attributes ; attr newattr ; node removednode ; doc = ( document ) load ( _str , builder ) ; elementlist = doc . getelementsbytagname ( _str ) ; testaddress = elementlist . item ( _num ) ; attributes = testaddress . getattributes ( ) ; removednode = attributes . removenameditemns ( _str , _str ) ; assertnotnull ( _str , removednode ) ; newattr = ( attr ) attributes . getnameditem ( _str ) ; assertnull ( _str , newattr ) ; }	runs the test case .
public static boolean isavailable ( ) { return s_links . size ( ) != _num ; }	is online help available .
public boolean connect ( final string address ) { if ( mbluetoothadapter == null || address == null ) { log . w ( tag , _str ) ; return _bool ; } if ( mbluetoothdeviceaddress != null && address . equals ( mbluetoothdeviceaddress ) && mbluetoothgatt != null ) { log . d ( tag , _str ) ; if ( mbluetoothgatt . connect ( ) ) { mconnectionstate = state_connecting ; return _bool ; } else { return _bool ; } } final bluetoothdevice device = mbluetoothadapter . getremotedevice ( address ) ; if ( device == null ) { log . d ( tag , _str ) ; return _bool ; } mbluetoothgatt = device . connectgatt ( this , _bool , mgattcallback ) ; log . d ( tag , _str ) ; mbluetoothdeviceaddress = address ; mconnectionstate = state_connecting ; return _bool ; }	connects to the gatt server hosted on the bluetooth le device .
public void filledcircle ( double x , double y , double r ) { if ( r < _num ) throw new illegalargumentexception ( _str ) ; double xs = scalex ( x ) ; double ys = scaley ( y ) ; double ws = factorx ( _num * r ) ; double hs = factory ( _num * r ) ; if ( ws <= _num && hs <= _num ) pixel ( x , y ) ; else offscreen . fill ( new ellipse2d . double ( xs - ws / _num , ys - hs / _num , ws , hs ) ) ; draw ( ) ; }	draws a filled circle of radius r , centered on ( x , y ) .
public void recalculatepath ( ) { if ( targetvector != null ) { deltapathx = targetvector . xpos - startpos . xpos ; deltapathy = targetvector . ypos - startpos . ypos ; deltapathz = targetvector . zpos - startpos . zpos ; flatdistance = vector2 . distance ( new vector2 ( startpos ) , new vector2 ( targetvector ) ) ; maxheight = _num + ( int ) ( flatdistance * _num ) ; missileflighttime = ( float ) math . max ( _num , _num * flatdistance ) - airborneticks ; acceleration = ( float ) maxheight * _num / ( missileflighttime * missileflighttime ) ; } }	recalculates required parabolic path for the missile registry.
private boolean hasremainingcomments ( ) { return lastcommentindex < comments . size ( ) - _num ; }	returns if there are comments in the input that we have not looked at yet.
public void registerreceiver ( broadcastreceiver receiver , intentfilter filter ) { synchronized ( mreceivers ) { receiverrecord entry = new receiverrecord ( filter , receiver ) ; arraylist < intentfilter > filters = mreceivers . get ( receiver ) ; if ( filters == null ) { filters = new arraylist < intentfilter > ( _num ) ; mreceivers . put ( receiver , filters ) ; } filters . add ( filter ) ; for ( int i = _num ; i < filter . countactions ( ) ; i ++ ) { string action = filter . getaction ( i ) ; arraylist < receiverrecord > entries = mactions . get ( action ) ; if ( entries == null ) { entries = new arraylist < receiverrecord > ( _num ) ; mactions . put ( action , entries ) ; } entries . add ( entry ) ; } } }	register a receive for any local broadcasts that match the given intentfilter .
public boolean more ( ) { return pos < in . length ( ) ; }	returns true until the input has been exhausted .
public void save ( ) throws filenotfoundexception { printstream p = new printstream ( file ) ; p . println ( comment_prefix + _str ) ; for ( pair < string , arraylist < string > > settings : store ) { p . println ( settings . first ) ; for ( string str : settings . second ) { p . println ( str ) ; } p . println ( ) ; } p . close ( ) ; }	save the current data to the given file .
public form showform ( string resourcename , command sourcecommand ) { form f = ( form ) createcontainer ( fetchresourcefile ( ) , resourcename ) ; showform ( f , sourcecommand , null ) ; return f ; }	this method is equivalent to the internal navigation behavior , it adds functionality such as the back command into the given form resource and shows it.
public generalnamestablemodel ( ) { columnname = res . getstring ( _str ) ; data = new arraylist < generalname > ( ) ; }	construct a new generalnamestablemodel .
private point2d calculaterangemarkertextanchorpoint ( graphics2d g2 , plotorientation orientation , rectangle2d dataarea , rectangle2d markerarea , rectangleinsets markeroffset , lengthadjustmenttype labeloffsetforrange , rectangleanchor anchor ) { rectangle2d anchorrect = null ; if ( orientation == plotorientation . horizontal ) { anchorrect = markeroffset . createadjustedrectangle ( markerarea , labeloffsetforrange , lengthadjustmenttype . contract ) ; } else if ( orientation == plotorientation . vertical ) { anchorrect = markeroffset . createadjustedrectangle ( markerarea , lengthadjustmenttype . contract , labeloffsetforrange ) ; } return rectangleanchor . coordinates ( anchorrect , anchor ) ; }	calculates the ( x , y ) coordinates for drawing a marker label .
public string readfilecontent ( file file ) { stringbuilder filecontentbuilder = new stringbuilder ( ) ; if ( file . exists ( ) ) { string stringline ; try { filereader filereader = new filereader ( file ) ; bufferedreader bufferedreader = new bufferedreader ( filereader ) ; boolean newline = _bool ; while ( ( stringline = bufferedreader . readline ( ) ) != null ) { if ( newline ) { filecontentbuilder . append ( _str ) ; } filecontentbuilder . append ( stringline ) ; newline = _bool ; } bufferedreader . close ( ) ; filereader . close ( ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } } return filecontentbuilder . tostring ( ) ; }	reads a content from a file.
public static word prepareword ( object object , offset offset ) { if ( vm . verifyassertions ) vm . _assert ( vm . not_reached ) ; return word . max ( ) ; }	get contents of ( object + offset ) and begin conditional critical section .
protected void transformpath ( path path ) { path . transform ( mmatrixvaluetopx ) ; path . transform ( mmatrixtouch ) ; path . transform ( mmatrixoffset ) ; }	transform a path with all the given matrices very important : keep order to value - touch - offset.
static private string int_max_plus ( ) { long tempvalue = integer . max_value + _num ; return string . valueof ( tempvalue ) ; }	get the max value plus one for an int.
public static byte [ ] decode ( string str ) throws coderexception { byte out [ ] = new byte [ str . length ( ) ] ; int len = _num ; int offset = _num ; byte b = _num ; boolean stop = _bool ; stringcharacteriterator it = new stringcharacteriterator ( str ) ; do { b = _dec ( it . current ( ) ) ; it . next ( ) ; if ( b > _num ) throw new coderexception ( _str + str + _str ) ; if ( b < _num ) stop = _bool ; len += b ; for ( ; b > _num ; b -= _num ) { decodechars ( it , out , offset ) ; offset += _num ; } it . next ( ) ; } while ( ! stop ) ; byte rtn [ ] = new byte [ len ] ; for ( int i = _num ; i < len ; i ++ ) rtn [ i ] = out [ i ] ; return rtn ; }	decodes back a string to a byte array.
void callstage3 ( p parameter , t object , c callback ) throws e ;	synchronous call , called multiple times , once per registered callback.
public void addall ( collection < ? extends t > collection ) { if ( meventdelegate != null ) meventdelegate . adddata ( collection == null ? _num : collection . size ( ) ) ; if ( collection != null && collection . size ( ) != _num ) { synchronized ( mlock ) { mobjects . addall ( collection ) ; } } int datacount = collection == null ? _num : collection . size ( ) ; if ( mobserver != null ) mobserver . onitemrangeinserted ( getcount ( ) - datacount + _num , datacount ) ; if ( mnotifyonchange ) notifyitemrangeinserted ( headers . size ( ) + getcount ( ) - datacount + _num , datacount ) ; log ( _str + ( headers . size ( ) + getcount ( ) - datacount + _num ) + _str + ( datacount ) ) ; }	adds the specified collection at the end of the array .
public void dumpstring ( final stringbuilder sblong , final long start , final long end ) { sblong . append ( _str ) ; sblong . append ( start ) ; sblong . append ( _str ) ; for ( long i = start ; i < end ; i ++ ) { sblong . append ( _str ) ; sblong . append ( formatinteger . tobits ( get ( i ) ) ) ; } sblong . append ( ls ) ; }	string representation on one line of part of the index .
private void merge ( final wordalignmentstate state ) { if ( ! stack . isempty ( ) && state . iscomplete ( ) ) { final wordalignmentstate parentstate = stack . pop ( ) ; if ( parentstate . iscomplete ( ) ) { throw new illegalstateexception ( _str ) ; } parentstate . substitutein ( state ) ; merge ( parentstate ) ; } else { stack . add ( state ) ; } }	merges a state with the top of the stack if applicable or places it on top of the stack .
protected void stopwitherrormessage ( string error , exception ex ) { stop ( ) ; if ( m_log != null ) { m_log . statusmessage ( statusmessageprefix ( ) + error + _str ) ; m_log . logmessage ( statusmessageprefix ( ) + error + ( ex != null ? _str + ex . getmessage ( ) : _str ) ) ; } }	stops the step ( and upstream ones ) and then prints an error message and optional exception message.
public node parsetext ( string text ) throws ioexception , saxexception { return parse ( new stringreader ( text ) ) ; }	a helper method to parse the given text as xml .
public void changeviewposition ( view child , int newindex ) { int currentindex = indexofchild ( child ) ; if ( child != null && child . getparent ( ) == this && currentindex != newindex ) { mchangepositioninprogress = _bool ; removeview ( child ) ; addview ( child , newindex ) ; mchangepositioninprogress = _bool ; if ( misexpanded && manimationsenabled && child . getvisibility ( ) != view . gone ) { mchildrenchangingpositions . add ( child ) ; mneedsanimation = _bool ; } } }	change the position of child to a new location.
public static < t > void write ( string filename , iterable < t > list , itransformer < t , string > transformer ) throws ioexception { bufferedwriter writer = new bufferedwriter ( new filewriter ( filename ) ) ; for ( t object : list ) { writer . write ( transformer . transform ( object ) ) ; writer . newline ( ) ; } writer . close ( ) ; }	this function writes a list of objects into a file , one per line.
public timetablexydataset ( timezone zone ) { this ( zone , locale . getdefault ( ) ) ; }	creates a new dataset with the given time zone .
public void skipto ( int desiredposition ) { desiredposition = math . max ( _num , desiredposition ) ; for ( int i = _num ; i < desiredposition ; i ++ ) skip ( ) ; }	this skips until the playlist is playing the specified track .
public static boolean isxml11validncname ( string ncname ) { int length = ncname . length ( ) ; if ( length == _num ) return _bool ; int i = _num ; char ch = ncname . charat ( _num ) ; if ( ! isxml11ncnamestart ( ch ) ) { if ( length > _num && isxml11namehighsurrogate ( ch ) ) { char ch2 = ncname . charat ( _num ) ; if ( ! xmlchar . islowsurrogate ( ch2 ) || ! isxml11ncnamestart ( xmlchar . supplemental ( ch , ch2 ) ) ) { return _bool ; } i = _num ; } else { return _bool ; } } while ( i < length ) { ch = ncname . charat ( i ) ; if ( ! isxml11ncname ( ch ) ) { if ( ++ i < length && isxml11namehighsurrogate ( ch ) ) { char ch2 = ncname . charat ( i ) ; if ( ! xmlchar . islowsurrogate ( ch2 ) || ! isxml11ncname ( xmlchar . supplemental ( ch , ch2 ) ) ) { return _bool ; } } else { return _bool ; } } ++ i ; } return _bool ; }	check to see if a string is a valid ncname according to [ 4 ] from the xml namespaces 1 . 1 recommendation.
public string consumetoany ( string ... seq ) { int start = pos ; while ( ! isempty ( ) && ! matchesany ( seq ) ) { pos ++ ; } return queue . substring ( start , pos ) ; }	consumes to the first sequence provided , or to the end of the queue.
protected void assertrequireddependentmetriccount ( string dictionaryname , list < string > dependentmetrics ) { int requiredcount = getdependentmetricsrequired ( ) ; int actualcount = dependentmetrics . size ( ) ; if ( actualcount != requiredcount ) { string message = string . format ( _str , dictionaryname , actualcount , requiredcount ) ; log . error ( message ) ; throw new illegalargumentexception ( message ) ; } }	checks that we have the right number of metrics , and throws an exception if we don ' t .
private static boolean serializefield ( field f ) { int mod = f . getmodifiers ( ) ; return ! modifier . isstatic ( mod ) && ! modifier . istransient ( mod ) ; }	whether the field must be serialized .
public componentmanager ( ) { gralcomponents = new sequencecollection ( ) ; gralseeds = collections . unmodifiableset ( collections . < sequence > emptyset ( ) ) ; }	create an empty component manager , with an empty seed sequence set .
public boolean loadproperties ( url url , properties props ) { try { inputstream propsin = url . openstream ( ) ; props . load ( propsin ) ; return _bool ; } catch ( java . io . ioexception e ) { return _bool ; } }	loads properties from a java resource.
public static string formatprice ( double price ) { return pricedecimalformat . format ( price ) ; }	formats a double representing a price into a string.
public countsimcomparisonkmlwriter ( final list < countsimcomparison > countsimcomplist , final network network , final coordinatetransformation coordtransform ) { super ( countsimcomplist ) ; this . network = network ; this . counts = null ; this . coordtransform = coordtransform ; this . graphname = _str ; }	sets the data to the fields of this class.
public boolean equals ( object obj ) { if ( this == obj ) return _bool ; if ( ! ( obj instanceof ipaddressname ) ) return _bool ; ipaddressname othername = ( ipaddressname ) obj ; byte [ ] other = othername . address ; if ( other . length != address . length ) return _bool ; if ( address . length == _num || address . length == _num ) { int masklen = address . length / _num ; for ( int i = _num ; i < masklen ; i ++ ) { byte maskedthis = ( byte ) ( address [ i ] & address [ i + masklen ] ) ; byte maskedother = ( byte ) ( other [ i ] & other [ i + masklen ] ) ; if ( maskedthis != maskedother ) { return _bool ; } } for ( int i = masklen ; i < address . length ; i ++ ) if ( address [ i ] != other [ i ] ) return _bool ; return _bool ; } else { return arrays . equals ( other , address ) ; } }	compares this name with another , for equality .
public ownerimpl ( principalimpl owner ) { ownerlist = new vector < principal > ( ) ; ownerlist . addelement ( owner ) ; }	constructs a list of owner with the specified principal as first element .
public final void writedouble ( double val ) throws ioexception { writelong ( double . doubletolongbits ( val ) ) ; }	writes a 64 - bit double to the target stream.
@ override protected void doget ( httpservletrequest request , httpservletresponse response ) throws servletexception , ioexception { string contextpath = request . getparameter ( _str ) ; string warurl = request . getparameter ( _str ) ; string command = request . getservletpath ( ) ; if ( command . equals ( _str ) ) { deploy ( response , contextpath , warurl ) ; } else if ( command . equals ( _str ) ) { undeploy ( response , contextpath ) ; } else { response . senderror ( _num , _str + command + _str ) ; } }	performs the http get method .
public int writeclassdata ( classdata classdata ) { int off = data . position ( ) ; writeuleb128 ( classdata . staticfields . length ) ; writeuleb128 ( classdata . instancefields . length ) ; writeuleb128 ( classdata . directmethods . length ) ; writeuleb128 ( classdata . virtualmethods . length ) ; writefields ( classdata . staticfields ) ; writefields ( classdata . instancefields ) ; writemethods ( classdata . directmethods ) ; writemethods ( classdata . virtualmethods ) ; return off ; }	write classdata item into current section .
@ deprecated public url tourl ( ) throws java . net . malformedurlexception { string name = getabsolutename ( ) ; if ( ! name . startswith ( _str ) ) { return new url ( _str , _str , - _num , _str + name , null ) ; } else if ( name . startswith ( _str ) ) { return new url ( _str + name ) ; } return new url ( _str , _str , - _num , name , null ) ; }	returns a uniform resource locator for this file.
public byte [ ] generatemwk ( byte [ ] desbytes ) { if ( debug ) { debug . loginfo ( _str + stringutil . tohexstring ( desbytes ) + _str + desbytes . length , module ) ; } secretkeyfactory skf1 = null ; secretkey mwk = null ; try { skf1 = secretkeyfactory . getinstance ( _str ) ; } catch ( nosuchalgorithmexception e ) { debug . logerror ( e , module ) ; } desedekeyspec desedespec2 = null ; try { desedespec2 = new desedekeyspec ( desbytes ) ; } catch ( invalidkeyexception e ) { debug . logerror ( e , module ) ; } if ( skf1 != null && desedespec2 != null ) { try { mwk = skf1 . generatesecret ( desedespec2 ) ; } catch ( invalidkeyspecexception e ) { debug . logerror ( e , module ) ; } } if ( mwk != null ) { return generatemwk ( mwk ) ; } else { return null ; } }	generate a new mwk.
@ override public boolean ispressed ( ) { boolean b = shouldactlikebutton ( ) ? pressed : super . ispressed ( ) ; return b || ( pressedwhenpopupvisible && combobox . ispopupvisible ( ) ) ; }	indicates if the button is pressed .
public static int randomint ( int lowerthan ) { return random . nextint ( lowerthan ) ; }	get a pseudo random int value between 0 ( including and the given value ( excluding ).
public void saveconfig ( ) { urlcombobox . getcurrenttext ( _bool ) ; programproperties . put ( _str , urlcombobox . getitemsasstring ( _num , _str ) ) ; }	save the current configuation.
public resourceurl ( string nuri ) throws malformeduriexception { super ( nuri ) ; if ( uri . length ( ) == colonlocation + _num ) throw new malformeduriexception ( _str , null ) ; if ( uri . charat ( colonlocation + _num ) != _str ) throw new malformeduriexception ( _str + uri + _str , uri ) ; if ( ! uri . regionmatches ( _num , _str , _num , colonlocation ) ) throw new malformeduriexception ( _str + uri + _str , uri ) ; }	creates a " res : " url from the given string .
public void aggregate ( classloadinginformationdata other ) { count += other . count ; minloadedclasscount = math . min ( minloadedclasscount , other . minloadedclasscount ) ; maxloadedclasscount = math . max ( maxloadedclasscount , other . maxloadedclasscount ) ; totalloadedclasscount += other . totalloadedclasscount ; mintotalloadedclasscount = math . min ( mintotalloadedclasscount , other . mintotalloadedclasscount ) ; maxtotalloadedclasscount = math . max ( maxtotalloadedclasscount , other . maxtotalloadedclasscount ) ; totaltotalloadedclasscount += other . totaltotalloadedclasscount ; minunloadedclasscount = math . min ( minunloadedclasscount , other . minunloadedclasscount ) ; maxunloadedclasscount = math . max ( maxunloadedclasscount , other . maxunloadedclasscount ) ; totalunloadedclasscount += other . maxunloadedclasscount ; }	aggregates other class loading object info this object .
private accessrequest createaccessrequest ( ) throws nosuchalgorithmexception { requestauthenticator ra = new requestauthenticator ( random , secret ) ; accessrequest req = new accessrequest ( getidentifier ( ) , ra ) ; return req ; }	generates an access request packet .
public boolean isdataflavorsupported ( dataflavor flavor ) { for ( dataflavor flavor2 : flavors ) { if ( flavor2 . equals ( flavor ) ) { return _bool ; } } return _bool ; }	returns whether the requested flavor is supported by this transferable .
public void write ( rotatestream stream , byte [ ] buffer , int offset , int length ) throws ioexception { try { _queue . offer ( new logitembinary ( stream , buffer , offset , length ) , _num , timeunit . seconds ) ; _queue . wake ( ) ; } catch ( throwable e ) { e . printstacktrace ( environmentstream . getoriginalsystemerr ( ) ) ; } }	writes to the stream.
private void expandnode ( final treenode node , final treepath path , final int level ) { if ( level <= _num ) { return ; } tree . expandpath ( path ) ; for ( int i = _num ; i < node . getchildcount ( ) ; ++ i ) { final treenode childnode = node . getchildat ( i ) ; expandnode ( childnode , path . pathbyaddingchild ( childnode ) , level - _num ) ; } }	expand the given tree to the given level , starting from the given node and path .
public void addvmproxyarg ( vmproxyarg vmpa ) { string key = vmpa . getcontextreference ( ) ; if ( vmpa . isconstant ( ) ) { localcontext . put ( key , vmpa . getobject ( wrappedcontext ) ) ; } else { vmproxyhash . put ( key , vmpa ) ; } }	used to put vmproxyargs into this context . it separates the vmproxyargs into constant and non - constant types pulling out the value of the constant types so they can be modified w / o damaging the vmproxyarg , and leaving the dynamic ones , as they modify context rather than their own state.
public void addpinger ( pinger pinger ) { if ( ! mpingers . contains ( pinger ) ) { mpingers . add ( pinger ) ; notifydatasetchanged ( ) ; } }	add a pinger to the list .
@ override public void onmessage ( message message ) { synchronized ( messages ) { messages . add ( message ) ; if ( verbose ) { log . info ( _str + message ) ; } messages . notifyall ( ) ; } }	method implemented from messagelistener interface .
public default independentdistribution queryprob ( bnetwork network , string queryvar ) { return queryprob ( network , queryvar , new assignment ( ) ) ; }	computes the probability distribution for the query variable , assuming no additional evidence .
public static string encodenoncodes ( string string ) { matcher matcher = noncodes . matcher ( string ) ; stringbuffer buf = new stringbuffer ( ) ; int idx = _num ; while ( matcher . find ( idx ) ) { int start = matcher . start ( ) ; buf . append ( string . substring ( idx , start ) ) ; buf . append ( _str ) ; idx = start + _num ; } buf . append ( string . substring ( idx ) ) ; return buf . tostring ( ) ; }	encode ' % ' if it is not an encoding sequence.
public void forceleader ( int timeout ) { long start = system . currenttimemillis ( ) ; while ( ! cmember . isleader ( ) ) { try { cmember . forceleader ( ) ; if ( timeout >= _num && system . currenttimemillis ( ) - start > timeout ) { break ; } thread . sleep ( _num ) ; } catch ( exception e ) { logger . error ( e . getmessage ( ) , e ) ; } } }	forces the local member of this shard to become the leader.
private synchronized void syncusers ( ) { try { users . clear ( ) ; users . addall ( provider . loadusers ( ) ) ; } catch ( final couldntloaddataexception exception ) { cutilityfunctions . logexception ( exception ) ; } }	synchronizes the internal list of known users with the list of known users in the database .
public geometryfunction find ( string name , int argcount ) { for ( iterator i = functions . iterator ( ) ; i . hasnext ( ) ; ) { geometryfunction func = ( geometryfunction ) i . next ( ) ; string funcname = func . getname ( ) ; if ( funcname . equalsignorecase ( name ) && func . getparametertypes ( ) . length == argcount ) return func ; } return null ; }	finds the first function which matches the given name and argument count .
@ override public string tostring ( ) { stringbuffer text = new stringbuffer ( ) ; if ( m_traininstances == null ) { text . append ( _str ) ; } else { text . append ( _str ) ; text . append ( _str ) ; if ( m_evalusingtrainingdata ) { text . append ( _str ) ; } else { text . append ( _str + getfolds ( ) + _str + _str ) ; } text . append ( _str + getminimumbucketsize ( ) ) ; } text . append ( _str ) ; return text . tostring ( ) ; }	return a description of the evaluator.
public inputtab ( imessageeditorcontroller controller , boolean editable ) { this . editable = editable ; guicontainer = new jtabbedpane ( ) ; sourceviewer = new uisourceviewer ( ) ; sourceviewer . setlistener ( listeners ) ; guicontainer . addtab ( _str , sourceviewer ) ; raweditor = new uiraweditor ( callbacks , editable ) ; raweditor . setlistener ( listeners ) ; guicontainer . addtab ( samlparamtername , raweditor . getcomponent ( ) ) ; samlattacker = new uisamlattacker ( ) ; samlattacker . setlisteners ( listeners ) ; guicontainer . addtab ( _str , samlattacker ) ; }	implementing the imessageeditortab . class with the ui components and the businesses logic .
private void markerwithcoloredicon ( googlemap googlemap , latlng latlng , string publicid , string hexcolor ) { markeroptions options = new markeroptions ( ) ; options . position ( latlng ) ; int color = color . parsecolor ( hexcolor ) ; float [ ] hsv = new float [ _num ] ; color . colortohsv ( color , hsv ) ; float hue = hsv [ _num ] ; options . icon ( bitmapdescriptorfactory . defaultmarker ( hue ) ) ; marker marker = googlemap . addmarker ( options ) ; publicmarkerids . put ( marker . getid ( ) , publicid ) ; }	places a colored default marker on the map at the required position .
public void run ( ) { string line ; try { while ( isconnectionopen ) { line = in . readline ( ) ; if ( line == null ) break ; processline ( line ) ; } } catch ( ioexception e ) { } finally { try { close ( ) ; } catch ( ioexception e2 ) { } } debug . message ( _str , _str ) ; }	the running thread simply reads all the lines of input and hands each line off to be parsed .
public static void signalcacheclose ( ) { iscacheclosing = _bool ; if ( proctor != null ) { proctor . interrupt ( ) ; } if ( watchdog != null ) { watchdog . interrupt ( ) ; } }	should be invoked when gemfire cache is closing or closed .
public synchronized int readfromfile ( jdbcsequentialfile file , bytebuffer bytes ) throws sqlexception { connection . setautocommit ( _bool ) ; readlargeobject . setint ( _num , file . getid ( ) ) ; int readlength = _num ; try ( resultset rs = readlargeobject . executequery ( ) ) { if ( rs . next ( ) ) { blob blob = rs . getblob ( _num ) ; readlength = ( int ) calculatereadlength ( blob . length ( ) , bytes . remaining ( ) , file . position ( ) ) ; byte [ ] data = blob . getbytes ( file . position ( ) + _num , readlength ) ; bytes . put ( data ) ; } connection . commit ( ) ; return readlength ; } catch ( throwable e ) { connection . rollback ( ) ; throw e ; } }	reads data from the file ( at file.
public static string [ ] splitstring ( string source , char delimeter ) { string [ ] resultarray = null ; int delimeterindex = source . indexof ( delimeter ) ; if ( delimeterindex < _num ) { resultarray = new string [ _num ] ; resultarray [ _num ] = source ; } else { string firststr = source . substring ( _num , delimeterindex ) ; string secondstr = source . substring ( delimeterindex + _num ) ; resultarray = new string [ _num ] ; resultarray [ _num ] = firststr ; resultarray [ _num ] = secondstr ; } return resultarray ; }	returns pair of string objects ( packed in as string array ) that are deparated by one delimeter character in passed source string object.
public static char tocharvalue ( string str ) throws pageexception { if ( str . length ( ) > _num ) return str . charat ( _num ) ; throw new expressionexception ( _str ) ; }	cast a object to a char value ( primitive value type ).
public columnentry ( int col , column column , columnmetadata metadata ) { this . colnum = col ; this . column = column ; this . metadata = metadata ; this . index = null ; }	create a new columnentry .
public static map parseadvicesxml ( string advicesxml ) throws policyexception { if ( debug . messageenabled ( ) ) { debug . message ( _str + _str + advicesxml ) ; } map advices = null ; if ( advicesxml != null ) { document document = xmlutils . todomdocument ( advicesxml , debug ) ; if ( document != null ) { node advicesnode = xmlutils . getrootnode ( document , advices_tag_name ) ; if ( advicesnode != null ) { advices = xmlutils . parseattributevaluepairtags ( advicesnode ) ; } else { if ( debug . messageenabled ( ) ) { debug . message ( _str + _str ) ; } } } else { if ( debug . messageenabled ( ) ) { debug . message ( _str + _str ) ; } } } if ( debug . messageenabled ( ) ) { debug . message ( _str + _str + advices ) ; } return advices ; }	parses an xml string representation of policy advices and returns a map of advices.
private void addunbuffered ( t elem ) { unbufferedelements . add ( elem ) ; if ( unbufferedelements . size ( ) == buffersize ) { collections . sort ( unbufferedelements , comparefn ) ; buffers . add ( new quantilebuffer < t > ( unbufferedelements ) ) ; unbufferedelements = lists . newarraylistwithcapacity ( buffersize ) ; collapseifneeded ( ) ; } }	add a new buffer to the unbuffered list , creating a new buffer and collapsing if needed .
public void addmoredatas ( list < m > datas ) { if ( datas != null ) { mdatas . addall ( mdatas . size ( ) , datas ) ; notifyitemrangeinserted ( mdatas . size ( ) , datas . size ( ) ) ; } }	insert data to datas footer ( example weibo loadmore same newly data ).
public static vec2d fromradians2 ( double angleinrad , double magnitude ) { double x = magnitude * math . sin ( angleinrad ) ; double y = magnitude * math . cos ( angleinrad ) ; return new vec2d ( x , y ) ; }	create a 2d vector from an angle relative to the positive y - axis and a magnitude.
public static document todomdocument ( inputstream is , debug debug ) { documentbuilder documentbuilder = null ; try { documentbuilder = getsafedocumentbuilder ( validating ) ; } catch ( parserconfigurationexception pe ) { if ( debug != null ) { debug . error ( _str , pe ) ; } } try { if ( documentbuilder == null ) { if ( debug != null ) { debug . error ( _str ) ; } return null ; } if ( debug != null && debug . warningenabled ( ) ) { documentbuilder . seterrorhandler ( new validationerrorhandler ( debug ) ) ; } return documentbuilder . parse ( is ) ; } catch ( exception e ) { if ( debug != null && debug . warningenabled ( ) ) { debug . warning ( _str , e ) ; } return null ; } }	converts the xml document from an input stream to dom document format .
public int prune ( double [ ] alphas , double [ ] errors , instances test ) throws exception { vector < lmtnode > nodelist ; comparenode comparator = new comparenode ( ) ; treeerrors ( ) ; calculatealphas ( ) ; nodelist = getnodes ( ) ; boolean prune = ( nodelist . size ( ) > _num ) ; alphas [ _num ] = _num ; evaluation eval ; if ( errors != null ) { eval = new evaluation ( test ) ; eval . evaluatemodel ( this , test ) ; errors [ _num ] = eval . errorrate ( ) ; } int iteration = _num ; while ( prune ) { iteration ++ ; lmtnode nodetoprune = collections . min ( nodelist , comparator ) ; nodetoprune . m_isleaf = _bool ; alphas [ iteration ] = nodetoprune . m_alpha ; if ( errors != null ) { eval = new evaluation ( test ) ; eval . evaluatemodel ( this , test ) ; errors [ iteration ] = eval . errorrate ( ) ; } treeerrors ( ) ; calculatealphas ( ) ; nodelist = getnodes ( ) ; prune = ( nodelist . size ( ) > _num ) ; } alphas [ iteration + _num ] = _num ; return iteration ; }	method for performing one fold in the cross - validation of the cost - complexity parameter.
public static < a > list < a > filter ( list < a > l , a elem ) { assert . checknonnull ( elem ) ; list < a > res = list . nil ( ) ; for ( a a : l ) { if ( a != null && ! a . equals ( elem ) ) { res = res . prepend ( a ) ; } } return res . reverse ( ) ; }	returns the list obtained from ' l ' after removing all elements ' elem '.
private void reloadcachewithnewvalue ( final long newvalue ) { final long newvalueasprimitive = newvalue == null ? getcacheupdateperiod ( ) : newvalue ; log . debug ( _str , cacheupdateperiodlisteners . size ( ) ) ; for ( final propertychangelistener listener : cacheupdateperiodlisteners ) { final propertychangeevent event = new propertychangeevent ( this , _str , getcacheupdateperiod ( ) , newvalueasprimitive ) ; listener . propertychange ( event ) ; } }	notify all listeners about cacheperiod property changed.
public lucene50storedfieldsformat ( mode mode ) { this . mode = objects . requirenonnull ( mode ) ; }	stored fields format with specified mode.
private void resetredo ( string name , tungstenproperties serviceprops , map < string , string > progress ) { string clusterhome ; try { clusterhome = clusterconfiguration . getclusterhome ( ) ; } catch ( configurationexception e ) { logger . error ( _str , e ) ; return ; } string vmrrcontrolscriptname = _str + name ; file vmrrcontrolscript = new file ( clusterhome , vmrrcontrolscriptname ) ; if ( vmrrcontrolscript . canexecute ( ) ) { logger . info ( _str + vmrrcontrolscript . getabsolutepath ( ) ) ; try { redoreadermanager vmrrmgr = new redoreadermanager ( ) ; vmrrmgr . setvmrrcontrolscript ( vmrrcontrolscript . getabsolutepath ( ) ) ; vmrrmgr . setreplicateapplyname ( name ) ; vmrrmgr . initialize ( ) ; vmrrmgr . reset ( _str ) ; } catch ( replicatorexception e ) { logger . error ( _str + e . getmessage ( ) , e ) ; } } }	resets the redo reader if it exists.
public boolean verify ( ) throws nosuchalgorithmexception , nosuchproviderexception , invalidkeyexception , signatureexception { return verify ( bouncycastleprovider . provider_name ) ; }	verify the request using the bc provider .
public static x509crl loadcrl ( final inputstream inputstream ) { try { final x509crl crl = ( x509crl ) certificatefactory . generatecrl ( inputstream ) ; return crl ; } catch ( crlexception e ) { throw new dssexception ( e ) ; } }	this method loads a crl from the given location .
private boolean copymastercctoslave ( consistencycheck cc , string schema , string table , database slavedb ) throws sqlexception , consistencyexception { table tableslave = slavedb . findtable ( schema , table , _bool ) ; consistencycheck ccslave = consistencycheckfactory . createconsistencycheck ( cc . getcheckid ( ) , tableslave , cc . getrowoffset ( ) , cc . getrowlimit ( ) , getmethod ( ) , _bool , _bool ) ; string query = string . format ( _str , consistencytable . mastercrccolumnname , consistencytable . mastercntcolumnname , serviceschema , consistencytable . table_name , consistencytable . idcolumnname , cc . getcheckid ( ) ) ; statement st = null ; resultset rs = null ; try { st = masterdbuser . createstatement ( ) ; rs = st . executequery ( query ) ; if ( rs . next ( ) ) { string mastercrc = rs . getstring ( consistencytable . mastercrccolumnname ) ; int mastercnt = rs . getint ( consistencytable . mastercntcolumnname ) ; slavedb . consistencycheck ( consistencytable , ccslave , mastercrc , mastercnt ) ; return _bool ; } else { return _bool ; } } finally { if ( rs != null ) { try { rs . close ( ) ; } catch ( sqlexception e ) { } } if ( st != null ) { try { st . close ( ) ; } catch ( sqlexception e ) { } } } }	reads result of the specified consistency check from the master and copies it over to the slave ( manually , without replication ) .
private boolean ismergepoint ( n target ) { if ( icfg . isstartpoint ( target ) ) return _bool ; list < n > preds = icfg . getpredsof ( target ) ; int size = preds . size ( ) ; if ( size > _num ) return _bool ; if ( size > _num ) for ( n pred : preds ) if ( icfg . iscallstmt ( pred ) ) return _bool ; return _bool ; }	gets whether the given unit is a merge point in the icfg.
jcexpression transformclassparametertype ( parameter parameter ) { functionorvalue decl = parameter . getmodel ( ) ; if ( ! ( decl . getcontainer ( ) instanceof class ) ) { throw new bugexception ( _str ) ; } jcexpression type ; functionorvalue attr = decl ; if ( ! decl . istransient ( attr ) ) { typedreference typedref = gettypedreference ( attr ) ; typedreference nonwideningtypedref = nonwideningtypedecl ( typedref ) ; type paramtype = nonwideningtype ( typedref , nonwideningtypedref ) ; type = makejavatype ( nonwideningtypedref . getdeclaration ( ) , paramtype , _num ) ; } else { type paramtype = decl . gettype ( ) ; type = makejavatype ( decl , paramtype , _num ) ; } return type ; }	transforms the type of the given class parameter.
public void updateflowgraphsettings ( final zygraphviewsettings settings ) { updategraphsettings ( flowgraphsettings , settings ) ; }	updates the default flow graph settings in the configuration file from graph settings .
public static boolean ismobilenum ( string mobiles ) { pattern p = pattern . compile ( _str ) ; matcher m = p . matcher ( mobiles ) ; return m . matches ( ) ; }	check whether mobile num is legal in mainland china.
private static void assertqualname ( string qualname ) throws xmpexception { if ( qualname == null || qualname . length ( ) == _num ) { throw new xmpexception ( _str , xmperror . badxpath ) ; } }	parameterasserts that a qualifier name is set .
public void kill ( string pid ) { send ( string . format ( imageserverdialogproperties . getstring ( _str ) , pid ) ) ; try { thread . sleep ( _num ) ; } catch ( interruptedexception e ) { } }	kill process by pid .
public static map < graphnode , point2d > translatenodes ( collection < graphnode > movenodes , map < graphnode , point2d > positions , translater translater ) { map < graphnode , point2d > result = maps . newhashmapwithexpectedsize ( movenodes . size ( ) ) ; for ( graphnode node : movenodes ) { point2d location = translatenode ( node , positions , translater ) ; if ( null == location ) { continue ; } result . put ( node , translater . translate ( location ) ) ; } return result ; }	compute positions of movenodes using the supplied translator.
public static color hex2rgb ( string colourstr ) { return new color ( integer . valueof ( colourstr . substring ( _num , _num ) , _num ) , integer . valueof ( colourstr . substring ( _num , _num ) , _num ) , integer . valueof ( colourstr . substring ( _num , _num ) , _num ) ) ; }	convert colour encoded as hex to rgb .
public dviewcertificatefingerprint ( jframe parent , byte [ ] encodedcertificate , digesttype fingerprintalg ) { super ( parent , dialog . modalitytype . document_modal ) ; this . encodedcertificate = encodedcertificate ; this . fingerprintalg = fingerprintalg ; initcomponents ( ) ; }	creates a new dviewcertificatefingerprint dialog .
private static ipcendpoint connecttcpendpoint ( string host , int port ) throws ignitecheckedexception { return new ipcclienttcpendpoint ( host , port ) ; }	connects loopback ipc endpoint .
public static byte [ ] slurp ( inputstream in ) throws ioexception { if ( in == null ) throw new nullpointerexception ( _str ) ; try { int nread ; byte [ ] buffer = new byte [ _num ] ; bytearrayoutputstream out = new bytearrayoutputstream ( ) ; while ( ( nread = in . read ( buffer , _num , buffer . length ) ) != - _num ) { out . write ( buffer , _num , nread ) ; } return out . tobytearray ( ) ; } finally { in . close ( ) ; } }	fully consume an inputstream into a byte array , and close the input .
public static indexreader maybewrapreader ( indexreader r ) throws ioexception { if ( rarely ( ) ) { r = wrapreader ( r ) ; } return r ; }	sometimes wrap the indexreader as slow , parallel or filter reader ( or combinations of that ).
public static saxparser newsaxparser ( string schemalanguage , boolean namespaceaware , boolean validating , file schema ) throws saxexception , parserconfigurationexception { schemafactory schemafactory = schemafactory . newinstance ( schemalanguage ) ; return newsaxparser ( namespaceaware , validating , schemafactory . newschema ( schema ) ) ; }	factory method to create a saxparser configured to validate according to a particular schema language and a file containing the schema to validate against .
public enumeration < option > listoptions ( ) { vector < option > newvector = new vector < option > ( _num ) ; newvector . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addall ( collections . list ( super . listoptions ( ) ) ) ; return newvector . elements ( ) ; }	returns an enumeration describing the available options .
public void stop ( ) { try { scheduledexecutorservice . shutdown ( ) ; scheduledexecutorservice . awaittermination ( termination_wait , timeunit . milliseconds ) ; } catch ( interruptedexception ignore ) { } }	stops the associated reporting service provided by the given implementation .
public void prependproperty ( string property , properties src ) { prependproperty ( property , src . getproperty ( property , _str ) ) ; }	prepend the given property into the current properties.
@ override public enumeration < option > listoptions ( ) { vector < option > newvector = new vector < option > ( _num ) ; newvector . addelement ( new option ( _str + _str + _str + _str , _str , _num , _str ) ) ; return newvector . elements ( ) ; }	returns an enumeration describing the available options .
void generatebarcodelogic ( string msg , int errorcorrectionlevel ) throws writerexception { int errorcorrectioncodewords = pdf417errorcorrection . geterrorcorrectioncodewordcount ( errorcorrectionlevel ) ; string highlevel = pdf417highlevelencoder . encodehighlevel ( msg , compaction ) ; int sourcecodewords = highlevel . length ( ) ; int [ ] dimension = determinedimensions ( sourcecodewords , errorcorrectioncodewords ) ; int cols = dimension [ _num ] ; int rows = dimension [ _num ] ; int pad = getnumberofpadcodewords ( sourcecodewords , errorcorrectioncodewords , cols , rows ) ; if ( sourcecodewords + errorcorrectioncodewords + _num > _num ) { throw new writerexception ( _str + msg . length ( ) + _str ) ; } int n = sourcecodewords + pad + _num ; stringbuilder sb = new stringbuilder ( n ) ; sb . append ( ( char ) n ) ; sb . append ( highlevel ) ; for ( int i = _num ; i < pad ; i ++ ) { sb . append ( ( char ) _num ) ; } string datacodewords = sb . tostring ( ) ; string ec = pdf417errorcorrection . generateerrorcorrection ( datacodewords , errorcorrectionlevel ) ; string fullcodewords = datacodewords + ec ; barcodematrix = new barcodematrix ( rows , cols ) ; encodelowlevel ( fullcodewords , cols , rows , errorcorrectionlevel , barcodematrix ) ; }	generates the barcode logic .
protected keyfactory ( keyfactoryspi keyfacspi , provider provider , string algorithm ) { this . spi = keyfacspi ; this . provider = provider ; this . algorithm = algorithm ; }	creates a keyfactory object .
public void rebuildclassifier ( int new_chain [ ] , instances d ) throws exception { }	rebuild - not yet implemented.
@ override public void drawseries ( canvas canvas , paint paint , list < float > points , xyseriesrenderer seriesrenderer , float yaxisvalue , int seriesindex , int startindex ) { int seriesnr = mdataset . getseriescount ( ) ; int length = points . size ( ) ; paint . setcolor ( seriesrenderer . getcolor ( ) ) ; paint . setstyle ( style . fill ) ; float halfdiffx = gethalfdiffx ( points , length , seriesnr ) ; int start = _num ; if ( startindex > _num ) { start = _num ; } for ( int i = start ; i < length ; i += _num ) { if ( points . size ( ) > i + _num ) { float xmin = points . get ( i ) ; float ymin = points . get ( i + _num ) ; float xmax = points . get ( i + _num ) ; float ymax = points . get ( i + _num ) ; drawbar ( canvas , xmin , ymin , xmax , ymax , halfdiffx , seriesnr , seriesindex , paint ) ; } } paint . setcolor ( seriesrenderer . getcolor ( ) ) ; }	the graphical representation of a series .
public static void sendemail ( context context , final string receiver , final string subject , final string text ) { sendemail ( context , new string [ ] { receiver } , subject , text , null , null , null ) ; }	starts email intent with filled by given receiver , subject and text.
public string value ( int arrindex ) throws exception { int index = locateindex ( arrindex ) ; if ( index >= _num && ( m_indices . get ( index ) == arrindex ) ) { return m_values . get ( index ) ; } else { return _str ; } }	gets the value at index from the array .
private void updatesystemicon ( ) { window window = getwindow ( ) ; if ( window == null ) { systemicon = null ; return ; } java . util . list < image > icons = window . geticonimages ( ) ; assert icons != null ; if ( icons . size ( ) == _num ) { systemicon = null ; } else if ( icons . size ( ) == _num ) { systemicon = icons . get ( _num ) ; } else { systemicon = suntoolkit . getscalediconimage ( icons , image_width , image_height ) ; } }	update the image used for the system icon.
public abstract void sendmessage ( string message ) ;	used to send a message to the send - point we may want to do this - as a reply to an incoming request - at certain intervals - when certain criteria are met ( e.
public static sentence newconjunction ( sentence ... conjuncts ) { return newconjunction ( arrays . aslist ( conjuncts ) ) ; }	create a conjunction of conjuncts .
public final synchronized void shutdownengine ( ) { if ( uciengine != null ) { enginemonitor . interrupt ( ) ; enginemonitor = null ; uciengine . shutdown ( ) ; uciengine = null ; } enginestate . setstate ( mainstate . dead ) ; }	stop the engine process .
public static void shutdownforcely ( int status ) throws exception { class z = class . forname ( _str ) ; method exit = z . getdeclaredmethod ( _str , int . class ) ; exit . setaccessible ( _bool ) ; exit . invoke ( z , status ) ; }	in order to fight against the permission manager by minecraft forge .
public boolean hasbadge ( @ idres final int itemid ) { return map . contains ( itemid ) ; }	returns if the menu item will require a badge.
private static string normalizedurl ( string host , int port , string path ) { if ( path == null || path . length ( ) == _num ) { path = _str ; } return _str + host + _str + port + path ; }	create a url out of the given parameters , translate an empty / null path to ' / '.
private void reset ( ) { mtransmittedconstellations . clear ( ) ; mnewpaths . clear ( ) ; mpathmetrics . reset ( ) ; msurvivorpaths . clear ( ) ; msurvivorpaths . add ( new path ( new node ( _num , tribit . t0 , con . c0 ) ) ) ; }	resets the decoder before decoding a new data packet .
@ override public void accepttestset ( testsetevent e ) { if ( m_trainingset != null ) { try { if ( m_state == idle ) { synchronized ( this ) { m_state = clustering ; } m_testingset = e . gettestset ( ) ; if ( m_trainingset . equalheaders ( m_testingset ) ) { batchclustererevent ce = new batchclustererevent ( this , m_clusterer , new datasetevent ( this , e . gettestset ( ) ) , e . getsetnumber ( ) , e . getmaxsetnumber ( ) , _num ) ; notifybatchclustererlisteners ( ce ) ; } m_state = idle ; } } catch ( exception ex ) { stop ( ) ; if ( m_log != null ) { m_log . statusmessage ( statusmessageprefix ( ) + _str ) ; m_log . logmessage ( _str + statusmessageprefix ( ) + _str + ex . getmessage ( ) ) ; } ex . printstacktrace ( ) ; } } }	accepts a test set for a batch trained clusterer.
private static pair < byte [ ] , byte [ ] > createnamesforreverseprefixscan ( @ nonnull byte [ ] name ) { preconditions . checknotnull ( name , _str ) ; preconditions . checkargument ( name . length <= cell . max_name_length , _str ) ; if ( name . length == _num ) { return pair . create ( name , name ) ; } byte [ ] startname = new byte [ cell . max_name_length ] ; system . arraycopy ( name , _num , startname , _num , name . length ) ; for ( int i = name . length ; i < startname . length ; i ++ ) { startname [ i ] = ( byte ) _num ; } byte [ ] endname = rangerequests . previouslexicographicname ( name ) ; return pair . create ( startname , endname ) ; }	this will return a start and end row that will exactly contain all rows for this prefix in reverse . < p > start will be on the left hand side and will be greater lexicographically.
public static _fields findbythriftid ( int fieldid ) { switch ( fieldid ) { case _num : return thing ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
public void testclearbitpositiveoutside1 ( ) { byte abytes [ ] = { _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num } ; int asign = _num ; int number = _num ; byte rbytes [ ] = { _num , - _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger result = anumber . clearbit ( number ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	clearbit ( int n ) outside a positive number.
public void writedata ( dataoutput dout ) throws ioexception { dout . writeshort ( reference ) ; dout . writeshort ( bitcount ) ; }	writedata - copy the attribute values for this message to the output buffer .
string parsetoken ( boolean quoted ) throws jasperexception { stringbuilder stringbuffer = new stringbuilder ( ) ; skipspaces ( ) ; stringbuffer . setlength ( _num ) ; if ( ! hasmoreinput ( ) ) { return _str ; } int ch = peekchar ( ) ; if ( quoted ) { if ( ch == _str || ch == _str ) { char endquote = ch == _str ? _str : _str ; ch = nextchar ( ) ; for ( ch = nextchar ( ) ; ch != - _num && ch != endquote ; ch = nextchar ( ) ) { if ( ch == _str ) ch = nextchar ( ) ; stringbuffer . append ( ( char ) ch ) ; } if ( ch == - _num ) { err . jsperror ( mark ( ) , _str ) ; } } else { err . jsperror ( mark ( ) , _str ) ; } } else { if ( ! isdelimiter ( ) ) { do { ch = nextchar ( ) ; if ( ch == _str ) { if ( peekchar ( ) == _str || peekchar ( ) == _str || peekchar ( ) == _str || peekchar ( ) == _str ) ch = nextchar ( ) ; } stringbuffer . append ( ( char ) ch ) ; } while ( ! isdelimiter ( ) ) ; } } return stringbuffer . tostring ( ) ; }	parse a space delimited token.
protected final boolean parseline ( pattern pattern , int timestamp , int hostname , int comp , int pid , int msg , string line ) { final matcher matcher = pattern . matcher ( line ) ; if ( matcher . matches ( ) ) { try { final string msgtimestr = tostring ( matcher , timestamp ) ; final string source255chars = tostring ( matcher , hostname ) ; if ( source255chars . length ( ) > _num ) { m_source = source255chars . substring ( _num , _num ) ; if ( ! ishostnametruncationlogged ) { logger . info ( _str + source255chars + _str + _str + source255chars . length ( ) + _str + m_source . length ( ) + _str + m_source + _str ) ; ishostnametruncationlogged = _bool ; } } else { m_source = source255chars ; } m_source = m_source . tolowercase ( ) ; m_msgtime = todate ( m_source , msgtimestr ) ; m_component = tostring ( matcher , comp ) ; m_pid = tostring ( matcher , pid ) ; m_text = tostring ( matcher , msg ) ; return _bool ; } catch ( illegalargumentexception e ) { e . printstacktrace ( ) ; return _bool ; } } return _bool ; }	parses a line based on a regex pattern.
public static < a > listtvalue < a > fromstream ( final anymvalue < ? extends stream < a > > monads ) { return of ( monads . map ( null ) ) ; }	create a listt from an anym that wraps a monad containing a stream.
public namedicon ( url purl , string pname ) { this ( purl . tostring ( ) , pname ) ; }	create a named icon that includes an image to be loaded from a url .
final bytebuffer [ ] map ( string resourcedescription , filechannel fc , long offset , long length ) throws ioexception { if ( ( length > > > chunksizepower ) >= integer . max_value ) throw new illegalargumentexception ( _str + resourcedescription ) ; final long chunksize = _num << chunksizepower ; final int nrbuffers = ( int ) ( length > > > chunksizepower ) + _num ; bytebuffer buffers [ ] = new bytebuffer [ nrbuffers ] ; long bufferstart = _num ; for ( int bufnr = _num ; bufnr < nrbuffers ; bufnr ++ ) { int bufsize = ( int ) ( ( length > ( bufferstart + chunksize ) ) ? chunksize : ( length - bufferstart ) ) ; mappedbytebuffer buffer ; try { buffer = fc . map ( mapmode . read_only , offset + bufferstart , bufsize ) ; } catch ( ioexception ioe ) { throw convertmapfailedioexception ( ioe , resourcedescription , bufsize ) ; } if ( preload ) { buffer . load ( ) ; } buffers [ bufnr ] = buffer ; bufferstart += bufsize ; } return buffers ; }	maps a file into a set of buffers.
@ override public long skip ( long n ) throws ioexception { return finputstream . skip ( n ) ; }	skip characters . this method will block until some characters are available , an i / o error occurs , or the end of the stream is reached .
public static int encodelatitudeceil ( double latitude ) { geoutils . checklatitude ( latitude ) ; if ( latitude == _num ) { latitude = math . nextdown ( latitude ) ; } return ( int ) math . ceil ( latitude / lat_decode ) ; }	quantizes double ( 64 bit ) latitude into 32 bits ( rounding up : in the direction of + 90 ).
protected storagepool checkpoolexistsindb ( string nativeguid ) throws ioexception { storagepool pool = null ; list < storagepool > poolindb = customqueryutility . getactivestoragepoolbynativeguid ( _dbclient , nativeguid ) ; if ( poolindb != null && ! poolindb . isempty ( ) ) { pool = poolindb . get ( _num ) ; } return pool ; }	check if pool exists in db .
protected void drawhtmltext ( string text , int x , int y , int w , int h , map < string , object > style ) { mxlighweightlabel textrenderer = mxlighweightlabel . getsharedinstance ( ) ; if ( textrenderer != null && rendererpane != null ) { boolean horizontal = mxutils . istrue ( style , mxconstants . style_horizontal , _bool ) ; if ( g . hitclip ( x , y , w , h ) ) { affinetransform at = g . gettransform ( ) ; if ( ! horizontal ) { g . rotate ( - math . pi / _num , x + w / _num , y + h / _num ) ; g . translate ( w / _num - h / _num , h / _num - w / _num ) ; int tmp = w ; w = h ; h = tmp ; } textrenderer . settext ( mxutils . createhtmldocument ( style , text ) ) ; g . scale ( scale , scale ) ; rendererpane . paintcomponent ( g , textrenderer , rendererpane , ( int ) ( x / scale ) + mxconstants . label_inset , ( int ) ( y / scale ) + mxconstants . label_inset , ( int ) ( w / scale ) , ( int ) ( h / scale ) , _bool ) ; g . settransform ( at ) ; } } }	draws the specified html markup .
public void testnegnegfirstlonger ( ) { byte abytes [ ] = { - _num , _num , _num , _num , - _num , - _num , _num , _num , _num , _num , - _num , _num , _num , - _num , _num , _num , - _num , - _num } ; byte bbytes [ ] = { - _num , - _num , - _num , - _num , _num , _num , _num , _num , _num , _num , _num , _num , _num , _num } ; int asign = - _num ; int bsign = - _num ; byte rbytes [ ] = { - _num , _num , - _num , - _num , - _num , _num , _num , _num , _num , - _num , - _num , _num , - _num , - _num , _num , - _num , - _num , _num , _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . and ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , - _num , result . signum ( ) ) ; }	and for two negative numbers ; the first is longer.
private int numcodedunits ( channel chan ) { chan . fillmode = br . read ( _num ) ; if ( chan . fillmode == _num ) { chan . numcodedvals = ctx . numquantunits ; } else { chan . numcodedvals = br . read ( _num ) ; if ( chan . numcodedvals > ctx . numquantunits ) { log . error ( string . format ( _str ) ) ; return at3p_error ; } if ( chan . fillmode == _num ) { chan . splitpoint = br . read ( _num ) + ( chan . chnum << _num ) + _num ; } } return _num ; }	decode number of coded quantization units .
public defineddefaultbehaviorprovider ( string ... values ) { if ( values == null || values . length == _num ) { throw new illegalargumentexception ( _str ) ; } this . values = arrays . aslist ( values ) ; }	create a new defined default behavior provider associated with the specified list of values .
public static list < integer > createcolors ( resources r , int [ ] colors ) { list < integer > result = new arraylist < > ( ) ; for ( int i : colors ) { result . add ( r . getcolor ( i ) ) ; } return result ; }	turn an array of resource - colors ( contains resource - id integers ) into an array list of actual color integers.
public static long subaddresstolong ( final string subaddress ) { preconditions . checknotnull ( subaddress , _str ) ; if ( subaddress . contains ( _str ) ) { final string [ ] parts = subaddress . split ( _str ) ; preconditions . checkargument ( parts . length == _num , _str ) ; final long firstpart = long . parselong ( parts [ _num ] ) ; final long secondpart = long . parselong ( parts [ _num ] ) ; return ( firstpart * _num ) + secondpart ; } else { throw new illegalargumentexception ( _str ) ; } }	converts a string that contains a subaddress into a long value with the same offset as the string.
public list < page > relevantpages ( string query ) { list < page > relevantpages = new arraylist < page > ( ) ; for ( page p : ptable . values ( ) ) { if ( matches ( query , p . getcontent ( ) ) ) { relevantpages . add ( p ) ; } } return relevantpages ; }	fetches and returns all pages that match the query.
public static string comparablequalifier ( string qualifier ) { int i = _qualifiers . indexof ( qualifier ) ; return i == - _num ? ( _qualifiers . size ( ) + _str + qualifier ) : string . valueof ( i ) ; }	returns a comparable value for a qualifier.
public void registersuccess ( string url ) { mdelayms = min_delay ; mlastrequestms = - _num ; int bonus = _num ; if ( textutils . equals ( murl , url ) ) { bonus = _num ; murl = null ; } mscore = math . min ( max_score , mscore + bonus ) ; sharedpreferences . editor editor = msharedpreferences . edit ( ) ; updateban ( editor ) ; editor . apply ( ) ; }	signals that an incoming intent matched with a maylaunchurl ( ) call.
@ visiblefortesting protected state buildpatch ( taskstate . taskstage stage , taskstate . substage substage ) { return buildpatch ( stage , substage , ( throwable ) null ) ; }	this method builds a patch state object which can be used to submit a self - patch .
private void writeobject ( java . io . objectoutputstream s ) throws java . io . ioexception { s . defaultwriteobject ( ) ; s . writeint ( values . size ( ) ) ; for ( int i = _num ; i < values . size ( ) ; i ++ ) { s . writeobject ( values . elementat ( i ) ) ; } }	overridden to avoid exposing implementation details.
public boolean remove ( object o ) { final reentrantlock lock = this . lock ; lock . lock ( ) ; try { return q . remove ( o ) ; } finally { lock . unlock ( ) ; } }	removes a single instance of the specified element from this queue , if it is present , whether or not it has expired .
public void sendaddentity ( entity entity ) { arraylist < entity > entities = new arraylist < entity > ( _num ) ; entities . add ( entity ) ; sendaddentity ( entities ) ; }	sends an " add entity " packet with only one entity .
public void readbytes ( int position , int num , byte [ ] buf ) { if ( page . pagesize < position + num ) { throw new pageexception ( _str ) ; } if ( buf . length < num ) { throw new pageexception ( _str ) ; } pagedata . position ( position ) ; pagedata . get ( buf , _num , num ) ; }	reads num bytes from offset position into buf .
public seq < c > takewhile ( predicate < c > condition ) { objects . requirenonnull ( condition ) ; itr itr = new itr ( ) ; mutableseq < c > seq = seqs . newmutableseq ( ) ; while ( itr . hasnext ( ) ) { c candidate = itr . next ( ) ; if ( ! condition . test ( candidate ) ) { break ; } seq . appendinplace ( candidate ) ; } return seq ; }	get elements at the front of this range which satisfy the condition .
@ override public void writeenddocument ( ) throws xmlstreamexception { log . log ( level . fine , _str ) ; while ( current . getelement ( ) != null ) { writeendelement ( ) ; } try { wbxmlencoder encoder = new wbxmlencoder ( stream , doc , encodertype ) ; encoder . encode ( ) ; encoded = _bool ; } catch ( ioexception e ) { throw new xmlstreamexception ( _str , e ) ; } }	closes any start tags and writes corresponding end tags.
public static void write ( omline line , link link , linkproperties props ) throws ioexception { switch ( line . getrendertype ( ) ) { case omline . rendertype_latlon : double [ ] ll = line . getll ( ) ; linkline . write ( ( float ) ll [ _num ] , ( float ) ll [ _num ] , ( float ) ll [ _num ] , ( float ) ll [ _num ] , line . getlinetype ( ) , line . getnumsegs ( ) , props , link . dos ) ; break ; case omline . rendertype_xy : int [ ] pts = line . getpts ( ) ; linkline . write ( pts [ _num ] , pts [ _num ] , pts [ _num ] , pts [ _num ] , props , link . dos ) ; break ; case omline . rendertype_offset : ll = line . getll ( ) ; pts = line . getpts ( ) ; linkline . write ( ( float ) ll [ _num ] , ( float ) ll [ _num ] , pts [ _num ] , pts [ _num ] , pts [ _num ] , pts [ _num ] , props , link . dos ) ; break ; default : debug . error ( _str ) ; } }	write an omline to the link .
public static void showasset ( frame frame , int windowno ) { info info = new infoasset ( frame , _bool , windowno , _num , _str , _bool , _bool , _str ) ; aenv . showcenterwindow ( frame , info ) ; }	show asset info ( non modal ).
public int max ( ) { if ( size ( ) == _num ) { throw new illegalstateexception ( _str ) ; } int max = _data [ _pos - _num ] ; for ( int i = _pos - _num ; i -- > _num ; ) { max = math . max ( max , _data [ _pos ] ) ; } return max ; }	finds the maximum value in the list .
public static string randomstring ( string sampler , int length ) { stringbuilder builder = new stringbuilder ( length ) ; for ( int i = _num ; i < length ; i ++ ) builder . append ( sampler . charat ( seeded_random . nextint ( sampler . length ( ) ) ) ) ; return builder . tostring ( ) ; }	create a string that is a random sample ( with replacement ) from the given string.
public void addim ( imentity im ) { ims . add ( im ) ; }	adds a new im to this user.
public static string escape ( string string ) { if ( string == null || string . equals ( _str ) ) { return string ; } string prefix = _str ; if ( string . indexof ( _str ) != - _num ) { prefix = string . substring ( _num , string . indexof ( _str ) + _num ) ; string = string . replacefirst ( prefix , _str ) ; } string = string . replaceall ( _str , _str ) ; if ( string . startswith ( _str ) ) { string = _str + string . replaceall ( _str , _str ) ; } else { string = string . replaceall ( _str , _str ) ; } return prefix . concat ( string ) ; }	escapes double slashes ( / / ) and replace all backslashes ( \ ) with slashes ( / ).
public servicecall < translationresult > translate ( final list < string > texts , final string modelid ) { validator . istrue ( ( modelid != null ) && ! modelid . isempty ( ) , _str ) ; return translaterequest ( texts , modelid , null , null ) ; }	translate multiple texts using a given model .
public void generate_snapshot ( ) { disable_redo ( ) ; collection < undoobjectnode > curr_deleted_objects_list = new linkedlist < undoobjectnode > ( ) ; deleted_objects_stack . add ( curr_deleted_objects_list ) ; ++ stack_level ; }	makes the current state of the list restorable by undo .
public static void printsummary ( printstream out ) { printsummary ( out , null ) ; printerrorsummary ( out ) ; }	print the statistics report to specified stream.
public static boolean curlandextractpackage ( string workingdirectory , string packageuri , string packagedestination , boolean isdeletepackage , boolean isverbose ) { log . log ( level . fine , _str , packageuri ) ; log . fine ( _str ) ; if ( ! shellutils . curlpackage ( packageuri , packagedestination , isverbose , _bool ) ) { log . severe ( _str ) ; return _bool ; } log . log ( level . fine , _str , packageuri ) ; if ( ! shellutils . extractpackage ( packagedestination , workingdirectory , isverbose , _bool ) ) { log . severe ( _str ) ; return _bool ; } if ( isdeletepackage && ! fileutils . deletefile ( packagedestination ) ) { log . warning ( _str + packagedestination ) ; } return _bool ; }	curl a package , extract it to working directory.
private string namewithouttaskid ( string objectname ) { int index = objectname . indexof ( _str + hadoop_attempt ) ; if ( index > _num ) { string attempt = objectname . substring ( objectname . lastindexof ( _str ) + _num ) ; try { taskattemptid . forname ( attempt ) ; return objectname . substring ( _num , index ) ; } catch ( illegalargumentexception e ) { return objectname ; } } return objectname ; }	accepts any object name.
public void addvariable ( variableinitializer v ) { assertnotnull ( v ) ; variables . add ( v ) ; v . setparent ( this ) ; }	adds a variable initializer node to the child list.
public static list < ? > clonelist ( list < ? > source ) { paramchecks . nullnotpermitted ( source , _str ) ; list result = new arraylist ( ) ; for ( object obj : source ) { if ( obj != null ) { try { result . add ( objectutilities . clone ( obj ) ) ; } catch ( clonenotsupportedexception ex ) { throw new runtimeexception ( ex ) ; } } else { result . add ( null ) ; } } return result ; }	returns a list containing cloned copies of the items in the source list .
public final list < string > executestringlistquery ( string sql ) throws adeexception { final list < string [ ] > temp = executestringlistquery2d ( sql ) ; final list < string > res = new arraylist < string > ( temp . size ( ) ) ; for ( int i = _num ; i < temp . size ( ) ; ++ i ) { final string [ ] row = temp . get ( i ) ; if ( row . length != _num ) { throw new adeinternalexception ( _str + ( i + _num ) + _str + sql + _str + row . length + _str ) ; } res . add ( row [ _num ] ) ; } return res ; }	executes a given query , that is expected to return a list of strings .
public static int testmonitor2snippet ( ) { integer x = new integer ( _num ) ; double y = new double ( _num ) ; object z = new object ( ) ; synchronized ( x ) { synchronized ( y ) { synchronized ( z ) { notinlineable ( ) ; return x . intvalue ( ) ; } } } }	this test case differs from the last one in that it requires inlining within a synchronized region .
@ rpcmethod public void transferimage ( string imageid , string source , string destination , serveraddress destinationhost , asyncmethodcallback < host . asyncclient . copy_image_call > handler ) throws rpcexception { ensureclient ( ) ; transferimagerequest transferimagerequest = new transferimagerequest ( ) ; transferimagerequest . setdestination_datastore_id ( destination ) ; transferimagerequest . setdestination_host ( destinationhost ) ; transferimagerequest . setsource_datastore_id ( source ) ; transferimagerequest . setsource_image_id ( imageid ) ; clientproxy . settimeout ( transfer_image_timeout_ms ) ; logger . info ( _str , gethostip ( ) , transferimagerequest ) ; try { clientproxy . transfer_image ( transferimagerequest , handler ) ; } catch ( texception e ) { throw new rpcexception ( e . getmessage ( ) ) ; } }	this method performs an asynchronous thrift call to copy an image from one host to another.
public static int parsergb ( fxgnode node , string value , string name ) { matcher m ; m = rgbpattern . matcher ( value ) ; if ( ! m . matches ( ) ) { throw new fxgexception ( node . getstartline ( ) , node . getstartcolumn ( ) , _str , name , value ) ; } value = value . substring ( _num ) ; int a = _num ; int r = integer . parseint ( value . substring ( _num , _num ) , _num ) & _num ; int g = integer . parseint ( value . substring ( _num , _num ) , _num ) & _num ; int b = integer . parseint ( value . substring ( _num , _num ) , _num ) & _num ; return ( a << _num ) | ( r << _num ) | ( g << _num ) | b ; }	convert an fxg hexadecimal color string to an int.
public boolean overpoint ( float lat , float lon ) { azimuthvar azvar = new azimuthvar ( ) ; point2d pt = _forward ( lat , lon , new point2d . float ( ) , azvar ) ; if ( azvar . invalid_forward ) { return _bool ; } if ( ( pt . getx ( ) < _num ) || ( pt . getx ( ) > width ) || ( pt . gety ( ) < _num ) || ( pt . gety ( ) > height ) ) { return _bool ; } return _bool ; }	checks if the point is visible on the screen .
public set < tableid > readalltablenames ( string [ ] tabletypes ) throws sqlexception { return readtablenames ( null , null , null , tabletypes ) ; }	get the identifiers of all available tables .
< t > t optional ( object obj , class < t > clazz , string part ) throws parseexception { if ( obj == null ) { return null ; } return expect ( obj , clazz , part ) ; }	abort with a parseexception if obj is not either null or of type clazz , returning obj otherwise .
@ override public void update ( graphics g ) { paint ( g ) ; }	updates the display area of the window .
private boolean serializecompactrdfattrprops ( xmpnode parentnode , int indent ) throws ioexception { boolean allareattrs = _bool ; for ( iterator it = parentnode . iteratechildren ( ) ; it . hasnext ( ) ; ) { xmpnode prop = ( xmpnode ) it . next ( ) ; if ( canberdfattrprop ( prop ) ) { writenewline ( ) ; writeindent ( indent ) ; write ( prop . getname ( ) ) ; write ( _str ) ; appendnodevalue ( prop . getvalue ( ) , _bool ) ; write ( _str ) ; } else { allareattrs = _bool ; } } return allareattrs ; }	write each of the parent ' s simple unqualified properties as an attribute.
public void processinvite ( requestevent requestevent , servertransaction servertransaction ) { sipprovider sipprovider = ( sipprovider ) requestevent . getsource ( ) ; request request = requestevent . getrequest ( ) ; try { servertransaction = sipprovider . getnewservertransaction ( request ) ; dialog = ( dialogext ) sipprovider . getnewdialog ( servertransaction ) ; dialog . disablesequencenumbervalidation ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } try { response okresponse = messagefactory . createresponse ( response . ok , request ) ; fromheader from = ( fromheader ) okresponse . getheader ( fromheader . name ) ; from . removeparameter ( _str ) ; address address = addressfactory . createaddress ( _str + myaddress + _str + myport + _str ) ; contactheader contactheader = headerfactory . createcontactheader ( address ) ; toheader toheader = ( toheader ) okresponse . getheader ( toheader . name ) ; toheader . settag ( _str ) ; fromheader fromheader = ( fromheader ) okresponse . getheader ( fromheader . name ) ; fromheader . settag ( _str ) ; okresponse . addheader ( contactheader ) ; servertransaction . sendresponse ( okresponse ) ; } catch ( exception ex ) { ex . printstacktrace ( ) ; system . exit ( _num ) ; } }	process the invite request .
private static pattern compilepattern ( final string s ) { stringbuilder rc = new stringbuilder ( ) ; for ( int i = _num ; i < s . length ( ) ; i ++ ) { char ch = s . charat ( i ) ; switch ( ch ) { case _str : rc . append ( _str ) ; break ; case _str : rc . append ( _str ) ; break ; case _str : rc . append ( _str ) ; default : rc . append ( ch ) ; } } return pattern . compile ( rc . tostring ( ) ) ; }	convert host pattern from glob format to regexp.
@ suppresswarnings ( _str ) public uniformgenerator ( vector < string > values ) { _values = ( vector < string > ) values . clone ( ) ; _laststring = null ; _gen = new uniformintegergenerator ( _num , values . size ( ) - _num ) ; }	creates a generator that will return strings from the specified set uniformly randomly.
public void testdirectsockets_exceptionifportnotopen ( ) throws ioexception { final inetsocketaddress serveraddr1 = new inetsocketaddress ( getport ( _num ) ) ; final inetsocketaddress serveraddr2 = new inetsocketaddress ( getport ( _num ) ) ; final serversocket ss1 = new serversocket ( ) ; try { ss1 . bind ( serveraddr1 ) ; asserttrue ( ss1 . getchannel ( ) == null ) ; try { accept ( ss1 ) ; fail ( _str ) ; } catch ( assertionfailederror afe ) { } final socketchannel cs1 = socketchannel . open ( ) ; try { final boolean immediate1 = cs1 . connect ( serveraddr1 ) ; if ( ! immediate1 ) { if ( ! cs1 . finishconnect ( ) ) { fail ( _str ) ; } } } finally { cs1 . close ( ) ; } final socketchannel cs2 = socketchannel . open ( ) ; try { cs1 . connect ( serveraddr2 ) ; fail ( _str + ioexception . class ) ; } catch ( ioexception ex ) { if ( log . isinfoenabled ( ) ) log . info ( _str + ex ) ; } finally { cs2 . close ( ) ; } try { accept ( ss1 ) ; fail ( _str ) ; } catch ( assertionfailederror afe ) { } } finally { ss1 . close ( ) ; } }	simple test of connecting to a server socket and the failure to connect to a port not associated with a server socket .
public void connected ( ) { synchronized ( this ) { if ( idlereconnectfuture != null ) idlereconnectfuture . cancel ( _bool ) ; scheduleidletask ( idletimeoutmsec . get ( ) , _bool ) ; } }	to be called when the connector has become connected .
public string escapeattributeentities ( string str ) { stringbuffer buffer ; char ch ; string entity ; buffer = null ; for ( int i = _num ; i < str . length ( ) ; i ++ ) { ch = str . charat ( i ) ; switch ( ch ) { case _str : entity = _str ; break ; case _str : entity = _str ; break ; case _str : entity = _str ; break ; case _str : entity = _str ; break ; case _str : entity = _str ; break ; case _str : entity = _str ; break ; case _str : entity = _str ; break ; default : entity = null ; break ; } if ( buffer == null ) { if ( entity != null ) { buffer = new stringbuffer ( str . length ( ) + _num ) ; buffer . append ( str . substring ( _num , i ) ) ; buffer . append ( entity ) ; } } else { if ( entity == null ) { buffer . append ( ch ) ; } else { buffer . append ( entity ) ; } } } return ( buffer == null ) ? str : buffer . tostring ( ) ; }	this will take the pre - defined entities in xml 1.
private void awaitall ( ) throws interruptedexception , executionexception { if ( buffer . isopen ( ) ) { throw new illegalstateexception ( ) ; } willshutdown ( ) ; while ( _bool ) { halted ( ) ; final e [ ] a ; lock . lockinterruptibly ( ) ; try { a = redirectqueue . poll ( ) ; if ( a == null ) { if ( finishedsubtaskqueue . isempty ( ) && sinks . isempty ( ) && redirectqueue . isempty ( ) && nothingpending ( ) ) { if ( log . isinfoenabled ( ) ) log . info ( _str + this ) ; return ; } if ( log . isdebugenabled ( ) ) log . debug ( _str + sinks . size ( ) + _str + this ) ; drainfutures ( ) ; if ( ! finishedsubtaskqueue . isempty ( ) ) { subtaskdone . await ( _num , timeunit . milliseconds ) ; } } } finally { lock . unlock ( ) ; } if ( a != null ) { handlechunk ( a , _bool ) ; } } }	await the completion of the writes on each index partition.
public void invoke ( object receiver , string methodname , string argument ) { util . throwifnull ( receiver , methodname , argument ) ; int size = invokers . size ( ) ; for ( int i = _num ; i < size ; ++ i ) { final typedmethodinvoker < ? > invoker = invokers . get ( i ) ; if ( invoker . invoke ( receiver , methodname , argument ) ) { return ; } } logutil . w ( _str + methodname + _str ) ; }	tries to invoke a method on receiver with a single argument by trying out different types for arg until it finds one that matches ( or not ).
public long size ( ) { return isnull ( ) ? _num : this . end - this . start + _num ; }	returns the size of this range ( the number of values within its bounds ) .
private void createpluginmanifest ( int i , string pfolderpath ) throws ioexception { filewriter out = new filewriter ( pfolderpath + file . separator + _str ) ; string xml = _str + _str + _str + i + _str + i + _str + _str + _str + _str + _str + _str + _str + _str + _str + _str + _str + _str ; out . write ( xml ) ; out . flush ( ) ; out . close ( ) ; }	creates an plugin manifest file.
static void b2ibig ( byte [ ] in , int inofs , int [ ] out , int outofs , int len ) { if ( ( inofs < _num ) || ( ( in . length - inofs ) < len ) || ( outofs < _num ) || ( ( out . length - outofs ) < len / _num ) ) { throw new arrayindexoutofboundsexception ( ) ; } if ( littleendianunaligned ) { inofs += bytearrayofs ; len += inofs ; while ( inofs < len ) { out [ outofs ++ ] = reversebytes ( unsafe . getint ( in , ( long ) inofs ) ) ; inofs += _num ; } } else if ( bigendian && ( ( inofs & _num ) == _num ) ) { inofs += bytearrayofs ; len += inofs ; while ( inofs < len ) { out [ outofs ++ ] = unsafe . getint ( in , ( long ) inofs ) ; inofs += _num ; } } else { len += inofs ; while ( inofs < len ) { out [ outofs ++ ] = ( ( in [ inofs + _num ] & _num ) ) | ( ( in [ inofs + _num ] & _num ) << _num ) | ( ( in [ inofs + _num ] & _num ) << _num ) | ( ( in [ inofs ] ) << _num ) ; inofs += _num ; } } }	byte [ ] to int [ ] conversion , big endian byte order .
private static jfreechart createchart ( ) { xyseries series1 = new xyseries ( _str ) ; series1 . add ( _num , _num ) ; series1 . add ( _num , _num ) ; series1 . add ( _num , _num ) ; xydataset dataset = new xyseriescollection ( series1 ) ; return chartfactory . createxyareachart ( _str , _str , _str , dataset ) ; }	create a chart for testing .
public void addintrapassorderingconstraint ( detectororderingconstraint constraint ) { intrapassconstraintlist . add ( constraint ) ; }	add an intra - pass detector ordering constraint .
public int connecttimeout ( ) { return reader . getinteger ( connect_timeout , default_connect_timeout ) ; }	the connect timeout in milliseconds .
public static duration parseduration ( string s ) { return dtfactory . newduration ( s ) ; }	parses the supplied xsd : duration value string and returns its value .
public static boolean islowercase ( final string value ) { validate ( value , null_string_predicate , null_string_msg_supplier ) ; for ( int i = _num ; i < value . length ( ) ; i ++ ) { if ( character . isuppercase ( value . charat ( i ) ) ) { return _bool ; } } return _bool ; }	verifies if string is lower case.
private void scorewaypointresults ( collection < waypoint > waypoints , searchquery query , collection < scoredresult > output ) { for ( waypoint waypoint : waypoints ) { double score = scorewaypointresult ( query , waypoint ) ; output . add ( new scoredresult ( waypoint , score ) ) ; } }	scores a collection of waypoint results .
public dgeneratekeypair ( jframe parent , keystoretype keystoretype , keypairtype keypairtype , int keypairsize ) { super ( parent , res . getstring ( _str ) , dialog . modalitytype . document_modal ) ; this . keypairtype = keypairtype ; this . keypairsize = keypairsize ; this . keystoretype = keystoretype ; initcomponents ( ) ; }	creates a new dgeneratekeypair dialog .
public updateinfo ( string featureid ) { this . featureid = featureid ; }	constructs an object to hold update information for the given feature .
public boolean leaveszone ( final rectangle2d shape ) { final double x = shape . getx ( ) ; final double y = shape . gety ( ) ; final double w = shape . getwidth ( ) ; final double h = shape . getheight ( ) ; return ( x < _num ) || ( x + w > width ) || ( y < _num ) || ( y + h > height ) ; }	check if a rectangle is at least partially outside the map .
static int exclusivecount ( int c ) { return c & exclusive_mask ; }	returns the number of exclusive holds represented in count.
public static boolean isfinal ( final field field ) { return modifier . isfinal ( field . getmodifiers ( ) ) ; }	checks if is final .
public void invalidatecache ( int start , int end ) { m_valid . clear ( start , end + _num ) ; }	invalidate a range of the cache .
@ override public stateconnection service ( ) throws ioexception { try { connectionprotocol request = requestorcreate ( ) ; if ( request == null ) { log . warning ( _str + this ) ; return stateconnection . close ; } stateconnection next = request . service ( ) ; if ( next != stateconnection . close ) { return next ; } else { return oncloseread ( ) ; } } catch ( outofmemoryerror e ) { string msg = _str ; shutdownsystem . shutdownoutofmemory ( msg ) ; log . log ( level . warning , e . tostring ( ) , e ) ; } catch ( throwable e ) { e . printstacktrace ( ) ; log . log ( level . warning , e . tostring ( ) , e ) ; } return stateconnection . close ; }	service a http request .
public boolean isautoarchive ( ) { string aa = getautoarchive ( ) ; return aa != null && ! aa . equals ( autoarchive_none ) ; }	is auto archive on.
private static int numericcompaction ( int [ ] codewords , int codeindex , stringbuilder result ) throws formatexception { int count = _num ; boolean end = _bool ; int [ ] numericcodewords = new int [ max_numeric_codewords ] ; while ( codeindex < codewords [ _num ] && ! end ) { int code = codewords [ codeindex ++ ] ; if ( codeindex == codewords [ _num ] ) { end = _bool ; } if ( code < text_compaction_mode_latch ) { numericcodewords [ count ] = code ; count ++ ; } else { if ( code == text_compaction_mode_latch || code == byte_compaction_mode_latch || code == byte_compaction_mode_latch_6 || code == begin_macro_pdf417_control_block || code == begin_macro_pdf417_optional_field || code == macro_pdf417_terminator ) { codeindex -- ; end = _bool ; } } if ( count % max_numeric_codewords == _num || code == numeric_compaction_mode_latch || end ) { if ( count > _num ) { string s = decodebase900tobase10 ( numericcodewords , count ) ; result . append ( s ) ; count = _num ; } } } return codeindex ; }	numeric compaction mode ( see 5.
private void checkcompletion ( ) { for ( iterator < computetaskfuture < integer > > iter = futures . iterator ( ) ; iter . hasnext ( ) ; ) { computetaskfuture < integer > fut = iter . next ( ) ; if ( fut . isdone ( ) ) { try { integer res = fut . get ( ) ; assert res == params . getjobscount ( ) : _str + fut . gettasksession ( ) . getid ( ) + _str + res + _str ; ignite . log ( ) . info ( _str + fut . gettasksession ( ) . getid ( ) ) ; } catch ( ignitefuturecancelledexception ignored ) { ignite . log ( ) . info ( _str + fut . gettasksession ( ) . getid ( ) ) ; } catch ( igniteexception e ) { ignite . log ( ) . warning ( _str + fut . gettasksession ( ) . getid ( ) , e ) ; } finally { iter . remove ( ) ; } } } }	finds completed tasks in the queue and removes them .
public void dupx2 ( ) { mv . visitinsn ( opcodes . dup_x2 ) ; }	generates a dup_x2 instruction .
public changeset addalltocollection ( string path , serializable ... newitems ) { return addalltocollection ( path , arrays . aslist ( newitems ) ) ; }	adds the given items to a collection property.
public void addwindowdraglistener ( windowdraglistener listener ) { draglisteners . add ( listener ) ; }	add a window drag listener.
static automaton reverse ( automaton a , set < integer > initialstates ) { if ( operations . isempty ( a ) ) { return new automaton ( ) ; } int numstates = a . getnumstates ( ) ; automaton . builder builder = new automaton . builder ( ) ; builder . createstate ( ) ; for ( int s = _num ; s < numstates ; s ++ ) { builder . createstate ( ) ; } builder . setaccept ( _num , _bool ) ; transition t = new transition ( ) ; for ( int s = _num ; s < numstates ; s ++ ) { int numtransitions = a . getnumtransitions ( s ) ; a . inittransition ( s , t ) ; for ( int i = _num ; i < numtransitions ; i ++ ) { a . getnexttransition ( t ) ; builder . addtransition ( t . dest + _num , s + _num , t . min , t . max ) ; } } automaton result = builder . finish ( ) ; int s = _num ; bitset acceptstates = a . getacceptstates ( ) ; while ( s < numstates && ( s = acceptstates . nextsetbit ( s ) ) != - _num ) { result . addepsilon ( _num , s + _num ) ; if ( initialstates != null ) { initialstates . add ( s + _num ) ; } s ++ ; } result . finishstate ( ) ; return result ; }	reverses the automaton , returning the new initial states .
public boolean addrules ( list < rule > rulelist ) { for ( int i = _num ; i < rulelist . size ( ) ; i ++ ) { if ( ! validrule ( rulelist . get ( i ) ) ) { return _bool ; } } if ( ! validateruleprobabilities ( rulelist ) ) { return _bool ; } this . rules = rulelist ; updatevarsandterminals ( ) ; return _bool ; }	add a rulelist as the grammar ' s rule list if all rules in it pass both the restrictions of the context - free grammar , and all rules or in chomsky - normal - form.
public static boolean isdigit ( char c ) { return character . isdigit ( c ) ; }	returns true if character c is a digit ( 0.
private static element addbean ( document doc , node parent , class < ? > cls ) { element elem = doc . createelement ( _str ) ; elem . setattribute ( _str , cls . getname ( ) ) ; parent . appendchild ( elem ) ; return elem ; }	add bean to xml document .
public void testfirstposition ( ) throws exception { breakiterator expected = breakiterator . getsentenceinstance ( locale . root ) ; breakiterator actual = new wholebreakiterator ( ) ; assertsamebreaks ( _str , _num , _num , _num , expected , actual ) ; }	the current position must be ignored , initial position is always first ( ).
public void testgetinstance2 ( ) throws java . security . cert . certificateencodingexception , certificateencodingexception { boolean certificateexception = _bool ; x509certificate c = null ; if ( this . cert == null ) { return ; } try { c = x509certificate . getinstance ( cert . getencoded ( ) ) ; } catch ( java . security . cert . certificateencodingexception e ) { fail ( _str ) ; } catch ( certificateexception e ) { certificateexception = _bool ; } if ( ! certificateexception ) { assertnotnull ( c ) ; asserttrue ( arrays . equals ( c . getencoded ( ) , cert . getencoded ( ) ) ) ; } try { x509certificate . getinstance ( new byte [ ] { ( byte ) _num } ) ; } catch ( certificateexception e ) { } try { x509certificate . getinstance ( ( byte [ ] ) null ) ; fail ( _str ) ; } catch ( certificateexception e ) { } }	getinstance ( byte [ ] certdata ) method testing .
public static boolean matches ( mappedmember mm , mappedmember mm2 , boolean orig ) { return matches ( mm , orig ? mm2 . getoriginalname ( ) : mm2 . getnewname ( ) , mm2 . getdesc ( ) , _bool ) ; }	checks if two mapped members are the same .
public void addall ( collection < pdfobject > c ) { list . addall ( c ) ; }	adds the collection of pdfobjects .
public boolean readfromfile ( ) { return readfromfile ( filename ) ; }	read save data from standard file loads the storage data from the default storage file note : lock is acquired in logic before this is called.
public static lnglat normalizelnglat ( lnglat p1 ) { if ( p1 . longitude < util . min_lon || p1 . longitude > util . max_lon ) { int wraps = ( int ) math . floor ( ( p1 . longitude - util . min_lon ) / util . lon_per_world ) ; p1 . longitude -= wraps * util . lon_per_world ; } return p1 ; }	mapzens mapcontroller sometimes returns longitudes outside of - 180 / + 180 so we convert it to a normal value.
public final boolean cancel ( @ nonnull final string tag , final boolean mayinterrupt ) { final integer id = mtaggedrequests . get ( tag ) ; if ( id != null ) { return cancel ( id , mayinterrupt ) ; } else { return _bool ; } }	cancels operation launch by its tag.
public void start ( ) { check ( numthreads , _num , _num ) ; go . countdown ( ) ; }	fires the pistol ! go threads go.
public < t extends node > t jjtgetchild ( class < t > type ) { for ( node n : children ) { if ( type . isinstance ( n ) ) { return ( t ) n ; } } return null ; }	gets the ( first ) child of this node that is of the specific type .
public static string urldecode ( string text ) { if ( stringutils . isempty ( text ) ) { return text ; } try { if ( text . contains ( _str ) ) { return urldecoder . decode ( text , _str ) ; } return urldecoder . decode ( text , _str ) ; } catch ( exception ex ) { log . warn ( _str + text , ex ) ; } return text ; }	tries to decode specified text ( also trying to autodetect encoding ).
protected void layout ( treenode node ) { if ( node != null ) { treenode child = node . child ; while ( child != null ) { layout ( child ) ; child = child . next ; } if ( node . child != null ) { attachparent ( node , join ( node ) ) ; } else { layoutleaf ( node ) ; } } }	starts the actual compact tree layout algorithm at the given node .
ofref ( abstractpipeline < ? , t , ? > upstream , comparator < ? super t > comparator ) { super ( upstream , streamshape . reference , streamopflag . is_ordered | streamopflag . not_sorted ) ; this . isnaturalsort = _bool ; this . comparator = objects . requirenonnull ( comparator ) ; }	sort using the provided comparator .
private void checkcyclicsubstitution ( final string varname , final list < string > priorvariables ) { if ( priorvariables . contains ( varname ) == _bool ) { return ; } final strbuilder buf = new strbuilder ( _num ) ; buf . append ( _str ) ; buf . append ( priorvariables . remove ( _num ) ) ; buf . append ( _str ) ; buf . appendwithseparators ( priorvariables , _str ) ; throw new illegalstateexception ( buf . tostring ( ) ) ; }	checks if the specified variable is already in the stack ( list ) of variables .
public static boolean isverydangerous ( double d ) { return double . isinfinite ( d ) || double . isnan ( d ) ; }	returns true if the argument is a " very dangerous " double to have around , namely one that is infinite or nan .
private void logmin ( string type , string value , string arg , long amount ) { key key = new key ( type , value , arg + minimum_indicator ) ; synchronized ( counts ) { long oldmin = counts . get ( key ) ; if ( oldmin == null ) { oldmin = amount ; } counts . put ( key , math . min ( oldmin , amount ) ) ; } }	logs the minimum amount that was logged for ( type , value , arg ) under ( type , value , arg_min ) .
public boolean append_items ( string p_button_name , string p_window_title , java . util . collection < brditem > p_items ) { java . util . collection < printableinfo > object_list = new java . util . linkedlist < printableinfo > ( ) ; object_list . addall ( p_items ) ; return append_objects ( p_button_name , p_window_title , object_list ) ; }	appends a button for creating a new objectinfowindow with the information of p_items to the text pane.
private static dexclassloader createinstance ( configuration config ) { file file1 ; file file2 ; switch ( config ) { case one_dex : file1 = dex_file ; file2 = null ; break ; case one_jar : file1 = jar_file ; file2 = null ; break ; case two_dex : file1 = dex_file ; file2 = dex2_file ; break ; case two_jar : file1 = jar_file ; file2 = jar2_file ; break ; default : throw new assertionerror ( _str ) ; } string path = file1 . getabsolutepath ( ) ; if ( file2 != null ) { path += file . pathseparator + file2 . getabsolutepath ( ) ; } return new dexclassloader ( path , optimized_dir . getabsolutepath ( ) , null , classloader . getsystemclassloader ( ) ) ; }	helper to construct an instance to test .
public boolean isright ( ) { return ! isleft ; }	returns whether or not this either represents a right value .
@ override public boolean close ( ) { if ( lastopenedtime != - _num ) { final long elapsedtimeopen = system . currenttimemillis ( ) - lastopenedtime ; dialogsettingshelper . recorddialogclosed ( dialogsettingskey , elapsedtimeopen ) ; lastopenedtime = - _num ; } dialogsettingshelper . persistshellgeometry ( getshell ( ) , dialogsettingskey ) ; hookdialogabouttoclose ( ) ; return super . close ( ) ; }	this base class overrides close ( ) to persist the dialog settings , record the elapsed open time for statistics , and to call a subclass hook .
public static void applyusersettings ( environment env , map < string , object > context ) throws templateexception { locale locale = ( locale ) context . get ( _str ) ; if ( locale == null ) { locale = locale . getdefault ( ) ; } env . setlocale ( locale ) ; timezone timezone = ( timezone ) context . get ( _str ) ; if ( timezone == null ) { timezone = timezone . getdefault ( ) ; } env . settimezone ( timezone ) ; }	apply user settings to an environment instance .
synchronized public static void tofile ( string context , string filename , boolean append ) throws ioexception { printstream ps = new printstream ( new fileoutputstream ( filename , append ) ) ; ps . println ( context ) ; ps . flush ( ) ; ps . close ( ) ; }	writes desired string data to appropriate file .
public void addbridgeidledebuglistener ( notthreadsafebridgeidledebuglistener listener ) { mbridgeidlelisteners . add ( listener ) ; }	adds a idle listener for this catalyst instance.
private void nextgeneration ( ) { trip . signalall ( ) ; count = parties ; generation = new generation ( ) ; }	updates state on barrier trip and wakes up everyone.
@ suppresswarnings ( _str ) public static < k extends throwable > void rewrapandthrowifinstance ( string newmessage , throwable t , class < k > clazz ) throws k { if ( ( t != null ) && clazz . isassignablefrom ( t . getclass ( ) ) ) { k kt = ( k ) t ; k wrapped = throwables . rewrap ( newmessage , kt ) ; throw wrapped ; } }	if ( t instanceof k ) throw throwables.
public static void registertilecodec ( int comp , xtifftilecodec codec ) { tilecodecs . put ( new integer ( comp ) , codec ) ; }	register a new xtifftilecodec for encoding and decoding compressed tiff image data.
static final void helpexpungestaleexceptions ( ) { final reentrantlock lock = exceptiontablelock ; if ( lock . trylock ( ) ) { try { expungestaleexceptions ( ) ; } finally { lock . unlock ( ) ; } } }	if lock is available , poll stale refs and remove them.
parsenode parseexpr ( entry inentry ) throws configurationexception , ioexception { list nodes = new arraylist ( ) ; for ( ; ; ) { nodes . add ( parsesubexpr ( inentry ) ) ; if ( st . nexttoken ( ) != _str ) { st . pushback ( ) ; break ; } } if ( nodes . size ( ) == _num ) { return ( parsenode ) nodes . get ( _num ) ; } else { return new stringconcatenation ( ( parsenode [ ] ) nodes . toarray ( new parsenode [ nodes . size ( ) ] ) , st . lineno ( ) ) ; } }	parses a string concatenation.
public static object clone ( object array ) { class < ? > componenttype = getcomponenttype ( array . getclass ( ) ) ; int dims [ ] = getarraylengths ( array ) ; object [ ] elements = ( object [ ] ) muxarray ( array , dims , componenttype ) ; return demuxarray ( elements , dims , componenttype ) ; }	clones the multi - dimension structure of an array but the not the individual elements.
public authpropertiesmodelimpl ( httpservletrequest req , map map ) { super ( req , map ) ; currentrealm = ( string ) map . get ( amadminconstants . current_realm ) ; if ( currentrealm == null ) { currentrealm = _str ; } }	creates a model instance for configuring the core auth properties .
private void readheaderfields ( final ciphertextheaders ciphertextheaders ) { final byte version = ciphertextheaders . getversion ( ) ; if ( version != versioninfo . current_ciphertext_version ) { throw new badciphertextexception ( _str ) ; } cryptoalgo_ = ciphertextheaders . getcryptoalgoid ( ) ; final ciphertexttype ciphertexttype = ciphertextheaders . gettype ( ) ; if ( ciphertexttype != ciphertexttype . customer_authenticated_encrypted_data ) { throw new badciphertextexception ( _str ) ; } final byte [ ] messageid = ciphertextheaders . getmessageid ( ) ; encryptioncontext_ = ciphertextheaders . getencryptioncontextmap ( ) ; if ( cryptoalgo_ . gettrailingsignaturelength ( ) > _num ) { try { trailingpublickey_ = deserializetrailingkeyfromec ( encryptioncontext_ . get ( constants . ec_public_key_field ) ) ; trailingsig_ = signature . getinstance ( cryptoalgo_ . gettrailingsignaturealgo ( ) , _str ) ; trailingsig_ . initverify ( trailingpublickey_ ) ; } catch ( final generalsecurityexception ex ) { throw new awscryptoexception ( ex ) ; } } else { trailingpublickey_ = null ; trailingsig_ = null ; } final contenttype contenttype = ciphertextheaders . getcontenttype ( ) ; final short noncelen = ciphertextheaders . getnoncelength ( ) ; final int framelen = ciphertextheaders . getframelength ( ) ; datakey_ = getdatakey ( ciphertextheaders ) ; try { decryptionkey_ = cryptoalgo_ . getencryptionkeyfromdatakey ( datakey_ . getkey ( ) , ciphertextheaders ) ; } catch ( final invalidkeyexception ex ) { throw new awscryptoexception ( ex ) ; } verifyheaderintegrity ( ciphertextheaders ) ; switch ( contenttype ) { case frame : contentcryptohandler_ = new framedecryptionhandler ( decryptionkey_ , ( byte ) noncelen , cryptoalgo_ , messageid , framelen ) ; break ; case singleblock : contentcryptohandler_ = new blockdecryptionhandler ( decryptionkey_ , ( byte ) noncelen , cryptoalgo_ , messageid ) ; break ; default : break ; } }	read the fields in the ciphertext headers to populate the corresponding instance variables used during decryption .
public static void moveend ( jscrollpane pane ) { jscrollbar bar = pane . getverticalscrollbar ( ) ; bar . setvalue ( bar . getmaximum ( ) ) ; }	move the cursor to the end of scrollpane .
public void populateedittext ( arraylist < string > matches ) { togglesearch ( ) ; string text = _str ; for ( int x = _num ; x < matches . size ( ) ; x ++ ) { text = text + matches . get ( x ) + _str ; } text = text . trim ( ) ; setsearchstring ( text ) ; search ( text ) ; }	populate the searchbox with words , in an arraylist . used by the voice input.
public candidate extendhypothesis ( ) { if ( ranks [ _num ] < hypotheses . size ( ) - _num ) { return new candidate ( featurefunctions , sentence , hypotheses , phrases , future_delta , new int [ ] { ranks [ _num ] + _num , ranks [ _num ] } ) ; } return null ; }	extends the cube pruning dot along the dimension of existing hypotheses .
public static bitmap resizebitmap ( bitmap bitmap , int reqwidth , int reqheight , cropimageview . requestsizeoptions options ) { try { if ( reqwidth > _num && reqheight > _num && ( options == cropimageview . requestsizeoptions . resize_fit || options == cropimageview . requestsizeoptions . resize_inside || options == cropimageview . requestsizeoptions . resize_exact ) ) { bitmap resized = null ; if ( options == cropimageview . requestsizeoptions . resize_exact ) { resized = bitmap . createscaledbitmap ( bitmap , reqwidth , reqheight , _bool ) ; } else { int width = bitmap . getwidth ( ) ; int height = bitmap . getheight ( ) ; float scale = math . max ( width / ( float ) reqwidth , height / ( float ) reqheight ) ; if ( scale > _num || options == cropimageview . requestsizeoptions . resize_fit ) { resized = bitmap . createscaledbitmap ( bitmap , ( int ) ( width / scale ) , ( int ) ( height / scale ) , _bool ) ; } } if ( resized != null ) { if ( resized != bitmap ) { bitmap . recycle ( ) ; } return resized ; } } } catch ( exception e ) { log . w ( _str , _str , e ) ; } return bitmap ; }	resize the given bitmap to the given width / height by the given option . < br >.
protected boolean addnewicon ( string name ) { if ( log . isdebugenabled ( ) ) { log . debug ( _str + _iconmap . size ( ) ) ; } if ( name == null || name . length ( ) == _num ) { joptionpane . showmessagedialog ( _parent . _paletteframe , bundle . getmessage ( _str ) , bundle . getmessage ( _str ) , joptionpane . warning_message ) ; return _bool ; } else if ( _iconmap . get ( name ) != null ) { joptionpane . showmessagedialog ( _parent . _paletteframe , bundle . getmessage ( _str , name ) , bundle . getmessage ( _str ) , joptionpane . warning_message ) ; return _bool ; } string filename = _str ; namedicon icon = new jmri . jmrit . catalog . namedicon ( filename , filename ) ; _iconmap . put ( name , icon ) ; return _bool ; }	action item for makeaddiconbuttonpanel.
public void init ( mcmcoptions options , likelihood likelihood , prior prior , operatorschedule schedule , logger [ ] loggers , markovchaindelegate [ ] delegates ) { mcmccriterion criterion = new mcmccriterion ( ) ; criterion . settemperature ( options . gettemperature ( ) ) ; mc = new markovchain ( prior , likelihood , schedule , criterion , options . getfullevaluationcount ( ) , options . minoperatorcountforfullevaluation ( ) , options . getevaluationtestthreshold ( ) , options . usecoercion ( ) ) ; this . options = options ; this . loggers = loggers ; this . schedule = schedule ; currentstate = _num ; for ( markovchaindelegate delegate : delegates ) { delegate . setup ( options , schedule , mc ) ; } this . delegates = delegates ; dumpstatefile = system . getproperty ( load_dump_file ) ; if ( system . getproperty ( dump_state ) != null ) { long debugwritestate = long . parselong ( system . getproperty ( dump_state ) ) ; mc . addmarkovchainlistener ( new debugchainlistener ( this , debugwritestate , _bool ) ) ; } if ( system . getproperty ( dump_every ) != null ) { long debugwriteevery = long . parselong ( system . getproperty ( dump_every ) ) ; mc . addmarkovchainlistener ( new debugchainlistener ( this , debugwriteevery , _bool ) ) ; } }	must be called before calling chain .
private final boolean relatedmoves ( move m1 , move m2 ) { if ( ( m1 . from == m1 . to ) || ( m2 . from == m2 . to ) ) return _bool ; if ( ( m1 . to == m2 . from ) || ( m1 . from == m2 . to ) || ( ( bitboard . squaresbetween [ m2 . from ] [ m2 . to ] & ( _num << m1 . from ) ) != _num ) ) return _bool ; return _bool ; }	return true if move m2 was made possible by move m1 .
@ override public void write ( int b ) throws ioexception { filestream . write ( b ) ; outputstream . write ( b ) ; }	writes the specified byte to the specified output stream and copies it to the file .
@ safevarargs public final testsubscriber < t > assertvalueswith ( consumer < t > ... expectations ) { if ( ! valuesstorage ) { throw new illegalstateexception ( _str ) ; } final int expectedvaluecount = expectations . length ; if ( expectedvaluecount != values . size ( ) ) { throw new assertionerror ( _str + expectedvaluecount + _str + valuecount , null ) ; } for ( int i = _num ; i < expectedvaluecount ; i ++ ) { consumer < t > consumer = expectations [ i ] ; t actualvalue = values . get ( i ) ; consumer . accept ( actualvalue ) ; } return this ; }	assert the specified values have been received in the declared order.
public static number multiply ( character left , number right ) { return numbernumbermultiply . multiply ( integer . valueof ( left ) , right ) ; }	multiply a character by a number.
public void write ( byte [ ] b , int off , int len ) { if ( sysproperties . check && ( len < _num || len % constants . file_block_size != _num ) ) { dbexception . throwinternalerror ( _str + name + _str + len ) ; } checkwritingallowed ( ) ; checkpoweroff ( ) ; try { fileutils . writefully ( file , bytebuffer . wrap ( b , off , len ) ) ; } catch ( ioexception e ) { closefilesilently ( ) ; throw dbexception . convertioexception ( e , name ) ; } filepos += len ; filelength = math . max ( filepos , filelength ) ; }	write a number of bytes .
public void removefooter ( object footer ) { if ( mfooters . contains ( footer ) ) { int position = mfooters . indexof ( footer ) ; mfooters . remove ( position ) ; notifyitemremoved ( mheaders . size ( ) + mdata . size ( ) + position ) ; } }	remove a footer from the adapter.
@ override public void refreshindex ( string rowid , dimensionrow dimensionrow , dimensionrow dimensionrowold ) { refreshindex ( collections . singletonmap ( rowid , new pair < > ( dimensionrow , dimensionrowold ) ) ) ; }	refresh lucene index query the lucene indexes on key column to see if there are any existing indexes.
@ override public void exporttree ( tree tree ) throws ioexception { java . util . list < tree > trees = new arraylist < tree > ( ) ; trees . add ( tree ) ; exporttrees ( trees ) ; }	export a single tree.
public static externalsortable [ ] readarrayofexternalsortable ( inputstream in , externalsortable ex ) throws ioexception { vector a = new vector ( ) ; int i = _num ; try { do { a . addelement ( ex . read ( in ) ) ; i ++ ; } while ( _bool ) ; } catch ( ioexception e ) { } externalsortable [ ] ea = new externalsortable [ i ] ; for ( int j = _num ; j < i ; j ++ ) ea [ j ] = ( externalsortable ) a . elementat ( j ) ; return ea ; }	reads in as many externalsortables as it can and returns an array corresponding to the externalsortables . input : in should contain some sequence of externalsortables , otherwise a runtimeexception is thrown.
public void post ( object event ) { list < object > eventqueue = currentthreadeventqueue . get ( ) ; eventqueue . add ( event ) ; booleanwrapper isposting = currentthreadisposting . get ( ) ; if ( isposting . value ) { return ; } else { boolean ismainthread = looper . getmainlooper ( ) == looper . mylooper ( ) ; isposting . value = _bool ; try { while ( ! eventqueue . isempty ( ) ) { postsingleevent ( eventqueue . remove ( _num ) , ismainthread ) ; } } finally { isposting . value = _bool ; } } }	posts the given event to the event bus .
public static methodsymbol findmethoddeclarationintype ( types types , typesymbol typesymbol , string methodname , methodtype methodtype ) { return findmethoddeclarationintype ( types , typesymbol , methodname , methodtype , _bool ) ; }	finds the method in the given type that matches the given name and signature .
public string remainder ( ) { stringbuilder accum = new stringbuilder ( ) ; while ( ! isempty ( ) ) { accum . append ( consume ( ) ) ; } return accum . tostring ( ) ; }	consume and return whatever is left on the queue .
private void firsttuple ( object inputevent ) { if ( firsttupleprocessed ) { return ; } firsttupleprocessed = _bool ; class < ? > clazz = inputevent . getclass ( ) ; getters = gpoutils . buildgpogetters ( fieldtogetter , schema . getvaluesdescriptor ( ) , clazz ) ; }	a helper method which builds the getter methods for retrieving fields from pojos .
public void removedebugger ( final debuggertemplate debugger ) throws couldntsavedataexception { preconditions . checknotnull ( debugger , _str ) ; preconditions . checkargument ( m_assigneddebuggers . contains ( debugger ) , _str ) ; m_provider . removedebugger ( m_project , debugger ) ; m_assigneddebuggers . remove ( debugger ) ; for ( final iprojectlistener listener : m_listeners ) { try { listener . removeddebugger ( m_project , debugger ) ; } catch ( final exception exception ) { cutilityfunctions . logexception ( exception ) ; } } updatemodificationdate ( ) ; }	removes an assigned debugger template from the project .
public void addlayout ( loadinglayout layout ) { if ( null != layout ) { mloadinglayouts . add ( layout ) ; } }	this allows you to add extra loadinglayout instances to this proxy . this is only necessary if you keep your own instances , and want to have them included in any.
public void check ( ) throws erlangversionexception { string erlangversion ; try { erlangversion = erlangshell . geterlangversion ( ) ; logger . debug ( _str , erlangversion ) ; } catch ( erlangshellexception e ) { throw new erlangversionexception ( _str , e ) ; } if ( minerlangversion == null ) { logger . debug ( _str ) ; return ; } else { logger . debug ( _str , minerlangversion ) ; } double expected ; double actual ; try { expected = parse ( minerlangversion ) ; actual = parse ( erlangversion ) ; } catch ( runtimeexception e ) { logger . warn ( _str + minerlangversion + _str + erlangversion + _str ) ; return ; } if ( actual < expected ) { throw new erlangversionexception ( string . format ( _str , minerlangversion , erlangversion ) ) ; } }	retrieves the current system ' s erlang version to compare it to the minimum required version.
public static void decodepathsegment ( list < pathsegment > segments , string segment , boolean decode ) { int colon = segment . indexof ( _str ) ; if ( colon != - _num ) { segments . add ( new pathsegmentimpl ( ( colon == _num ) ? _str : segment . substring ( _num , colon ) , decode , decodematrix ( segment , decode ) ) ) ; } else { segments . add ( new pathsegmentimpl ( segment , decode ) ) ; } }	decode the path segment and add it to the list of path segments .
protected void parseandadd ( map lexicon , string line ) { stringtokenizer tokenizer = new stringtokenizer ( line , _str ) ; string phones = null ; string wordandpos = tokenizer . nexttoken ( ) ; string pos = wordandpos . substring ( wordandpos . length ( ) - _num ) ; if ( ! partsofspeech . contains ( pos ) ) { partsofspeech . add ( pos ) ; } if ( tokenizer . hasmoretokens ( ) ) { phones = tokenizer . nexttoken ( ) ; } if ( ( phones != null ) && ( tokenizeonload ) ) { lexicon . put ( wordandpos , getphones ( phones ) ) ; } else if ( phones == null ) { lexicon . put ( wordandpos , no_phones ) ; } else { lexicon . put ( wordandpos , phones ) ; } }	creates a word from the given input line and add it to the lexicon .
public void fromarray ( int [ ] members ) { if ( this . members . length != members . length ) { throw new illegalargumentexception ( _str ) ; } memberset . clear ( ) ; for ( int i = _num ; i < members . length ; i ++ ) { this . members [ i ] = members [ i ] ; memberset . add ( members [ i ] ) ; } validate ( ) ; }	populates this subset from an array .
private boolean startcompactmode ( string type ) { long timepassed = system . currenttimemillis ( ) - compactmodestart ; if ( timepassed > max_compactmode_time ) { closecompactmode ( ) ; } if ( ! type . equals ( compactmode ) ) { closecompactmode ( ) ; } if ( compactmode == null ) { compactmode = type ; compactmodestart = system . currenttimemillis ( ) ; compactmodelength = _num ; return _bool ; } return _bool ; }	enters compact mode , closes it first if necessary .
public void close ( ) { logger . debug ( _str ) ; setclosed ( _bool ) ; while ( ! isempty ( ) || isfiring ( ) && ! checkingthread . isdaemon ( ) ) { try { thread . sleep ( minwindowsize ) ; } catch ( exception e ) { logger . debug ( _str ) ; } } }	close the buffer and deallocate resources.
void freewritelock ( ) { synchronized ( write_lock ) { iswritelocked = _bool ; write_lock . notifyall ( ) ; } }	frees the channel for writing .
private void addmitrejoin ( coordinate p , linesegment offset0 , linesegment offset1 , double distance ) { boolean ismitrewithinlimit = _bool ; coordinate intpt = null ; try { intpt = hcoordinate . intersection ( offset0 . p0 , offset0 . p1 , offset1 . p0 , offset1 . p1 ) ; double mitreratio = distance <= _num ? _num : intpt . distance ( p ) / math . abs ( distance ) ; if ( mitreratio > bufparams . getmitrelimit ( ) ) ismitrewithinlimit = _bool ; } catch ( notrepresentableexception ex ) { intpt = new coordinate ( _num , _num ) ; ismitrewithinlimit = _bool ; } if ( ismitrewithinlimit ) { seglist . addpt ( intpt ) ; } else { addlimitedmitrejoin ( offset0 , offset1 , distance , bufparams . getmitrelimit ( ) ) ; } }	adds a mitre join connecting the two reflex offset segments.
public void addlistener ( amclientdatalistener cdl ) { synchronized ( listeners ) { if ( ! listeners . contains ( cdl ) ) { listeners . add ( cdl ) ; } } }	register for listening to client data changes.
public static double rand ( ) { return rand . nextdouble ( ) ; }	generates an equally distributed double precision random number . the upper boundary.
public void cancelthrottlerequest ( int address , throttlelistener l ) { boolean islong = _bool ; if ( canbeshortaddress ( address ) ) { islong = _bool ; } cancelthrottlerequest ( address , islong , l ) ; }	cancel a request for a throttle.
private shape createthumbshape ( int width , int height , boolean upper ) { path2d path = new path2d . float ( ) ; if ( slider . getorientation ( ) == jslider . horizontal ) { float d = _num * width ; path . moveto ( d , _num ) ; path . lineto ( ( upper ? width : _num ) , d ) ; path . lineto ( ( upper ? width : _num ) , height ) ; path . lineto ( _num * width , height ) ; } else { float d = _num * height ; path . moveto ( _num , d ) ; path . lineto ( d , ( upper ? height : _num ) ) ; path . lineto ( width , ( upper ? height : _num ) ) ; path . lineto ( height , _num * height ) ; } path . closepath ( ) ; return path ; }	returns a shape representing a thumb .
public final void open ( string page , string ref ) { if ( ref == null ) { ref = _str ; } ref = ref . replace ( _str , _str ) ; if ( page == null ) { page = default_page ; } if ( currentpage != null && currentpage . equals ( page ) ) { jumpto ( ref ) ; } else { reference = ref ; } loadpage ( page ) ; historyitem location = new historyitem ( page , ref ) ; history . addifnew ( location ) ; updatehistorybuttons ( ) ; currentlocation . settext ( location . tostring ( ) ) ; }	open a page and go to a position ( ref , which is an anchor in the html document ) on that page .
public void close ( ) throws ioexception { if ( input != null ) { input . close ( ) ; input = null ; } }	closes this character stream , as well as the the reader it its iterating over .
protected void rehash ( int newcapacity ) { int oldcapacity = _set . length ; object oldkeys [ ] = _set ; v oldvals [ ] = _values ; _set = new object [ newcapacity ] ; arrays . fill ( _set , free ) ; _values = ( v [ ] ) new object [ newcapacity ] ; for ( int i = oldcapacity ; i -- > _num ; ) { if ( oldkeys [ i ] != free && oldkeys [ i ] != removed ) { object o = oldkeys [ i ] ; int index = insertionindex ( ( k ) o ) ; if ( index < _num ) { throwobjectcontractviolation ( _set [ ( - index - _num ) ] , o ) ; } _set [ index ] = o ; _values [ index ] = oldvals [ i ] ; } } }	rehashes the map to the new capacity .
@ override public void writeendelement ( ) throws xmlstreamexception { log . log ( level . fine , _str ) ; calculateandnexttag ( ) ; }	writes an end tag to the output relying on the internal state of the writer to determine the prefix and local name of the event.
private string nextliteral ( boolean assignoffsetsonly ) throws ioexception { stringbuilder builder = null ; valuepos = - _num ; valuelength = _num ; int i = _num ; findnonliteralcharacter : while ( _bool ) { for ( ; pos + i < limit ; i ++ ) { switch ( buffer [ pos + i ] ) { case _str : case _str : case _str : case _str : case _str : checklenient ( ) ; case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : case _str : break findnonliteralcharacter ; } } if ( i < buffer . length ) { if ( fillbuffer ( i + _num ) ) { continue ; } else { buffer [ limit ] = _str ; break ; } } if ( builder == null ) { builder = new stringbuilder ( ) ; } builder . append ( buffer , pos , i ) ; valuelength += i ; pos += i ; i = _num ; if ( ! fillbuffer ( _num ) ) { break ; } } string result ; if ( assignoffsetsonly && builder == null ) { valuepos = pos ; result = null ; } else if ( skipping ) { result = _str ; } else if ( builder == null ) { result = stringpool . get ( buffer , pos , i ) ; } else { builder . append ( buffer , pos , i ) ; result = builder . tostring ( ) ; } valuelength += i ; pos += i ; return result ; }	reads the value up to but not including any delimiter characters.
protected void writecolumndefaultvaluestmt ( table table , column column , stringbuilder ddl ) { object parseddefault = column . getparseddefaultvalue ( ) ; if ( parseddefault != null ) { if ( ! databaseinfo . isdefaultvaluesforlongtypessupported ( ) && ( ( column . getmappedtypecode ( ) == types . longvarbinary ) || ( column . getmappedtypecode ( ) == types . longvarchar ) ) ) { throw new modelexception ( _str ) ; } if ( isvaliddefaultvalue ( column . getdefaultvalue ( ) , column . getmappedtypecode ( ) ) ) { ddl . append ( _str ) ; writecolumndefaultvalue ( table , column , ddl ) ; } } else if ( databaseinfo . isdefaultvalueusedforidentityspec ( ) && column . isautoincrement ( ) ) { ddl . append ( _str ) ; writecolumndefaultvalue ( table , column , ddl ) ; } else if ( ! stringutils . isblank ( column . getdefaultvalue ( ) ) ) { ddl . append ( _str ) ; writecolumndefaultvalue ( table , column , ddl ) ; } }	prints the default value stmt part for the column .
public synchronized byte [ ] readnextpart ( string username ) throws jplagexception { transferobject obj = usertodownloadmap . get ( username ) ; if ( obj == null ) { throw new jplagexception ( _str , _str , _str ) ; } downloadtimeoutqueue . remove ( obj ) ; byte [ ] data = obj . readnextpart ( ) ; if ( obj . getremainingbytes ( ) != _num ) { obj . settimeout ( _num ) ; downloadtimeoutqueue . add ( obj ) ; } else { usertodownloadmap . remove ( username ) ; jplagcentral . cancelsubmission ( obj . getstruct ( ) ) ; } return data ; }	reads the next part of the download identified by the username . if it was the last part it unmarks the user and deletes the entry file.
public boolean isexpired ( calendar fromdate ) { calendar endtime = ( calendar ) fromdate . clone ( ) ; if ( window == null ) { endtime . add ( calendar . hour_of_day , infinite_window_order_execution_timeout ) ; } else { endtime . add ( getwindowlengthcalendarfield ( ) , window . getexecutionwindowlength ( ) ) ; } calendar currtime = calendar . getinstance ( ) ; log . debug ( _str , currtime , endtime ) ; return currtime . compareto ( endtime ) > _num ; }	check if order ' s scheduled time + schedule window already expire .
public void adjuststaticcertificate ( certificate copyfrom ) { if ( this != unsigned && this != expired ) { throw new unsupportedoperationexception ( _str ) ; } commonname = copyfrom . commonname ; organization = copyfrom . organization ; validfrom = copyfrom . validfrom ; validto = copyfrom . validto ; valid = _bool ; }	copies the company information from a valid certificate to show on an invalid signature certificate .
private int detecttype ( string filename ) throws ioexception , ftpillegalreplyexception , ftpexception { int start = filename . lastindexof ( _str ) + _num ; int stop = filename . length ( ) ; if ( start > _num && start < stop - _num ) { string ext = filename . substring ( start , stop ) ; ext = ext . tolowercase ( ) ; if ( textualextensionrecognizer . istextualext ( ext ) ) { return type_textual ; } else { return type_binary ; } } else { return type_binary ; } }	this method detects the type for a file transfer .
cut ( constant value , double diff ) { this . value = value ; this . diff = diff ; }	represents a cut at given value on a range.
public void addpropertychangelistener ( propertychangelistener l ) { if ( listeners == null ) { listeners = new arraylist < propertychangelistener > ( _num ) ; } if ( ! listeners . contains ( l ) ) { listeners . add ( l ) ; } }	add an addresslistener . addresslisteners are notified when the user selects a new address and when a throttle is acquired for that address.
private void processresponseheaders ( state state , innerstate innerstate , httpresponse response ) throws stoprequest { if ( innerstate . mcontinuingdownload ) { return ; } readresponseheaders ( state , innerstate , response ) ; try { state . mfilename = mservice . generatesavefile ( minfo . mfilename , minfo . mtotalbytes ) ; } catch ( downloaderservice . generatesavefileerror exc ) { throw new stoprequest ( exc . mstatus , exc . mmessage ) ; } try { state . mstream = new fileoutputstream ( state . mfilename ) ; } catch ( filenotfoundexception exc ) { file pathfile = new file ( helpers . getsavefilepath ( mservice ) ) ; try { if ( pathfile . mkdirs ( ) ) { state . mstream = new fileoutputstream ( state . mfilename ) ; } } catch ( exception ex ) { throw new stoprequest ( downloaderservice . status_file_error , _str + exc . tostring ( ) , exc ) ; } } if ( constants . logv ) { log . v ( constants . tag , _str + minfo . muri + _str + state . mfilename ) ; } updatedatabasefromheaders ( state , innerstate ) ; checkconnectivity ( state ) ; }	read http response headers and take appropriate action , including setting up the destination file and updating the database .
@ override public void write ( byte [ ] buf , int off , int nbytes ) { digest . update ( buf , off , nbytes ) ; }	updates a digest with byte array .
@ override public double driftdiscretization ( final stochasticprocess1d sp , final double t0 , final double x0 , final double dt ) { return sp . drift ( t0 , x0 ) * dt ; }	returns an approximation of the drift defined as < p > \ mu ( t_0 , x_0 ) \ delta t.
private void dotreetag ( jcas jcas ) { try { if ( ttproc == null ) { ttproc = new treetaggerprocess ( ttprops . gettreetaggingprocess ( ) ) ; } logger . printdetail ( component , _str + ttprops . parfilename ) ; annotationindex ai = jcas . getannotationindex ( token . type ) ; list < string > tokenstrings = new arraylist < > ( ) ; list < token > tokens = new arraylist < > ( ) ; for ( fsiterator fsi = ai . iterator ( ) ; fsi . hasnext ( ) ; ) { token token = ( token ) fsi . next ( ) ; tokenstrings . add ( token . getcoveredtext ( ) ) ; tokens . add ( token ) ; } ttreader = new treetaggerreader ( tokens , ttproc . getstdout ( ) , jcas , annotate_sentences ) ; ttwriter = new treetaggerwriter ( tokenstrings , ttproc . getstdin ( ) ) ; thread rthread = new thread ( ttreader ) ; thread wthread = new thread ( ttwriter ) ; rthread . start ( ) ; wthread . start ( ) ; rthread . join ( ) ; wthread . join ( ) ; } catch ( ioexception | interruptedexception e ) { e . printstacktrace ( ) ; } }	based on tokens from the jcas object , adds part of speech ( pos ) and sentence tags to the jcas object using the treetagger program .
public void terminate ( ) { this . terminated = _bool ; executorservice . shutdown ( ) ; boolean finished = _bool ; boolean interrupted = _bool ; while ( ! finished ) { try { log . warning ( _str ) ; finished = executorservice . awaittermination ( radiusserverconstants . thread_pool_shutdown_wait_seconds , timeunit . seconds ) ; } catch ( final interruptedexception e ) { log . warning ( _str ) ; interrupted = _bool ; } } final thread t = listenerthread ; if ( t != null ) { t . interrupt ( ) ; while ( listenerthread != null ) { log . warning ( _str ) ; try { thread . sleep ( _num ) ; } catch ( final interruptedexception e ) { } } } }	blocking call that terminates the thread pool , tells the listener to drop any new requests , waits until the thread pool is empty , and then interrupts the listener thread in case it is blocked waiting for new requests.
public static void writeoneblocktoxml ( block toserialize , outputstream os ) throws blocklyserializerexception { list < block > temp = new arraylist < > ( ) ; temp . add ( toserialize ) ; writetoxml ( temp , os ) ; }	convenience function to serialize only one block .
private void renderformsontog2withhtml ( final int pageindex , final map componentstoignore ) { this . componentstoignore = componentstoignore ; formobject formobject ; for ( final formobject nextval : formsordered [ pageindex ] ) { if ( nextval != null ) { formobject = nextval ; checkguiobjectresolved ( formobject ) ; } } }	use swing to draw forms.
public builder addpattern ( string pattern ) { patterns . add ( pattern ) ; return this ; }	add a resource pattern that guides the resource for a policy .
protected static string addmavennamespace ( string effectivexml , boolean ispom ) { saxbuilder builder = new saxbuilder ( ) ; try { document document = builder . build ( new stringreader ( effectivexml ) ) ; element rootelement = document . getrootelement ( ) ; namespace pomnamespace = namespace . getnamespace ( _str , _str ) ; rootelement . setnamespace ( pomnamespace ) ; namespace xsinamespace = namespace . getnamespace ( _str , _str ) ; rootelement . addnamespacedeclaration ( xsinamespace ) ; if ( rootelement . getattribute ( _str , xsinamespace ) == null ) { rootelement . setattribute ( _str , _str + ( ispom ? pom_xsd_url : settings_xsd_url ) , xsinamespace ) ; } elementfilter elementfilter = new elementfilter ( namespace . getnamespace ( _str ) ) ; for ( iterator < ? > i = rootelement . getdescendants ( elementfilter ) ; i . hasnext ( ) ; ) { element e = ( element ) i . next ( ) ; e . setnamespace ( pomnamespace ) ; } stringwriter w = new stringwriter ( ) ; format format = format . getprettyformat ( ) ; xmloutputter out = new xmloutputter ( format ) ; out . output ( document . getrootelement ( ) , w ) ; return w . tostring ( ) ; } catch ( jdomexception e ) { return effectivexml ; } catch ( ioexception e ) { return effectivexml ; } }	method from org . apache . maven . plugins . help . abstracteffectivemojo add a pom / settings namespaces to the effective xml content .
public void dispose ( ) { logdebug ( _str ) ; msetupdone = _bool ; log . e ( _str , _str ) ; if ( mserviceconn != null ) { log . e ( _str , _str ) ; logdebug ( _str ) ; if ( mcontext != null ) { log . e ( _str , _str ) ; mcontext . unbindservice ( mserviceconn ) ; } } mdisposed = _bool ; mcontext = null ; mserviceconn = null ; mservice = null ; mpurchaselistener = null ; }	dispose of object , releasing resources.
private static byte [ ] hexstringtobytearray ( string hexstring ) { int len = hexstring . length ( ) ; byte [ ] data = new byte [ len / _num ] ; for ( int i = _num ; i < len ; i += _num ) { data [ i / _num ] = ( byte ) ( ( character . digit ( hexstring . charat ( i ) , _num ) << _num ) + character . digit ( hexstring . charat ( i + _num ) , _num ) ) ; } return data ; }	converts hex values from strings to byte array.
public static generalizedtime currenttime ( ) { return valueof ( calendar . getinstance ( ) ) ; }	returns a generalized time whose value is the current time , using the default time zone and locale .
private void commit ( ) throws interruptedexception , replicatorexception { applier . commit ( ) ; schedule . commit ( ) ; blockeventcount = _num ; lastcommitmillis = system . currenttimemillis ( ) ; }	utility routine to issue commit with appropriate transaction accounting .
private namedlist < object > processresponse ( xmlstreamreader parser ) { try { namedlist < object > response = null ; for ( int event = parser . next ( ) ; event != xmlstreamconstants . end_document ; event = parser . next ( ) ) { switch ( event ) { case xmlstreamconstants . start_element : if ( response != null ) { throw new exception ( _str ) ; } string name = parser . getlocalname ( ) ; if ( name . equals ( _str ) || name . equals ( _str ) ) { response = readnamedlist ( parser ) ; } else if ( name . equals ( _str ) ) { return new simpleorderedmap < > ( ) ; } else { throw new exception ( _str + _str + parser . getlocalname ( ) ) ; } break ; } } return response ; } catch ( exception ex ) { throw new solrexception ( solrexception . errorcode . server_error , _str , ex ) ; } finally { try { parser . close ( ) ; } catch ( exception ex ) { } } }	parse the text into a named list.
public boolean ispluralforms ( ) { return nouns != null ; }	if an attempt is made to convert set property names to their plural form .
object processavt_qname ( stylesheethandler handler , string uri , string name , string rawname , string value , elemtemplateelement owner ) throws org . xml . sax . saxexception { avt avt = null ; try { avt = new avt ( handler , uri , name , rawname , value , owner ) ; if ( avt . issimple ( ) ) { int indexofnssep = value . indexof ( _str ) ; if ( indexofnssep >= _num ) { string prefix = value . substring ( _num , indexofnssep ) ; if ( ! xml11char . isxml11validncname ( prefix ) ) { handleerror ( handler , xslterrorresources . invalid_qname , new object [ ] { name , value } , null ) ; return null ; } } string localname = ( indexofnssep < _num ) ? value : value . substring ( indexofnssep + _num ) ; if ( ( localname == null ) || ( localname . length ( ) == _num ) || ( ! xml11char . isxml11validncname ( localname ) ) ) { handleerror ( handler , xslterrorresources . invalid_qname , new object [ ] { name , value } , null ) ; return null ; } } } catch ( transformerexception te ) { throw new org . xml . sax . saxexception ( te ) ; } return avt ; }	process an attribute string of type t_qname into a qname value .
public boolean hasmouse ( ) { return ( ( movable != null ) ) ; }	determine if this inputhandler is dragging an object.
private void triggercopyservices ( set < string > targetdatastoreset , state current ) { if ( targetdatastoreset . isempty ( ) ) { serviceutils . loginfo ( this , _str ) ; return ; } for ( string targetdatastore : targetdatastoreset ) { triggercopyservice ( current , targetdatastore ) ; } }	this function creates a set of imagecopyservice instances parented to the current service instance .
public long tominutes ( ) { return timeunit . tominutes ( length ) ; }	returns the duration in minutes .
private static void addvariableifrequired ( dataset data , string var ) { list < string > nodes = data . getvariablenames ( ) ; if ( ! nodes . contains ( var ) ) { data . addvariable ( new continuousvariable ( var ) ) ; } }	adds a column for the given varible if required .
public static anymseq < integer > fromrange ( final int start , final int end ) { return anym . fromstream ( reactiveseq . range ( start , end ) ) ; }	construct an anym instance that wraps a range from start ( inclusive ) to end ( exclusive ) provided the anym will contain a sequencem over the spefied range.
public string distancefunctiontiptext ( ) { return _str + _str ; }	returns the tip text for this property .
protected panelstate findnearestpanelstatefromheight ( float desiredpanelheight ) { panelstate closestpanelstate = panelstate . closed ; float smallestheightdiff = float . positive_infinity ; for ( panelstate state : panelstate . values ( ) ) { if ( ! isvalidstate ( state ) ) { continue ; } if ( ! isfullscreensizepanel ( ) && state == panelstate . expanded ) { continue ; } float height = getpanelheightfromstate ( state ) ; float heightdiff = math . abs ( desiredpanelheight - height ) ; if ( heightdiff < smallestheightdiff ) { closestpanelstate = state ; smallestheightdiff = heightdiff ; } } return closestpanelstate ; }	finds the state which has the nearest height compared to a given | desiredpanelheight | .
private static boolean aremethodargscompatible ( class [ ] argtypes , object [ ] args ) { for ( int i = _num ; i < args . length ; i ++ ) { object arg = args [ i ] ; class argtype = wrap ( argtypes [ i ] ) ; if ( arg != null && ! argtype . isassignablefrom ( arg . getclass ( ) ) ) return _bool ; } return _bool ; }	determines whether specified method arguments are compatible with given method parameter definitions .
public static string removequotationmarksifneeded ( string str ) { if ( str . startswith ( _str ) && str . endswith ( _str ) ) return str . substring ( _num , str . length ( ) - _num ) ; return str ; }	remove quotation marks at the beginning and end of the string if present .
public static bytebuffer resizebytebuffer ( bytebuffer buf , long size ) { bytebuffer ret = bytebuffer . allocatedirect ( ( int ) size ) ; if ( ret != null ) { if ( null != buf ) { ret . put ( buf ) ; ret . flip ( ) ; } } return ret ; }	resize a bytebuffer with a new instance.
public void removeall ( ) { ioobjects . clear ( ) ; }	removes all objects from this iocontainer .
public void clear ( ) { int index1 = delegate . size ( ) - _num ; delegate . removeallelements ( ) ; if ( index1 >= _num ) { fireintervalremoved ( this , _num , index1 ) ; } }	removes all of the elements from this list.
protected void skipremainingtagsincurrentifd ( ) throws ioexception , exifinvalidformatexception { int endoftags = mifdstartoffset + offset_size + tag_size * mnumoftaginifd ; int offset = mtiffstream . getreadbytecount ( ) ; if ( offset > endoftags ) { return ; } if ( mneedtoparseoffsetsincurrentifd ) { while ( offset < endoftags ) { mtag = readtag ( ) ; offset += tag_size ; if ( mtag == null ) { continue ; } checkoffsetorimagetag ( mtag ) ; } } else { skipto ( endoftags ) ; } long ifdoffset = readunsignedlong ( ) ; if ( mifdtype == ifdid . type_ifd_0 && ( isifdrequested ( ifdid . type_ifd_1 ) || isthumbnailrequested ( ) ) ) { if ( ifdoffset > _num ) { registerifd ( ifdid . type_ifd_1 , ifdoffset ) ; } } }	skips the tags area of current ifd , if the parser is not in the tag area , nothing will happen .
public static date parsedate ( final string datevalue ) throws dateparseexception { return parsedate ( datevalue , null ) ; }	parses a date value.
public boolean isfilled ( ) { return filled ; }	returns the filled boolean .
public void clear ( ) { mplottables . clear ( ) ; }	clears all plottables from this entity.
@ override public void sendmail ( mimemessage message ) throws messagingexception { mailaddress sender = new mailaddress ( ( internetaddress ) message . getfrom ( ) [ _num ] ) ; collection < mailaddress > recipients = new hashset < mailaddress > ( ) ; address addresses [ ] = message . getallrecipients ( ) ; if ( addresses != null ) { for ( address address : addresses ) { if ( address instanceof internetaddress ) { recipients . add ( new mailaddress ( ( internetaddress ) address ) ) ; } } } sendmail ( sender , recipients , message ) ; }	place a mail on the spool for processing.
private void sendcomposedtext ( ) { attributedstring as = new attributedstring ( buffer . tostring ( ) ) ; as . addattribute ( textattribute . input_method_highlight , inputmethodhighlight . selected_raw_text_highlight ) ; context . dispatchinputmethodevent ( inputmethodevent . input_method_text_changed , as . getiterator ( ) , _num , texthitinfo . leading ( insertionpoint ) , null ) ; }	send the composed text to the client .
public static dbmaker < ? > newdefaultdb ( string loc , enum < ? > e ) { return newdefaultdb ( loc , e . name ( ) ) ; }	creates a db for some enumeration.
public void removeaddendum ( string word , string partofspeech ) { addenda . remove ( word + fixpartofspeech ( partofspeech ) ) ; }	removes a word from the addenda .
@ override public void closearchiveentry ( ) throws ioexception { if ( finished ) { throw new ioexception ( _str ) ; } if ( entry == null ) { throw new ioexception ( _str ) ; } if ( ! entry . haswritten ) { write ( empty , _num , _num ) ; } flushdeflater ( ) ; final zip64mode effectivemode = geteffectivezip64mode ( entry . entry ) ; long byteswritten = written - entry . datastart ; long realcrc = crc . getvalue ( ) ; crc . reset ( ) ; final boolean actuallyneedszip64 = handlesizesandcrc ( byteswritten , realcrc , effectivemode ) ; if ( raf != null ) { rewritesizesandcrc ( actuallyneedszip64 ) ; } writedatadescriptor ( entry . entry ) ; entry = null ; }	writes all necessary data for this entry .
private double pdf ( double x , int j ) { int from = arrays . binarysearch ( x , x - h * k . cutoff ( ) ) ; int to = arrays . binarysearch ( x , x + h * k . cutoff ( ) ) ; from = from < _num ? - from - _num : from ; to = to < _num ? - to - _num : to ; if ( weights . length == _num && k instanceof uniformkf ) return ( to - from ) * _num / ( sumofweights * h ) ; double sum = _num ; for ( int i = math . max ( _num , from ) ; i < math . min ( x . length , to + _num ) ; i ++ ) if ( i != j ) sum += k . k ( ( x - x [ i ] ) / h ) * getweight ( i ) ; return sum / ( sumofweights * h ) ; }	computes the leave one out pdf of the estimator.
public jsheet ( frame owner ) { super ( owner ) ; init ( ) ; }	creates a new jsheet .
public string globalinfo ( ) { return _str + _str + _str + _str + _str + _str + _str + _str + _str + _str + _str + _str + _str ; }	returns a string describing this filter.
public static boolean parameterlistcontainsparametername ( list < iparameter > parameterlist , set < string > parameternames ) { boolean result = _bool ; for ( iparameter p : parameterlist ) { if ( parameternames . contains ( p . getname ( ) ) ) { result = _bool ; break ; } } return result ; }	search for the first appearance of a parameter in the list .
@ override protected void propertychange ( propertychangeevent evt ) { super . propertychange ( evt ) ; string name = evt . getpropertyname ( ) ; if ( name . equals ( _str ) ) { updateforeground ( ( color ) evt . getnewvalue ( ) ) ; } else if ( name . equals ( _str ) ) { updatefont ( ( font ) evt . getnewvalue ( ) ) ; } else if ( name . equals ( _str ) ) { jcomponent comp = getcomponent ( ) ; updateforeground ( comp . getforeground ( ) ) ; updatefont ( comp . getfont ( ) ) ; } }	this method gets called when a bound property is changed on the associated jtextcomponent.
public void puticon ( string extension , icon icon ) { icons . put ( extension , icon ) ; }	adds an icon based on the file type " dot " extension string , e.
public static @ dottedclassname string extractpackagename ( @ dottedclassname string classname ) { int i = classname . lastindexof ( _str ) ; if ( i < _num ) { return _str ; } return classname . substring ( _num , i ) ; }	extract the package name from a dotted class name.
public static byte [ ] tobytearray ( final biginteger value , final int numbytes ) { final byte [ ] outputbytes = new byte [ numbytes ] ; final byte [ ] bigintegerbytes = value . tobytearray ( ) ; int copystartindex = ( _num == bigintegerbytes [ _num ] ) ? _num : _num ; int numbytestocopy = bigintegerbytes . length - copystartindex ; if ( numbytestocopy > numbytes ) { copystartindex += numbytestocopy - numbytes ; numbytestocopy = numbytes ; } for ( int i = _num ; i < numbytestocopy ; ++ i ) { outputbytes [ i ] = bigintegerbytes [ copystartindex + numbytestocopy - i - _num ] ; } return outputbytes ; }	converts a biginteger to a little endian byte array .
public result filteronly ( list < string > sources ) { result ret = new result ( ) ; for ( resultentry l : this . log ) { if ( sources . contains ( l . getsource ( ) ) ) { ret . add ( l ) ; } } return ret ; }	complementary operation to filteronly.
public long scheduledexecutiontime ( ) { if ( expired ) { return - _num ; } else { return time . gettime ( ) ; } }	returns the time which this headtaskrunnable is scheduled .
public static void createdir ( file target ) throws adeusageexception { if ( ! target . exists ( ) && ! target . mkdir ( ) ) { throw new adeusageexception ( _str + target . getpath ( ) ) ; } }	create a directory if it does not already exist .
public void release ( ) { if ( hprogram >= _num ) gles20 . gldeleteprogram ( hprogram ) ; hprogram = - _num ; }	terminatinng , this should be called in gl context.
private void writelargedatatofile ( file file , int size ) throws filenotfoundexception , ioexception { fileoutputstream fos = new fileoutputstream ( file ) ; byte [ ] buf = new byte [ size ] ; try { fos . write ( buf ) ; } finally { fos . close ( ) ; } }	initializes large test file .
public notifications action ( action ... actions ) { this . actions = actions == null ? fxcollections . < action > observablearraylist ( ) : fxcollections . observablearraylist ( actions ) ; return this ; }	specify the actions that should be shown in the notification as buttons .
private static classnode createusableclassnodefromgenericstype ( final genericstype genericstype ) { classnode value = genericstype . gettype ( ) ; if ( genericstype . isplaceholder ( ) ) { value = object_type ; } classnode lowerbound = genericstype . getlowerbound ( ) ; if ( lowerbound != null ) { value = lowerbound ; } else { classnode [ ] upperbounds = genericstype . getupperbounds ( ) ; if ( upperbounds != null ) { value = wideningcategories . lowestupperbound ( arrays . aslist ( upperbounds ) ) ; } } return value ; }	given a genericstype instance , returns a classnode which can be used as an inferred type .
public boolean istrue ( string condition ) { boolean result = _bool ; if ( condition != null && condition . length ( ) > _num ) { string s = condition . substring ( _num , _num ) ; if ( s . equalsignorecase ( _str ) || s . equals ( _str ) || s . equalsignorecase ( _str ) ) result = _bool ; } return result ; }	convert string into boolean.
public fluxmapfuseable ( publisher < ? extends t > source , function < ? super t , ? extends r > mapper ) { super ( source ) ; this . mapper = objects . requirenonnull ( mapper , _str ) ; }	constructs a fluxmap instance with the given source and mapper .
public void createindexhash ( environment env ) { indexhashobject = new hashtable ( ) ; indexhashascii = new hashtable ( ) ; for ( int i = _num ; i < cpool . length ; i ++ ) { if ( types [ i ] == constant_utf8 ) { indexhashascii . put ( cpool [ i ] , new integer ( i ) ) ; } else { try { indexhashobject . put ( getconstant ( i , env ) , new integer ( i ) ) ; } catch ( classformaterror e ) { } } } }	create a hash table of all the items in the constant pool that could possibly be referenced from the outside .
public void testgetdateandtime ( ) { x509crlselector selector = new x509crlselector ( ) ; assertnull ( _str , selector . getdateandtime ( ) ) ; date date = new date ( _num ) ; selector . setdateandtime ( date ) ; asserttrue ( _str , date . equals ( selector . getdateandtime ( ) ) ) ; }	getdateandtime ( ) method testing.
private double determinealphamin ( int n , double [ ] alpha_min , hyperboundingbox interval ) { double alpha_n = extremum_alpha_n ( n , alpha_min ) ; double lower = interval . getmin ( n ) ; double upper = interval . getmax ( n ) ; double [ ] alpha_extreme = new double [ alpha_min . length ] ; system . arraycopy ( alpha_min , n , alpha_extreme , n , alpha_extreme . length - n ) ; alpha_extreme [ n ] = alpha_n ; extremumtype type = extremumtype ( n , alpha_extreme , interval ) ; if ( type . equals ( extremumtype . minimum ) || type . equals ( extremumtype . constant ) ) { if ( lower <= alpha_n && alpha_n <= upper ) { return alpha_n ; } else if ( alpha_n < lower ) { return lower ; } else { if ( alpha_n <= upper ) { throw new illegalstateexception ( _str ) ; } return upper ; } } else { if ( lower <= alpha_n && alpha_n <= upper ) { if ( alpha_n - lower <= upper - alpha_n ) { return upper ; } else { return lower ; } } else if ( alpha_n < lower ) { return upper ; } else { if ( alpha_n <= upper ) { throw new illegalstateexception ( _str ) ; } return lower ; } } }	determines the n - th alpha value where this function has a minimum in the specified interval .
public profiler startcollecting ( ) { thread = new thread ( this , _str ) ; thread . setdaemon ( _bool ) ; thread . start ( ) ; return this ; }	start collecting profiling data .
protected void checkrelease ( ) { if ( ! ispersistentobject ( ) && listeners . isempty ( ) && ! isacquired ( ) ) { log . info ( _str , name ) ; if ( storage != null ) { if ( ! storage . remove ( this ) ) { log . error ( _str ) ; } } close ( ) ; } }	check if shared object must be released .
public stemmedstring ( string orig , charsequence stemmed ) { strorig = orig ; strstemmed = stemmed . tostring ( ) ; }	create a stemmedstring from one charsequence ( stemmed ) and one string ( original ).
void decodestats ( ) throws ioexception { final int upto = ( int ) ord % interval ; final int oldblockord = statsblockord ; statsblockord = ( int ) ord / interval ; if ( oldblockord != statsblockord ) { refillstats ( ) ; } state . docfreq = docfreq [ upto ] ; state . totaltermfreq = totaltermfreq [ upto ] ; }	decodes stats data into term state.
public static integer zpvc ( number ... values ) { if ( values == null || values . length == _num ) { throw new illegalargumentexception ( _str ) ; } int count = _num ; for ( number value : values ) { if ( value != null && value . doublevalue ( ) >= _num ) { count ++ ; } } return count ; }	function which will return the count of zero or positive values among the given argument values .
public string tostring ( ) { object [ ] elements = getarray ( ) ; int maxindex = elements . length - _num ; stringbuffer buf = new stringbuffer ( ) ; buf . append ( _str ) ; for ( int i = _num ; i <= maxindex ; i ++ ) { buf . append ( string . valueof ( elements [ i ] ) ) ; if ( i < maxindex ) buf . append ( _str ) ; } buf . append ( _str ) ; return buf . tostring ( ) ; }	returns a string representation of this list , containing the string representation of each element .
private boolean movetofinalscrollerposition ( scroller scroller ) { scroller . forcefinished ( _bool ) ; int amounttoscroll = scroller . getfinaly ( ) - scroller . getcurry ( ) ; int futurescrolloffset = ( mcurrentscrolloffset + amounttoscroll ) % mselectorelementheight ; int overshootadjustment = minitialscrolloffset - futurescrolloffset ; if ( overshootadjustment != _num ) { if ( math . abs ( overshootadjustment ) > mselectorelementheight / _num ) { if ( overshootadjustment > _num ) { overshootadjustment -= mselectorelementheight ; } else { overshootadjustment += mselectorelementheight ; } } amounttoscroll += overshootadjustment ; scrollby ( _num , amounttoscroll ) ; return _bool ; } return _bool ; }	move to the final position of a scroller.
public void addgraph ( final graph graph ) { if ( graph == null ) { throw new illegalargumentexception ( _str ) ; } graphs . add ( graph ) ; }	add a graph object to bukkitmetrics that represents data for the plugin that should be sent to the backend.
public boolean equals ( int ignoreownelement , sequence sequence , int ignoreitselement ) { int ownindex = _num ; int itsindex = _num ; iterator < item > owniterator = itemiterator ( ) ; iterator < item > itsiterator = sequence . itemiterator ( ) ; while ( _bool ) { if ( ignoreownelement == ownindex ) { owniterator . next ( ) ; ownindex ++ ; } if ( ignoreitselement == itsindex ) { itsiterator . next ( ) ; itsindex ++ ; } if ( ! owniterator . hasnext ( ) || ! itsiterator . hasnext ( ) ) { if ( ! owniterator . hasnext ( ) && ! itsiterator . hasnext ( ) ) { return _bool ; } return _bool ; } item ownitem = owniterator . next ( ) ; item itsitem = itsiterator . next ( ) ; ownindex ++ ; itsindex ++ ; if ( ! ownitem . equals ( itsitem ) ) { return _bool ; } } }	this method implements an enhanced equals method where the specified elements of the sequences are treated as if not existent.
public void switchlistmode ( ) { adapter . setlistitemsize ( adapter . getlistitemsize ( ) == adapter_alerts . listitemsize . reduced ? adapter_alerts . listitemsize . expanded : adapter_alerts . listitemsize . reduced ) ; }	switch from flat to expanded list mode.
public void start ( int totalseeds , int maxnfe ) { this . totalseeds = totalseeds ; this . maxnfe = maxnfe ; lastseed = _num ; lastnfe = _num ; currentseed = _num ; currentnfe = _num ; statistics . clear ( ) ; starttime = system . currenttimemillis ( ) ; lasttime = starttime ; }	prepares this progress helper for use.
public void append ( resultentry entry ) throws ioexception { numberofentries ++ ; list < solution > feasiblesolutions = new arraylist < solution > ( ) ; for ( solution solution : entry . getpopulation ( ) ) { if ( ! solution . violatesconstraints ( ) ) { feasiblesolutions . add ( solution ) ; } } properties properties = entry . getproperties ( ) ; if ( feasiblesolutions . isempty ( ) && ( ( properties == null ) || ( properties . isempty ( ) ) ) ) { writer . println ( _str ) ; } if ( ( properties != null ) && ! properties . isempty ( ) ) { printproperties ( properties ) ; } if ( ! feasiblesolutions . isempty ( ) ) { for ( solution solution : feasiblesolutions ) { printsolution ( solution ) ; } } writer . println ( _str ) ; }	appends the decision variables , objectives and optional properties to the output file.
public void invalidate ( ) { net_no = - _num ; drill_list . clear ( ) ; }	invalidates the drills of this page so that they are recalculated at the next call of get_drills ( ) .
public void addpriorityunit ( int id ) { priorityunittargets . add ( id ) ; }	add an enemy unit to the priority list .
protected void writenetscapeext ( ) throws ioexception { out . write ( _num ) ; out . write ( _num ) ; out . write ( _num ) ; writestring ( _str + _str ) ; out . write ( _num ) ; out . write ( _num ) ; writeshort ( repeat ) ; out . write ( _num ) ; }	writes netscape application extension to define repeat count .
public static boolean ischaratequal ( string string , int index , char chartocompare ) { if ( ( index < _num ) || ( index >= string . length ( ) ) ) { return _bool ; } return string . charat ( index ) == chartocompare ; }	safely compares provided char with char on given location .
public synchronized void putquadtree ( string key , quadtree quadtree ) { quadtree . timestamp = system . currenttimemillis ( ) ; quadtreemap . put ( key , quadtree ) ; cleanupcache ( ) ; }	place a quadtree in the cache update the timestamp.
public void queue ( string entity , string event , string key ) { if ( broadcastevents == null ) return ; try { counter . incrementandget ( ) ; broadcastevents . putfirst ( new broadcastevent ( entity , event , key ) ) ; } catch ( exception e ) { counter . decrementandget ( ) ; logger . error ( _str , e ) ; } }	broadcast an event out.
public static string [ ] tostringarray ( object value ) { if ( value == null ) { return new string [ _num ] ; } class < ? > type = value . getclass ( ) ; if ( type . isarray ( ) == _bool ) { return new string [ ] { value . tostring ( ) } ; } class componenttype = type . getcomponenttype ( ) ; if ( componenttype . isprimitive ( ) ) { if ( componenttype == int . class ) { return arraysutil . tostringarray ( ( int [ ] ) value ) ; } else if ( componenttype == long . class ) { return arraysutil . tostringarray ( ( long [ ] ) value ) ; } else if ( componenttype == double . class ) { return arraysutil . tostringarray ( ( double [ ] ) value ) ; } else if ( componenttype == float . class ) { return arraysutil . tostringarray ( ( float [ ] ) value ) ; } else if ( componenttype == boolean . class ) { return arraysutil . tostringarray ( ( boolean [ ] ) value ) ; } else if ( componenttype == short . class ) { return arraysutil . tostringarray ( ( short [ ] ) value ) ; } else if ( componenttype == byte . class ) { return arraysutil . tostringarray ( ( byte [ ] ) value ) ; } else { throw new illegalargumentexception ( ) ; } } else { return arraysutil . tostringarray ( ( object [ ] ) value ) ; } }	converts an array object to array of strings , where every element of input array is converted to a string.
public creationtool ( figure prototype ) { this ( prototype , null , null ) ; }	creates a new instance with the specified prototype but without an attribute set.
private void skip ( pattern pattern ) throws decodeexception { matcher matcher = pattern . matcher ( gservalue . substring ( pos , length ) ) ; if ( matcher . find ( ) && matcher . groupcount ( ) >= _num ) { pos += matcher . end ( _num ) ; } else { final localizablemessage msg = warn_gser_pattern_no_match . get ( pattern . pattern ( ) , gservalue . substring ( pos , length ) ) ; throw decodeexception . error ( msg ) ; } }	skips the input matched by the first capturing group .
public boolean isdepreciated ( timestamp date ) { timestamp lastactiondate = getlastactiondate ( ) ; boolean isdepr = ! date . after ( lastactiondate ) ; log . fine ( _str + lastactiondate + _str + date + _str + isdepr ) ; return isdepr ; }	check if the asset is depreciated at the specified date.
public privilegedboot ( final string classname , final string [ ] args ) { this . classname = classname ; this . args = args ; }	creates a privilagedboot object .
public static < t > t wrapthrow ( callable < t > callable ) { try { return callable . call ( ) ; } catch ( runtimeexception e ) { throw e ; } catch ( exception e ) { throw new runtimeexception ( e ) ; } }	execute the callable wrapping checked exceptions inside a runtimeexception .
public string header ( string name ) { return ( string ) headers . get ( name . tolowercase ( ) ) ; }	the headers are stored and fetched as lower case .
public boolean addall ( int index , collection < ? extends e > c ) { object [ ] cs = c . toarray ( ) ; final reentrantlock lock = this . lock ; lock . lock ( ) ; try { object [ ] elements = getarray ( ) ; int len = elements . length ; if ( index > len || index < _num ) throw new indexoutofboundsexception ( _str + index + _str + len ) ; if ( cs . length == _num ) return _bool ; int nummoved = len - index ; object [ ] newelements ; if ( nummoved == _num ) newelements = arrays . copyof ( elements , len + cs . length ) ; else { newelements = new object [ len + cs . length ] ; system . arraycopy ( elements , _num , newelements , _num , index ) ; system . arraycopy ( elements , index , newelements , index + cs . length , nummoved ) ; } system . arraycopy ( cs , _num , newelements , index , cs . length ) ; setarray ( newelements ) ; return _bool ; } finally { lock . unlock ( ) ; } }	inserts all of the elements in the specified collection into this list , starting at the specified position.
public void andwith ( querypredicate predicate ) { children . add ( predicate ) ; }	adds a query predicate that must be met by vertices .
public string objecttostring ( final long shopid , final string skucode , final bigdecimal quantity ) { stringbuilder stringbuilder = new stringbuilder ( ) ; stringbuilder . append ( idbridge . objecttostring ( new bigdecimal ( shopid ) ) ) ; stringbuilder . append ( _str ) ; stringbuilder . append ( skucode ) ; stringbuilder . append ( _str ) ; stringbuilder . append ( qtybridge . objecttostring ( quantity ) ) ; return stringbuilder . tostring ( ) ; }	create index value for given shop currency and price .
public static string readfilecontents ( file file ) { stringbuilder scripttext = new stringbuilder ( ) ; string newline = system . getproperty ( _str ) ; scanner scanner = null ; try { scanner = new scanner ( new fileinputstream ( file ) ) ; while ( scanner . hasnextline ( ) ) { scripttext . append ( scanner . nextline ( ) + newline ) ; } } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } finally { scanner . close ( ) ; } return scripttext . tostring ( ) ; }	returns the contents of a file as a string .
public configsetshandler ( final corecontainer corecontainer ) { this . corecontainer = corecontainer ; }	overloaded ctor to inject corecontainer into the handler .
public boolean exists ( final string file ) { return exists ( file , _bool ) ; }	use this to check whether or not a file exists on the filesystem .
public static string bytestosequenceinccg ( final byte [ ] seq , final int start , final int length ) { final stringbuilder sb = new stringbuilder ( ) ; for ( int i = start ; i < start + length ; i ++ ) { if ( i < _num || i >= seq . length ) { sb . append ( _str ) ; } else if ( seq [ i ] != _num ) { sb . append ( bases [ seq [ i ] ] ) ; } } return sb . tostring ( ) ; }	convert a binary dna sequence to a human readable string using uppercase characters.
public void update ( int length , long rtpts ) throws ioexception { mpacketcount += _num ; moctetcount += length ; setlong ( mpacketcount , _num , _num ) ; setlong ( moctetcount , _num , _num ) ; now = systemclock . elapsedrealtime ( ) ; delta += oldnow != _num ? now - oldnow : _num ; oldnow = now ; if ( interval > _num ) { if ( delta >= interval ) { send ( system . nanotime ( ) , rtpts ) ; delta = _num ; } } }	updates the number of packets sent , and the total amount of data sent .
private void activerecyclerview ( list mymaps ) { recyclerview . layoutmanager layoutmanager ; mapsrv = ( recyclerview ) findviewbyid ( r . id . my_maps_download_recycler_view ) ; defaultitemanimator animator = new defaultitemanimator ( ) ; animator . setaddduration ( _num ) ; animator . setremoveduration ( _num ) ; mapsrv . setitemanimator ( animator ) ; mapsrv . sethasfixedsize ( _bool ) ; layoutmanager = new linearlayoutmanager ( this ) ; mapsrv . setlayoutmanager ( layoutmanager ) ; mydownloadadapter = new mydownloadadapter ( mymaps , this ) ; mapsrv . setadapter ( mydownloadadapter ) ; }	active directions , and directions view.
public int push ( int i ) { if ( ( m_firstfree + _num ) >= m_mapsize ) { m_mapsize += m_blocksize ; int newmap [ ] = new int [ m_mapsize ] ; system . arraycopy ( m_map , _num , newmap , _num , m_firstfree + _num ) ; m_map = newmap ; } m_map [ m_firstfree ] = i ; m_firstfree ++ ; return i ; }	pushes an item onto the top of this stack .
private static method findmethod ( object instance , string name , class < ? > ... parametertypes ) throws nosuchmethodexception { for ( class < ? > clazz = instance . getclass ( ) ; clazz != null ; clazz = clazz . getsuperclass ( ) ) { try { method method = clazz . getdeclaredmethod ( name , parametertypes ) ; if ( ! method . isaccessible ( ) ) { method . setaccessible ( _bool ) ; } return method ; } catch ( nosuchmethodexception e ) { } } throw new nosuchmethodexception ( _str + name + _str + arrays . aslist ( parametertypes ) + _str + instance . getclass ( ) ) ; }	locates a given method anywhere in the class inheritance hierarchy .
private static double distance ( double [ ] p1 , double [ ] p2 ) { double sum = _num ; for ( int i = _num ; i < p1 . length ; i ++ ) { sum += math . pow ( p2 [ i ] - p1 [ i ] , _num ) ; } return math . sqrt ( sum ) ; }	returns the euclidean distance between two points .
public boolean loadspec ( string rootexternalmodulename , errors errors ) throws abortexception { rootparseunit = findorcreateparsedunit ( rootexternalmodulename , errors , _bool ) ; rootmodule = rootparseunit . getrootmodule ( ) ; parseunit nextextentionorinstantiationparseunit = null ; while ( findnextunresolvedextention ( rootmodule ) || findnextunresolvedinstantiation ( rootmodule ) ) { if ( parseunitcontext . get ( nextparseunitname ) == null ) { nextextentionorinstantiationparseunit = findorcreateparsedunit ( nextparseunitname , errors , _bool ) ; } else { nextextentionorinstantiationparseunit = ( parseunit ) parseunitcontext . get ( nextparseunitname ) ; } parseunit extenderorinstancerparseunit = nextextenderorinstancermodule . getparseunit ( ) ; if ( extentionfound ) { extenderorinstancerparseunit . addextendee ( nextextentionorinstantiationparseunit ) ; nextextentionorinstantiationparseunit . addextendedby ( extenderorinstancerparseunit ) ; } if ( instantiationfound ) { extenderorinstancerparseunit . addinstancee ( nextextentionorinstantiationparseunit ) ; nextextentionorinstantiationparseunit . addinstancedby ( extenderorinstancerparseunit ) ; } noncircularitytest ( nextextentionorinstantiationparseunit , errors ) ; if ( extentionfound ) { resolvenamesbetweenspecandextention ( nextextenderorinstancermodule , nextextentionorinstantiationparseunit ) ; } if ( instantiationfound ) { resolvenamesbetweenspecandinstantiation ( nextextenderorinstancermodule , nextextentionorinstantiationparseunit ) ; } } calculatedependencies ( rootparseunit ) ; return _bool ; }	this method " loads " an entire specification , starting with the top - level rootexternalmodule and followed by all of the external modules it references via extends and instance statements .
public void add ( node n ) { list . add ( n ) ; root = null ; }	appends a node to the list.
private int processerror ( l10nmessageimpl e , string headermessagecode , string debugmessage , object ... messageparameters ) throws authloginexception { if ( null == e ) { return processerror ( headermessagecode , debugmessage , messageparameters ) ; } string headermessage ; if ( null == headermessagecode ) { headermessage = e . getl10nmessage ( getloginlocale ( ) ) ; } else { headermessage = bundle . getstring ( headermessagecode ) ; } if ( debugmessage != null ) { debug . error ( debugmessage , messageparameters , e ) ; } substituteheader ( state_error , headermessage ) ; return state_error ; }	writes out an error debug ( if a throwable and debug message are provided ) and returns a user - facing error page .
public static int clampmono ( int value ) { return math . max ( math . min ( value , _num ) , - _num ) ; }	clamp a mono audio sample to a valid range [ - 0x8000.
unittype ( datainputstream is ) throws ioexception { this . name = utilities . getstring ( is ) ; this . start = is . readint ( ) ; this . count = is . readint ( ) ; }	creates a unit type by reading it from the given input stream .
public void addresponse ( recordresponse response ) { if ( response . getresponsesize ( ) + getresponsesize ( ) > _num ) { throw new illegalargumentexception ( ) ; } if ( records == null ) { records = new recordresponse [ _num ] ; } else { recordresponse old [ ] = records ; records = new recordresponse [ old . length + _num ] ; system . arraycopy ( old , _num , records , _num , old . length ) ; } records [ records . length - _num ] = response ; setdatalength ( getresponsesize ( ) ) ; }	addresponse - - add a new record response .
public void flattenhierarchy ( constraintwidgetcontainer root ) { arraylist < constraintwidgetcontainer > containers = gathercontainers ( root ) ; while ( containers . size ( ) > _num ) { for ( constraintwidgetcontainer container : containers ) { removecontainer ( container ) ; } containers = gathercontainers ( root ) ; } }	flatten the hierachy - - remove all existing containers children of the given container.
@ override public boolean has ( pattern pattern ) { final matcher matcher = pattern . matcher ( rest ( ) ) ; return matcher . find ( ) && matcher . start ( ) == _num ; }	this method will determine whether the indicated pattern can be found at this point in the document or not.
public int hashcode ( ) { return arrays . hashcode ( chars ) ; }	returns the hash code for this set of characters.
public static int patchfast ( file oldfile , file newfile , file difffile , int extlen ) throws ioexception { if ( oldfile == null || oldfile . length ( ) <= _num ) { return return_old_file_err ; } if ( newfile == null ) { return return_new_file_err ; } if ( difffile == null || difffile . length ( ) <= _num ) { return return_diff_file_err ; } inputstream oldinputstream = new bufferedinputstream ( new fileinputstream ( oldfile ) ) ; byte [ ] diffbytes = new byte [ ( int ) difffile . length ( ) ] ; inputstream diffinputstream = new fileinputstream ( difffile ) ; try { bsutil . readfromstream ( diffinputstream , diffbytes , _num , diffbytes . length ) ; } finally { diffinputstream . close ( ) ; } byte [ ] newbytes = patchfast ( oldinputstream , ( int ) oldfile . length ( ) , diffbytes , extlen ) ; outputstream newoutputstream = new fileoutputstream ( newfile ) ; try { newoutputstream . write ( newbytes ) ; } finally { newoutputstream . close ( ) ; } return return_success ; }	this patch method is fast , but using more memory . memory size = oldbuf + diffbuf + newbuf.
public static double polynomialdistance ( double [ ] coeffs1 , double [ ] coeffs2 ) { if ( coeffs1 == null || coeffs2 == null ) throw new nullpointerexception ( _str ) ; if ( coeffs1 . length != coeffs2 . length ) throw new illegalargumentexception ( _str ) ; double dist = _num ; int order = coeffs1 . length - _num ; for ( int i = _num ; i <= order ; i ++ ) { dist += ( coeffs1 [ order - i ] - coeffs2 [ order - i ] ) / ( i + _num ) ; } return math . abs ( dist ) ; }	compute the integrated distance between two polynomials of same order.
public ecparameterspec ( ellipticcurve curve , ecpoint g , biginteger n , int h ) { if ( curve == null ) { throw new nullpointerexception ( _str ) ; } if ( g == null ) { throw new nullpointerexception ( _str ) ; } if ( n == null ) { throw new nullpointerexception ( _str ) ; } if ( n . signum ( ) != _num ) { throw new illegalargumentexception ( _str ) ; } if ( h <= _num ) { throw new illegalargumentexception ( _str ) ; } this . curve = curve ; this . g = g ; this . n = n ; this . h = h ; }	creates elliptic curve domain parameters based on the specified values .
private boolean isinstancemodificationevent ( hashtable < string , string > notification ) { string eventtype = _str ; boolean isinstancemodificationevent = boolean . false ; eventtype = notification . get ( cimconstants . indication_class_tag ) ; if ( eventtype != null && eventtype . length ( ) > _num && eventtype . contains ( cimconstants . inst_modification_event ) ) { isinstancemodificationevent = boolean . true ; } return isinstancemodificationevent ; }	this method helps to identify whether the provided indication type is instance modification event or not .
protected int addchildnode ( nodebuilder child ) { synchronized ( nodes ) { nodes . add ( child ) ; return nodes . size ( ) - _num ; } }	this method adds the supplied node builder as a child of this node builder .
public static byte [ ] tounsignedbytearray ( biginteger bi ) { if ( bi == null ) { return null ; } byte [ ] bb = bi . tobytearray ( ) ; if ( bb [ _num ] == _num ) { byte [ ] nozero = new byte [ bb . length - _num ] ; system . arraycopy ( bb , _num , nozero , _num , nozero . length ) ; return nozero ; } else { return bb ; } }	remove first byte if 0.
private void checklimits ( float temp , float year ) { if ( float . isnan ( overall_max_temp_ ) || temp > overall_max_temp_ ) overall_max_temp_ = temp ; if ( float . isnan ( overall_min_temp_ ) || temp < overall_min_temp_ ) overall_min_temp_ = temp ; if ( float . isnan ( overall_max_year_ ) || year > overall_max_year_ ) overall_max_year_ = year ; if ( float . isnan ( overall_min_year_ ) || year < overall_min_year_ ) overall_min_year_ = year ; }	see if these values for temp and year are outside of our current notion of how large our data space is . < p >.
private string createworkflowstepforrelinknativetargets ( workflow workflow , blocksnapshotsession tgtsnapsession , list < uri > snapshoturis , string waitfor , workflow . method rollbackmethod ) { uri parentsystemuri = tgtsnapsession . getstoragecontroller ( ) ; storagesystem parentsystem = getdataobject ( storagesystem . class , parentsystemuri , _dbclient ) ; workflow . method relinkmethod = new workflow . method ( relink_snapshot_session_targets_method_name , parentsystemuri , tgtsnapsession . getid ( ) , snapshoturis , boolean . false ) ; workflow . createstep ( relink_snapshot_session_target_step , string . format ( _str , snapshoturis , tgtsnapsession . getid ( ) ) , waitfor , parentsystemuri , parentsystem . getsystemtype ( ) , blockdevicecontroller . class , relinkmethod , rollbackmethod , null ) ; _log . info ( _str , snapshoturis , tgtsnapsession . getid ( ) ) ; return relink_snapshot_session_target_step ; }	create a step in the passed workflow to call the block controller to natively relink the passed linked targets to the passed target snapshot session .
public void auditaccessmessage ( string resource , string action , ssotoken token ) { init ( ) ; if ( accesslogger != null && msgprovider != null ) { final logrecord record = msgprovider . createlogrecord ( _str , new string [ ] { resource , action } , token ) ; if ( record != null ) { accesslogger . log ( record , accesscontroller . doprivileged ( admintokenaction . getinstance ( ) ) ) ; } } }	audits an attempted rest request , indicating which resource was accessed using which method linked to the ssotoken of the accessing user .
public static void write ( ompoint point , link link , linkproperties props ) throws ioexception { props . setproperty ( linkpoint . lpc_point_oval , point . isoval ( ) ? _str : _str ) ; switch ( point . getrendertype ( ) ) { case ompoint . rendertype_latlon : linkpoint . write ( ( float ) point . getlat ( ) , ( float ) point . getlon ( ) , point . getradius ( ) , props , link . dos ) ; break ; case ompoint . rendertype_xy : linkpoint . write ( point . getx ( ) , point . gety ( ) , point . getradius ( ) , props , link . dos ) ; break ; case ompoint . rendertype_offset : linkpoint . write ( ( float ) point . getlat ( ) , ( float ) point . getlon ( ) , point . getx ( ) , point . gety ( ) , point . getradius ( ) , props , link . dos ) ; break ; default : debug . error ( _str ) ; } }	write an ompoint to the link .
public static byte [ ] reversedwordbytes ( byte [ ] bytes , int trimlength ) { checkargument ( bytes . length % _num == _num ) ; checkargument ( trimlength < _num || trimlength % _num == _num ) ; byte [ ] rev = new byte [ trimlength >= _num && bytes . length > trimlength ? trimlength : bytes . length ] ; for ( int i = _num ; i < rev . length ; i += _num ) { system . arraycopy ( bytes , i , rev , i , _num ) ; for ( int j = _num ; j < _num ; j ++ ) { rev [ i + j ] = bytes [ i + _num - j ] ; } } return rev ; }	returns a copy of the given byte array with the bytes of each double - word ( 4 bytes ) reversed .
public v remove ( a arg ) { future < v > future = cache . remove ( arg ) ; v res = null ; if ( future != null ) { try { res = future . get ( ) ; } catch ( interruptedexception | executionexception ignore ) { } } return res ; }	removes the value to which the specified key is mapped , or null otherwise . note : this is a blocking call.
@ override public boolean test ( object receiver , string property , object [ ] args , object expectedvalue ) { if ( is_angular2_project_property . equals ( property ) ) { return testistypescriptproject ( receiver ) ; } return _bool ; }	tests if the receiver object is a project is a angular2 project.
public playerminednumberofitemscondition ( int number , string ... items ) { itemminedlist = new arraylist < string > ( ) ; if ( items != null ) { for ( string item : items ) { itemminedlist . add ( item ) ; } } quantity = number ; }	create a new playerminednumberofitemscondition.
public static map < string , object > makevalidcontext ( modelservice model , string mode , map < string , ? extends object > context ) throws genericserviceexception { map < string , object > newcontext ; int modeint = _num ; if ( mode . equalsignorecase ( _str ) ) { modeint = _num ; } else if ( mode . equalsignorecase ( _str ) ) { modeint = _num ; } if ( model == null ) { throw new genericserviceexception ( _str ) ; } else { switch ( modeint ) { case _num : newcontext = model . makevalid ( context , modelservice . out_param , _bool , null ) ; break ; case _num : newcontext = model . makevalid ( context , modelservice . in_param , _bool , null ) ; break ; default : throw new genericserviceexception ( _str ) ; } return newcontext ; } }	uses an existing map of name value pairs and extracts the keys which are used in servicename note : this goes not guarantee the context will be 100 % valid , there may be missing fields.
public static void addoreweight ( string ore , int weight ) { oreweights . put ( ore , weight ) ; }	maps an ore ( ore dictionary key ) to it ' s weight on the world generation.
protected pair < class < ? extends page > , pageparameters > determinecanceltarget ( boolean ischeckout , final customer customer ) { return determinesuccesstarget ( ischeckout , customer ) ; }	extension hook to override classes for themes .
public void startelement ( stylesheethandler handler , string uri , string localname , string rawname , attributes attributes ) throws org . xml . sax . saxexception { super . startelement ( handler , uri , localname , rawname , attributes ) ; try { xsltelementdef def = getelemdef ( ) ; class classobject = def . getclassobject ( ) ; elemtemplateelement elem = null ; try { elem = ( elemtemplateelement ) classobject . newinstance ( ) ; elem . setdombackpointer ( handler . getoriginatingnode ( ) ) ; elem . setlocaterinfo ( handler . getlocator ( ) ) ; elem . setprefixes ( handler . getnamespacesupport ( ) ) ; } catch ( instantiationexception ie ) { handler . error ( xslterrorresources . er_failed_creating_elemtmpl , null , ie ) ; } catch ( illegalaccessexception iae ) { handler . error ( xslterrorresources . er_failed_creating_elemtmpl , null , iae ) ; } setpropertiesfromattributes ( handler , rawname , attributes , elem ) ; appendandpush ( handler , elem ) ; } catch ( transformerexception te ) { throw new org . xml . sax . saxexception ( te ) ; } }	receive notification of the start of an element .
private boolean checkexternalstorageandnotify ( string filename , string fulldirpath , string externalstoragestatus ) { if ( fulldirpath == null ) { log . e ( tag , _str ) ; alertdownloadfailure ( filename ) ; return _bool ; } if ( ! externalstoragestatus . equals ( environment . media_mounted ) ) { if ( externalstoragestatus . equals ( environment . media_shared ) ) { log . e ( tag , _str ) ; } else { log . e ( tag , _str ) ; } alertdownloadfailure ( filename ) ; return _bool ; } return _bool ; }	check the external storage and notify user on error .
private void updatestorageportsforaddinitiators ( exportmaskaddinitiatorcompleter taskcompleter , storagesystem system , exportmask exportmask , list < com . emc . storageos . db . client . model . initiator > initiatorlist , list < com . emc . storageos . db . client . model . storageport > selectedportsformask , uri virtualarray , exportpathparams pathparams ) { list < uri > porturis = new arraylist < > ( ) ; for ( com . emc . storageos . db . client . model . storageport port : selectedportsformask ) { porturis . add ( port . getid ( ) ) ; } taskcompleter . settargeturis ( porturis ) ; list < uri > initiatoruris = uriutil . touris ( initiatorlist ) ; for ( uri initiatoruri : initiatoruris ) { exportmask . removezoningmapentry ( initiatoruri . tostring ( ) ) ; } map < uri , list < uri > > assignments = blockscheduler . assignselectedstorageports ( system , selectedportsformask , virtualarray , initiatorlist , pathparams , exportmask . getzoningmap ( ) ) ; exportmask . addzoningmap ( blockstoragescheduler . getzonemapfromassignments ( assignments ) ) ; dbclient . updateobject ( exportmask ) ; }	this method updates storage ports in export masks for new initiators , based on array selected ports .
public static boolean usenamesuggestions ( set < string > usedkeys ) { return ! ( usedkeys . contains ( tags . key_highway ) || usedkeys . contains ( tags . key_waterway ) || usedkeys . contains ( tags . key_landuse ) || usedkeys . contains ( tags . key_natural ) || usedkeys . contains ( tags . key_railway ) ) ; }	return true if the edited object could have a name in the name index.
public vnxecommandresult removelunsfromlungroup ( string lungroupid , list < string > luns ) { lungroupmodifyparam param = new lungroupmodifyparam ( ) ; list < lunaddparam > lunremoves = new arraylist < lunaddparam > ( ) ; for ( string lunid : luns ) { vnxebase lun = new vnxebase ( lunid ) ; lunaddparam lunadd = new lunaddparam ( ) ; lunadd . setlun ( lun ) ; lunremoves . add ( lunadd ) ; } param . setlunremove ( lunremoves ) ; lungrouprequests req = new lungrouprequests ( _khclient ) ; return req . modifylungroupsync ( lungroupid , param ) ; }	remove luns from the lun group.
public static boolean isinvoicetype ( genericvalue invoice , string inputtypeid ) throws genericentityexception { if ( invoice == null ) { return _bool ; } genericvalue invoicetype = invoice . getrelatedone ( _str , _bool ) ; if ( invoicetype == null ) { throw new genericentityexception ( _str + invoice . getstring ( _str ) ) ; } string invoicetypeid = invoicetype . getstring ( _str ) ; if ( inputtypeid . equals ( invoicetypeid ) ) { return _bool ; } return isinvoicetyperecurse ( invoicetype , inputtypeid ) ; }	checks if a invoice is of a specified invoicetype.
watch watch ( compilationrequest request ) { watch watch = requestforthread . get ( ) ; if ( watch == null ) { watch = new watch ( ) ; synchronized ( requests ) { requests . put ( thread . currentthread ( ) , watch ) ; } } watch . open ( request ) ; return watch ; }	opens a scope for watching the compilation of a given method .
public orderbyclause add ( string property , boolean isdescending ) { orderbyexpressions . add ( new orderbyelement ( expressions . getpropexpr ( property ) , isdescending ) ) ; return this ; }	adds a property and flag .
public void addcancellistener ( actionlistener a ) { m_cancelbut . addactionlistener ( a ) ; }	this is used to hook an action listener to the cancel button .
@ deprecated protected final class < ? > defineclass ( byte [ ] classrep , int offset , int length ) throws classformaterror { return defineclass ( null , classrep , offset , length ) ; }	constructs a new class from an array of bytes containing a class definition in class file format .
public static void extractidat ( inputstream is , outputstream os , boolean stripfilterbyte , boolean checkcrc ) { try { chunkseqpngrawpixels cr = new chunkseqpngrawpixels ( is , os ) ; cr . setcheckcrc ( checkcrc ) ; cr . setomitfilterbyte ( stripfilterbyte ) ; cr . readall ( ) ; is . close ( ) ; os . close ( ) ; } catch ( ioexception e ) { throw new pngjexception ( e ) ; } }	reads a png and and writes the uncompressed unfiltered raw stream to os.
private void completecommits ( long previouscommitindex , long commitindex ) { for ( long i = previouscommitindex + _num ; i <= commitindex ; i ++ ) { completablefuture < long > future = appendfutures . remove ( i ) ; if ( future != null ) { future . complete ( i ) ; } } }	completes append entries attempts up to the given index .
public concurrentskiplistmap ( sortedmap < k , ? extends v > m ) { this . comparator = m . comparator ( ) ; initialize ( ) ; buildfromsorted ( m ) ; }	constructs a new map containing the same mappings and using the same ordering as the specified sorted map .
private void handleexception ( string message , exception exception ) { boolean unexpected = ! quitting ( ) ; if ( unexpected && ! ( exception instanceof cancelexception ) ) { logger . warn ( localizedmessage . create ( localizedstrings . cacheclientupdater_0__1__2 , new object [ ] { this , message , exception } ) , exception ) ; } }	conditionally print a warning describing the failure < p > signals run thread to stop.
private void updatemediainformationlists ( movie movie ) { list < string > availablecodecs = new arraylist < > ( videocodecsobservable ) ; for ( mediafile mf : movie . getmediafiles ( mediafiletype . video ) ) { string codec = mf . getvideocodec ( ) ; boolean codecfound = _bool ; for ( string mfcodec : availablecodecs ) { if ( mfcodec . equals ( codec ) ) { codecfound = _bool ; break ; } } if ( ! codecfound ) { addvideocodec ( codec ) ; } } availablecodecs = new arraylist < > ( audiocodecsobservable ) ; for ( mediafile mf : movie . getmediafiles ( mediafiletype . video ) ) { for ( mediafileaudiostream audio : mf . getaudiostreams ( ) ) { string codec = audio . getcodec ( ) ; boolean codecfound = _bool ; for ( string mfcodec : availablecodecs ) { if ( mfcodec . equals ( codec ) ) { codecfound = _bool ; break ; } } if ( ! codecfound ) { addaudiocodec ( codec ) ; } } } }	update media information used in movies .
public collectionrelationshipprovider ( final connectionfactory connectionfactory , final resourcepath resourcepath , final schemafield schemafield , final activitylogger activitylogger , final managedobjectsetservice managedobjectsyncservice ) { super ( connectionfactory , resourcepath , schemafield , activitylogger , managedobjectsyncservice ) ; final router router = new router ( ) ; router . addroute ( routingmode . starts_with , uritemplate ( string . format ( _str , param_managed_object_id , schemafield . getname ( ) ) ) , resources . newhandler ( this ) ) ; this . requesthandler = router ; }	create a new relationship set for the given managed resource.
public static boolean shouldhighlightmethd ( string sootmethodsignature ) { return methodstohighlight . contains ( sootmethodsignature ) ; }	return true if the soot method signature is in the list of methods to highlight .
private boolean autoreconnect ( int count ) { if ( ! isclosed ( ) ) { return _bool ; } if ( ! autoreconnect ) { return _bool ; } if ( ! cluster && ! autocommit ) { return _bool ; } if ( count > sysproperties . max_reconnect ) { return _bool ; } lastreconnect ++ ; while ( _bool ) { try { embedded = connectembeddedorserver ( _bool ) ; break ; } catch ( dbexception e ) { if ( e . geterrorcode ( ) != errorcode . database_is_in_exclusive_mode ) { throw e ; } try { thread . sleep ( _num ) ; } catch ( exception e2 ) { } } } if ( embedded == this ) { embedded = null ; } else { connectembeddedorserver ( _bool ) ; } recreatesessionstate ( ) ; if ( eventlistener != null ) { eventlistener . setprogress ( databaseeventlistener . state_reconnected , databasename , count , sysproperties . max_reconnect ) ; } return _bool ; }	automatically re - connect if necessary and if configured to do so .
protected void finalize ( ) { synchronized ( statsmap ) { statsmap . remove ( statsname ) ; } synchronized ( this ) { if ( statsfile == null ) { return ; } statsstate = stats . off ; statsfile . flush ( ) ; statsfile . close ( ) ; statsfile = null ; } }	flushes and then closes the stats file .
void declare ( string name , type type ) { if ( reservedwords . contains ( name ) ) throw new runtimeexception ( name + _str ) ; if ( table . containskey ( name ) ) throw new runtimeexception ( _str + name + _str ) ; symbol symbol = new symbol ( this , name , type ) ; table . put ( name , symbol ) ; stackmap . add ( new declaration ( symbol ) ) ; }	declare a new variable.
protected void addxml11component ( xmlcomponent component ) { if ( fxml11components . contains ( component ) ) { return ; } fxml11components . add ( component ) ; addrecognizedparamsandsetdefaults ( component ) ; }	adds an xml 1.
private set < string > waitformacappquit ( string browser ) { set < string > runningapps ; boolean appclosed = _bool ; final long startmillis = system . currenttimemillis ( ) ; final long waitmillis = _num ; do { runningapps = runningapplications ( ) ; if ( runningapps . contains ( browser ) ) { appclosed = _bool ; try { thread . sleep ( waitmillis ) ; } catch ( interruptedexception e ) { return runningapps ; } long currentmillis = system . currenttimemillis ( ) ; if ( currentmillis - startmillis >= max_terminate_wait_millis ) break ; } else { appclosed = _bool ; } } while ( ! appclosed ) ; return runningapps ; }	utility function to wait for a mac application to quit.
public static void assertarrayequals ( string message , object [ ] expected , object [ ] actual ) { if ( expected == null ) { assertequals ( ( object ) null , actual ) ; return ; } if ( actual == null ) { throw new assertionfailederror ( message + _str + arrays . tostring ( expected ) + _str ) ; } assertequals ( message + _str , expected . length , actual . length ) ; for ( int i = _num ; i < expected . length ; i ++ ) { assertequals ( message , expected [ i ] , actual [ i ] ) ; } }	tests all objects in the array .
@ override public void remove ( ) { m_src . remove ( ) ; }	delegates remove request to source iterator.
public static tcfeature create ( class < ? extends resource > featurename , object ... parameters ) { string id = featurename . getsimplename ( ) + system . nanotime ( ) ; list < object > params = getparameterasstring ( parameters ) ; params . add ( featureextractorresource_implbase . param_unique_extractor_name ) ; params . add ( id ) ; tcfeature tcfeature = new tcfeature ( featurename , id , params . toarray ( ) ) ; return tcfeature ; }	creates a new instance of a tcfeature.
public void print ( object x ) { out . print ( x ) ; out . flush ( ) ; }	prints an object to this output stream and flushes this output stream .
public byte [ ] serialize ( ) { if ( currentbytearrayindex == _num ) { return new byte [ _num ] ; } final byte [ ] extractedserializeddata = new byte [ currentbytearrayindex ] ; system . arraycopy ( serializeddata , _num , extractedserializeddata , _num , currentbytearrayindex ) ; return extractedserializeddata ; }	finishes serialization , returning the object as a byte array .
public synchronized int length ( ) { return value . size ( ) ; }	returns the length of the array .
public static byte [ ] readall ( inputstream instr ) throws ioexception { bytearrayoutputstream buf = new bytearrayoutputstream ( ) ; pipeall ( instr , buf ) ; return buf . tobytearray ( ) ; }	read stream fully , returning contents in a byte array .
public static list < list < file > > findjavafilesperdirectory ( file parent , string ... dirnames ) { list < list < file > > filesperdirectory = new arraylist < > ( ) ; for ( string dirname : dirnames ) { file dir = new file ( parent , dirname ) ; if ( dir . isdirectory ( ) ) { filesperdirectory . addall ( findjavatestfilesindirectory ( dir ) ) ; } } return filesperdirectory ; }	returns a list where each item is a list of java files , excluding any skip tests , for each directory given by dirname and also a list for any subdirectory .
private bytebuffer decodestream ( ) throws ioexception { bytebuffer outstream = null ; if ( decodedstream != null ) { outstream = ( bytebuffer ) decodedstream . get ( ) ; } if ( outstream == null ) { stream . rewind ( ) ; outstream = pdfdecoder . decodestream ( this , stream ) ; decodedstream = new softreference ( outstream ) ; } return outstream ; }	get the decoded stream value.
private boolean isallportslooped ( list < uri > orderednetworks , map < uri , list < storageport > > allocatableports , set < string > usedports ) { for ( uri networkuri : orderednetworks ) { for ( storageport port : allocatableports . get ( networkuri ) ) { if ( ! usedports . contains ( port . getportname ( ) ) ) { return _bool ; } } } return _bool ; }	checks if is all given ports have been processed or selected .
public static string tostring ( int rank , int suit ) { stringbuffer sb = new stringbuffer ( ) ; switch ( rank ) { case ace : sb . append ( aceabbreviation ) ; break ; case jack : sb . append ( jackabbreviation ) ; break ; case queen : sb . append ( queenabbreviation ) ; break ; case king : sb . append ( kingabbreviation ) ; break ; default : if ( rank < _num ) throw new illegalargumentexception ( _str ) ; if ( rank > _num ) throw new illegalargumentexception ( _str ) ; sb . append ( rank ) ; } switch ( suit ) { case clubs : sb . append ( clubsabbreviation ) ; break ; case diamonds : sb . append ( diamondsabbreviation ) ; break ; case hearts : sb . append ( heartsabbreviation ) ; break ; case spades : sb . append ( spadesabbreviation ) ; break ; default : throw new illegalargumentexception ( _str ) ; } return sb . tostring ( ) ; }	static method for converting a specific rank / suit into its string representation . creation date : ( 10 / 1 / 01 8 : 53 : 13 pm ).
public hbaselogbyrowkeyreader ( string table , string columnfamily , boolean includingallqualifiers , list < string > qualifiers ) { this . table = table ; this . columnfamily = columnfamily ; if ( qualifiers != null ) { this . outputqualifiers = new byte [ qualifiers . size ( ) ] [ ] ; int i = _num ; for ( string qualifier : qualifiers ) { this . outputqualifiers [ i ++ ] = qualifier . getbytes ( ) ; } } this . includingallqualifiers = includingallqualifiers ; }	if includingallqualifiers is true , then the fourth argument outputqualifiers is ignored if includingallqualifiers is false , then need calculate based on the fourth argument outputqualifiers.
public void fadeinalllayers ( ) { mtransitionstate = transition_starting ; arrays . fill ( mislayeron , _bool ) ; invalidateself ( ) ; }	starts fading in all layers .
private int stripsourceroute ( string address , int pos ) { if ( pos < address . length ( ) ) { if ( address . charat ( pos ) == _str ) { int i = address . indexof ( _str ) ; if ( i != - _num ) { pos = i + _num ; } } } return pos ; }	strips source routing . according to rfc - 2821 it is a valid approach to handle mails containing rfc - 821 source - route information .
public static boolean implementszeroargmethod ( classnode classnode , string methodname ) { return implementsmethod ( classnode , methodname , new class [ _num ] ) ; }	tests whether the clasnode implements the specified method name.
public int parse ( char c , char [ ] ia , int ip , int il ) { assert ( ia [ ip ] == c ) ; if ( character . ishighsurrogate ( c ) ) { if ( il - ip < _num ) { error = coderresult . underflow ; return - _num ; } char d = ia [ ip + _num ] ; if ( character . islowsurrogate ( d ) ) { character = character . tocodepoint ( c , d ) ; ispair = _bool ; error = null ; return character ; } error = coderresult . malformedforlength ( _num ) ; return - _num ; } if ( character . islowsurrogate ( c ) ) { error = coderresult . malformedforlength ( _num ) ; return - _num ; } character = c ; ispair = _bool ; error = null ; return character ; }	parses a ucs - 4 character from the given source buffer , handling surrogates .
public value read ( type type , nodemap node , map map ) throws exception { class actual = readvalue ( type , node ) ; class expect = type . gettype ( ) ; if ( expect . isarray ( ) ) { return readarray ( actual , node ) ; } if ( expect != actual ) { return new objectvalue ( actual ) ; } return null ; }	this is used to resolve and load a class for the given element.
public static oembed createoembed ( final string rawjson ) throws twitterexception { try { final jsonobject json = new jsonobject ( rawjson ) ; return oembedconstructor . newinstance ( json ) ; } catch ( final instantiationexception e ) { throw new twitterexception ( e ) ; } catch ( final illegalaccessexception e ) { throw new assertionerror ( e ) ; } catch ( final invocationtargetexception e ) { throw new twitterexception ( e ) ; } catch ( final jsonexception e ) { throw new twitterexception ( e ) ; } }	constructs an oembed object from rawjson string .
private arraylist < cluster > defineclustersrandom ( random random ) throws exception { arraylist < cluster > clusters = new arraylist < cluster > ( m_numclusters ) ; double diffinstnum = m_maxinstnum - m_mininstnum ; double mininstnum = m_mininstnum ; double diffradius = m_maxradius - m_minradius ; cluster cluster ; for ( int i = _num ; i < m_numclusters ; i ++ ) { int instnum = ( int ) ( random . nextdouble ( ) * diffinstnum + mininstnum ) ; double radius = ( random . nextdouble ( ) * diffradius ) + m_minradius ; cluster = new cluster ( instnum , radius , random ) ; clusters . add ( cluster ) ; } return clusters ; }	defines the clusters if pattern is random.
public static synchronized fsentityresolver instance ( ) { if ( instance == null ) { instance = new fsentityresolver ( ) ; } return instance ; }	gets an instance of this class .
public static long pop_xor ( long [ ] arr1 , long [ ] arr2 , int wordoffset , int numwords ) { long popcount = _num ; for ( int i = wordoffset , end = wordoffset + numwords ; i < end ; ++ i ) { popcount += long . bitcount ( arr1 [ i ] ^ arr2 [ i ] ) ; } return popcount ; }	returns the popcount or cardinality of a ^ b neither array is modified .
public dbexception ( exception e , string sql , object [ ] params ) { this ( e ) ; m_sql = sql ; if ( params != null ) m_params = arrays . copyof ( params , params . length ) ; }	create a new dbexception based on a sqlexception and sql query.
public static < t > t first ( list < t > l ) { return l . get ( _num ) ; }	get the first element from a list .
protected string [ ] removeblacklist ( string [ ] options ) { hashtable < string , option > pool ; option option ; enumeration < option > enm = listoptions ( ) ; pool = new hashtable < string , option > ( ) ; while ( enm . hasmoreelements ( ) ) { option = enm . nextelement ( ) ; if ( isonblacklist ( option . name ( ) ) ) { pool . put ( option . name ( ) , option ) ; } } enumeration < string > enm2 = pool . keys ( ) ; while ( enm2 . hasmoreelements ( ) ) { option = pool . get ( enm2 . nextelement ( ) ) ; try { if ( option . numarguments ( ) == _num ) { utils . getflag ( option . name ( ) , options ) ; } else { utils . getoption ( option . name ( ) , options ) ; } } catch ( exception e ) { e . printstacktrace ( ) ; } } return options ; }	removes all the options from the options array that are blacklisted.
static public serialsensormanager instance ( ) { if ( _instance == null ) { _instance = new serialsensormanager ( ) ; } return _instance ; }	static function returning the serialsensormanager instance to use .
@ override protected void onactivityresult ( int requestcode , int resultcode , intent data ) { if ( requestcode == get_code ) { editable text = ( editable ) mresults . gettext ( ) ; if ( resultcode == result_canceled ) { text . append ( _str ) ; } else { text . append ( _str ) ; text . append ( integer . tostring ( resultcode ) ) ; text . append ( _str ) ; if ( data != null ) { text . append ( data . getaction ( ) ) ; } } text . append ( _str ) ; } }	this method is called when the sending activity has finished , with the result it supplied .
private static void rdf_nodeelement ( xmpmetaimpl xmp , xmpnode xmpparent , node xmlnode , boolean istoplevel ) throws xmpexception { int nodeterm = getrdftermkind ( xmlnode ) ; if ( nodeterm != rdfterm_description && nodeterm != rdfterm_other ) { throw new xmpexception ( _str , badrdf ) ; } else if ( istoplevel && nodeterm == rdfterm_other ) { throw new xmpexception ( _str , badxmp ) ; } else { rdf_nodeelementattrs ( xmp , xmpparent , xmlnode , istoplevel ) ; rdf_propertyelementlist ( xmp , xmpparent , xmlnode , istoplevel ) ; } }	7 . 2 . 5 nodeelementuris anyuri - ( coresyntaxterms | rdf : li | oldterms ) 7 . 2 . 11 nodeelement start - element ( uri = = nodeelementuris , attributes = = set ( ( idattr | nodeidattr | aboutattr ) ? , propertyattr * ) ) propertyeltlist end - element ( ) a node element uri is rdf : description or anything else that is not an rdf term .
public list tolist ( ) { object [ ] copiedelements = new object [ numelements ] ; system . arraycopy ( elements , _num , copiedelements , _num , numelements ) ; return arrays . aslist ( copiedelements ) ; }	returns a unbacked list of elements in this set .
public void updatevarsandterminals ( ) { if ( rules == null ) { vars = new arraylist < string > ( ) ; terminals = new arraylist < string > ( ) ; return ; } for ( int i = _num ; i < rules . size ( ) ; i ++ ) { rule r = rules . get ( i ) ; updatevarsandterminals ( r ) ; } }	whenever a new rule is added to the grammar , we want to update the list of variables and terminals with any new grammar symbols.
public void additems ( int howmany ) { if ( howmany > _num ) { for ( int i = lastinsertedindex + _num ; i <= lastinsertedindex + howmany ; i ++ ) { items . add ( _str + i ) ; notifyiteminserted ( items . size ( ) - _num ) ; } lastinsertedindex = lastinsertedindex + howmany ; } }	utility method to add some rows for testing purposes.
private void initresourcebundle ( uidefaults table ) { table . setdefaultlocale ( locale . getdefault ( ) ) ; table . addresourcebundle ( _str ) ; }	initialize the defaults table with the name of the resourcebundle used for getting localized defaults.
public boolean matches ( ) { return regexmatcher . matches ( ) ; }	attempts to match the entire region against the pattern including grok predicates .
public static void putbyte ( bytebuffer bb , short value ) { bb . put ( ( byte ) ( value & _num ) ) ; }	put a byte into the byte buffer unsigned .
public extendedmessageformat ( final string pattern ) { this ( pattern , locale . getdefault ( ) ) ; }	create a new extendedmessageformat for the default locale .
public void startelement ( string namespaceuri , string localname , string name , attributes atts ) throws org . xml . sax . saxexception { if ( m_inentityref ) return ; if ( m_needtocallstartdocument ) { startdocumentinternal ( ) ; m_needtocallstartdocument = _bool ; m_docisempty = _bool ; } else if ( m_cdatatagopen ) closecdata ( ) ; try { if ( m_needtooutputdoctypedecl ) { if ( null != getdoctypesystem ( ) ) { outputdoctypedecl ( name , _bool ) ; } m_needtooutputdoctypedecl = _bool ; } if ( m_elemcontext . m_starttagopen ) { closestarttag ( ) ; m_elemcontext . m_starttagopen = _bool ; } if ( namespaceuri != null ) ensureprefixisdeclared ( namespaceuri , name ) ; m_ispreserve = _bool ; if ( shouldindent ( ) && m_startnewline ) { indent ( ) ; } m_startnewline = _bool ; final java . io . writer writer = m_writer ; writer . write ( _str ) ; writer . write ( name ) ; } catch ( ioexception e ) { throw new saxexception ( e ) ; } if ( atts != null ) addattributes ( atts ) ; m_elemcontext = m_elemcontext . push ( namespaceuri , localname , name ) ; m_isprevtext = _bool ; if ( m_tracer != null ) firepseudoattributes ( ) ; }	receive notification of the beginning of an element , although this is a sax method additional namespace or attribute information can occur before or after this call , that is associated with this element .
private static void docopyfile ( file srcfile , file destfile , boolean preservefiledate ) throws ioexception { if ( destfile . exists ( ) && destfile . isdirectory ( ) ) { throw new ioexception ( _str + destfile + _str ) ; } fileinputstream fis = null ; fileoutputstream fos = null ; filechannel input = null ; filechannel output = null ; try { fis = new fileinputstream ( srcfile ) ; fos = new fileoutputstream ( destfile ) ; input = fis . getchannel ( ) ; output = fos . getchannel ( ) ; long size = input . size ( ) ; long pos = _num ; long count = _num ; while ( pos < size ) { count = size - pos > file_copy_buffer_size ? file_copy_buffer_size : size - pos ; pos += output . transferfrom ( input , pos , count ) ; } } finally { ioutils . closequietly ( output ) ; ioutils . closequietly ( fos ) ; ioutils . closequietly ( input ) ; ioutils . closequietly ( fis ) ; } if ( srcfile . length ( ) != destfile . length ( ) ) { throw new ioexception ( _str + srcfile + _str + destfile + _str ) ; } if ( preservefiledate ) { destfile . setlastmodified ( srcfile . lastmodified ( ) ) ; } }	internal copy file method .
private void computerotationtime ( ) { _keyrotationintervalinmsecs = _maxlifevaluesholder . computerotationtimeinmsecs ( ) ; _log . info ( _str , _keyrotationintervalinmsecs ) ; }	initializes the rotation time based on the max token life value .
public void publish ( final string queuename , final string routingkey , final string message ) { if ( ( mchannel != null ) && mchannel . isopen ( ) ) { try { mchannel . basicpublish ( queuename , routingkey , null , message . getbytes ( http . utf_8 ) ) ; } catch ( final unsupportedencodingexception e ) { e . printstacktrace ( ) ; } catch ( final ioexception e ) { e . printstacktrace ( ) ; } } }	publish a message to a queue.
private void translateheader ( float of ) { float ofcalculated = of * mscrollmultiplier ; if ( build . version . sdk_int >= build . version_codes . honeycomb && of < mheaderview . getheight ( ) ) { mheaderview . settranslationy ( ofcalculated ) ; } else if ( of < mheaderview . getheight ( ) ) { translateanimation anim = new translateanimation ( _num , _num , ofcalculated , ofcalculated ) ; anim . setfillafter ( _bool ) ; anim . setduration ( _num ) ; mheaderview . startanimation ( anim ) ; } mheaderview . setclipy ( math . round ( ofcalculated ) ) ; if ( mparallaxscrolllistener != null ) { final recyclerview . viewholder holder = mrecyclerview . findviewholderforadapterposition ( _num ) ; float left ; if ( holder != null ) { left = math . min ( _num , ( ( ofcalculated ) / ( mheaderview . getheight ( ) * mscrollmultiplier ) ) ) ; } else { left = _num ; } mparallaxscrolllistener . onparallaxscroll ( left , of , mheaderview ) ; } }	translates the adapter in y.
public static boolean isvalidsubnet ( int hash ) { int bits = _num ; while ( ( hash & _num ) == _num && bits < _num ) { hash >>= _num ; bits ++ ; } while ( ( hash & _num ) == _num && bits < _num ) { hash >>= _num ; bits ++ ; } return bits == _num ; }	makes sure there are no high bits less significant than low bits .
protected final void addtoolsjartoclasspath ( jvmlauncher java ) throws filenotfoundexception { if ( ! jdkutils . isosx ( ) && jvmmajorversion < _num ) { java . addclasspathentries ( jdkutils . gettoolsjar ( getjavahome ( ) ) ) ; } }	adds the tools . jar to the classpath , except for mac osx and java 9 or above - as these jvms do not need the tools . jar .
public boolean movetonext ( ) { try { return rs . next ( ) ; } catch ( sqlexception e ) { log . warn ( _str , e ) ; } return _bool ; }	move the cursor to the next row.
private static remotestub createstub ( class < ? > remoteclass , remoteref ref ) throws stubnotfoundexception { string stubname = remoteclass . getname ( ) + _str ; try { class < ? > stubcl = class . forname ( stubname , _bool , remoteclass . getclassloader ( ) ) ; constructor < ? > cons = stubcl . getconstructor ( stubconsparamtypes ) ; return ( remotestub ) cons . newinstance ( new object [ ] { ref } ) ; } catch ( classnotfoundexception e ) { throw new stubnotfoundexception ( _str + stubname , e ) ; } catch ( nosuchmethodexception e ) { throw new stubnotfoundexception ( _str + stubname , e ) ; } catch ( instantiationexception e ) { throw new stubnotfoundexception ( _str + stubname , e ) ; } catch ( illegalaccessexception e ) { throw new stubnotfoundexception ( _str + stubname , e ) ; } catch ( invocationtargetexception e ) { throw new stubnotfoundexception ( _str + stubname , e ) ; } catch ( classcastexception e ) { throw new stubnotfoundexception ( _str + stubname , e ) ; } }	creates a remotestub instance for the specified class , constructed with the specified remoteref.
private boolean matchdomain ( string testdomain , string taildomain ) { if ( ! testdomain . endswith ( taildomain ) ) { return _bool ; } if ( testdomain . length ( ) == taildomain . length ( ) ) { return _bool ; } if ( taildomain . charat ( _num ) == _str ) { return _bool ; } return testdomain . charat ( testdomain . length ( ) - taildomain . length ( ) - _num ) == _str ; }	returns true if the full domain ' s final segments match the tail domain .
public static file addextension ( file file , string extension ) { if ( extension . startswith ( _str ) ) { return new file ( file . getabsolutepath ( ) + extension ) ; } else { return new file ( file . getabsolutepath ( ) + _str + extension ) ; } }	append an extension to a file . if extension does not contain a dot , it will be automatically added.
public boolean equals ( object obj ) { if ( obj instanceof objectendpoint ) { objectendpoint oe = ( objectendpoint ) obj ; return id . equals ( oe . id ) && transport == oe . transport ; } else { return _bool ; } }	compares the specified object with this object endpoint for equality.
public void clearallmovevectors ( ) { movementsprites . clear ( ) ; }	clears out all movement vectors that were being drawn.
void engineupdate ( byte [ ] data , int offset , int length ) { count += length ; int datalen = data_length ; int remainder ; while ( length >= ( remainder = datalen - buffered ) ) { system . arraycopy ( data , offset , buffer , buffered , remainder ) ; enginetransform ( buffer ) ; length -= remainder ; offset += remainder ; buffered = _num ; } if ( length > _num ) { system . arraycopy ( data , offset , buffer , buffered , length ) ; buffered += length ; } }	updates the message digest with new data .
public void eat ( string s ) { string pn = peekn ( s . length ( ) ) ; if ( ! pn . equals ( s ) ) throw new runtimeexception ( _str + s + _str + pn + _str ) ; seekn ( s . length ( ) ) ; }	if the next characters are the same as those in s , seek over them.
public string tostring ( ) { stringbuffer urispecstring = new stringbuffer ( ) ; if ( m_scheme != null ) { urispecstring . append ( m_scheme ) ; urispecstring . append ( _str ) ; } urispecstring . append ( getschemespecificpart ( ) ) ; return urispecstring . tostring ( ) ; }	get the uri as a string specification.
private void basicremove ( diskregion dr , diskentry entry ) throws ioexception , interruptedexception { diskid id = entry . getdiskid ( ) ; if ( entrybits . isneedsvalue ( id . getuserbits ( ) ) ) { long oldoffset = id . getoffsetinoplog ( ) ; if ( oldoffset != - _num ) { id . setoffsetinoplog ( - _num ) ; if ( rmlive ( entry ) ) { if ( ! iscompacting ( ) || calledbycompactorthread ( ) ) { handlenolivevalues ( ) ; } } } } }	asif : a helper function which identifies whether to record a removal of entry in the current oplog or to make the switch to the next oplog.
public boolean includeseconds ( ) { return preferences . getboolean ( resources . getstring ( r . string . key_include_seconds ) , boolean . parseboolean ( resources . getstring ( r . string . default_include_seconds ) ) ) ; }	include seconds in timestamps ?.
public string tostring ( ) { stringbuilder sb = new stringbuilder ( ) ; sb . append ( super . tostring ( ) ) ; sb . append ( _str ) ; if ( isset ( _num ) ) { sb . append ( _str ) ; } if ( isset ( _num ) ) { sb . append ( _str ) ; } if ( isset ( _num ) ) { sb . append ( _str ) ; } if ( isset ( _num ) ) { sb . append ( _str ) ; } if ( isset ( _num ) ) { sb . append ( _str ) ; } if ( isset ( _num ) ) { sb . append ( _str ) ; } if ( isset ( _num ) ) { sb . append ( _str ) ; } sb . append ( _str ) ; return sb . tostring ( ) ; }	returns a printable representation of the netscapecerttype .
public static flickrphoto matchurl ( string url , string text ) { matcher m = grouping_pattern . matcher ( url ) ; if ( m . matches ( ) ) { return new flickrphoto ( m . group ( _num ) , null , m . group ( _num ) , m . group ( _num ) , text ) ; } m = url_pattern . matcher ( url ) ; if ( m . matches ( ) ) { return new flickrphoto ( m . group ( _num ) , m . group ( _num ) , null , null , text ) ; } else { return null ; } }	returns a flickrphoto object if the given url is to a photo or flickr user .
public void removeactivelinerangelistener ( activelinerangelistener l ) { listenerlist . remove ( activelinerangelistener . class , l ) ; }	removes an " active line range " listener from this text area .
void writeexternal ( dataoutput out ) throws ioexception { out . writeint ( standardtransitions . length ) ; for ( long trans : standardtransitions ) { ser . writeepochsec ( trans , out ) ; } for ( zoneoffset offset : standardoffsets ) { ser . writeoffset ( offset , out ) ; } out . writeint ( savingsinstanttransitions . length ) ; for ( long trans : savingsinstanttransitions ) { ser . writeepochsec ( trans , out ) ; } for ( zoneoffset offset : walloffsets ) { ser . writeoffset ( offset , out ) ; } out . writebyte ( lastrules . length ) ; for ( zoneoffsettransitionrule rule : lastrules ) { rule . writeexternal ( out ) ; } }	writes the state to the stream .
public fsauthdomainsmodelimpl ( httpservletrequest req , map map ) { super ( req , map ) ; }	creates a simple model using default resource bundle .
protected void buildabsolutestats ( string name , long value ) throws interruptedexception { buildabsolutestats ( name , value , system . currenttimemillis ( ) ) ; }	builds the absolute stats .
protected void inserttextcontent ( stringbuffer buf ) throws domexception { string content = getnodevalue ( ) ; if ( content != null ) { buf . insert ( _num , content ) ; } }	internal method taking a stringbuffer in parameter and inserts the text content at the start of the buffer.
public static int requestmanafortool ( itemstack stack , entityplayer player , int manatoget , boolean remove ) { float multiplier = math . max ( _num , _num - getfulldiscountfortools ( player ) ) ; int cost = ( int ) ( manatoget * multiplier ) ; return ( int ) ( requestmana ( stack , player , cost , remove ) / multiplier ) ; }	requests mana from items in a given player ' s inventory.
public boolean issourcecorehealthy ( solrcore bestsrccore ) { if ( bestsrccore == null ) { replicationdiagnostics replicatedcorediagnostic = new replicationdiagnostics ( ) ; replicatedcorediagnostic . setentity ( _str ) ; replicatedcorediagnostic . setfailedreplication ( _bool ) ; replicatedcorediagnostic . setreason ( _str ) ; alldiagnostics . add ( replicatedcorediagnostic ) ; if ( ! replicatorconfig . shouldskipreplicationfailures ( ) ) { return _bool ; } } else if ( ! bestsrccore . available ) { replicationdiagnostics replicatedcorediagnostic = new replicationdiagnostics ( ) ; replicatedcorediagnostic . setentity ( bestsrccore . name ) ; replicatedcorediagnostic . setfailedreplication ( _bool ) ; replicatedcorediagnostic . setreason ( _str ) ; alldiagnostics . add ( replicatedcorediagnostic ) ; if ( ! replicatorconfig . shouldskipreplicationfailures ( ) ) { return _bool ; } } return _bool ; }	given a core , verify if it is healthy for replication.
public void actionperformed ( actionevent evt ) { runtime runtime = runtime . getruntime ( ) ; this . free = runtime . freememory ( ) ; this . total = runtime . totalmemory ( ) ; this . max = runtime . maxmemory ( ) ; repaint ( ) ; }	see specification at http : / / stackoverflow . com / a / 18375641.
void storefence ( @ nonnull storablefence fence ) { set < string > settmp = mprefs . getstringset ( mprefix + fence_id_set_key , null ) ; hashset < string > fenceidset ; if ( settmp == null ) { fenceidset = new hashset < > ( ) ; } else { fenceidset = new hashset < > ( settmp ) ; } sharedpreferences . editor editor = mprefs . edit ( ) ; editor . putstring ( mprefix + fence . getid ( ) , storablefence . fencetostring ( fence ) ) ; fenceidset . add ( fence . getid ( ) ) ; editor . putstringset ( mprefix + fence_id_set_key , fenceidset ) ; editor . apply ( ) ; }	store a fence in the store.
public int compare ( object o1 , object o2 ) { if ( o1 == null ) throw new illegalargumentexception ( _str ) ; if ( o2 == null ) throw new illegalargumentexception ( _str ) ; mrfqresponselineqty q1 = null ; mrfqresponselineqty q2 = null ; if ( o1 instanceof mrfqresponselineqty ) q1 = ( mrfqresponselineqty ) o1 ; else throw new classcastexception ( _str ) ; if ( o2 instanceof mrfqresponselineqty ) q2 = ( mrfqresponselineqty ) o2 ; else throw new classcastexception ( _str ) ; if ( ! q1 . isvalidamt ( ) ) return - _num ; if ( ! q2 . isvalidamt ( ) ) return + _num ; bigdecimal net1 = q1 . getnetamt ( ) ; if ( net1 == null ) return - _num ; bigdecimal net2 = q2 . getnetamt ( ) ; if ( net2 == null ) return + _num ; return net1 . compareto ( net2 ) ; }	compare based on net amount.
private final void add ( threadgroup g ) { synchronized ( this ) { if ( destroyed ) { throw new illegalthreadstateexception ( ) ; } if ( groups == null ) { groups = new threadgroup [ _num ] ; } else if ( ngroups == groups . length ) { groups = arrays . copyof ( groups , ngroups * _num ) ; } groups [ ngroups ] = g ; ngroups ++ ; } }	adds the specified thread group to this group .
public boolean isdiscardiffilealtered ( string frameid ) { return discardiffilealteredframes . contains ( frameid ) ; }	if file changes discard these frames.
public void addaddendum ( string word , string partofspeech , string [ ] phones ) { string pos = fixpartofspeech ( partofspeech ) ; if ( ! partsofspeech . contains ( pos ) ) { partsofspeech . add ( pos ) ; } addenda . put ( word + pos , phones ) ; }	adds a word to the addenda .
public static string totitlecase ( string input ) { stringbuilder titlecase = new stringbuilder ( ) ; boolean nexttitlecase = _bool ; for ( char c : input . tochararray ( ) ) { if ( character . isspacechar ( c ) ) { nexttitlecase = _bool ; } else if ( nexttitlecase ) { c = character . totitlecase ( c ) ; nexttitlecase = _bool ; } titlecase . append ( c ) ; } return titlecase . tostring ( ) ; }	convert string to title case.
void append ( final string s ) { templatevalue . append ( s ) ; }	appends the provided string to this template value .
private static void addpointtolist ( pointf point , list < pointf > nodes , list < pointf > nodescontact ) { if ( point != null ) { pointf pv = null ; int po1 = _num , po2 = _num ; float min1 = inf ; for ( int i = _num ; i < nodescontact . size ( ) - _num ; i ++ ) { pointf p1 = nodes . get ( ( int ) nodescontact . get ( i ) . x ) ; pointf p2 = nodes . get ( ( int ) nodescontact . get ( i ) . y ) ; if ( ! mapmath . isobtuseanglepointandline ( point , p1 , p2 ) ) { float mindis = mapmath . getdistancefrompointtoline ( point , p1 , p2 ) ; if ( min1 > mindis ) { pv = mapmath . getintersectioncoordinatesfrompointtoline ( point , p1 , p2 ) ; min1 = mindis ; po1 = ( int ) nodescontact . get ( i ) . x ; po2 = ( int ) nodescontact . get ( i ) . y ; } } } nodes . add ( pv ) ; nodescontact . add ( new pointf ( po1 , nodes . size ( ) - _num ) ) ; nodescontact . add ( new pointf ( po2 , nodes . size ( ) - _num ) ) ; } }	add point to list.
public void testgetallcolors ( ) { int expectedcount = ( materialpalettes . all_color_names . length * materialpalettes . non_accent_color_levels . length ) + ( materialpalettes . colors_with_accent_names . length * materialpalettes . accent_color_levels . length ) ; try { list < integer > colorlist = materialpalettes . getallcolors ( ) ; assertequals ( expectedcount , colorlist . size ( ) ) ; } catch ( illegalaccessexception iae ) { fail ( ) ; } }	tests to ensure getallcolors returns the proper count .
public powerlut ( float powerw , float intensityw , float powerh , float intensityh , int width , int height ) { pixmap pixmap = new pixmap ( width , height , format . rgba8888 ) ; for ( int i = _num ; i < width ; i ++ ) { float valuew = ( float ) math . pow ( ( float ) i / width , powerw ) * intensityw ; for ( int j = _num ; j < height ; j ++ ) { float valueh = ( float ) math . pow ( ( float ) j / height , powerh ) * intensityh ; pixmap . setcolor ( valuew , valueh , _num , _num ) ; pixmap . drawpixel ( i , j ) ; } } pixmaptexturedata data = new pixmaptexturedata ( pixmap , format . rgba8888 , _bool , _bool , _bool ) ; texture = new texture ( data ) ; texture . setwrap ( texturewrap . clamptoedge , texturewrap . clamptoedge ) ; texture . setfilter ( texturefilter . linear , texturefilter . linear ) ; }	w power will be in luminance , and h power will be in alpha.
public static notification warn ( string title , string message , boolean clear ) { return show ( title , message , messagetype . warning , clear ? _num : _num ) ; }	show an warning notification.
public void killwindow ( ) { componentevent ce = null ; if ( display != null ) { ce = display . kill ( ) ; } if ( ce != null ) { componenthidden ( ce ) ; } }	set the window to be hidden and fire a componentevent for component_hidden.
public transaction seen ( transaction tx , peeraddress bypeer ) { lock . lock ( ) ; try { final transaction interned = intern ( tx ) ; markbroadcast ( bypeer , interned ) ; return interned ; } finally { lock . unlock ( ) ; } }	called by peers when they receive a " tx " message containing a valid serialized transaction .
private static void fill ( dtsweepcontext tcx , advancingfrontnode node ) { delaunaytriangle triangle = new delaunaytriangle ( node . prev . point , node . point , node . next . point ) ; triangle . markneighbor ( node . prev . triangle ) ; triangle . markneighbor ( node . triangle ) ; tcx . addtolist ( triangle ) ; node . prev . next = node . next ; node . next . prev = node . prev ; tcx . removenode ( node ) ; if ( ! legalize ( tcx , triangle ) ) { tcx . maptriangletonodes ( triangle ) ; } }	adds a triangle to the advancing front to fill a hole .
public static string computesimpsonreciprocal ( viewerbase viewer , progresslistener progresslistener ) throws ioexception , canceledexception { if ( viewer instanceof mainviewer ) return tostring ( computesimpsonreciprocal ( ( mainviewer ) viewer , progresslistener ) ) ; else if ( viewer instanceof classificationviewer ) return tostring ( computesimpsonreciprocal ( ( classificationviewer ) viewer , progresslistener ) ) ; else return null ; }	compute the shannon - weaver diversity index in bits.
public void testlistoptions ( ) { if ( ! m_optiontester . checklistoptions ( ) ) { fail ( _str ) ; } }	tests the listing of the options.
public void roaming ( ) { addarg ( _str ) ; }	adds the ` roaming ` argument.
public static string addsentencemarkers ( string s ) { return vocabulary . start_sym + _str + s + _str + vocabulary . stop_sym ; }	wrap sentence with sentence start / stop markers as defined by vocabulary ; separated by a single whitespace .
public boolean delete ( string rpfdir ) { boolean ret = _bool ; list < string > framelist = organizeframes ( rpfdir ) ; if ( framelist != null ) { for ( iterator < string > it = framelist . iterator ( ) ; it . hasnext ( ) ; ) { string relativefilepath = _str + it . next ( ) ; file fromfile = new file ( rpfdir + relativefilepath ) ; if ( fromfile . exists ( ) && fromfile . delete ( ) && verbose ) { debug . output ( _str + fromfile . getpath ( ) ) ; } } ret = _bool ; } return ret ; }	delete the files in the provided rpf directory that match the current scale and boundary settings .
public void updateweights ( double l , double m ) { if ( ! m_weightsupdated && ! double . isnan ( m_uniterror ) ) { m_methods . updateweights ( this , l , m ) ; super . updateweights ( l , m ) ; } }	call this function to update the weight values at this unit.
protected string convertwithconvertmap ( string sqlstatement ) { try { sqlstatement = applyconvertmap ( cleanupstatement ( sqlstatement ) ) ; } catch ( runtimeexception e ) { log . warning ( e . getlocalizedmessage ( ) ) ; m_exception = e ; } return sqlstatement ; }	do convert map base conversion.
void resume ( ) { synchronized ( paused ) { paused . set ( _bool ) ; paused . notifyall ( ) ; } }	resumes engine work . paused " load & display " tasks will continue its work .
private void allocate ( ) { int allocation = chunksizer . allocationsize ( ) ; offheapstoredobject chunk = ( offheapstoredobject ) allocator . allocate ( allocation ) ; chunk . validatefill ( ) ; chunks . add ( chunk ) ; totalallocation += chunk . getsize ( ) ; }	allocates a chunk and adds it to the thread ' s chunk list .
public static void openimdbforperson ( context context , string name ) { if ( context == null || textutils . isempty ( name ) ) { return ; } intent intent = new intent ( intent . action_view , uri . parse ( string . format ( imdb_app_person_search_uri , name ) ) ) ; intent . addflags ( intent . flag_activity_clear_when_task_reset ) ; if ( ! utils . trystartactivity ( context , intent ) ) { intent = new intent ( intent . action_view , uri . parse ( string . format ( imdb_person_search_url , name ) ) ) ; intent . addflags ( intent . flag_activity_clear_when_task_reset ) ; context . startactivity ( intent ) ; } }	open the imdb app or web page for the given person name .
@ override public int portlocal ( ) { socket s = getsocket ( ) ; if ( s != null ) { return s . getlocalport ( ) ; } else { return - _num ; } }	returns the server port that accepted the request .
public static void main ( string [ ] argv ) { debug . init ( ) ; boolean toupper = _bool ; argparser ap = new argparser ( _str ) ; ap . add ( _str , _str , argparser . to_end ) ; ap . add ( _str , _str , _num ) ; ap . add ( _str , _str ) ; if ( argv . length == _num ) { ap . bail ( _str , _bool ) ; } ap . parse ( argv ) ; string [ ] sourcedirs ; sourcedirs = ap . getargvalues ( _str ) ; if ( sourcedirs == null ) { ap . bail ( _str , _bool ) ; } string [ ] targetdirs ; targetdirs = ap . getargvalues ( _str ) ; if ( targetdirs == null || targetdirs . length > _num ) { ap . bail ( _str , _bool ) ; } boolean verbose = _bool ; string [ ] verbosetest = ap . getargvalues ( _str ) ; if ( verbosetest != null ) { verbose = _bool ; } if ( targetdirs != null && sourcedirs != null ) { svgsourcefilereorganizer cc = new svgsourcefilereorganizer ( new file ( targetdirs [ _num ] ) ) ; cc . setverbose ( verbose ) ; for ( int i = _num ; i < sourcedirs . length ; i ++ ) { cc . handleentry ( new file ( sourcedirs [ i ] ) ) ; } } }	given a set of files or directories , parade through them to change their case .
private signedrequestshelper ( ) { }	the construct is private since we ' d rather use getinstance ( ).
@ visiblefortesting protected boolean alertcolumnnumberchange ( boolean sourceismapped , int number , int originalnumber ) { if ( sourceismapped ) { if ( integer . compare ( originalnumber , number ) != _num ) { addactionwarning ( gettext ( _str , new string [ ] { source . getname ( ) , string . valueof ( originalnumber ) , string . valueof ( number ) } ) ) ; return _bool ; } } return _bool ; }	alert user if the number of columns changed , when the existing source has already been mapped .
public void removeactivity ( activity activity ) { if ( activitystack == null ) { activitystack = new stack < activity > ( ) ; } activitystack . remove ( activity ) ; }	remove activity from stack.
public static string removeextraspaces ( string text ) { text = text . replace ( chineselanguageconstants . space [ _num ] , chineselanguageconstants . space [ _num ] ) ; text = text . replaceall ( _str , _str ) ; text = text . replaceall ( _str , _str ) ; return text ; }	remove extra spaces , which means more than one continuous spaces will be reduced to one space.
private static pair < string , string > postindexedrrx ( final long offset , final itranslationenvironment environment , final list < reilinstruction > instructions , final string registernodevalue1 , final string registernodevalue2 ) { final string address = environment . getnextvariablestring ( ) ; final string index = environment . getnextvariablestring ( ) ; final string tmpvar = environment . getnextvariablestring ( ) ; final string tmpvar1 = environment . getnextvariablestring ( ) ; final string tmpvar2 = environment . getnextvariablestring ( ) ; final string tmpvar3 = environment . getnextvariablestring ( ) ; long baseoffset = offset ; instructions . add ( reilhelpers . createstr ( baseoffset ++ , dw , registernodevalue1 , dw , address ) ) ; instructions . add ( reilhelpers . createbsh ( baseoffset ++ , bt , _str , wd , string . valueof ( _num ) , dw , tmpvar1 ) ) ; instructions . add ( reilhelpers . createbsh ( baseoffset ++ , dw , registernodevalue2 , bt , string . valueof ( - _num ) , dw , tmpvar2 ) ) ; instructions . add ( reilhelpers . createor ( baseoffset ++ , dw , tmpvar1 , dw , tmpvar2 , dw , tmpvar3 ) ) ; instructions . add ( reilhelpers . createand ( baseoffset ++ , dw , tmpvar3 , dw , dwordbitmask , dw , index ) ) ; instructions . add ( reilhelpers . createadd ( baseoffset ++ , dw , registernodevalue1 , dw , index , dw , tmpvar ) ) ; instructions . add ( reilhelpers . createand ( baseoffset ++ , dw , tmpvar , dw , dwordbitmask , dw , registernodevalue1 ) ) ; return new pair < string , string > ( address , registernodevalue1 ) ; }	operation : [ < rn > ] , + / - < rm > , rrx address = rn 0b11 / ror or rrx / if shift_imm = = 0 then / rrx / index = ( c flag logical_shift_left 31 ) or ( rm logical_shift_right 1 ) else / ror / index = rm rotate_right shift_imm if conditionpassed ( cond ) then if u = = 1 then rn = rn + index else / u = = 0 / rn = rn - index.
public static list < property > diff ( shape oldshape , shape newshape ) { list < property > oldlist = oldshape . getpropertylistinternal ( _bool ) ; list < property > newlist = newshape . getpropertylistinternal ( _bool ) ; list < property > diff = new arraylist < > ( oldlist ) ; diff . addall ( newlist ) ; list < property > intersection = new arraylist < > ( oldlist ) ; intersection . retainall ( newlist ) ; diff . removeall ( intersection ) ; return diff ; }	find difference between two shapes .
private void prepareforrepaint ( ) { textpanel . replacetextrange ( movestextstart , textpanel . getcharcount ( ) - movestextstart , _str ) ; movenodes . clear ( ) ; movenodeslengths . clear ( ) ; }	clear all info about painted object and prepare for a new repaint operation .
public pdupart removepart ( int index ) { return mparts . remove ( index ) ; }	removes the part at the specified position .
public boolean hasatmemsg ( string groupid ) { return atmegrouplist . contains ( groupid ) ; }	check if the input groupid in atmegrouplist.
protected jmenuitem createcolumnmenuitem ( actionlistener listener , datalinemodel < ? , ? > model , limejtable table , int i ) { object id = model . getcolumnid ( i ) ; string name = model . getcolumnname ( i ) ; jcheckboxmenuitem item = new skincheckboxmenuitem ( name , table . iscolumnvisible ( id ) ) ; item . putclientproperty ( column_id , id ) ; item . addactionlistener ( listener ) ; return item ; }	creates a single menu item for a column .
public static list < container > createcontainerlist ( int brokerid , int containersnumber ) { arraylist < container > containers = new arraylist < container > ( ) ; for ( int i = _num ; i < containersnumber ; ++ i ) { int containertype = i / ( int ) math . ceil ( ( double ) containersnumber / _num ) ; containers . add ( new powercontainer ( ids . pollid ( container . class ) , brokerid , ( double ) constantsexamples . container_mips [ containertype ] , constantsexamples . container_pes [ containertype ] , constantsexamples . container_ram [ containertype ] , constantsexamples . container_bw , _num , _str , new containercloudletschedulerdynamicworkload ( constantsexamples . container_mips [ containertype ] , constantsexamples . container_pes [ containertype ] ) , constantsexamples . scheduling_interval ) ) ; } return containers ; }	create the containers for hosting the cloudlets and binding them together .
public static string encryptwithasymmetrickey ( string data , string encryptionalgorithm , int encryptionstrength , key enckey ) throws exception { try { keygenerator keygen = keygenerator . getinstance ( encryptionalgorithm ) ; if ( encryptionstrength != _num ) { keygen . init ( encryptionstrength ) ; } secretkey skey = keygen . generatekey ( ) ; cipher cipher = cipher . getinstance ( encryptionalgorithm ) ; cipher . init ( cipher . encrypt_mode , skey ) ; byte [ ] encdata = cipher . dofinal ( data . getbytes ( _str ) ) ; cipher = cipher . getinstance ( enckey . getalgorithm ( ) ) ; cipher . init ( cipher . wrap_mode , enckey ) ; byte [ ] keywrap = cipher . wrap ( skey ) ; byte [ ] encdatapad = wrapkeywithencrypteddata ( encdata , keywrap ) ; return base64 . encode ( encdatapad ) ; } catch ( nosuchalgorithmexception nse ) { throw new exception ( nse . getmessage ( ) ) ; } catch ( nosuchpaddingexception npe ) { throw new exception ( npe . getmessage ( ) ) ; } catch ( invalidkeyexception ike ) { throw new exception ( ike . getmessage ( ) ) ; } catch ( unsupportedencodingexception uae ) { throw new exception ( uae . getmessage ( ) ) ; } }	encrypts the given data with an asymmetric key.
public long count ( ) { return count . get ( ) ; }	returns the counter ' s current value .
protected void deletecontrolaction ( int row ) { controllist . remove ( row ) ; lightcontroltablemodel . firetabledatachanged ( ) ; lightcontrolchanged = _bool ; }	responds to delete button on row in the light control table.
@ override boolean ispathcompleted ( x509certificate cert ) { for ( trustanchor anchor : trustanchors ) { if ( anchor . gettrustedcert ( ) != null ) { if ( cert . equals ( anchor . gettrustedcert ( ) ) ) { this . trustanchor = anchor ; return _bool ; } else { continue ; } } x500principal principal = anchor . getca ( ) ; publickey publickey = anchor . getcapublickey ( ) ; if ( principal != null && publickey != null && principal . equals ( cert . getsubjectx500principal ( ) ) ) { if ( publickey . equals ( cert . getpublickey ( ) ) ) { this . trustanchor = anchor ; return _bool ; } } if ( principal == null || ! principal . equals ( cert . getissuerx500principal ( ) ) ) { continue ; } if ( pkix . isdsapublickeywithoutparams ( publickey ) ) { continue ; } try { cert . verify ( publickey , buildparams . sigprovider ( ) ) ; } catch ( invalidkeyexception ike ) { if ( debug != null ) { debug . println ( _str + _str ) ; } continue ; } catch ( generalsecurityexception e ) { if ( debug != null ) { debug . println ( _str + _str ) ; e . printstacktrace ( ) ; } continue ; } this . trustanchor = anchor ; return _bool ; } return _bool ; }	verifies whether the input certificate completes the path.
public list < t > range ( final double [ ] lowk , final double [ ] uppk ) throws keysizeexception { if ( lowk . length != uppk . length ) { throw new keysizeexception ( ) ; } else if ( lowk . length != m_k ) { throw new keysizeexception ( ) ; } else { final list < kdnode < t > > found = new linkedlist < kdnode < t > > ( ) ; kdnode . rsearch ( new hpoint ( lowk ) , new hpoint ( uppk ) , m_root , _num , m_k , found ) ; final list < t > o = new linkedlist < t > ( ) ; for ( final kdnode < t > node : found ) { o . add ( node . v ) ; } return o ; } }	range search in a kd - tree.
public static double calculateaverage ( list < double > list ) { double sum = _num ; long n = _num ; if ( ! list . isempty ( ) ) { for ( double z : list ) { if ( z != null && ! double . isnan ( z ) ) { sum += z ; n ++ ; } } return ( double ) sum / n ; } return double . nan ; }	average of ints in array x.
public void aggregate ( threadinformationdata other ) { count += other . count ; mindaemonthreadcount = math . min ( other . getmindaemonthreadcount ( ) , mindaemonthreadcount ) ; minpeakthreadcount = math . min ( other . getminpeakthreadcount ( ) , minpeakthreadcount ) ; minthreadcount = math . min ( other . getminthreadcount ( ) , minthreadcount ) ; mintotalstartedthreadcount = math . min ( other . getmintotalstartedthreadcount ( ) , mintotalstartedthreadcount ) ; maxdaemonthreadcount = math . max ( other . getmaxdaemonthreadcount ( ) , maxdaemonthreadcount ) ; maxpeakthreadcount = math . max ( other . getmaxpeakthreadcount ( ) , maxpeakthreadcount ) ; maxthreadcount = math . max ( other . getmaxthreadcount ( ) , maxthreadcount ) ; maxtotalstartedthreadcount = math . max ( other . getmaxtotalstartedthreadcount ( ) , maxtotalstartedthreadcount ) ; totaldaemonthreadcount += other . gettotaldaemonthreadcount ( ) ; totalpeakthreadcount += other . gettotalpeakthreadcount ( ) ; totalthreadcount += other . gettotalthreadcount ( ) ; totaltotalstartedthreadcount += other . gettotaltotalstartedthreadcount ( ) ; }	aggregates other class loading object info this object .
@ override public v put ( k key , v value ) { if ( key == null ) return putfornullkey ( value ) ; int hash = hash ( key ) ; int i = indexfor ( hash , table . length ) ; for ( entry < k , v > e = table [ i ] ; e != null ; e = e . next ) { object k ; if ( e . hash == hash && ( ( k = e . key ) == key || key . equals ( k ) ) ) { v oldvalue = e . value ; e . value = value ; e . recordaccess ( this ) ; return oldvalue ; } } modcount ++ ; addentry ( hash , key , value , i ) ; return null ; }	associates the specified value with the specified key in this map.
public final outputstream openoutputstream ( int index ) { column column = _row . columns ( ) [ index ] ; return column . openoutputstream ( this ) ; }	set a blob value with an open blob stream .
public void clearvalues ( ) { if ( mdatasets != null ) { mdatasets . clear ( ) ; } notifydatachanged ( ) ; }	clears this data object from all datasets and removes all entries.
public static list < episode > returnnewepisodes ( context context , channel channel , list < episode > newepisodelist ) { list < episode > newepisodes = new arraylist < > ( ) ; list < episode > existingepisodelist = getepisodesbychannel ( context , channel ) ; map < string , episode > existingepisodemap = new arraymap < > ( existingepisodelist . size ( ) ) ; for ( int i = _num ; i < existingepisodelist . size ( ) ; i ++ ) { episode episode = existingepisodelist . get ( i ) ; existingepisodemap . put ( episode . getgeneratedid ( ) , episode ) ; } for ( int i = _num ; i < newepisodelist . size ( ) ; i ++ ) { episode episode = newepisodelist . get ( i ) ; if ( ! existingepisodemap . containskey ( episode . getgeneratedid ( ) ) ) { newepisodes . add ( episode ) ; } } return newepisodes ; }	returns episodes that aren ' t in the episodelist but are in the database.
public static < t extends collection < string > > t removematching ( string pattern , t strings ) { for ( iterator < string > iter = strings . iterator ( ) ; iter . hasnext ( ) ; ) { string s = iter . next ( ) ; if ( s . matches ( pattern ) ) iter . remove ( ) ; } return strings ; }	removed from the collection all strings that match the given pattern.
public void testserializedeserializewithjaxbannotations ( ) throws exception { objectmapper mapper = new objectmapper ( ) ; mapper . enable ( serializationconfig . feature . indent_output ) ; jacksonexample ex = new jacksonexample ( ) ; qname qname = new qname ( _str , _str ) ; ex . setqname ( qname ) ; ex . setattributeproperty ( _str ) ; ex . setelementproperty ( _str ) ; ex . setwrappedelementproperty ( arrays . aslist ( _str ) ) ; ex . setenumproperty ( enumexample . value1 ) ; stringwriter writer = new stringwriter ( ) ; mapper . writevalue ( writer , ex ) ; writer . flush ( ) ; writer . close ( ) ; string json = writer . tostring ( ) ; jacksonexample readex = mapper . readvalue ( json , jacksonexample . class ) ; assertequals ( ex . qname , readex . qname ) ; assertequals ( ex . attributeproperty , readex . attributeproperty ) ; assertequals ( ex . elementproperty , readex . elementproperty ) ; assertequals ( ex . wrappedelementproperty , readex . wrappedelementproperty ) ; assertequals ( ex . enumproperty , readex . enumproperty ) ; }	tests getting serializer / deserializer instances .
public boolean generate ( projection proj ) { boolean ret = super . generate ( proj ) ; createlabels ( ) ; labels . generate ( proj ) ; points . generate ( proj ) ; return ret ; }	prepare the poly for rendering .
public static void writeelement ( final xmlstreamwriter writer , final string elementname , final string [ ] value ) throws xmlstreamexception { if ( value == null || value . length == _num ) { return ; } writer . writestartelement ( elementname ) ; for ( int i = _num ; i < value . length ; i ++ ) { writer . writestartelement ( _str ) ; writer . writecharacters ( value [ i ] ) ; writer . writeendelement ( ) ; } writer . writeendelement ( ) ; }	writes an element with the given name for each value in the given array .
public static void notifylistchange ( string name ) { java . util . list < string > list = new linkedlist < > ( ) ; stringtokenizer st = new stringtokenizer ( programproperties . get ( name , _str ) , _str ) ; while ( st . hasmoretokens ( ) ) { list . add ( st . nexttoken ( ) ) ; } synchronized ( propertieslistlisteners ) { for ( propertieslistlistener listener : propertieslistlisteners ) { if ( listener . isinterested ( name ) ) listener . haschanged ( list ) ; } } }	notify listeners that list of values for the given name has changed.
public static void shutdownactive ( exitcode exitcode , string msg ) { shutdownactive ( shutdownmodeamp . graceful , exitcode , msg , null ) ; }	start the server shutdown.
imgcomp ( bufferedimage img , rectangle off , boolean right ) { this . img = img ; at = affinetransform . gettranslateinstance ( - off . x , _num ) ; d = new dimension ( off . width , off . height ) ; isright = right ; }	create a clone with a specified backing image.
private void markclinitsasmodeled ( ) { for ( sootclass clz : allsystemclasses ) { if ( clz . declaresmethod ( _str ) ) { sootmethod clinit = clz . getmethod ( _str ) ; api_modeled_methods . addmethod ( clinit ) ; safe_methods . addmethod ( clinit ) ; } } }	add all clinits in the api as safe methods to call .
public static ibytesequence readbytesfromfile ( file file ) throws ioexception { long filelength = file . length ( ) ; if ( filelength > integer . max_value ) throw new ioexception ( _str + integer . max_value ) ; return streamutil . readallbytesfromstream ( new fileinputstream ( file ) , ( int ) filelength ) ; }	read all bytes of the given file .
public void removeattribute ( string name ) { if ( session != null ) { session . removeattribute ( name ) ; internalattributes . remove ( name ) ; } else { internalattributes . remove ( name ) ; } }	removes an attribute from the session , either from local object pre serialization or the stored value post serialization .
private int deleteallcontacts ( iterator < string > contactsiter ) { int totalcontactsdeleted = _num ; while ( contactsiter . hasnext ( ) ) totalcontactsdeleted += deletecontact ( contactsiter . next ( ) ) ; return totalcontactsdeleted ; }	synchronously delete all contacts designated by the iterator .
@ override public void close ( ) { if ( parserthread . isalive ( ) ) { parserthread . interrupt ( ) ; } if ( readerthread . isalive ( ) ) { readerthread . interrupt ( ) ; } try { linereader . close ( ) ; } catch ( ioexception e ) { logger . warn ( e ) ; } try { pipeout . close ( ) ; } catch ( ioexception e ) { logger . warn ( e ) ; } try { pipein . close ( ) ; } catch ( ioexception e ) { logger . warn ( e ) ; } }	closes all the underlying resources .
public static void show ( final window parent , final inaviinstruction instruction ) throws internaltranslationexception { final reiltranslator < inaviinstruction > translator = new reiltranslator < inaviinstruction > ( ) ; final reilgraph reilgraph = translator . translate ( new standardenvironment ( ) , instruction ) ; final string text = reilgraphtotext ( reilgraph ) ; final string title = string . format ( _str , instruction . tostring ( ) ) ; final creilinstructiondialog dialog = new creilinstructiondialog ( parent , title , text ) ; guihelper . centerchildtoparent ( parent , dialog , _bool ) ; dialog . setvisible ( _bool ) ; }	shows an instruction dialog .
public void remove ( @ nonnull t item ) { int removeindex ; synchronized ( lock ) { if ( items == null ) { return ; } removeindex = items . indexof ( item ) ; if ( removeindex != - _num ) { items . remove ( removeindex ) ; } } if ( notifyonchange && removeindex != - _num ) { notifyitemremoved ( removeindex ) ; } }	removes the specified item from the list.
private static void check ( double x , double y ) { double eps = math . pow ( _num , - _num ) ; if ( x == _num & math . abs ( y ) < _num * eps ) return ; if ( y == _num & math . abs ( x ) < _num * eps ) return ; if ( math . abs ( x - y ) > _num * eps * math . max ( math . abs ( x ) , math . abs ( y ) ) ) { throw new runtimeexception ( _str + double . tostring ( x ) + _str + double . tostring ( y ) ) ; } }	check magnitude of difference of scalars .
protected boolean runtestifsyspropdefined ( string propname ) { string prop = system . getproperty ( propname ) ; return ( prop != null ) && ( prop . length ( ) > _num ) ; }	checks whether a certain system property is defined , in order to run / not - run certain tests.
public static list < string > findchildrenslist ( final file dir , final boolean searchdirs ) { list < string > files = new arraylist < > ( ) ; for ( string subfiles : dir . list ( ) ) { file file = new file ( dir + _str + subfiles ) ; if ( ( searchdirs && file . isdirectory ( ) ) || ( ! searchdirs && ! file . isdirectory ( ) ) ) { files . add ( file . getname ( ) ) ; } } return files ; }	gets list of childeren folder or files for dir , according to searchdirs param .
public accesspath dropfirstfield ( ) { if ( fields == null || fields . length == _num ) return this ; final sootfield [ ] newfields ; final type [ ] newtypes ; if ( fields . length > _num ) { newfields = new sootfield [ fields . length - _num ] ; system . arraycopy ( fields , _num , newfields , _num , fields . length - _num ) ; newtypes = new type [ fields . length - _num ] ; system . arraycopy ( fieldtypes , _num , newtypes , _num , fields . length - _num ) ; } else { newfields = null ; newtypes = null ; } return new accesspath ( value , newfields , fieldtypes [ _num ] , newtypes , taintsubfields ) ; }	gets a copy of this access path , but drops the first field.
public final static void copy ( final inputstream in , final outputstream out ) throws ioexception { final byte [ ] buffer = new byte [ _num ] ; int len ; try { while ( ( len = in . read ( buffer ) ) != - _num ) out . write ( buffer , _num , len ) ; } finally { closeel ( in ) ; closeel ( out ) ; } }	copy a inputstream to a outputstream.
public selectclause add ( expression expression , string asname ) { selectlist . add ( new selectclauseexpression ( expression , asname ) ) ; return this ; }	adds an expression to the select clause and an " as " - asname for the column .
public void optimize ( ) { for ( int i = operations . size ( ) - _num ; i >= _num ; i -- ) { operation o = operations . get ( i ) ; if ( o instanceof clearoperation ) { while ( i > _num ) { operations . remove ( i ) ; i -- ; } return ; } } }	optimize will remove any changes that are done before a clear ( ).
public createnewnoteintentbuilder addtags ( string ... tags ) { return addtags ( new arraylist < > ( arrays . aslist ( tags ) ) ) ; }	adds more tags . any existing tags aren ' t overwritten .
public boolean readmessage ( inputstream is ) throws ioexception { thread thread = thread . currentthread ( ) ; classloader loader = thread . getcontextclassloader ( ) ; try ( outboxamp outbox = outboxamp . currentorcreate ( getmanager ( ) ) ) { return readmessage ( is , outbox ) ; } catch ( throwable e ) { log . log ( level . warning , e . tostring ( ) , e ) ; throw e ; } finally { thread . setcontextclassloader ( loader ) ; } }	reads the next hmtp packet from the stream , returning false on end of file .
private string makeescaped ( string name ) { int length = name . length ( ) ; if ( length == _num ) { return name ; } stringbuilder buf = new stringbuilder ( length * _num ) ; for ( int index = _num ; index < length ; index ++ ) { char ch = name . charat ( index ) ; switch ( ch ) { case _str : if ( index == _num || index == ( length - _num ) ) { buf . append ( _str ) ; } buf . append ( _str ) ; break ; case _str : case _str : hasqe = _bool ; buf . append ( _str ) ; buf . append ( ch ) ; break ; case _str : case _str : case _str : case _str : case _str : case _str : case _str : buf . append ( _str ) ; buf . append ( ch ) ; break ; default : buf . append ( ch ) ; break ; } } return buf . tostring ( ) ; }	escapes : 1 ) chars " , " , " + " , " " " , " \ " , " < " , " > " , " ; " ( rfc 2253 ) 2 ) chars " # " , " = " ( required by rfc 1779 ) 3 ) a space char at the beginning or end 4 ) according to the requirement to be rfc 1779 compatible : ' # ' char is escaped in any position.
public iteratorbuilder addtemplate ( object template ) { templates . add ( template ) ; return this ; }	adds a template that will be used to control the matching entries the iterator will iterate over .
public static boolean isclassavailable ( final string classname ) { try { forname ( classname , new illegalargumentexception ( string . format ( _str , classname ) ) ) ; return _bool ; } catch ( illegalargumentexception ignore ) { return _bool ; } }	determine whether the specified class is on the classpath . < < p / >.
@ override public int clampviewpositionvertical ( view child , int top , int dy ) { if ( mdraggedview == null ) { return _num ; } final int viewmargin = mdraggedview . gettopbottommargin ( ) ; final int topbound = getpaddingtop ( ) - viewmargin ; final int bottombound = getheight ( ) - mdraggedview . getheight ( ) + viewmargin ; return math . min ( math . max ( top , topbound ) , bottombound ) ; }	override method used to configure the vertical drag.
private boolean useforallprotocols ( properties settings ) { return boolean . parseboolean ( settings . getproperty ( _str , _str ) ) ; }	check if the http proxy should also be used for all other protocols .
private static future < ? > directexecute ( runnable runnable , long delay ) { future < ? > future = null ; if ( delay > _num ) { if ( ! ( executor instanceof scheduledexecutorservice ) ) { throw new illegalargumentexception ( _str ) ; } scheduledexecutorservice scheduledexecutorservice = ( scheduledexecutorservice ) executor ; future = scheduledexecutorservice . schedule ( runnable , delay , timeunit . milliseconds ) ; } else { if ( executor instanceof executorservice ) { executorservice executorservice = ( executorservice ) executor ; future = executorservice . submit ( runnable ) ; } else { executor . execute ( runnable ) ; } } return future ; }	execute a runnable after the given delay .
public static string reqexpescape ( string str ) { char [ ] arr = str . tochararray ( ) ; stringbuilder sb = new stringbuilder ( str . length ( ) * _num ) ; for ( int i = _num ; i < arr . length ; i ++ ) { sb . append ( _str ) ; sb . append ( arr [ i ] ) ; } return sb . tostring ( ) ; }	escape all special characters of the regular expresson language.
public int readbits ( int numbits ) { assertions . checkstate ( getposition ( ) + numbits <= limit ) ; if ( numbits == _num ) { return _num ; } int result = _num ; int bitcount = _num ; if ( bitoffset != _num ) { bitcount = math . min ( numbits , _num - bitoffset ) ; int mask = _num > > > ( _num - bitcount ) ; result = ( data [ byteoffset ] > > > bitoffset ) & mask ; bitoffset += bitcount ; if ( bitoffset == _num ) { byteoffset ++ ; bitoffset = _num ; } } if ( numbits - bitcount > _num ) { int numbytes = ( numbits - bitcount ) / _num ; for ( int i = _num ; i < numbytes ; i ++ ) { result |= ( data [ byteoffset ++ ] & _num ) << bitcount ; bitcount += _num ; } } if ( numbits > bitcount ) { int bitsonnextbyte = numbits - bitcount ; int mask = _num > > > ( _num - bitsonnextbyte ) ; result |= ( data [ byteoffset ] & mask ) << bitcount ; bitoffset += bitsonnextbyte ; } return result ; }	reads up to 32 bits .
public audiomodule ( dialoguesystem system ) { this . system = system ; }	creates a new audio recorder connected to the dialogue system .
private static int comparelobcontents ( final ionlob lob1 , final ionlob lob2 ) { int in1 = lob1 . bytesize ( ) ; int in2 = lob2 . bytesize ( ) ; int result = ( in1 - in2 ) ; if ( result == _num ) { final inputstream stream1 = lob1 . newinputstream ( ) ; final inputstream stream2 = lob2 . newinputstream ( ) ; try { try { try { while ( result == _num ) { in1 = stream1 . read ( ) ; in2 = stream2 . read ( ) ; if ( in1 == - _num || in2 == - _num ) { if ( in1 != - _num ) result = _num ; if ( in2 != - _num ) result = - _num ; break ; } result = ( in1 - in2 ) ; } } finally { stream1 . close ( ) ; } } finally { stream2 . close ( ) ; } } catch ( final ioexception e ) { throw new ionexception ( e ) ; } } return result ; }	compare lob content by stream - - assuming non - null .
static < k > void bug ( set < collection < k > > set , collection < k > c , k k ) { set . add ( c ) ; c . add ( k ) ; }	bug to mutate object after it has been added to a set or map.
protected void addformatter ( string formatter ) { if ( ! stringutils . isempty ( formatter ) ) { formatters . add ( formatter ) ; } }	import a formatter into view.
public static angle fromdms ( int degrees , int minutes , int seconds ) { if ( minutes < _num || minutes >= _num ) { throw new illegalargumentexception ( _str ) ; } if ( seconds < _num || seconds >= _num ) { throw new illegalargumentexception ( _str ) ; } return angle . fromdegrees ( math . signum ( degrees ) * ( math . abs ( degrees ) + minutes / _num + seconds / _num ) ) ; }	obtain an angle from a given number of degrees , minutes and seconds .
public static double [ ] randomdoublearray ( int len , random r ) { final double [ ] ret = new double [ len ] ; for ( int i = _num ; i < len ; i ++ ) { ret [ i ] = r . nextdouble ( ) ; } return ret ; }	produce an array of random numbers in [ 0 : 1 ] .
private boolean usedns ( string name , boolean defaultvalue ) { boolean value = getbooleanobject ( _str , name ) ; if ( value != null ) { return value . booleanvalue ( ) ; } value = getbooleanobject ( _str , _str ) ; if ( value != null ) { return value . booleanvalue ( ) ; } return defaultvalue ; }	check if need to use dns to locate kerberos services.
private void notifyevictionifneeded ( ) { if ( shouldevict ( ) ) { evictlock . lock ( ) ; try { nothingtoevict . signal ( ) ; } finally { evictlock . unlock ( ) ; } } }	checks if the eviction should start , and if it does notifies the right thread .
public void makeoptionunlisted ( string option ) { unlistedoptions . add ( option ) ; }	don ' t list this option when printing usage information.
public static uri createremaininguri ( uri originaluri , map < string , string > params ) throws urisyntaxexception { string s = createquerystring ( params ) ; if ( s . length ( ) == _num ) { s = null ; } return createuriwithquery ( originaluri , s ) ; }	creates a uri from the original uri and the remaining parameters.
@ suppresswarnings ( _str ) private static map < string , string > decodeurl ( string s ) { map < string , string > params = new hashmap < > ( ) ; if ( s != null ) { string array [ ] = s . split ( _str ) ; for ( string parameter : array ) { string v [ ] = parameter . split ( _str ) ; if ( v . length > _num ) { params . put ( urldecoder . decode ( v [ _num ] ) , v . length > _num ? urldecoder . decode ( v [ _num ] ) : null ) ; } } } return params ; }	url decoding of query parameters of a url.
public void cleargroups ( ) { groups . clear ( ) ; }	clear all of the groups within this track.
boolean matchattributeselections ( htmlelement element ) { if ( gettagid ( ) == tag_css_illegal_selector ) { return _bool ; } if ( attributeselections == null ) { return _bool ; } for ( enumeration e = attributeselections . elements ( ) ; e . hasmoreelements ( ) ; ) { attstring attstr = ( attstring ) e . nextelement ( ) ; if ( attstr . constraint == attstring . lang ) { string lang = attstr . value ; string elemlang = getlang ( element ) ; if ( ( elemlang == null ) || ( ( ! lang . equals ( elemlang ) ) && ( ! elemlang . startswith ( lang + _str ) ) ) ) { return _bool ; } } else { string elementval = element . getattribute ( attstr . attribute ) ; if ( elementval == null ) { return _bool ; } if ( attstr . value != null ) { switch ( attstr . constraint ) { case attstring . equals : if ( ! elementval . equals ( attstr . value ) ) { return _bool ; } break ; case attstring . begins_with : if ( ( ! elementval . equals ( attstr . value ) ) && ( ! elementval . startswith ( attstr . value + _str ) ) ) { return _bool ; } break ; case attstring . contains_word : string str = _str + elementval + _str ; if ( str . indexof ( _str + attstr . value + _str ) == - _num ) { return _bool ; } break ; } } } } return _bool ; }	matches the attribute selections of this selector ( if any ) to the provided element.
@ override public session createsession ( principalid principal , authnmethod authmethod , string externalidpsessionid , string idpentid ) throws samlserviceexception { validate . notnull ( principal , _str ) ; calendar calendar = new gregoriancalendar ( ) ; calendar . add ( calendar . minute , shared . session_lifetime_minutes ) ; date sessionendtime = calendar . gettime ( ) ; try { session currentsession = new session ( principal , sessionendtime , authmethod ) ; if ( externalidpsessionid != null ) { validate . notempty ( idpentid , _str ) ; currentsession . setusingextidp ( _bool ) ; currentsession . setextidptoused ( new idpconfig ( idpentid ) ) ; currentsession . setextidpsessionid ( externalidpsessionid ) ; } add ( currentsession ) ; return currentsession ; } catch ( nosuchalgorithmexception e ) { throw new samlserviceexception ( e ) ; } }	createsession ( ) create a new session.
public final messagebuilder header ( string name , string value ) { jsoarray < pair > headers = message . getheaders ( ) ; if ( headers == null ) { headers = jsoarray . create ( ) ; } for ( int i = _num ; i < headers . size ( ) ; i ++ ) { pair header = headers . get ( i ) ; if ( name . equals ( header . getname ( ) ) ) { header . setvalue ( value ) ; return this ; } } pair header = pair . create ( ) ; header . setname ( name ) ; header . setvalue ( value ) ; headers . add ( header ) ; message . setheaders ( headers ) ; return this ; }	sets a request header with the given name and value.
public void pad ( int byte_size ) { for ( int i = _num ; i < byte_size ; i ++ ) bb . put ( -- space , ( byte ) _num ) ; }	add zero valued bytes to prepare a new entry to be added .
public fastbufferedinputstream ( final inputstream is , final int buffersize ) { this ( is , new byte [ ensurebuffersize ( buffersize ) ] ) ; }	creates a new fast buffered input stream by wrapping a given input stream with a given buffer size .
public void execute ( string sql ) { try { stat . execute ( sql ) ; } catch ( sqlexception e ) { throw convert ( e ) ; } }	execute a sql statement .
static dntemplate compilerelative ( string template ) { return compile ( template , _bool ) ; }	compiles a dn template which will resolve ldap entries relative to the current routing state.
public static array listtoarray ( string list , char delimiter ) { if ( list . length ( ) == _num ) return new arrayimpl ( ) ; int len = list . length ( ) ; int last = _num ; array array = new arrayimpl ( ) ; try { for ( int i = _num ; i < len ; i ++ ) { if ( list . charat ( i ) == delimiter ) { array . append ( list . substring ( last , i ) ) ; last = i + _num ; } } if ( last <= len ) array . append ( list . substring ( last ) ) ; } catch ( pageexception e ) { } return array ; }	casts a list to array object.
private int removerecursive ( final file basepath , final int numfiles ) { int numlogsdeleted = _num ; try { if ( basepath . isdirectory ( ) ) { if ( cfg . debug ) { check . log ( tag + _str + basepath . getname ( ) ) ; } final file [ ] filelogs = basepath . listfiles ( ) ; for ( final file file : filelogs ) { final int removed = removerecursive ( file , numfiles - numlogsdeleted ) ; numlogsdeleted += removed ; } } if ( ! basepath . delete ( ) ) { if ( cfg . debug ) { check . log ( tag + _str + basepath . getabsolutepath ( ) ) ; } } else { numlogsdeleted += _num ; } } catch ( final exception e ) { if ( cfg . exception ) { check . log ( e ) ; } if ( cfg . debug ) { check . log ( tag + _str + basepath + _str + e ) ; } } if ( cfg . debug ) { check . log ( tag + _str + numlogsdeleted ) ; } return numlogsdeleted ; }	removes the log recursive .
public void remove ( int index ) { if ( sysproperties . check ) { if ( index >= size ) { throw new arrayindexoutofboundsexception ( _str + index + _str + size ) ; } } system . arraycopy ( data , index + _num , data , index , size - index - _num ) ; size -- ; }	remove the value at the given index .
protected boolean displaypopup ( list < component > contents , mouseevent me ) { if ( debug ) { debug . output ( _str + contents + _str + me ) ; } if ( contents != null && ! contents . isempty ( ) ) { jpopupmenu jpm = new jpopupmenu ( ) ; for ( component comp : contents ) { jpm . add ( comp ) ; } jpm . show ( ( component ) me . getsource ( ) , me . getx ( ) , me . gety ( ) ) ; return _bool ; } return _bool ; }	create a pop - up menu from grp requests , over the mouse event location .
@ override public commandoutput executecommand ( command command ) throws commandexception { if ( ! isconnected ( ) ) { connect ( ) ; } string cli = command . getcommandline ( ) ; return sendcommand ( cli ) ; }	executes a command on the remote system .
private boolean isvalidanonusername ( ) { if ( iscasesensitive ) { return validanonusernames . contains ( usernameparam ) ; } else { for ( iterator it = validanonusernames . iterator ( ) ; it . hasnext ( ) ; ) { string name = ( string ) it . next ( ) ; if ( name != null && name . equalsignorecase ( usernameparam ) ) { usernameparam = name ; return _bool ; } } } return _bool ; }	check if the username is a valid anonymous user name in either case sensitive or insensitive cases .
public static double hypot ( double a , double b ) { double r ; if ( math . abs ( a ) > math . abs ( b ) ) { r = b / a ; r = math . abs ( a ) * math . sqrt ( _num + r * r ) ; } else if ( b != _num ) { r = a / b ; r = math . abs ( b ) * math . sqrt ( _num + r * r ) ; } else { r = _num ; } return r ; }	returns sqrt ( a ^ 2 + b ^ 2 ) without under / overflow .
public void testoneone ( ) { byte abytes [ ] = { _num } ; byte bbytes [ ] = { _num } ; int asign = _num ; int bsign = _num ; byte rbytes [ ] = { _num } ; biginteger anumber = new biginteger ( asign , abytes ) ; biginteger bnumber = new biginteger ( bsign , bbytes ) ; biginteger result = anumber . or ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _str , _num , result . signum ( ) ) ; }	or for one and one.
private void registertaskinstances ( ) { for ( taskfromdbtrigger trigger : taskslist ) { if ( trigger . isvalid ( ) ) { trigger . inittrigger ( ) ; } else { log . error ( _str + trigger . gettaskid ( ) ) ; } } }	launching & checking task process.
private void readobject ( objectinputstream oos ) throws ioexception , classnotfoundexception { iinstant = ( datetime ) oos . readobject ( ) ; datetimefieldtype type = ( datetimefieldtype ) oos . readobject ( ) ; ifield = type . getfield ( iinstant . getchronology ( ) ) ; }	reads the property from a safe serialization format .
private jtextarea createasmfield ( ) { final jtextarea asmfield = new jtextarea ( _num , _num ) ; asmfield . setfont ( guihelper . monospaced_font ) ; asmfield . seteditable ( _bool ) ; return asmfield ; }	creates a text field that can be used to display assembler code .
public void removedrawerlistener ( @ nonnull drawerlistener listener ) { if ( listener == null ) { return ; } if ( mlisteners == null ) { return ; } mlisteners . remove ( listener ) ; }	removes the specified listener from the list of listeners that will be notified of drawer events .
public void validatemetaaliasfornewentity ( string realm , list < string > newmetaaliases ) throws wsfederationmetaexception { if ( null != newmetaaliases && ! newmetaaliases . isempty ( ) ) { if ( newmetaaliases . size ( ) > _num ) { set checkforduplicates = new hashset < string > ( newmetaaliases ) ; if ( checkforduplicates . size ( ) < newmetaaliases . size ( ) ) { debug . error ( _str + _str + newmetaaliases ) ; string [ ] data = { newmetaaliases . tostring ( ) } ; throw new wsfederationmetaexception ( _str , data ) ; } } list < string > allrealmmetaaliaes = getallhostedmetaaliasesbyrealm ( realm ) ; if ( ! allrealmmetaaliaes . isempty ( ) ) { list < string > duplicatemetaaliases = new arraylist < string > ( ) ; for ( string metaalias : newmetaaliases ) { if ( allrealmmetaaliaes . contains ( metaalias ) ) { duplicatemetaaliases . add ( metaalias ) ; } } if ( ! duplicatemetaaliases . isempty ( ) ) { stringbuilder sb = new stringbuilder ( ) ; for ( string value : duplicatemetaaliases ) { sb . append ( value ) ; sb . append ( _str ) ; } debug . error ( _str + sb . tostring ( ) + _str + realm ) ; string [ ] data = { sb . tostring ( ) , realm } ; throw new wsfederationmetaexception ( _str , data ) ; } } } }	checks that the provided metaaliases are valid for a new hosted entity in the specified realm.
public static set < string > assertvalidciphersuites ( set < string > expected , string [ ] ciphersuites ) { assertnotnull ( ciphersuites ) ; asserttrue ( ciphersuites . length != _num ) ; set remainingciphersuites = new hashset < string > ( expected ) ; set unknownciphersuites = new hashset < string > ( ) ; for ( string ciphersuite : ciphersuites ) { boolean removed = remainingciphersuites . remove ( ciphersuite ) ; if ( ! removed ) { unknownciphersuites . add ( ciphersuite ) ; } } assertequals ( _str , collections . empty_set , unknownciphersuites ) ; return remainingciphersuites ; }	asserts that the cipher suites array is non - null and that it all of its contents are cipher suites known to this implementation.
public void move ( double x , double y ) { move move = new move ( x , y ) ; if ( x < minx ) { minx = x ; } if ( y < miny ) { miny = y ; } if ( x > maxx ) { maxx = x ; } if ( y > maxy ) { maxy = y ; } elements . add ( move ) ; }	move the pen without drawing any line.
public keywordsearchtupleset ( ) { m_lucene = new lucenesearcher ( ) ; }	creates a new keywordsearchfocusset using an in - memory search index .
private static string substituteproperties ( string str ) { str = str . trim ( ) ; matcher matcher = prop_regex . matcher ( str ) ; stringbuffer buf = new stringbuffer ( ) ; while ( matcher . find ( ) ) { string match = matcher . group ( ) ; if ( match . length ( ) >= _num ) { string key = match . substring ( _num , match . length ( ) - _num ) ; string val = system . getenv ( key ) ; if ( val == null ) val = system . getproperty ( key ) ; if ( val != null ) { match = val . replaceall ( _str , _str ) ; } else if ( match . startswith ( _str ) ) match = match . replace ( _str , _str ) ; } matcher . appendreplacement ( buf , match ) ; } matcher . appendtail ( buf ) ; return buf . tostring ( ) ; }	substitutes environmental or system properties in the given string .
private queuedrequestsender ( builder builder ) { this . messagestore = builder . messagestore ; this . clientregistry = builder . clientregistry ; this . observationregistry = builder . observationregistry ; this . delegatesender = builder . delegatesender ; this . clientstatustracker = new clientstatustracker ( ) ; this . queuemodeclientregistrylistener = new queuemodeclientregistrylistener ( ) ; clientregistry . addlistener ( queuemodeclientregistrylistener ) ; this . queuemodeobservationregistrylistener = new queuemodeobservationregistrylistener ( ) ; observationregistry . addlistener ( queuemodeobservationregistrylistener ) ; delegatesender . addresponselistener ( createresponselistener ( ) ) ; }	creates a new queuerequestsender using given builder .
public void start ( int conditions ) throws ioexception { super . start ( conditions ) ; int ptr = ( int ) tagout . getbyteswritten ( ) ; int offset = ptr - lastptr ; offsets . add ( new int [ ] { lastptr , offset } ) ; lastptr = ptr ; tagout . writeui16 ( _num ) ; tagout . writeui16 ( conditions ) ; }	description of the method.
public synchronized int writetofile ( jdbcsequentialfile file , byte [ ] data ) throws sqlexception { try { connection . setautocommit ( _bool ) ; appendtolargeobject . setbytes ( _num , data ) ; appendtolargeobject . setint ( _num , file . getid ( ) ) ; appendtolargeobject . executeupdate ( ) ; connection . commit ( ) ; return data . length ; } catch ( sqlexception e ) { connection . rollback ( ) ; throw e ; } }	persists data to this files associated database mapping .
private void close ( ) { db . close ( m_rs , m_pstmt ) ; m_rs = null ; m_pstmt = null ; }	close resultset and statement.
public boolean equalsignature ( assignment obj ) { if ( this == obj ) return _bool ; if ( obj == null ) return _bool ; if ( label == null ) { if ( obj . label != null ) return _bool ; } else if ( ! label . equals ( obj . label ) ) return _bool ; return ( params . length == obj . params . length ) ; }	compares if the signature ( label and the number of parameters matches ).
public mpinstancepara createparameter ( int seqno , string parametername , object value ) { mpinstancepara ip = new mpinstancepara ( this , seqno ) ; if ( value == null ) { ip . setparameter ( parametername , ( string ) null ) ; } else if ( value instanceof bigdecimal ) { ip . setparameter ( parametername , ( bigdecimal ) value ) ; } else if ( value instanceof integer ) { ip . setparameter ( parametername , ( integer ) value ) ; } else if ( value instanceof timestamp ) { ip . setparameter ( parametername , ( timestamp ) value ) ; } else if ( value instanceof boolean ) { ip . setparameter ( parametername , ( boolean ) value ) ; } else { ip . setparameter ( parametername , value . tostring ( ) ) ; } ip . saveex ( ) ; return ip ; }	create process instance parameter and save to database.
public void testaddingadocumentfragmentaddsitschildren ( ) { element a = document . createelement ( _str ) ; element b = document . createelement ( _str ) ; element c = document . createelement ( _str ) ; documentfragment fragment = document . createdocumentfragment ( ) ; fragment . appendchild ( a ) ; fragment . appendchild ( b ) ; fragment . appendchild ( c ) ; node returned = menu . appendchild ( fragment ) ; assertsame ( fragment , returned ) ; nodelist children = menu . getchildnodes ( ) ; assertequals ( _num , children . getlength ( ) ) ; asserttrue ( children . item ( _num ) instanceof text ) ; assertequals ( item , children . item ( _num ) ) ; asserttrue ( children . item ( _num ) instanceof text ) ; assertequals ( a , children . item ( _num ) ) ; assertequals ( b , children . item ( _num ) ) ; assertequals ( c , children . item ( _num ) ) ; }	documents shouldn ' t contain document fragments.
public void add ( t graphic ) { synchronized ( mlock ) { mgraphics . add ( graphic ) ; if ( mfirstgraphic == null ) { mfirstgraphic = graphic ; } } postinvalidate ( ) ; }	adds a graphic to the overlay .
@ override public string tostring ( ) { try { stringbuffer text = new stringbuffer ( ) ; text . append ( m_attr . name ( ) + _str ) ; for ( int v = _num ; v < m_classifications . length ; v ++ ) { text . append ( _str ) ; if ( m_attr . isnominal ( ) ) { text . append ( m_attr . value ( v ) ) ; } else if ( v < m_breakpoints . length ) { text . append ( _str + m_breakpoints [ v ] ) ; } else if ( v > _num ) { text . append ( _str + m_breakpoints [ v - _num ] ) ; } else { text . append ( _str ) ; } text . append ( _str + m_class . value ( m_classifications [ v ] ) + _str ) ; } if ( m_missingvalueclass != - _num ) { text . append ( _str + m_class . value ( m_missingvalueclass ) + _str ) ; } text . append ( _str + m_correct + _str + m_numinst + _str ) ; return text . tostring ( ) ; } catch ( exception e ) { return _str ; } }	returns a description of the rule .
protected int parseint ( ) throws ioexception { int sign = _num ; int value = _num ; int ch = skipwhitespace ( ) ; if ( ch == _str ) ch = read ( ) ; else if ( ch == _str ) { sign = - _num ; ch = read ( ) ; } for ( ; ch >= _str && ch <= _str ; ch = read ( ) ) value = _num * value + ch - _str ; peek = ch ; return sign * value ; }	parses an integer value from the stream .
private list < byte [ ] > convertstringlisttobytearray ( list < string > valuelist ) { list < byte [ ] > bytearraylist = new arraylist < > ( valuelist . size ( ) ) ; for ( string value : valuelist ) { bytearraylist . add ( value . getbytes ( charset . forname ( carboncommonconstants . default_charset ) ) ) ; } return bytearraylist ; }	this method will convert list of string to list of byte array.
private void addobjectifnotfound ( object obj , vector v ) { int n = v . size ( ) ; boolean addit = _bool ; for ( int i = _num ; i < n ; i ++ ) { if ( v . elementat ( i ) == obj ) { addit = _bool ; break ; } } if ( addit ) { v . addelement ( obj ) ; } }	add object to vector if not already there .
public void put ( final long key ) { keylist . add ( key ) ; }	add the key to the task , prior to execution .
@ post @ produces ( { mediatype . application_xml , mediatype . application_json } ) @ path ( _str ) @ checkpermission ( roles = { role . tenant_admin } ) public taskresourcerep createvcentercluster ( @ pathparam ( _str ) uri id , vcenterclusterparam vcenterclusterparam ) { return createorupdatevcentercluster ( _bool , id , vcenterclusterparam . getid ( ) , null , null ) ; }	create a new vcenter cluster with all hosts and datastores.
public void addserver ( inetsocketaddress addr ) { serveraddresses . add ( addr . gethostname ( ) + _str + addr . getport ( ) ) ; }	adds a server address.
public static int utf8length ( string string ) { characteriterator iter = new stringcharacteriterator ( string ) ; char ch = iter . first ( ) ; int size = _num ; while ( ch != characteriterator . done ) { if ( ( ch >= _num ) && ( ch < _num ) ) { char trail = iter . next ( ) ; if ( ( trail > _num ) && ( trail < _num ) ) { size += _num ; } else { size += _num ; iter . previous ( ) ; } } else if ( ch < _num ) { size ++ ; } else if ( ch < _num ) { size += _num ; } else { size += _num ; } ch = iter . next ( ) ; } return size ; }	for the given string , returns the number of utf - 8 bytes required to encode the string .
public static void unregisterclientapp ( context context ) throws appcatalogexception { string serverip = preference . getstring ( context , constants . preferenceflag . ip ) ; if ( serverip != null && ! serverip . isempty ( ) ) { string applicationname = preference . getstring ( context , constants . client_name ) ; string consumerkey = preference . getstring ( context , constants . client_id ) ; string userid = preference . getstring ( context , constants . username ) ; if ( applicationname != null && ! applicationname . isempty ( ) && consumerkey != null && ! consumerkey . isempty ( ) && userid != null && ! userid . isempty ( ) ) { unregisterprofile profile = new unregisterprofile ( ) ; profile . setapplicationname ( applicationname ) ; profile . setconsumerkey ( consumerkey ) ; profile . setuserid ( userid ) ; serverconfig utils = new serverconfig ( ) ; utils . setserverip ( serverip ) ; dynamicclientmanager dynamicclientmanager = new dynamicclientmanager ( ) ; boolean isunregistered = dynamicclientmanager . unregisterclient ( profile , utils , context ) ; if ( ! isunregistered ) { log . e ( tag , _str ) ; } } else { log . e ( tag , _str ) ; } } else { log . e ( tag , _str ) ; } }	this method is used to initiate the oauth client app unregister process .
protected byte [ ] ftpget ( final string urlstring ) { inputstream inputstream = null ; try { final url url = new url ( urlstring ) ; inputstream = url . openstream ( ) ; return dssutils . tobytearray ( inputstream ) ; } catch ( exception e ) { log . warn ( e . getmessage ( ) ) ; } finally { ioutils . closequietly ( inputstream ) ; } return null ; }	this method retrieves data using ftp protocol .
public void testsetbitnegativeinside3 ( ) { string as = _str ; string res = _str ; int number = _num ; biginteger anumber = new biginteger ( as ) ; biginteger result = anumber . setbit ( number ) ; assertequals ( res , result . tostring ( ) ) ; }	setbit ( int n ) inside a negative number with all ones in bit representation.
private static double gnorm ( double a , double x ) { double sx ; if ( ( x <= _num ) || ( a <= _num ) ) { return _num ; } else { sx = math . sqrt ( a ) * _num * ( math . pow ( x / a , _num / _num ) + _num / ( a * _num ) - _num ) ; return normalcdf ( sx ) ; } }	compute gamma cdf by a normal approximation.
public object createparameter ( final class < ? > c ) { if ( c == integer . type ) { return integer . valueof ( random . nextint ( ) ) ; } else if ( c == double . type ) { return double . valueof ( random . nextdouble ( ) ) ; } else if ( c == double [ ] . class ) { final double [ ] v = new double [ dim ] ; for ( int i = _num ; i < dim ; i ++ ) { v [ i ] = random . nextdouble ( ) ; } return v ; } else if ( c . isassignablefrom ( realvector . class ) ) { return createvector ( ) ; } else if ( c . isassignablefrom ( univariatefunction . class ) ) { return new sin ( ) ; } else { throw new illegalargumentexception ( _str + c ) ; } }	creates a new random object of the specified type .
@ override public void clear ( ) { entry tab [ ] = table ; modcount ++ ; for ( int index = tab . length ; -- index >= _num ; ) tab [ index ] = null ; count = _num ; }	removes all mappings from this map .
public void showlist ( list < itemchooserrow > list ) { mprogressbar . setvisibility ( view . gone ) ; if ( ! list . isempty ( ) ) { mitemadapter . addall ( list ) ; } setstate ( state . progress_update_available ) ; }	add items to show in the dialog .
protected ieobjectdescription createsingleelementdescription ( tmember existingmember ) { return eobjectdescription . create ( existingmember . getname ( ) , existingmember ) ; }	creates a description for a successfully found element.
public list < iresource > chooseresources ( ) { if ( open ( ) == window . ok ) { list < iresource > resources = new arraylist < iresource > ( ) ; for ( object obj : getresult ( ) ) { resources . add ( ( iresource ) obj ) ; } return resources ; } return null ; }	return the selected resource ( s ) as a list of iresource objects .
@ override public void emit ( alertstreamevent event ) { try { queue . put ( event ) ; } catch ( interruptedexception e ) { log . error ( e . getmessage ( ) , e ) ; } }	emit method can be called in multi - thread .
public static tungstenproperties loadfromjson ( string json ) throws jsonparseexception , jsonmappingexception , ioexception { objectmapper mapper = new objectmapper ( ) ; tungstenproperties tungstenprop = mapper . readvalue ( json , tungstenproperties . class ) ; return tungstenprop ; }	load values from a json serialized string.
public < t > string makestringvalue ( t value ) { return value . tostring ( ) ; }	scipio : makes an escaped freemarker string value without enclosing double - quotes , as intended for a regular ( non - raw ) string.
public void testavailable ( ) throws exception { byte [ ] data = new byte [ ] { - _num , - _num , - _num , - _num , - _num , _num , _num , _num , _num , _num } ; testinputstream tis = new testinputstream ( data ) ; cipherinputstream cis = new cipherinputstream ( tis , new nullcipher ( ) ) ; assertequals ( _str + _str , cis . available ( ) , _num ) ; }	available ( ) method testing.
private void encodefullrevisionuncompressed ( final diffpart part ) throws unsupportedencodingexception , encodingexception { data . writebit ( _num ) ; data . writebit ( _num ) ; data . writebit ( _num ) ; string text = part . gettext ( ) ; byte [ ] btext = text . getbytes ( wikipedia_encoding ) ; data . writevalue ( codecdata . getblocksizel ( ) , btext . length ) ; data . write ( btext ) ; }	encodes a fullrevision operation .
public static string tobits ( final long x ) { final stringbuilder sb = new stringbuilder ( ) ; long t = x ; boolean first = _bool ; for ( int i = _num ; i < _num ; i ++ ) { if ( t < _num ) { sb . append ( _str ) ; first = _bool ; } else if ( first ) { sb . append ( _str ) ; } t = t << _num ; } assert t == _num ; return sb . tostring ( ) ; }	convert a number into a bit string .
private void hideablelabel ( jlabel label , string text ) { if ( text . isempty ( ) ) { label . setforeground ( label_invisible ) ; } else { label . setforeground ( label_visible ) ; label . settext ( text ) ; } }	changes the text on the given label , making it invisible if the text is empty or visible again otherwise .
public static string join ( collection < ? > c , string delim ) { stringbuilder retval = new stringbuilder ( ) ; iterator < ? > itr = c . iterator ( ) ; if ( itr . hasnext ( ) ) retval . append ( itr . next ( ) ) ; else return _str ; while ( itr . hasnext ( ) ) { retval . append ( delim ) ; retval . append ( itr . next ( ) ) ; } return retval . tostring ( ) ; }	similar to perl ' s join ( ) method on lists , but works with all collections .
public void enddocument ( ) throws saxexception { write ( _str ) ; super . enddocument ( ) ; try { flush ( ) ; } catch ( ioexception e ) { throw new saxexception ( e ) ; } }	write a newline at the end of the document.
protected boolean isstopped ( ) { return this . _isstopped ; }	returns whether the dispatcher is stopped.
public string scmrevision ( ) { return properties . getproperty ( _str ) ; }	returns the revision number of the source repository on which this build is based .
public void askpermissions ( ) { mpermissionstoask = getnotgrantedpermissions ( ) ; if ( mpermissionstoask . size ( ) > _num && build . version . sdk_int >= build . version_codes . m ) { requestpermissions ( mpermissionstoask . toarray ( new string [ mpermissionstoask . size ( ) ] ) , my_permission_request_all ) ; } else { sendresponse ( _bool ) ; } }	main function to ask permissions.
public greaterequalconstraint ( double constraintvalue ) { super ( double . valueof ( constraintvalue ) ) ; }	creates a greater - equal parameter constraint.
public void testgetownerdocument1 ( ) throws throwable { document doc ; document ownerdoc ; domimplementation domimpl ; documenttype doctype ; string nullid = null ; doc = ( document ) load ( _str , builder ) ; domimpl = doc . getimplementation ( ) ; doctype = domimpl . createdocumenttype ( _str , nullid , nullid ) ; ownerdoc = doctype . getownerdocument ( ) ; assertnull ( _str , ownerdoc ) ; }	runs the test case .
private void addaction ( string label , int id , int type ) { cardaction cardaction = new cardaction ( ) ; cardaction . label = label ; cardaction . id = id ; cardaction . type = type ; mcardactions . add ( cardaction ) ; }	adds an action to this card during build time .
private date backofftime ( date starttime ) { if ( starttime . before ( dateutils . addminutes ( new date ( ) , - _num ) ) ) { return dateutils . addseconds ( starttime , - _num ) ; } return dateutils . addseconds ( starttime , - backoff_time ) ; }	adds backoff time to start time.
public static final int binarysearch ( object [ ] a , object key , comparator cp , int begin , int end ) { int x1 = begin ; int x2 = end ; int i = x1 + ( x2 - x1 ) / _num , c ; while ( x1 < x2 ) { c = cp . compare ( a [ i ] , key ) ; if ( c == _num ) { return i ; } else if ( c < _num ) { x1 = i + _num ; } else { x2 = i ; } i = x1 + ( x2 - x1 ) / _num ; } return - _num * ( i + _num ) ; }	perform a binary search over a sorted range of an array for the given key .
private void postinitviewpager ( ) { try { class < ? > viewpager = viewpager . class ; field scroller = viewpager . getdeclaredfield ( _str ) ; scroller . setaccessible ( _bool ) ; field interpolator = viewpager . getdeclaredfield ( _str ) ; interpolator . setaccessible ( _bool ) ; mscroller = new customdurationscroller ( getcontext ( ) , ( interpolator ) interpolator . get ( null ) ) ; double duration = _num ; mscroller . setscrolldurationfactor ( duration ) ; scroller . set ( this , mscroller ) ; } catch ( nosuchfieldexception e ) { } catch ( illegalargumentexception e ) { } catch ( illegalaccessexception e ) { } }	override the scroller instance with our own class so we can change the duration.
public ipreparedsparqlupdate prepareupdate ( final string updatestr ) throws exception { return prepareupdate ( updatestr , uuid . randomuuid ( ) ) ; }	prepare a sparql update request .
private void handlecertificaterequest ( certificaterequest request ) { if ( request . getrenew ( ) ) { val certificateresponse = requesthandler . requestcertificate ( request . getdomains ( ) ) ; secretmanager . updatecertificate ( namespace , request . getsecretname ( ) , certificateresponse ) ; } else { val certificateresponse = requesthandler . requestcertificate ( request . getdomains ( ) ) ; secretmanager . insertcertificate ( namespace , request . getsecretname ( ) , certificateresponse ) ; } }	this function performs a certificate request as determined by preparecertificaterequest ( ).
private final void sendchunkto ( bytebuffer in , socketchannel sc , bytebuffer out ) throws ioexception { int bytessent = in . remaining ( ) ; if ( in . isdirect ( ) ) { flushbuffer ( sc , out ) ; while ( in . remaining ( ) > _num ) { sc . write ( in ) ; } } else { int out_max = out . remaining ( ) ; if ( bytessent <= out_max ) { out . put ( in ) ; } else { final byte [ ] bytes = in . array ( ) ; int off = in . arrayoffset ( ) + in . position ( ) ; int len = bytessent ; while ( len > _num ) { int bytesthistime = len ; if ( bytesthistime > out_max ) { bytesthistime = out_max ; } out . put ( bytes , off , bytesthistime ) ; off += bytesthistime ; len -= bytesthistime ; flushbuffer ( sc , out ) ; out_max = out . remaining ( ) ; } in . position ( in . limit ( ) ) ; } } this . size -= bytessent ; }	sends the data from " in " by writing it to " sc " through " out " ( out is used to chunk to data and is probably a direct memory buffer ) .
public void clearlastlogintime ( ) { operations . add ( passwordpolicystateoperationtype . clear_last_login_time ) ; }	clears the last login time .
public boolean copy ( string torpfdir ) { file todir = new file ( torpfdir ) ; boolean ret = _bool ; string sourcerpfdir = getrpfdir ( ) ; if ( ( todir . exists ( ) || todir . mkdirs ( ) ) && framelist != null ) { if ( verbose ) { debug . output ( _str + sourcerpfdir + _str + torpfdir + _str ) ; } for ( iterator < string > it = framelist . iterator ( ) ; it . hasnext ( ) ; ) { string relativefilepath = _str + it . next ( ) ; file fromfile = new file ( sourcerpfdir + relativefilepath ) ; file tofile = new file ( torpfdir + relativefilepath ) ; file toparent = tofile . getparentfile ( ) ; if ( ! toparent . exists ( ) ) { toparent . mkdirs ( ) ; } if ( verbose ) { debug . output ( _str + relativefilepath ) ; } try { fileutils . copy ( fromfile , tofile , _num ) ; } catch ( ioexception ioe ) { debug . error ( _str + ioe . getmessage ( ) ) ; return _bool ; } } ret = _bool ; } return ret ; }	copy the frame files currently set on the framelist to the provided rpf directory .
protected void stopresetexpiredjobsthread ( ) { if ( resetexpiredjobthread != null ) { try { resetexpiredjobthread . join ( ) ; } catch ( interruptedexception e ) { log . warn ( _str , e ) ; } resetexpiredjobthread = null ; } }	stops the reset expired jobs thread.
@ suppresswarnings ( { _str , _str } ) private list filterresourcesforlookup ( iterable resources , resourcefield field ) { list results = new arraylist ( ) ; iterator iterator = resources . iterator ( ) ; while ( iterator . hasnext ( ) ) { object resource = iterator . next ( ) ; object property = propertyutils . getproperty ( resource , field . getunderlyingname ( ) ) ; lookupincludebehavior lookupincludebehavior = field . getlookupincludeautomatically ( ) ; if ( lookupincludebehavior == lookupincludebehavior . automatically_always || ( property == null && lookupincludebehavior == lookupincludebehavior . automatically_when_null ) ) { results . add ( resource ) ; } } return results ; }	filter by resources that need lookup based on incusion behavior .
public void clearnodemap ( ) { nodeloc . clear ( ) ; }	clears node local map .
public static < t > t checknotnull ( t reference , object errormessage ) { if ( exoplayerlibraryinfo . assertions_enabled && reference == null ) { throw new nullpointerexception ( string . valueof ( errormessage ) ) ; } return reference ; }	ensures that an object reference is not null .
public synchronized void rollback ( ) throws replicatorexception { assertwritable ( ) ; }	rollback transactions stored in the log .
private synchronized void updatethreadpanel ( boolean forceupdate ) { if ( ! forceupdate && ! isvisible ( ) ) { return ; } threadpanel . removeall ( ) ; gridbagconstraints gbc = new gridbagconstraints ( ) ; gbc . gridx = _num ; gbc . gridy = _num ; gbc . weightx = _num ; gbc . weighty = _num ; gbc . fill = gridbagconstraints . horizontal ; gbc . ipady = _num ; for ( progressthread currentthread : progressthread . getcurrentthreads ( ) ) { progressthreaddisplay pgpanel = new progressthreaddisplay ( currentthread , _bool ) ; threadpanel . add ( pgpanel , gbc ) ; mapping_pg_to_ui . put ( currentthread , pgpanel ) ; updateprogressmessage ( currentthread ) ; updateprogress ( currentthread ) ; gbc . gridy += _num ; } for ( progressthread queuedthread : progressthread . getqueuedthreads ( ) ) { progressthreaddisplay pgpanel = new progressthreaddisplay ( queuedthread , _bool ) ; threadpanel . add ( pgpanel , gbc ) ; mapping_pg_to_ui . put ( queuedthread , pgpanel ) ; gbc . gridy += _num ; } gbc . gridy += _num ; gbc . weighty = _num ; gbc . fill = gridbagconstraints . both ; threadpanel . add ( new jlabel ( ) , gbc ) ; threadpanel . revalidate ( ) ; threadpanel . repaint ( ) ; }	updates the thread display panel which shows running / queued threads .
private boolean isimplicitimport ( string name ) { boolean yes = implicitimports . get ( name ) ; if ( yes != null ) { return yes ; } try { class . forname ( _str + name ) ; yes = _bool ; } catch ( exception e ) { yes = _bool ; } implicitimports . put ( name , yes ) ; return yes ; }	checks whether the simple type name is implicitly imported from java.
public void addbannedmac ( final string mac ) { addbannedmac ( mac , null ) ; }	ban the mac permanently.
@ override public void accept ( int value ) { ++ count ; sum += value ; min = math . min ( min , value ) ; max = math . max ( max , value ) ; }	records a new value into the summary information.
public void mouseentered ( mouseevent e ) { jcomponent c = ( jcomponent ) e . getsource ( ) ; c . setcursor ( cursor ) ; }	show a special cursor while the mouse is inside the window.
private void printpoolrecommendations ( list < recommendation > poolrecommendations ) { stringbuffer buf = new stringbuffer ( ) ; buf . append ( string . format ( _str ) ) ; for ( recommendation poolrec : poolrecommendations ) { storagepool pool = dbclient . queryobject ( storagepool . class , poolrec . getsourcestoragepool ( ) ) ; buf . append ( string . format ( _str , pool . getlabel ( ) , pool . getfreecapacity ( ) ) ) ; } buf . append ( string . format ( _str ) ) ; _log . info ( buf . tostring ( ) ) ; }	display storage pool information from recommendation.
private tuple < message , connection > tryothermessages ( ) { list < tuple < message , connection > > messages = new arraylist < tuple < message , connection > > ( ) ; collection < message > msgcollection = getmessagecollection ( ) ; for ( connection con : getconnections ( ) ) { dtnhost other = con . getothernode ( gethost ( ) ) ; prophetrouter othrouter = ( prophetrouter ) other . getrouter ( ) ; if ( othrouter . istransferring ( ) ) { continue ; } for ( message m : msgcollection ) { if ( othrouter . hasmessage ( m . getid ( ) ) ) { continue ; } if ( othrouter . getpredfor ( m . getto ( ) ) > getpredfor ( m . getto ( ) ) ) { messages . add ( new tuple < message , connection > ( m , con ) ) ; } } } if ( messages . size ( ) == _num ) { return null ; } collections . sort ( messages , new tuplecomparator ( ) ) ; return trymessagesforconnected ( messages ) ; }	tries to send all other messages to all connected hosts ordered by their delivery probability.
public static string tostring ( object value ) { if ( value == null ) { return null ; } return value . tostring ( ) ; }	converts safely an object to a string .
static boolean lessthanunsigned ( long x1 , long x2 ) { return ( x1 + long . min_value ) < ( x2 + long . min_value ) ; }	returns true if x1 is less than x2 , when both values are treated as unsigned .
@ override public boolean remove ( object object ) { return removeelement ( object ) ; }	removes the first occurrence , starting at the beginning and moving towards the end , of the specified object from this vector.
public static int findendofstring ( string str , int loc , int line ) throws parsealgorithmexception { int pos = loc + _num ; boolean found = _bool ; while ( ( ! found ) && ( pos < str . length ( ) ) ) { char c = str . charat ( pos ) ; if ( c == _str ) { found = _bool ; } else if ( c == _str && ( pos < str . length ( ) - _num ) ) { pos ++ ; } pos ++ ; } if ( ! found ) { throw new parsealgorithmexception ( _str + _str + ( line + _num ) + _str + ( loc + _num ) ) ; } return pos ; }	this method assumes that str is a string whose character at position loc is a quote ( " ).
public string toverbosestring ( ) { stringbuffer result = new stringbuffer ( ) ; result . append ( _str ) ; result . append ( getname ( ) ) ; result . append ( _str ) ; result . append ( getjavaname ( ) ) ; result . append ( _str ) ; result . append ( getmappedtype ( ) ) ; result . append ( _str ) ; result . append ( getmappedtypecode ( ) ) ; result . append ( _str ) ; result . append ( getsize ( ) ) ; result . append ( _str ) ; result . append ( isrequired ( ) ) ; result . append ( _str ) ; result . append ( isprimarykey ( ) ) ; result . append ( _str ) ; result . append ( isautoincrement ( ) ) ; result . append ( _str ) ; result . append ( getdefaultvalue ( ) ) ; result . append ( _str ) ; result . append ( getprecisionradix ( ) ) ; result . append ( _str ) ; result . append ( getscale ( ) ) ; result . append ( _str ) ; return result . tostring ( ) ; }	returns a verbose string representation of this column .
private void simulateblock ( ssabasicblock block ) { for ( ssainsn insn : block . getinsns ( ) ) { if ( insn instanceof phiinsn ) { simulatephi ( ( phiinsn ) insn ) ; } else { simulatestmt ( insn ) ; } } }	simulate a block and note the results in the lattice .
public static bigdecimal roundoff ( final bigdecimal amount ) { return amount . setscale ( decimals , rounding_mode ) ; }	this method is a utility method , which takes a bigdecimal and rounds that to 0 places .
public fits ( ) { }	create an empty fits object which is not associated with an input stream .
@ deprecated public void correctlyspends ( transaction txcontainingthis , long scriptsigindex , script scriptpubkey ) throws scriptexception { correctlyspends ( txcontainingthis , scriptsigindex , scriptpubkey , all_verify_flags ) ; }	verifies that this script ( interpreted as a scriptsig ) correctly spends the given scriptpubkey , enabling all validation rules .
public void done ( ) { output . println ( ) ; }	description of the method.
protected void processinitiators ( exportgroup exportgroup , collection < initiator > initiators , collection < string > portnames , map < string , uri > portnametoinitiatoruri , collection < uri > hosturis , listmultimap < string , string > computeresourcetoportnames ) { for ( initiator initiator : initiators ) { string normalizedname = initiator . normalizeport ( initiator . getinitiatorport ( ) ) ; portnames . add ( normalizedname ) ; portnametoinitiatoruri . put ( normalizedname , initiator . getid ( ) ) ; if ( hosturis != null ) { if ( ! nullcolumnvaluegetter . isnulluri ( initiator . gethost ( ) ) && ! hosturis . contains ( initiator . gethost ( ) ) ) { hosturis . add ( initiator . gethost ( ) ) ; } } if ( computeresourcetoportnames != null ) { string computeresourceid ; if ( exportgroup != null && exportgroup . forcluster ( ) ) { computeresourceid = initiator . getclustername ( ) ; } else { uri hosturi = initiator . gethost ( ) ; if ( hosturi == null ) { hosturi = nullcolumnvaluegetter . getnulluri ( ) ; } computeresourceid = hosturi . tostring ( ) ; } computeresourcetoportnames . put ( computeresourceid , normalizedname ) ; } } }	a utility for processing initiators and updating data structures.
public void writeasserializedbytearray ( object v ) throws ioexception { if ( this . ignorewrites ) return ; checkifwritable ( ) ; ensurecapacity ( _num ) ; if ( v instanceof heapdataoutputstream ) { heapdataoutputstream other = ( heapdataoutputstream ) v ; other . finishwriting ( ) ; internaldataserializer . writearraylength ( other . size ( ) , this ) ; if ( this . donotcopy ) { if ( other . chunks != null ) { for ( bytebuffer bb : other . chunks ) { write ( bb ) ; } } write ( other . buffer ) ; } else { other . sendto ( ( bytebufferwriter ) this ) ; other . rewind ( ) ; } } else { bytebuffer sizebuf = this . buffer ; int sizepos = sizebuf . position ( ) ; sizebuf . position ( sizepos + _num ) ; final int prearraysize = size ( ) ; dataserializer . writeobject ( v , this ) ; int arraysize = size ( ) - prearraysize ; sizebuf . put ( sizepos , internaldataserializer . int_array_len ) ; sizebuf . putint ( sizepos + _num , arraysize ) ; } }	writes the given object to this stream as a byte array.
private boolean isclosed ( ) { if ( ! verifyreader ) { return _bool ; } try { br . mark ( _num ) ; int nextbyte = br . read ( ) ; br . reset ( ) ; return nextbyte == - _num ; } catch ( ioexception e ) { return _bool ; } }	checks to see if the file is closed .
public static void appendfiletofile ( final file file1 , final file file2 ) { if ( ! isreadable ( file1 ) || ! isreadable ( file2 ) || ! iswritable ( file1 ) ) { return ; } try { fileinputstream inputstream = new fileinputstream ( file2 ) ; fileoutputstream outputstream = new fileoutputstream ( file1 , _bool ) ; int count ; final int buffer_size = _num ; byte [ ] bytes = new byte [ buffer_size ] ; while ( ( count = inputstream . read ( bytes , _num , buffer_size ) ) > _num ) outputstream . write ( bytes , _num , count ) ; fileutils . sync ( outputstream ) ; outputstream . close ( ) ; inputstream . close ( ) ; } catch ( filenotfoundexception e ) { e . printstacktrace ( ) ; } catch ( ioexception e ) { e . printstacktrace ( ) ; } }	appends one file to another .
public static double distance ( latlng pointa , latlng pointb ) { double lat = math . toradians ( pointa . latitude ) ; double lat2 = math . toradians ( pointb . latitude ) ; double diflat = math . toradians ( pointb . latitude - pointa . latitude ) ; double diflong = math . toradians ( pointb . longitude - pointa . longitude ) ; double a = ( math . pow ( math . sin ( diflat / _num ) , _num ) ) + ( math . cos ( lat ) * math . cos ( lat2 ) * math . pow ( math . sin ( diflong / _num ) , _num ) ) ; double c = _num * math . atan2 ( math . sqrt ( a ) , math . sqrt ( _num - a ) ) ; return earth * c ; }	returns the distance from ' this ' point to destination point ( using haversine formula ) .
public final boolean is_clearance_compensation_used ( ) { return compensated_clearance_class_no > _num ; }	if for the shapes stored in this tree clearance compensation is used .
private long trydecreaderoverflow ( long s ) { if ( ( s & abits ) == rfull ) { if ( u . compareandswaplong ( this , state , s , s | rbits ) ) { int r ; long next ; if ( ( r = readeroverflow ) > _num ) { readeroverflow = r - _num ; next = s ; } else next = s - runit ; u . putlongvolatile ( this , state , next ) ; return next ; } } else if ( ( nextsecondaryseed ( ) & overflow_yield_rate ) == _num ) thread . yield ( ) ; return _num ; }	tries to decrement readeroverflow .
public static string signatureclass ( string sig ) { int pos = sig . indexof ( _str ) ; return sig . substring ( _num , pos ) ; }	given a method signature , returns a substring denoting the class name .
protected list < powerhost > extracthostlistfrommigrationmap ( list < map < string , object > > migrationmap ) { list < powerhost > hosts = new linkedlist < powerhost > ( ) ; for ( map < string , object > map : migrationmap ) { hosts . add ( ( powerhost ) map . get ( _str ) ) ; } return hosts ; }	extracts the host list from a migration map .
protected boolean include ( iterable < string > path , string name ) throws ioexception , lexerexception { for ( string dir : path ) { virtualfile file = filesystem . getfile ( dir , name ) ; if ( include ( file ) ) return _bool ; } virtualfile file = filesystem . getfile ( name ) ; if ( include ( file ) ) return _bool ; return _bool ; }	includes a file from an include path , by name .
public static string formatstation ( int station ) { float frequency = ( float ) station / convert_rate ; string result = string . format ( locale . english , _str , float . valueof ( frequency ) ) ; return result ; }	according station to get frequency string.
public void removepriorityunit ( string id ) { if ( ! stringutil . ispositiveinteger ( id ) ) { return ; } removepriorityunit ( integer . parseint ( id ) ) ; }	remove a unit from the priority target list .
public void commitchanges ( synapsegroup synapsegroup ) { double percentexcitatory = utils . doubleparsable ( eratio ) / _num ; if ( ! double . isnan ( percentexcitatory ) ) synapsegroup . setexcitatoryratio ( percentexcitatory ) ; excitatoryrandomizerpanel . commitchanges ( ) ; inhibitoryrandomizerpanel . commitchanges ( ) ; synapsegroup . setexcitatoryrandomizer ( exrandomizer ) ; synapsegroup . setinhibitoryrandomizer ( inrandomizer ) ; }	commits changes to a synapse group .
private void returnbuffer ( bytebuffer buf ) { if ( buf != null ) { buf . clear ( ) ; bufferpool . add ( buf ) ; } }	returns direct buffer to pool .
public void write ( char buf [ ] ) { write ( buf , _num , buf . length ) ; }	writes an array of characters.
public void insertchild ( node [ ] nodes , int index ) { for ( node node : nodes ) { node . detachfromparent ( ) ; node . parentnode = this ; try { initchildnodes ( node ) ; childnodes . add ( index , node ) ; index ++ ; } catch ( indexoutofboundsexception ignore ) { throw new lagartodomexception ( _str + index ) ; } } reindexchildren ( ) ; }	inserts several nodes at ones.
public properties loadproperties ( string artifact , string version ) throws ioexception { properties props = new properties ( ) ; path propertiesfile = getpropertiesfile ( artifact , version ) ; if ( ! files . exists ( propertiesfile ) ) { throw new artifactnotfoundexception ( artifact , version ) ; } try ( inputstream in = new bufferedinputstream ( files . newinputstream ( propertiesfile ) ) ) { props . load ( in ) ; } return props ; }	loads the properties of the artifact .
protected arraylist < float [ ] > _forwardpoly ( float [ ] rawllpts , int ltype , int nsegs , boolean isfilled ) { double [ ] drawllpts = new double [ rawllpts . length ] ; system . arraycopy ( drawllpts , _num , rawllpts , _num , rawllpts . length ) ; return _forwardpoly ( drawllpts , ltype , nsegs , isfilled ) ; }	forward project a lat / lon poly . remember to specify vertices in radians !.
@ override public enumeration < option > listoptions ( ) { vector < option > result = enumtovector ( super . listoptions ( ) ) ; result . addelement ( new option ( _str + defaultnumexamples ( ) + _str , _str , _num , _str ) ) ; return result . elements ( ) ; }	returns an enumeration describing the available options .
public static _fields findbythriftid ( int fieldid ) { switch ( fieldid ) { case _num : return id ; default : return null ; } }	find the _fields constant that matches fieldid , or null if its not found .
static replaypromise < void > allreplay ( final duration timeout , final promise < ? > ... promises ) { return allreplay ( timeout , system . currenttimemillis ( ) , promises ) ; }	all promises must complete .
private void importzielobjekte ( final iprogressmonitor monitor ) { activator . inheritverinicecontextstate ( ) ; importtask importtask = new importtask ( dialog . isbausteine ( ) , dialog . ismassnahmenpersonen ( ) , dialog . iszielobjektezielobjekte ( ) , dialog . isschutzbedarf ( ) , dialog . isrollen ( ) , dialog . iskosten ( ) , dialog . isumsetzung ( ) , dialog . isbausteinpersonen ( ) ) ; long importtaskstart = system . currenttimemillis ( ) ; importtask . execute ( importtask . type_sqlserver , new eclipseprogressmonitordelegator ( monitor ) ) ; if ( log . isdebugenabled ( ) ) { log . debug ( _str + string . valueof ( ( system . currenttimemillis ( ) - importtaskstart ) / _num ) + _str ) ; } sourceid = importtask . getsourceid ( ) ; }	imports zielobjekte from gstool bausteine , gefaehrdungen , massnahmen und relations between these objects are also imported if selected in configuration dialog .
private static double [ ] computelabels ( final double start , final double end , final int approxnumlabels ) { if ( math . abs ( start - end ) < _num ) { return new double [ ] { start , start , _num } ; } double s = start ; double e = end ; boolean switched = _bool ; if ( s > e ) { switched = _bool ; double tmp = s ; s = e ; e = tmp ; } double xstep = roundup ( math . abs ( s - e ) / approxnumlabels ) ; double xstart = xstep * math . ceil ( s / xstep ) ; double xend = xstep * math . floor ( e / xstep ) ; if ( switched ) { return new double [ ] { xend , xstart , - _num * xstep } ; } return new double [ ] { xstart , xend , xstep } ; }	computes a reasonable number of labels for a data range .
public void addtransform ( datatransform transform ) { transformsource . add ( transform ) ; }	adds a transform to the list of transforms.
socketcreator ( final sslconfig sslconfig ) { this . sslconfig = sslconfig ; initialize ( ) ; }	constructs new socketcreator instance .
public static boolean isabsoluteuri ( string systemid ) { if ( iswindowsabsolutepath ( systemid ) ) { return _bool ; } final int fragmentindex = systemid . indexof ( _str ) ; final int queryindex = systemid . indexof ( _str ) ; final int slashindex = systemid . indexof ( _str ) ; final int colonindex = systemid . indexof ( _str ) ; int index = systemid . length ( ) - _num ; if ( fragmentindex > _num ) index = fragmentindex ; if ( ( queryindex > _num ) && ( queryindex < index ) ) index = queryindex ; if ( ( slashindex > _num ) && ( slashindex < index ) ) index = slashindex ; return ( ( colonindex > _num ) && ( colonindex < index ) ) ; }	return true if the systemid denotes an absolute uri .
public defaulthttpmethodretryhandler ( final int retrycount , final boolean requestsentretryenabled ) { super ( ) ; this . retrycount = retrycount ; this . requestsentretryenabled = requestsentretryenabled ; }	creates a new defaulthttpmethodretryhandler .
private static void checkforkoml ( ) { try { class . forname ( _str ) ; m_present = _bool ; } catch ( exception e ) { m_present = _bool ; } }	checks whether the koml is present in the class path.
@ override public synchronized void addinstancelistener ( instancelistener dsl ) { m_listeners . add ( dsl ) ; }	add an instance listener.
public typename ( string fullname , string nickname , string parenttypename ) { this . toplevelalias = typealias . create ( fullname , nickname , parenttypename ) ; this . pattern = null ; this . innertypenames = arrays . aslist ( ) ; }	creates a type alias for a static inner type with the given fullname and nickname .
@ override public void removepropertychangelistener ( string name , propertychangelistener pcl ) { m_bcsupport . removepropertychangelistener ( name , pcl ) ; }	remove a property change listener from this bean.
@ override public void run ( ) { if ( ! _lifecycle . toactive ( ) ) { log . fine ( this + _str ) ; return ; } try { runimpl ( ) ; } finally { } }	running process accepting connections .
public static string createhtmldocument ( map < string , object > style , string text , double scale ) { stringbuffer css = new stringbuffer ( ) ; css . append ( _str + getstring ( style , mxconstants . style_fontfamily , mxconstants . default_fontfamilies ) + _str ) ; css . append ( _str + ( int ) ( getint ( style , mxconstants . style_fontsize , mxconstants . default_fontsize ) * scale ) + _str ) ; string color = mxutils . getstring ( style , mxconstants . style_fontcolor ) ; if ( color != null ) { css . append ( _str + color + _str ) ; } int fontstyle = mxutils . getint ( style , mxconstants . style_fontstyle ) ; if ( ( fontstyle & mxconstants . font_bold ) == mxconstants . font_bold ) { css . append ( _str ) ; } if ( ( fontstyle & mxconstants . font_italic ) == mxconstants . font_italic ) { css . append ( _str ) ; } if ( ( fontstyle & mxconstants . font_underline ) == mxconstants . font_underline ) { css . append ( _str ) ; } string align = getstring ( style , mxconstants . style_align , mxconstants . align_left ) ; if ( align . equals ( mxconstants . align_center ) ) { css . append ( _str ) ; } else if ( align . equals ( mxconstants . align_right ) ) { css . append ( _str ) ; } return _str + css . tostring ( ) + _str + text + _str ; }	returns a new , empty dom document .
public void startlogcleaningprocess ( file accesslogdirectory ) { logger . info ( _str , accesslogdirectory . getabsolutepath ( ) ) ; timer timer = new timer ( is_daemon ) ; accesslogcleanertask tomcataccesslogcleaner = new accesslogcleanertask ( accesslogdirectory ) ; logger . info ( _str ) ; timer . scheduleatfixedrate ( tomcataccesslogcleaner , _num , timer_task_delay_in_millis ) ; }	perform clean up of the tomcat access log files.
public boolean isknownrepository ( string location , boolean requireexactmatch ) { set < string > keys = repositories . keyset ( ) ; for ( string checklocation : keys ) { if ( ! requireexactmatch && location . indexof ( checklocation ) != - _num ) { return _bool ; } if ( location . equals ( checklocation ) ) return _bool ; } return _bool ; }	answer whether the provided repository location is known by the provider or not . the location string corresponds to the strin returned by isvnrepositorylocation # getlocation ( ).
public static int indexheaderlength ( string codec , string suffix ) { return headerlength ( codec ) + stringhelper . id_length + _num + suffix . length ( ) ; }	computes the length of an index header .
private int testinrange ( long actual , long expected , long epsilon ) { long min = expected - epsilon ; long max = expected + epsilon ; return actual < min ? - _num : actual > max ? _num : _num ; }	returns - 1 , 0 , 1 if actual is less than , equal to , or greater than expected w / in epsilon .
public void removemethod ( sootmethod method ) { methods . remove ( method ) ; }	remove method from list .
public void addstats ( long [ ] msg1uniquemsgidstats , long [ ] msg1totalstats , long [ ] msg2uniquemsgidstats , long [ ] msg2totalstats ) { m_numberofintervals += msg1uniquemsgidstats . length ; for ( int i = _num ; i < msg1uniquemsgidstats . length ; i ++ ) { final long msg1uniquemsgidstat = msg1uniquemsgidstats [ i ] ; final long msg1totalstat = msg1totalstats [ i ] ; final long msg2uniquemsgidstat = msg2uniquemsgidstats [ i ] ; final long msg2totalstat = msg2totalstats [ i ] ; if ( msg1uniquemsgidstat == _num ) { m_intervalwithzerocounts ++ ; } else { m_minmsg1uniquemsgidcount = math . min ( m_minmsg1uniquemsgidcount , msg1uniquemsgidstat ) ; } m_maxmsg1uniquemsgidcount = math . max ( m_maxmsg1uniquemsgidcount , msg1uniquemsgidstat ) ; m_sumofmsg1uniquemsgidcount += msg1uniquemsgidstat ; m_sumofmsg2uniquemsgidcount += msg2uniquemsgidstat ; m_sumofmsg1uniquemsgidcountsquare += msg1uniquemsgidstat * msg1uniquemsgidstat ; m_msg1totalcount += msg1totalstat ; m_msg2totalcount += msg2totalstat ; } }	add an array of stats.
@ patch public void patchobjects ( list < apipatch < string > > patches ) throws guacamoleexception { for ( apipatch < string > patch : patches ) { if ( patch . getop ( ) != apipatch . operation . remove ) throw new guacamoleunsupportedexception ( _str + _str ) ; string path = patch . getpath ( ) ; if ( ! path . startswith ( _str ) ) throw new guacamoleclientexception ( _str ) ; directory . remove ( path . substring ( _num ) ) ; } }	applies the given object patches , updating the underlying directory accordingly.
public void adddimensionkeyname ( string key ) { dimensionkeynames . add ( key ) ; }	add the key that should be treated as one of the dimensions . the key must be in the input map.
private static boolean isinverticaltargetzone ( float x , float y , float handlex , float handleystart , float handleyend , float targetradius ) { if ( math . abs ( x - handlex ) <= targetradius && y > handleystart && y < handleyend ) { return _bool ; } return _bool ; }	determines if the specified coordinate is in the target touch zone for a vertical bar handle .
public static int countoccurrencesof ( string str , string sub ) { if ( str == null || sub == null || str . length ( ) == _num || sub . length ( ) == _num ) { return _num ; } int count = _num ; int pos = _num ; int idx ; while ( ( idx = str . indexof ( sub , pos ) ) != - _num ) { ++ count ; pos = idx + sub . length ( ) ; } return count ; }	count the occurrences of the substring in string s .
public void addfileset ( fileset set ) { filesets . addelement ( set ) ; }	adds a set of files ( nested fileset attribute ) .
private void putwithvalidation ( string key , object value ) throws bitcoinuriparseexception { if ( parametermap . containskey ( key ) ) { throw new bitcoinuriparseexception ( string . format ( _str , key ) ) ; } else { parametermap . put ( key , value ) ; } }	put the value against the key in the map checking for duplication.
public boolean isidentical ( final double x , final double y , final double z ) { return math . abs ( this . x - x ) < minimum_resolution && math . abs ( this . y - y ) < minimum_resolution && math . abs ( this . z - z ) < minimum_resolution ; }	compute whether point matches another .
@ override protected string translate ( final string name ) { return _str + name + _str ; }	translate a resource name into it ' s sprite image path .
public accountheaderbuilder addprofiles ( @ nonnull iprofile ... profiles ) { if ( this . mprofiles == null ) { this . mprofiles = new arraylist < > ( ) ; } collections . addall ( this . mprofiles , iddistributor . checkids ( profiles ) ) ; return this ; }	add single ore more draweritems to the drawer.
private boolean overloaded ( methodsymbol m , typesymbol c , types types ) { for ( com . redhat . ceylon . langtools . tools . javac . util . list < type > is = types . interfaces ( c . type ) ; is . nonempty ( ) ; is = is . tail ) { typesymbol i = is . head . tsym ; if ( overloadedin ( m , i , types ) ) return _bool ; if ( overloaded ( m , i , types ) ) return _bool ; } return _bool ; }	copied from methodsymbol . implemented and adapted for overloading.
private boolean hasnodesincontext ( sitenode node ) { @ suppresswarnings ( _str ) enumeration < sitenode > en = node . children ( ) ; while ( en . hasmoreelements ( ) ) { sitenode sn = en . nextelement ( ) ; if ( isincontext ( sn ) ) { return _bool ; } if ( hasnodesincontext ( sn ) ) { return _bool ; } } return _bool ; }	tells whether or not there ' s at least one node from the sites tree in context.
public gzipconfigurableoutputstream ( outputstream out , int size , int compression ) throws ioexception { super ( out , new deflater ( compression , _bool ) , size ) ; writeheader ( ) ; crc . reset ( ) ; }	creates a new output stream with the specified buffer size .
private void addauxclasspathentries ( string argument ) { stringtokenizer tok = new stringtokenizer ( argument , file . pathseparator ) ; while ( tok . hasmoretokens ( ) ) { project . addauxclasspathentry ( tok . nexttoken ( ) ) ; } }	parse the argument as auxclasspath entries and add them.
public boolean qualify ( final node that , final declaration d ) { string path = qualifiedpath ( that , d ) ; if ( path . length ( ) > _num ) { out ( path , d instanceof constructor ? names . constructorseparator ( d ) : _str ) ; } return path . length ( ) > _num ; }	outputs the module name for the specified declaration.
public sidedplane ( final vector p , final vector a , final vector b ) { super ( a , b ) ; signum = math . signum ( evaluate ( p ) ) ; if ( signum == _num ) throw new illegalargumentexception ( _str ) ; }	construct a sided plane from a pair of vectors describing points , and including origin , plus a point p which describes the side .
public static string encode ( string source ) { stringbuffer dest = new stringbuffer ( ) ; int sourcelen = source . length ( ) ; for ( int i = _num ; i < sourcelen ; i ++ ) { int runlength = _num ; final char currentchar = source . charat ( i ) ; while ( i + _num < sourcelen && currentchar == source . charat ( i + _num ) ) { runlength ++ ; i ++ ; } dest . append ( runlength ) ; dest . append ( currentchar ) ; } return dest . tostring ( ) ; }	returns encoded string . for example , converts " wwwwwwwwwwwwbwwwwwwwwwwwwbbb " to " 12w1b12w3b ".
public void addprimer ( string modulefilename , string extendedmodulename ) { tlabuffer . append ( resourcehelper . getextendingmodulecontent ( modulefilename , extendedmodulename ) ) ; }	add file header , which consists of the module - beginning - - - - - module.
public boolean isunique ( ) { return classid . equals ( stem ) ; }	is this spec unique or is it a class pattern ?.
public void testexamplekeystorepath ( ) { assertnotnull ( _str + _str + _str , ssltestconfig . test_keystore ) ; }	a trivial test that verifies the example keystore used for ssl testing can be found using the base class.
@ visiblefortesting protected void addomadownloadtosharedprefs ( string omainfo ) { set < string > omadownloads = getstoreddownloadinfo ( pending_oma_downloads ) ; omadownloads . add ( omainfo ) ; storedownloadinfo ( pending_oma_downloads , omadownloads ) ; }	add oma download info to sharedprefs .
final boolean isrunningorshutdown ( boolean shutdownok ) { int rs = runstateof ( ctl . get ( ) ) ; return rs == running || ( rs == shutdown && shutdownok ) ; }	state check needed by scheduledthreadpoolexecutor to enable running tasks during shutdown .
public void waitforidtounlock ( final vaultid id , final long timeout ) { if ( timeout <= _num ) { throw new illegalargumentexception ( _str ) ; } final long starttime = system . currenttimemillis ( ) ; long lefttowait = timeout ; while ( lefttowait > _num && ! isunlocked ( id ) ) { synchronized ( m_waitforlock ) { if ( isunlocked ( id ) ) { return ; } try { m_waitforlock . wait ( lefttowait ) ; } catch ( final interruptedexception e ) { } lefttowait = starttime + timeout - system . currenttimemillis ( ) ; } } }	wait until the given id is unlocked.
static string formatdebugtime ( long unixtime , long now ) { time time = new time ( ) ; time . set ( unixtime ) ; long delta = unixtime - now ; if ( delta > dateutils . minute_in_millis ) { delta /= dateutils . minute_in_millis ; return string . format ( _str , unixtime , time . format ( _str ) , delta ) ; } else { delta /= dateutils . second_in_millis ; return string . format ( _str , unixtime , time . format ( _str ) , delta ) ; } }	format given time for debugging output .
public static file ensurelogdirectoryexists ( ) { if ( mlogdirectory == null ) { return null ; } if ( ! mlogdirectory . exists ( ) ) { mlogdirectory . mkdirs ( ) ; } return mlogdirectory ; }	check if the log directory exists . create it if it s not created.
protected void requirearguments ( string ... names ) { stringbuilder missing = new stringbuilder ( ) ; for ( string name : names ) { if ( ! hasargument ( name ) ) { if ( missing . length ( ) > _num ) { missing . append ( _str ) ; } missing . append ( name ) ; } } if ( missing . length ( ) > _num ) { throw new commandexception ( _str + missing ) ; } }	requires that the specified arguments are present .
public void actionperformed ( actionevent e ) { jtextcomponent target = gettextcomponent ( e ) ; if ( target != null ) { int selectedindex ; rectangle visible = new rectangle ( ) ; target . computevisiblerect ( visible ) ; if ( left ) { visible . x = math . max ( _num , visible . x - visible . width ) ; } else { visible . x += visible . width ; } selectedindex = target . getcaretposition ( ) ; if ( selectedindex != - _num ) { if ( left ) { selectedindex = target . viewtomodel ( new point ( visible . x , visible . y ) ) ; } else { selectedindex = target . viewtomodel ( new point ( visible . x + visible . width - _num , visible . y + visible . height - _num ) ) ; } document doc = target . getdocument ( ) ; if ( ( selectedindex != _num ) && ( selectedindex > ( doc . getlength ( ) - _num ) ) ) { selectedindex = doc . getlength ( ) - _num ; } else if ( selectedindex < _num ) { selectedindex = _num ; } if ( select ) target . movecaretposition ( selectedindex ) ; else target . setcaretposition ( selectedindex ) ; } } }	the operation to perform when this action is triggered .
public static void clickbuttonbylabel ( string text ) { if ( verbose ) { log ( _str + text + _str ) ; } button b = ( button ) findlabeltext ( text ) ; waitfor ( _num ) ; b . pressed ( ) ; waitfor ( _num ) ; b . released ( ) ; waitfor ( _num ) ; }	clicks the button with the given label.
private int parsefuzziness ( state state ) { char sloptext [ ] = new char [ state . length ] ; int sloplength = _num ; if ( state . data [ state . index ] == _str ) { while ( state . index < state . length ) { state . index ++ ; if ( state . index < state . length ) { if ( tokenfinished ( state ) ) { break ; } sloptext [ sloplength ] = state . data [ state . index ] ; sloplength ++ ; } } int fuzziness = _num ; try { fuzziness = integer . parseint ( new string ( sloptext , _num , sloplength ) ) ; } catch ( numberformatexception e ) { } if ( fuzziness < _num ) { fuzziness = _num ; } return fuzziness ; } return _num ; }	helper parsing fuzziness from parsing state.
public double pdf ( double x ) { double diff = x - mean ; return sqrt_inv * math . exp ( - ( diff * diff ) / ( _num * variance ) ) ; }	returns the probability distribution function .
public void repaintpanel ( ) { removeall ( ) ; initializelayout ( ) ; repaint ( ) ; }	called to repaint the panel based on changes in the to the selected synapse type .
private string formatbooleanvalue ( boolean val ) { return string . valueof ( val ? _num : _num ) ; }	formats boolean value into a string one .
public void clearimage ( ) { clearimageint ( ) ; mcropoverlayview . setinitialcropwindowrect ( null ) ; }	clear the current image set for cropping .
public static string removedotfromfileextension ( string fileext ) { string temfileext = fileext ; if ( fileext . charat ( _num ) == _str ) { temfileext = fileext . substring ( _num , fileext . length ( ) ) ; } return temfileext ; }	removes the leading '.
private void bcopy ( int cidx , int bidx ) { int length = mchidx - cidx ; if ( ( bidx + length + _num ) >= mbuff . length ) { char buff [ ] = new char [ mbuff . length + length ] ; system . arraycopy ( mbuff , _num , buff , _num , mbuff . length ) ; mbuff = buff ; } system . arraycopy ( mchars , cidx , mbuff , bidx , length ) ; mbuffidx += length ; }	appends ( mchidx - cidx ) characters from character buffer ( mchars ) to parser ' s buffer ( mbuff ) .
public void save ( @ notnull progressindicator progress ) { if ( issourcesmodified ( ) ) { repositorysourceprovider usersourceprovider = getusersourceprovider ( ) ; assert usersourceprovider != null ; usersourceprovider . save ( new repoprogressindicatoradapter ( progress ) ) ; reset ( ) ; } }	save any changes the user has made .
public synchronized result remove ( int index ) { result result ; date date ; date = m_ordered . remove ( index ) ; m_suffixes . remove ( date ) ; m_payloads . remove ( date ) ; result = m_results . remove ( date ) ; return result ; }	removes the specified entry .
public boolean has_trace_exit_restrictions ( ) { for ( int index = first_layer ( ) ; index <= last_layer ( ) ; ++ index ) { collection < brdtraceexitrestriction > curr_exit_restrictions = get_trace_exit_restrictions ( index ) ; if ( curr_exit_restrictions . size ( ) > _num ) return _bool ; } return _bool ; }	returns true , if this pin has exit restrictions on some kayer .
public static string formattime ( string millis ) { string result ; try { long time = long . valueof ( millis ) ; result = formattime ( time ) ; } catch ( numberformatexception e ) { throw new illegalargumentexception ( _str + millis ) ; } return result ; }	convert the time it took to compute these results into a label to add to the scorecard .
@ override public boolean add ( e o ) { return offer ( o ) ; }	adds the specified object to the priority queue .
private void selectclicked ( mouseevent e , boolean onlyoutside ) { int index = locationtoindex ( e . getpoint ( ) ) ; rectangle bounds = getcellbounds ( index , index ) ; if ( bounds != null && bounds . contains ( e . getpoint ( ) ) ) { if ( ! onlyoutside ) { if ( isselectedindex ( index ) ) { addselectioninterval ( index , index ) ; } else { setselectedindex ( index ) ; } } } else { clearselection ( ) ; } }	adds selection of the clicked element , or removes selection if no element was clicked .
public double fullpathdistance ( final distancestyle distancestyle ) { synchronized ( fulldistancecache ) { double dist = fulldistancecache . get ( distancestyle ) ; if ( dist == null ) { dist = new double ( distancestyle . computedistance ( start , end . x , end . y , end . z ) ) ; fulldistancecache . put ( distancestyle , dist ) ; } return dist . doublevalue ( ) ; } }	compute the full distance along this path segment .
public playervisitedzonescondition ( string ... zones ) { this . zonenames = new linkedlist < string > ( ) ; for ( string zone : zones ) { zonenames . add ( zone ) ; } }	creates a new playervisitedzonescondition.
public groovyclassloader ( classloader loader ) { this ( loader , null ) ; }	creates a groovyclassloader using the given classloader as parent.
@ override public void windowdeactivated ( windowevent e ) { }	invoked when a window is deactivated.
public void addsprite ( odorworldentity sprite ) { sprites . add ( sprite ) ; }	adds a odorworldentity object to this map .
public void freeusecount ( ) { if ( _indirectsource != null ) { _indirectsource . freeusecount ( ) ; } else if ( _usecount != null ) { if ( _usecount . decrementandget ( ) < _num ) { closeself ( ) ; } } }	frees a use - counter , so getinputstream can be called multiple times .
public void closejdbcstatement ( statement stmt ) { try { if ( stmt != null ) { stmt . close ( ) ; } } catch ( sqlexception sqle ) { subclasslogwrapper ( _str ) ; } }	closes database statement and logs if an error is encountered.
public void testnegatepositive ( ) { string a = _str ; int ascale = _num ; string c = _str ; int cscale = _num ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) , ascale ) ; bigdecimal cnumber = new bigdecimal ( new biginteger ( c ) , cscale ) ; assertequals ( _str , cnumber , anumber . negate ( ) ) ; }	negate ( ) for a positive bigdecimal.
public string statementtocodestring ( int i ) { stringbuilder onestatement = new stringbuilder ( ) ; sequence . appendcode ( onestatement , i ) ; return onestatement . tostring ( ) ; }	return the code representation of the i ' th statement .
private byte skiptagforward ( ) { int initialcharindex = charindex ; while ( charindex < length ) { lastchar = text . charat ( charindex ++ ) ; if ( lastchar == _str ) { return character . directionality_whitespace ; } if ( lastchar == _str || lastchar == _str ) { char quote = lastchar ; while ( charindex < length && ( lastchar = text . charat ( charindex ++ ) ) != quote ) { } } } charindex = initialcharindex ; lastchar = _str ; return character . directionality_other_neutrals ; }	advances charindex forward through an html tag ( after the opening & lt ; has already been read ) and returns character.
public sessioninfo refresh ( session session , boolean reset ) throws sessionexception { sessionid sessionid = session . getid ( ) ; if ( debug . messageenabled ( ) ) { debug . message ( messageformat . format ( _str + _str , sessionid . tostring ( ) , reset ) ) ; } return getsessioninfo ( sessionid , reset ) ; }	fetches the sessioninfo from the sessionservice .
public void nextgroup ( ) { release ( ) ; }	move to a new sl that represents a new group of same - values - used in fifo group scanning.
public void assertnotequals ( string assertid , string expected , string actual ) { framework . assertnotequals ( this , assertid , expected , actual ) ; }	asserts that values of expected and actual are not equal .
protected void duplicateclass ( diagnosticposition pos , classsymbol c ) { log . error ( pos , _str , c . fullname ) ; }	complain about a duplicate class .
public static string createnameidentifier ( ) { string handle = null ; try { byte [ ] handlebytes = new byte [ _num ] ; randomgenerator . nextbytes ( handlebytes ) ; handle = base64 . encode ( handlebytes ) ; if ( debug . messageenabled ( ) ) { debug . message ( _str + handle ) ; } } catch ( exception e ) { debug . message ( _str + _str + e . getmessage ( ) ) ; } return handle ; }	returns a name identifier.
public static long calculateserverfeereverse ( long amount ) { long a = constants . server_fee_flat ; long b = amount + a ; long c = ( long ) ( ( b / ( _num - constants . server_fee_percentage ) ) - b ) ; return math . min ( constants . server_fee_max , math . max ( constants . server_fee_min , c + a ) ) ; }	calculate server fee reverse .
private static void loadextensionbundles ( configserverimpl cs , configimpl config , document doc , log log ) { element parent = getchildbyname ( doc . getdocumentelement ( ) , _str ) ; element [ ] children = getchildren ( parent , _str ) ; string strbundles ; map < string , bundledefinition > extensionbundles = new hashmap < string , bundledefinition > ( ) ; list < rhextension > extensions = new arraylist < rhextension > ( ) ; for ( element child : children ) { rhextension rhe ; try { rhe = new rhextension ( config , child ) ; if ( rhe . getstartbundles ( ) ) rhe . deploybundles ( ) ; extensions . add ( rhe ) ; } catch ( exception e ) { log . error ( _str , e ) ; continue ; } bundleinfo [ ] bfs = rhe . getbundles ( ) ; bundleinfo bf ; bundledefinition bd ; for ( int i = _num ; i < bfs . length ; i ++ ) { bf = bfs [ i ] ; extensionbundles . put ( bf . getsymbolicname ( ) + _str + bf . getversionasstring ( ) , bd = bf . tobundledefinition ( ) ) ; try { if ( rhe . getstartbundles ( ) ) { bundle b = bd . getbundle ( config ) ; osgiutil . startifnecessary ( b ) ; } } catch ( bundleexception e ) { log . error ( _str , e ) ; } } } config . setextensions ( extensions . toarray ( new rhextension [ extensions . size ( ) ] ) ) ; config . setextensionbundledefintions ( extensionbundles ) ; }	loads the bundles defined in the extensions.
public static string stringto8859_1 ( string str ) throws unsupportedencodingexception { if ( str == null ) { return _str ; } return new string ( str . getbytes ( _str ) , _str ) ; }	used to convert username - value , passwd or realm to 8859_1 encoding if all chars in string are within the 8859_1 ( latin 1 ) encoding range .
public boolean isdebuggingfiner ( ) { return logger . isloggable ( level . finer ) ; }	test whether to log ' debug ' at ' finer ' level.
public static void selectnodeswithstring ( final zygraph graph , final string searchstring ) { preconditions . checknotnull ( graph , _str ) ; preconditions . checknotnull ( searchstring , _str ) ; final graphsearcher searcher = new graphsearcher ( ) ; searcher . search ( graphhelpers . getnodes ( graph ) , new arraylist < naviedge > ( ) , searchstring ) ; final list < searchresult > results = searcher . getresults ( ) ; final list < navinode > resultnodes = new arraylist < navinode > ( ) ; for ( final searchresult searchresult : results ) { resultnodes . add ( ( navinode ) searchresult . getobject ( ) ) ; } graph . selectnodes ( resultnodes , _bool ) ; searcher . dispose ( ) ; }	selects all nodes of a graph that contain a given search string .
private void addblocklisteners ( tracker tracker ) { list < oblock > range = tracker . getrange ( ) ; if ( log . isdebugenabled ( ) ) { log . debug ( _str + tracker . gettrainname ( ) + _str + range . size ( ) + _str ) ; } iterator < oblock > iter = range . iterator ( ) ; while ( iter . hasnext ( ) ) { addblocklistener ( iter . next ( ) , tracker ) ; } }	adds listeners to all blocks in the range of a tracker.
public synchronized void openwrite ( ) throws replicatorexception , interruptedexception { if ( ! file . exists ( ) ) { throw new thlexception ( _str + file . getname ( ) ) ; } try { bufferedfiledatainput bfdi = new bufferedfiledatainput ( file , buffersize ) ; checkfileheader ( bfdi ) ; bfdi . close ( ) ; dataoutput = new bufferedfiledataoutput ( file , buffersize ) ; } catch ( ioexception e ) { throw new thlexception ( _str + file . getname ( ) , e ) ; } mode = accessmode . write ; if ( logflushtask != null ) logflushtask . addlogfile ( this ) ; }	prepare the log file for writing.
public static boolean verifyvolumesincg ( list < volume > volumes , blockconsistencygroup cg , dbclient dbclient ) { list < volume > cgvolumes = blockconsistencygrouputils . getactivevplexvolumesincg ( cg , dbclient , null ) ; return verifyvolumesincg ( volumes , cgvolumes , dbclient ) ; }	verifies if the passed volumes are all the volumes in the same backend arrays in the passed consistency group .
private void cleanupstreams ( exception inflight ) { if ( stream != null ) { try { stream . close ( ) ; stream = null ; } catch ( ioexception closeexception ) { inflight . addsuppressed ( closeexception ) ; } } if ( connection != null ) { byte [ ] buf = new byte [ _num * _num ] ; inputstream es = connection . geterrorstream ( ) ; if ( es != null ) { try { try { while ( es . read ( buf ) > _num ) { } } finally { es . close ( ) ; } } catch ( ioexception errorstreamerror ) { inflight . addsuppressed ( errorstreamerror ) ; } } } }	according to https : / / docs.
public void dofilter ( final servletrequest request , final servletresponse response , final filterchain chain ) throws ioexception , servletexception { urlrewriter urlrewriter = geturlrewriter ( request , response , chain ) ; final httpservletrequest hsrequest = ( httpservletrequest ) request ; final httpservletresponse hsresponse = ( httpservletresponse ) response ; urlrewritewrappedresponse urlrewritewrappedresponse = new urlrewritewrappedresponse ( hsresponse , hsrequest , urlrewriter ) ; if ( statusenabled && statusservernamematcher . ismatch ( request . getservername ( ) ) ) { string uri = hsrequest . getrequesturi ( ) ; if ( log . isdebugenabled ( ) ) { log . debug ( _str + uri ) ; } string contextpath = hsrequest . getcontextpath ( ) ; if ( uri != null && uri . startswith ( contextpath + statuspath ) ) { showstatus ( hsrequest , urlrewritewrappedresponse ) ; return ; } } boolean requestrewritten = _bool ; if ( urlrewriter != null ) { requestrewritten = urlrewriter . processrequest ( hsrequest , urlrewritewrappedresponse , chain ) ; } else { if ( log . isdebugenabled ( ) ) { log . debug ( _str ) ; } } if ( ! requestrewritten ) { chain . dofilter ( hsrequest , urlrewritewrappedresponse ) ; } }	the main method called for each request that this filter is mapped for .
@ override public string tostring ( ) { string str = _str ; for ( basiceffect e : subeffects ) { str += e . tostring ( ) + _str ; } return ( ! subeffects . isempty ( ) ) ? str . substring ( _num , str . length ( ) - _num ) : _str ; }	returns a string representation for the effect.
private e createusingstaticcreatemethod ( ) throws checkedanalysisexception { method createmethod ; try { createmethod = databaseclass . getmethod ( _str , new class [ _num ] ) ; } catch ( nosuchmethodexception e ) { return null ; } if ( ! modifier . isstatic ( createmethod . getmodifiers ( ) ) ) { return null ; } if ( createmethod . getreturntype ( ) != databaseclass ) { return null ; } try { return databaseclass . cast ( createmethod . invoke ( null , new object [ _num ] ) ) ; } catch ( invocationtargetexception e ) { throw new checkedanalysisexception ( _str + databaseclass . getname ( ) , e ) ; } catch ( illegalaccessexception e ) { throw new checkedanalysisexception ( _str + databaseclass . getname ( ) , e ) ; } }	try to create the database using a static create ( ) method .
public void testnegatemathcontextpositive ( ) { string a = _str ; int ascale = _num ; int precision = _num ; roundingmode rm = roundingmode . floor ; mathcontext mc = new mathcontext ( precision , rm ) ; string c = _str ; int cscale = _num ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) , ascale ) ; bigdecimal res = anumber . negate ( mc ) ; assertequals ( _str , c , res . tostring ( ) ) ; assertequals ( _str , cscale , res . scale ( ) ) ; }	negate ( mathcontext ) for a positive bigdecimal.
public static void flagdocumentascorrected ( element element ) { document doc = element . getownerdocument ( ) ; if ( doc != null ) { doc . setuserdata ( _str , _str , null ) ; } }	flags a mini - language xml document as corrected .
protected void paintoriginlabel ( point2d originpnt , graphics graphics , mapbean themap ) { if ( themap != null && originpnt != null ) { omtext text = new omtext ( originpnt . gety ( ) , originpnt . getx ( ) , getoriginlabel ( ) , omtext . justify_center ) ; text . setbaseline ( omtext . baseline_bottom ) ; text . putattribute ( omgraphicconstants . no_rotate , boolean . true ) ; preparelabel ( text ) ; text . generate ( themap . getrotatedprojection ( ) ) ; text . render ( graphics ) ; } }	paints the origin label of the range rings on the given graphics .
public static void clearlogfilters ( ) { if ( filters == null || filters . isempty ( ) ) { return ; } filters . clear ( ) ; }	remove all the log filters which have been added before .
public coderresult unmappableresult ( ) { assert ( error == null ) ; return coderresult . unmappableforlength ( ispair ? _num : _num ) ; }	returns an unmappable - input result object , with the appropriate input length , for the previously - parsed character .
public static boolean seekforv1orv11tag ( bytebuffer bytebuffer ) { byte [ ] buffer = new byte [ field_tagid_length ] ; bytebuffer . get ( buffer , _num , field_tagid_length ) ; return ( arrays . equals ( buffer , tag_id ) ) ; }	does a v1tag or a v11tag exist.
private void setupui ( ) { contentpane = new jpanel ( ) ; contentpane . setlayout ( new borderlayout ( _num , _num ) ) ; splitpane = new jsplitpane ( ) ; contentpane . add ( splitpane , borderlayout . center ) ; final jscrollpane scrollpane1 = new jscrollpane ( ) ; splitpane . setleftcomponent ( scrollpane1 ) ; methodlist = new jlist ( ) ; scrollpane1 . setviewportview ( methodlist ) ; final jscrollpane scrollpane2 = new jscrollpane ( ) ; splitpane . setrightcomponent ( scrollpane2 ) ; methoddetailtable = new jtable ( ) ; scrollpane2 . setviewportview ( methoddetailtable ) ; }	method generated by intellij idea gui designer > > > important ! ! < < < do not edit this method or call it in your code !.
public void remove ( int index ) { entries . remove ( index ) ; }	removes the entry at the specified position in the table .
public string buildactivitiidstring ( string namespacecd , string jobname ) { map < string , string > pathtotokenvaluemap = new hashmap < > ( ) ; pathtotokenvaluemap . put ( getnamespacetoken ( ) , namespacecd ) ; pathtotokenvaluemap . put ( getjobnametoken ( ) , jobname ) ; string activitiid = getactivitijobdefinitiontemplate ( ) ; for ( map . entry < string , string > mapentry : pathtotokenvaluemap . entryset ( ) ) { activitiid = activitiid . replaceall ( mapentry . getkey ( ) , mapentry . getvalue ( ) ) ; } return activitiid ; }	returns activiti id constructed according to the template defined .
public string rubytypename ( typeref typeref ) { switch ( typeref . getkind ( ) ) { case type_message : return rubytypenameforprotoelement ( typeref . getmessagetype ( ) ) ; case type_enum : return rubytypenameforprotoelement ( typeref . getenumtype ( ) ) ; default : { string name = primitive_type_names . get ( typeref . getkind ( ) ) ; if ( ! strings . isnullorempty ( name ) ) { return name ; } throw new illegalargumentexception ( _str + typeref . getkind ( ) ) ; } } }	returns the name of ruby class for the given typeref .
private vplexvirtualvolumeinfo findvirtualvolumeafterdevicemigration ( string originalvolumename , vplexmigrationinfo migrationinfo , list < vplexclusterinfo > clusterinfolist ) { vplexvirtualvolumeinfo virtualvolumeinfo = null ; vplexapidiscoverymanager discoverymgr = _vplexapiclient . getdiscoverymanager ( ) ; for ( vplexclusterinfo clusterinfo : clusterinfolist ) { string clustername = clusterinfo . getname ( ) ; virtualvolumeinfo = discoverymgr . findvirtualvolume ( clustername , originalvolumename , _bool ) ; if ( virtualvolumeinfo != null ) { s_logger . info ( _str , originalvolumename , clustername ) ; break ; } else { string virtualvolumename = migrationinfo . gettarget ( ) ; virtualvolumeinfo = discoverymgr . findvirtualvolume ( clustername , virtualvolumename , _bool ) ; if ( virtualvolumeinfo != null ) { s_logger . info ( _str , virtualvolumename , clustername ) ; break ; } else { virtualvolumename += vplexapiconstants . virtual_volume_suffix ; virtualvolumeinfo = discoverymgr . findvirtualvolume ( clusterinfo . getname ( ) , virtualvolumename , _bool ) ; if ( virtualvolumeinfo != null ) { s_logger . info ( _str , virtualvolumename , clustername ) ; break ; } } } } return virtualvolumeinfo ; }	finds the virtual volume after a device migration .
private static final boolean issupplementary ( int ch ) { return ch >= character . min_supplementary_code_point || character . issurrogate ( ( char ) ch ) ; }	determines if the specified code point is a supplementary character or unpaired surrogate .
public builder addservice ( actionservice service ) { if ( service == null ) { throw new illegalargumentexception ( _str ) ; } if ( service . getsupportedannotationtype ( ) == null ) { throw new illegalargumentexception ( _str ) ; } services . add ( service ) ; return this ; }	add an service for action processing.
protected boolean computechildren ( openableelementinfo info , file underlyingresource ) throws javamodelexception { hashtableofarraytoobject rawpackageinfo = new hashtableofarraytoobject ( ) ; ijavaelement [ ] children ; zipfile jar = null ; try { string compliance = compileroptions . version_1_8 ; jar = getjar ( ) ; rawpackageinfo . put ( charoperation . no_strings , new arraylist [ ] { empty_list , empty_list } ) ; for ( enumeration e = jar . entries ( ) ; e . hasmoreelements ( ) ; ) { zipentry member = ( zipentry ) e . nextelement ( ) ; initrawpackageinfo ( rawpackageinfo , member . getname ( ) , member . isdirectory ( ) , compliance ) ; } children = new ijavaelement [ rawpackageinfo . size ( ) ] ; int index = _num ; for ( int i = _num , length = rawpackageinfo . keytable . length ; i < length ; i ++ ) { string [ ] pkgname = ( string [ ] ) rawpackageinfo . keytable [ i ] ; if ( pkgname == null ) continue ; children [ index ++ ] = getpackagefragment ( pkgname ) ; } } catch ( coreexception e ) { if ( e . getcause ( ) instanceof zipexception ) { util . log ( istatus . error , _str + tostringwithancestors ( ) ) ; children = no_elements ; } else if ( e instanceof javamodelexception ) { throw ( javamodelexception ) e ; } else { throw new javamodelexception ( e ) ; } } finally { manager . closezipfile ( jar ) ; } info . setchildren ( children ) ; ( ( jarpackagefragmentrootinfo ) info ) . rawpackageinfo = rawpackageinfo ; return _bool ; }	compute the package fragment children of this package fragment root.
@ override public string filter ( string value , string previousvalue ) { if ( previousvalue != null && value . length ( ) > previousvalue . length ( ) ) return value ; return value . equals ( _str ) || value . equals ( _str ) ? _str : value ; }	the default filter removes the display of ' 0 ' or ' 0.
private void free ( ) { offheapstoredobject chunk = chunks . remove ( random . nextint ( chunks . size ( ) ) ) ; totalallocation -= chunk . getsize ( ) ; chunk . release ( ) ; }	frees a random chunk from the chunk list .
public sqlexception ( throwable thecause ) { this ( thecause == null ? null : thecause . tostring ( ) , null , _num , thecause ) ; }	creates an sqlexception object.
private boolean isnumericstring ( final string s ) { int i = _num ; if ( s . length ( ) == _num ) { return _bool ; } final char [ ] chars = s . tochararray ( ) ; boolean seendot = _bool ; if ( chars [ _num ] == _str || chars [ _num ] == _str ) { i ++ ; } while ( i < s . length ( ) ) { if ( chars [ i ] == _str ) { if ( seendot ) { return _bool ; } seendot = _bool ; } else if ( chars [ i ] < _str || chars [ i ] > _str ) { return _bool ; } i ++ ; } return _bool ; }	check whether the string is a decimal numeric string .
public void testabandbcbrokernetwork ( ) throws exception { bridgebrokers ( _str , _str ) ; bridgebrokers ( _str , _str ) ; startallbrokers ( ) ; waitforbridgeformation ( ) ; destination dest = createdestination ( _str , _bool ) ; messageconsumer clientc = createconsumer ( _str , dest ) ; sendmessages ( _str , dest , message_count ) ; thread . sleep ( _num ) ; messageidlist msgsc = getconsumermessages ( _str , clientc ) ; assertequals ( _num , msgsc . getmessagecount ( ) ) ; }	brokera - > brokerb - > brokerc.
@ override protected final void closenolock ( string reason ) { if ( isclosed . compareandset ( _bool , _bool ) ) { assert rwl . iswritelockedbycurrentthread ( ) || failenginelock . isheldbycurrentthread ( ) : _str ; try { this . versionmap . clear ( ) ; try { ioutils . close ( searchermanager ) ; } catch ( throwable t ) { logger . warn ( _str , t ) ; } try { ioutils . close ( translog ) ; } catch ( throwable t ) { logger . warn ( _str , t ) ; } logger . trace ( _str ) ; try { indexwriter . rollback ( ) ; } catch ( alreadyclosedexception e ) { } logger . trace ( _str ) ; } catch ( throwable e ) { logger . warn ( _str , e ) ; } finally { store . decref ( ) ; logger . debug ( _str , reason ) ; } } }	closes the engine without acquiring the write lock.
private list < object > executegroupby ( profilemeasurement m ) { list < object > groups = new arraylist < > ( ) ; if ( ! isempty ( m . getgroupby ( ) ) ) { try { beanmap measureasmap = new beanmap ( m ) ; for ( string expr : m . getgroupby ( ) ) { object result = executor . execute ( expr , measureasmap , object . class ) ; groups . add ( result ) ; } } catch ( throwable e ) { string msg = format ( _str , e . getmessage ( ) , m . getprofilename ( ) , m . getentity ( ) ) ; throw new parseexception ( msg , e ) ; } } return groups ; }	executes each of the ' groupby ' expressions.
public static void safeclose ( inputstream in ) { try { if ( in != null ) in . close ( ) ; } catch ( ioexception e ) { } }	closes a stream and ignores any resulting exception .
public static string expandline ( charsequence self , int tabstop ) { string s = self . tostring ( ) ; int index ; while ( ( index = s . indexof ( _str ) ) != - _num ) { stringbuilder builder = new stringbuilder ( s ) ; int count = tabstop - index % tabstop ; builder . deletecharat ( index ) ; for ( int i = _num ; i < count ; i ++ ) builder . insert ( index , _str ) ; s = builder . tostring ( ) ; } return s ; }	expands all tabs into spaces.
private bshmethod [ ] flattenmethodcollection ( enumeration e ) { vector v = new vector ( ) ; while ( e . hasmoreelements ( ) ) { object o = e . nextelement ( ) ; if ( o instanceof bshmethod ) v . addelement ( o ) ; else { vector ov = ( vector ) o ; for ( int i = _num ; i < ov . size ( ) ; i ++ ) v . addelement ( ov . elementat ( i ) ) ; } } bshmethod [ ] bma = new bshmethod [ v . size ( ) ] ; v . copyinto ( bma ) ; return bma ; }	flatten the vectors of overloaded methods to a single array .
public static string printline ( string a , int num ) { stringbuilder builder = new stringbuilder ( ) ; for ( int i = _num ; i < num ; i ++ ) { builder . append ( a ) ; } return builder . tostring ( ) ; }	below method will create string like " * * * * * * * * * * * ".
public connection connect ( ) throws sqlexception { properties p = new properties ( ) ; if ( issybase ( ) ) { p . setproperty ( _str , _str ) ; p . setproperty ( _str , _str ) ; } p . setproperty ( _str , user ) ; p . setproperty ( _str , password ) ; return driver . connect ( uri , p ) ; }	connect to the database and return the connection .
public void removeontagselectlistener ( tagsselectlistener listener ) { if ( selectlisteners != null ) { selectlisteners . remove ( listener ) ; } }	removing selection items listener.
private static void createandshowgui ( ) { jframe frame = new jframe ( _str ) ; frame . setdefaultcloseoperation ( jframe . exit_on_close ) ; addcomponentstopane ( frame . getcontentpane ( ) ) ; frame . pack ( ) ; frame . setvisible ( _bool ) ; }	create the gui and show it.
public int next ( ) { treenode n = stack . pop ( ) ; pushall ( n . right ) ; return n . val ; }	to get the next smallest value.
public publishermerge < t > mergeadditionalsource ( publisher < ? extends t > source , intfunction < supplier < ? extends queue < t > > > newqueuesupplier ) { int n = sources . length ; @ suppresswarnings ( _str ) publisher < ? extends t > [ ] newarray = new publisher [ n + _num ] ; system . arraycopy ( sources , _num , newarray , _num , n ) ; newarray [ n ] = source ; supplier < ? extends queue < t > > newmainqueue ; int mc = maxconcurrency ; if ( mc != integer . max_value ) { mc ++ ; newmainqueue = newqueuesupplier . apply ( mc ) ; } else { newmainqueue = mainqueuesupplier ; } return new publishermerge < > ( newarray , delayerror , mc , newmainqueue , prefetch , innerqueuesupplier ) ; }	returns a new instance which has the additional source to be merged together with the current array of sources.
@ targetapi ( lollipop ) private bonjourevent newbonjourevent ( bonjourevent . type type , nsdserviceinfo serviceinfo ) { bonjourservice . builder servicebuilder = new bonjourservice . builder ( serviceinfo . getservicename ( ) , serviceinfo . getservicetype ( ) ) ; if ( build . version . sdk_int >= lollipop ) { map < string , byte [ ] > attributes = serviceinfo . getattributes ( ) ; for ( string key : attributes . keyset ( ) ) { servicebuilder . addtxtrecord ( key , new string ( attributes . get ( key ) , charset . forname ( _str ) ) ) ; } } servicebuilder . addaddress ( serviceinfo . gethost ( ) ) ; servicebuilder . setport ( serviceinfo . getport ( ) ) ; return new bonjourevent ( type , servicebuilder . build ( ) ) ; }	creates a new bonjourevent instance from an nsd service info object .
static private string short_max ( ) { short tempvalue = short . max_value ; return string . valueof ( tempvalue ) ; }	get the max value for a short.
public void append ( final char c ) { builder . append ( c ) ; }	directly append the given character .
@ suppresswarnings ( _str ) public boolean addtelegramwriter ( telegramwriter newwriter ) { return ( telegramwriters . add ( newwriter ) ) ; }	add a new writer to be notified about new telegrams.
private resource packicon ( int dpi , bitmap icon ) { resource res = new resource ( ) ; res . dpi = dpi ; bytearrayoutputstream os = new bytearrayoutputstream ( ) ; if ( icon . compress ( image_format , image_compression_quality , os ) ) { res . data = os . tobytearray ( ) ; } return res ; }	serialize an icon resource for persistence , including a checksum wrapper .
public void retain ( ) { bbllist . add ( this ) ; }	ensure that this blockbosslogic object is available for later retrieval.
public enumeration < option > listoptions ( ) { vector < option > newvector = new vector < option > ( ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str + _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str + _str + _str + _str + _str + _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addelement ( new option ( _str , _str , _num , _str ) ) ; newvector . addall ( collections . list ( super . listoptions ( ) ) ) ; return newvector . elements ( ) ; }	returns an enumeration describing the available options .
bcrsaprivatecrtkey ( rsaprivatecrtkeyspec spec ) { this . modulus = spec . getmodulus ( ) ; this . publicexponent = spec . getpublicexponent ( ) ; this . privateexponent = spec . getprivateexponent ( ) ; this . primep = spec . getprimep ( ) ; this . primeq = spec . getprimeq ( ) ; this . primeexponentp = spec . getprimeexponentp ( ) ; this . primeexponentq = spec . getprimeexponentq ( ) ; this . crtcoefficient = spec . getcrtcoefficient ( ) ; }	construct a private key from an rsaprivatecrtkeyspec.
private void morph ( hgpersistenthandle instancehandle , hgatomtype oldtype , hgatomtype newtype ) { hgpersistenthandle [ ] layout = store . getlink ( instancehandle ) ; object oldinstance = rawmake ( layout , oldtype , instancehandle ) ; typeutils . releasevalue ( this , oldtype , layout [ _num ] ) ; indexbyvalue . removeentry ( layout [ _num ] , instancehandle ) ; layout [ _num ] = typeutils . storevalue ( this , oldinstance , newtype ) ; indexbyvalue . addentry ( layout [ _num ] , instancehandle ) ; store . store ( instancehandle , layout ) ; object newinstance = rawmake ( layout , newtype , instancehandle ) ; hglivehandle instancelivehandle = cache . get ( instancehandle ) ; if ( instancelivehandle != null && instancelivehandle . getref ( ) != null ) cache . atomrefresh ( instancelivehandle , newinstance , _bool ) ; if ( oldinstance instanceof hgatomtype ) { hgsearchresult < hgpersistenthandle > rs = null ; try { rs = indexbytype . find ( instancehandle ) ; if ( rs . hasnext ( ) && ! ( newinstance instanceof hgatomtype ) ) throw new hgexception ( _str + instancehandle + _str ) ; oldtype = ( hgatomtype ) oldinstance ; newtype = ( hgatomtype ) newinstance ; while ( rs . hasnext ( ) ) { morph ( ( hgpersistenthandle ) rs . next ( ) , oldtype , newtype ) ; } } finally { if ( rs != null ) rs . close ( ) ; } } }	change the type value of an atom value.
private addressingmodetwogenerator ( ) { }	the addressingmodegenerator class takes the addressing_mode operand of an arm instruction and provides the result of the computation within the operand to the caller.
public static vec2d fromradians ( double angleinrad , double magnitude ) { double x = magnitude * math . cos ( angleinrad ) ; double y = magnitude * math . sin ( angleinrad ) ; return new vec2d ( x , y ) ; }	create a 2d vector from an angle relative to the positive x - axis and a magnitude.
protected void elementaltosemantic ( ) { if ( ! issparse ) { logger . warning ( _str + _str ) ; return ; } votingrecord = new arraylist < fixedbitset > ( ) ; votingrecord . add ( ( fixedbitset ) bitset . clone ( ) ) ; totalnumberofvotes . set ( _num ) ; tempset = new fixedbitset ( dimension ) ; issparse = _bool ; }	automatically translate elemental vector ( no storage capacity ) into semantic vector ( storage capacity initialized , this will occupy ram ).
public void writestate ( dataoutputstream stream ) throws ioexception { int len = mt . length ; for ( int x = _num ; x < len ; x ++ ) stream . writeint ( mt [ x ] ) ; len = mag01 . length ; for ( int x = _num ; x < len ; x ++ ) stream . writeint ( mag01 [ x ] ) ; stream . writeint ( mti ) ; stream . writedouble ( __nextnextgaussian ) ; stream . writeboolean ( __havenextnextgaussian ) ; }	writes the entire state of the mersennetwister rng to the stream.
final byte [ ] compute ( byte type , byte buf [ ] , int offset , int len , boolean issimulated ) { if ( macalg . size == _num ) { return nullmac ; } if ( ! issimulated ) { byte [ ] additional = acquireauthenticationbytes ( type , len ) ; mac . update ( additional ) ; } mac . update ( buf , offset , len ) ; return mac . dofinal ( ) ; }	computes and returns the mac for the data in this byte array .
protected object visit ( binarylogicoperator filter , object extradata ) { logger . finer ( _str ) ; final list < filterbuilder > filterlist = new arraylist < > ( ) ; for ( final filter child : filter . getchildren ( ) ) { child . accept ( this , extradata ) ; filterlist . add ( filterbuilder ) ; } final filterbuilder [ ] filters ; filters = filterlist . toarray ( new filterbuilder [ filterlist . size ( ) ] ) ; if ( extradata . equals ( _str ) ) { filterbuilder = filterbuilders . andfilter ( filters ) ; } else { filterbuilder = filterbuilders . orfilter ( filters ) ; } return extradata ; }	common implementation for binarylogicoperator filters.
@ safevarargs public static < t > set < t > asset ( final t ... array ) { set < t > arrayset = new hashset < t > ( array . length ) ; collections . addall ( arrayset , array ) ; return arrayset ; }	returns the specified array as a set of elements . < p / >.
private map < string , set < string > > findmissingclasses ( map < string , set < string > > deps , set < string > zipclasses ) { map < string , set < string > > missing = new treemap < string , set < string > > ( ) ; for ( entry < string , set < string > > entry : deps . entryset ( ) ) { string name = entry . getkey ( ) ; for ( string dep : entry . getvalue ( ) ) { if ( ! zipclasses . contains ( dep ) ) { set < string > set = missing . get ( dep ) ; if ( set == null ) { set = new treeset < string > ( ) ; missing . put ( dep , set ) ; } set . add ( name ) ; } } } return missing ; }	computes which classes fqcn were found as dependencies that are not listed in the original jar classes .
private static url filetourl ( file file ) { string name ; try { name = file . getcanonicalpath ( ) ; } catch ( ioexception e ) { name = file . getabsolutepath ( ) ; } name = name . replace ( file . separatorchar , _str ) ; if ( ! name . startswith ( _str ) ) { name = _str + name ; } if ( ! file . isfile ( ) ) { name = name + _str ; } try { return new url ( _str , _str , name ) ; } catch ( malformedurlexception e ) { throw new illegalargumentexception ( _str ) ; } }	returns the directory or jar file url corresponding to the specified local file name .
public element selectelementmatchingxpath ( string xpath , element tosearch ) { list < element > results = selectelementsmatchingxpath ( xpath , tosearch ) ; if ( results . isempty ( ) ) { throw new elementnotfoundexception ( xpath , tosearch ) ; } element match = results . get ( _num ) ; return match ; }	the following will search the given element for the specified xpath and return any node that matches .
public byteordermark ( string charsetname , int ... bytes ) { if ( charsetname == null || charsetname . length ( ) == _num ) { throw new illegalargumentexception ( _str ) ; } if ( bytes == null || bytes . length == _num ) { throw new illegalargumentexception ( _str ) ; } this . charsetname = charsetname ; this . bytes = new int [ bytes . length ] ; system . arraycopy ( bytes , _num , this . bytes , _num , bytes . length ) ; }	construct a new bom .
public void failovercopycancel ( rpcopyrequestparams copytofailoverto ) throws recoverpointexception { recoverpointimagemanagementutils imagemanager = new recoverpointimagemanagementutils ( ) ; imagemanager . disablecopyimage ( functionalapi , copytofailoverto ) ; }	cancel a failover operation , usually a failover after a failover without a swap .
public static boolean isjwt ( string data ) { string [ ] base64 = data . split ( _str ) ; boolean val = _bool ; try { val = isbase64encoded ( base64 [ _num ] ) && isbase64encoded ( base64 [ _num ] ) && isbase64encoded ( base64 [ _num ] ) ; } catch ( indexoutofboundsexception e ) { return _bool ; } return val ; }	check if the input is a json web token ( jwt ).
public static boolean isconfigured ( ) { return system . getproperty ( _str ) != null ; }	checks if logger is already configured within this vm or not .
public int read ( byte [ ] buffer , int offset , int length ) throws ioexception { return _file . read ( buffer , offset , length ) ; }	reads a block starting from the current file pointer .
public static boolean ismac ( ) { return ( os . indexof ( _str ) >= _num ) ; }	checks if is mac .
private void validateblockletsize ( ) { string blockletsizestr = carbonproperties . getproperty ( carboncommonconstants . blocklet_size , carboncommonconstants . blocklet_size_default_val ) ; try { int blockletsize = integer . parseint ( blockletsizestr ) ; if ( blockletsize < carboncommonconstants . blocklet_size_min_val || blockletsize > carboncommonconstants . blocklet_size_max_val ) { logger . info ( _str + blockletsizestr + _str + carboncommonconstants . blocklet_size_default_val ) ; carbonproperties . setproperty ( carboncommonconstants . blocklet_size , carboncommonconstants . blocklet_size_default_val ) ; } } catch ( numberformatexception e ) { logger . info ( _str + blockletsizestr + _str + carboncommonconstants . blocklet_size_default_val ) ; carbonproperties . setproperty ( carboncommonconstants . blocklet_size , carboncommonconstants . blocklet_size_default_val ) ; } }	this method validates the blocklet size.
javasourcefromstring ( @ notnull string name , string code ) { super ( uri . create ( _str + name . replace ( _str , _str ) + kind . source . extension ) , kind . source ) ; this . code = code ; }	constructs a new javasourcefromstring .
public < e , d > void addmappedentityclass ( class < e > entityclass , class < d > dtoclass , jpamapper < e , d > mapper ) { checknotinitialized ( ) ; if ( mappings . containskey ( dtoclass ) ) { throw new illegalargumentexception ( dtoclass . getname ( ) + _str ) ; } mappings . put ( dtoclass , new mappedregistration < > ( entityclass , dtoclass , mapper ) ) ; }	adds the given entity class which is mapped to a dto with the provided mapper .
public string todot ( ) { stringbuilder b = new stringbuilder ( ) ; b . append ( _str ) ; b . append ( _str ) ; final int numstates = getnumstates ( ) ; if ( numstates > _num ) { b . append ( _str ) ; b . append ( _str ) ; } transition t = new transition ( ) ; for ( int state = _num ; state < numstates ; state ++ ) { b . append ( _str ) ; b . append ( state ) ; if ( isaccept ( state ) ) { b . append ( _str + state + _str ) ; } else { b . append ( _str + state + _str ) ; } int numtransitions = inittransition ( state , t ) ; for ( int i = _num ; i < numtransitions ; i ++ ) { getnexttransition ( t ) ; assert t . max >= t . min ; b . append ( _str ) ; b . append ( state ) ; b . append ( _str ) ; b . append ( t . dest ) ; b . append ( _str ) ; appendcharstring ( t . min , b ) ; if ( t . max != t . min ) { b . append ( _str ) ; appendcharstring ( t . max , b ) ; } b . append ( _str ) ; } } b . append ( _str ) ; return b . tostring ( ) ; }	returns the dot ( graphviz ) representation of this automaton.
public static void validate ( string topicstring , boolean wildcardallowed ) throws illegalstateexception , illegalargumentexception { int topiclen = _num ; try { topiclen = topicstring . getbytes ( _str ) . length ; } catch ( unsupportedencodingexception e ) { throw new illegalstateexception ( e ) ; } if ( topiclen < min_topic_len || topiclen > max_topic_len ) { throw new illegalargumentexception ( string . format ( _str , new object [ ] { new integer ( min_topic_len ) , new integer ( max_topic_len ) } ) ) ; } if ( wildcardallowed ) { if ( strings . equalsany ( topicstring , new string [ ] { multi_level_wildcard , single_level_wildcard } ) ) { return ; } if ( strings . countmatches ( topicstring , multi_level_wildcard ) > _num || ( topicstring . contains ( multi_level_wildcard ) && ! topicstring . endswith ( multi_level_wildcard_pattern ) ) ) { throw new illegalargumentexception ( _str + topicstring ) ; } validatesinglelevelwildcard ( topicstring ) ; return ; } if ( strings . containsany ( topicstring , topic_wildcards ) ) { throw new illegalargumentexception ( _str ) ; } }	validate the topic name or topic filter.
public boolean isattackedby ( final ientity attacker ) { return attackers . contains ( attacker ) ; }	check if a specific entity is attacking this rpentity .
public int viewtomodel ( float fx , float fy , shape a , position . bias [ ] bias ) { bias [ _num ] = position . bias . forward ; rectangle alloc = a . getbounds ( ) ; rsyntaxdocument doc = ( rsyntaxdocument ) getdocument ( ) ; int x = ( int ) fx ; int y = ( int ) fy ; if ( y < alloc . y ) { return getstartoffset ( ) ; } else if ( y > alloc . y + alloc . height ) { return getendoffset ( ) - _num ; } else { element map = doc . getdefaultrootelement ( ) ; int lineindex = math . abs ( ( y - alloc . y ) / lineheight ) ; if ( lineindex >= map . getelementcount ( ) ) return getendoffset ( ) - _num ; element line = map . getelement ( lineindex ) ; if ( x < alloc . x ) return line . getstartoffset ( ) ; else if ( x > alloc . x + alloc . width ) return line . getendoffset ( ) - _num ; else { int p0 = line . getstartoffset ( ) ; token tokenlist = doc . gettokenlistforline ( lineindex ) ; tabbase = alloc . x ; int offs = tokenlist . getlistoffset ( ( rsyntaxtextarea ) getcontainer ( ) , this , tabbase , x ) ; return offs != - _num ? offs : p0 ; } } }	provides a mapping from the view coordinate space to the logical coordinate space of the model .
public void testmaxunequal2 ( ) { string a = _str ; int ascale = _num ; string b = _str ; int bscale = _num ; string c = _str ; int cscale = _num ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) , ascale ) ; bigdecimal bnumber = new bigdecimal ( new biginteger ( b ) , bscale ) ; bigdecimal cnumber = new bigdecimal ( new biginteger ( c ) , cscale ) ; assertequals ( _str , cnumber , anumber . max ( bnumber ) ) ; }	max ( ) for unequal bigdecimals.
public void removepauselistener ( animatorpauselistener listener ) { if ( mpauselisteners == null ) { return ; } mpauselisteners . remove ( listener ) ; if ( mpauselisteners . size ( ) == _num ) { mpauselisteners = null ; } }	removes a pause listener from the set listening to this animation .
public void showerror ( drawable errorimagedrawable , string errortexttitle , string errortextcontent , string errorbuttontext , view . onclicklistener onclicklistener ) { switchstate ( error , errorimagedrawable , errortexttitle , errortextcontent , errorbuttontext , onclicklistener , collections . < integer > emptylist ( ) ) ; }	show error view with a button when something goes wrong and prompting the user to try again.
public booleancolumn ( int nrows , int capacity , boolean defaultvalue ) { super ( boolean . class , new boolean ( defaultvalue ) ) ; if ( capacity < nrows ) { throw new illegalargumentexception ( _str ) ; } m_bits = new bitset ( capacity ) ; m_bits . set ( _num , capacity , defaultvalue ) ; m_size = nrows ; }	create a new booleancolumn .
public x509certpathimpl ( list certs ) throws certificateexception { super ( _str ) ; int size = certs . size ( ) ; certificates = new arraylist ( size ) ; for ( int i = _num ; i < size ; i ++ ) { object cert = certs . get ( i ) ; if ( ! ( cert instanceof x509certificate ) ) { throw new certificateexception ( _str ) ; } certificates . add ( cert ) ; } }	creates an instance of x.
public void addtreemodellistener ( treemodellistener l ) { treemodellisteners . addelement ( l ) ; }	adds a listener for the treemodelevent posted after the tree changes .
public int right_x_value ( int p_y ) { int result = math . min ( oct_rx , oct_urx - p_y ) ; return math . min ( result , oct_lrx + p_y ) ; }	computes the x value of the right boundary of this octagon at p_y.
public static string rjust ( string str , int columnwidth ) { return string . format ( _str + columnwidth + _str , str ) ; }	this should not be in this class , move to a dedicated ascii - art class when appropriate.
public void parsepackage ( dynamicapkmanager dpkg , context context , file apkfile ) { if ( isapkfile ( apkfile ) ) { parsebasepackage ( dpkg , context , apkfile ) ; } else if ( apkfile . isdirectory ( ) ) { file [ ] apkfiles = apkfile . listfiles ( ) ; if ( apkfiles != null && apkfiles . length > _num ) { for ( file file : apkfiles ) { parsepackage ( dpkg , context , file ) ; } } } }	parse the given apk file , treating it as as a single monolithic package . < p >.
int appendslot ( int w0 , int w1 , int w2 , int w3 ) { { final int slotsize = _num ; int newoffset = ( lastused + _num ) * slotsize ; int chunkpos = newoffset > > lowbits ; int slotpos = ( newoffset & lowmask ) ; if ( chunkpos > chunks . size ( ) - _num ) chunks . addelement ( new int [ chunkalloc ] ) ; int [ ] chunk = chunks . elementat ( chunkpos ) ; chunk [ slotpos ] = w0 ; chunk [ slotpos + _num ] = w1 ; chunk [ slotpos + _num ] = w2 ; chunk [ slotpos + _num ] = w3 ; return ++ lastused ; } }	append a 4 - integer record to the cia , starting with record 1.
public string nexttoken ( ) { string result = null ; synchronized ( this ) { if ( isempty ( ) ) { return null ; } else { if ( iseatingblocksofdelimiters ) { trimstartingdelimiters ( ) ; } int nearestdelimeter = - _num ; for ( int i = _num ; i < delimiters . length ( ) ; i ++ ) { int delimiter = source . indexof ( delimiters . charat ( i ) , currentindex ) ; if ( nearestdelimeter == - _num || delimiter != - _num && delimiter < nearestdelimeter ) { nearestdelimeter = delimiter ; } } if ( nearestdelimeter == - _num ) { result = source . substring ( currentindex ) ; currentindex = source . length ( ) ; } else { result = source . substring ( currentindex , nearestdelimeter ) ; currentindex = nearestdelimeter + _num ; if ( iseatingblocksofdelimiters ) { trimstartingdelimiters ( ) ; } } } } return result ; }	returns null if there is nothing left .
public static onlybranchcoveragetestfitness createonlybranchcoveragetestfitness ( controldependency cd ) { return createonlybranchcoveragetestfitness ( cd . getbranch ( ) , cd . getbranchexpressionvalue ( ) ) ; }	create a fitness function for branch coverage aimed at executing the given controldependency .
private set < emoticon > parseemoticons ( string json ) { set < emoticon > result = new hashset < > ( ) ; if ( json == null ) { return null ; } jsonparser parser = new jsonparser ( ) ; int errors = _num ; try { jsonobject root = ( jsonobject ) parser . parse ( json ) ; jsonarray emoticons = ( jsonarray ) root . get ( _str ) ; for ( object obj : emoticons ) { if ( obj instanceof jsonobject ) { jsonobject emote_json = ( jsonobject ) obj ; emoticon emote = parseemoticon ( emote_json ) ; if ( emote == null ) { if ( errors < _num ) { logger . warning ( _str + emote_json ) ; } errors ++ ; } else { result . add ( emote ) ; } } } if ( errors > _num ) { logger . warning ( errors + _str ) ; } if ( errors > _num ) { return null ; } return result ; } catch ( parseexception | nullpointerexception | classcastexception ex ) { logger . warning ( _str + ex ) ; return null ; } }	parses the list of emoticons from the twitch api .
private string copy ( final char [ ] array , final int start , final int end ) { stringbuilder text = new stringbuilder ( ) ; for ( int j = start ; j < end ; j ++ ) { text . append ( array [ j ] ) ; } return text . tostring ( ) ; }	copies the specified interval of characters for the array .
public void redirectmethodcall ( string oldmethodname , ctmethod newmethod ) throws cannotcompileexception { transformers = new transformcall ( transformers , oldmethodname , newmethod ) ; }	correct invocations to a method that has been renamed.
private string readline ( inputstream inputstream ) throws ioexception { stringbuffer retval = new stringbuffer ( _str ) ; while ( _bool ) { char ch ; int i = inputstream . read ( ) ; if ( i == - _num ) { throw new ioexception ( _str ) ; } else ch = ( char ) i ; if ( this . maxmessagesize > _num ) { this . sizecounter -- ; if ( this . sizecounter <= _num ) throw new ioexception ( _str ) ; } if ( ch != _str ) retval . append ( ch ) ; if ( ch == _str ) { break ; } } return retval . tostring ( ) ; }	read a line of input ( i cannot use buffered reader because we may need to switch encodings mid - stream !.
public void showerror ( drawable errorimagedrawable , string errortexttitle , string errortextcontent , string errorbuttontext , onclicklistener onclicklistener ) { switchstate ( error , errorimagedrawable , errortexttitle , errortextcontent , errorbuttontext , onclicklistener , collections . < integer > emptylist ( ) ) ; }	show error view with a button when something goes wrong and prompting the user to try again.
void notifychange ( ) { notifychange ( inferencevars . diff ( restvars ( ) ) ) ; }	mark the inference context as complete and trigger evaluation of all deferred checks .
public boolean containsonecategory ( list categories ) { for ( iterator iter = categories . iterator ( ) ; iter . hasnext ( ) ; ) { groupcategory category = ( groupcategory ) iter . next ( ) ; if ( contains ( category ) ) return _bool ; } return _bool ; }	returns whether one of the given categories is contained in this set of group categories.
public static document readdocument ( inputstream in , string encoding ) throws ioexception , xmlexception { try { inputstreamreader reader = new inputstreamreader ( in , encoding ) ; inputsource source = new inputsource ( new bufferedreader ( reader ) ) ; document document ; try { document = documentbuilder . parse ( source ) ; } catch ( saxexception e ) { throw new xmlexception ( _str , e ) ; } return document ; } finally { in . close ( ) ; } }	creates a document instance from a reader reading an xml input stream .
public static string ticktostring ( stringbuilder clslbls , long timestamp , long location , long elevation , object value ) { try { stringbuilder sb = new stringbuilder ( ) ; sb . append ( timestamp ) ; sb . append ( _str ) ; if ( geotimeserie . no_location != location ) { double [ ] latlon = geoxplib . fromgeoxppoint ( location ) ; sb . append ( latlon [ _num ] ) ; sb . append ( _str ) ; sb . append ( latlon [ _num ] ) ; } sb . append ( _str ) ; if ( geotimeserie . no_elevation != elevation ) { sb . append ( elevation ) ; } sb . append ( _str ) ; if ( null != clslbls && clslbls . length ( ) > _num ) { sb . append ( clslbls ) ; sb . append ( _str ) ; } encodevalue ( sb , value ) ; return sb . tostring ( ) ; } catch ( exception e ) { e . printstacktrace ( ) ; } return null ; }	return a string representation of a gts measurement at ' tick '.
public static color hextocolor ( string hexstring ) { int decimalcolor ; decimalcolor = integer . parseint ( hexstring , _num ) ; return new color ( decimalcolor ) ; }	convert a hex string to a color object.
public static x509certimpl toimpl ( x509certificate cert ) throws certificateexception { if ( cert instanceof x509certimpl ) { return ( x509certimpl ) cert ; } else { return x509factory . intern ( cert ) ; } }	utility method to convert an arbitrary instance of x509certificate to a x509certimpl.
public nasipaddressattribute ( inetaddress ip ) { super ( nasipaddressattribute . tooctets ( ip ) ) ; this . ip = ip ; }	construct an instance from the ip address of the nas originating the request .
private static int generatepushparam ( classfilewriter cfw , int paramoffset , class < ? > paramtype ) { if ( ! paramtype . isprimitive ( ) ) { cfw . addaload ( paramoffset ) ; return _num ; } string typename = paramtype . getname ( ) ; switch ( typename . charat ( _num ) ) { case _str : case _str : case _str : case _str : case _str : cfw . addiload ( paramoffset ) ; return _num ; case _str : cfw . addlload ( paramoffset ) ; return _num ; case _str : cfw . addfload ( paramoffset ) ; return _num ; case _str : cfw . adddload ( paramoffset ) ; return _num ; } throw kit . codebug ( ) ; }	generates code to push typed parameters onto the operand stack prior to a direct java method call .
biginteger add ( long val ) { if ( val == _num ) return this ; if ( signum == _num ) return valueof ( val ) ; if ( long . signum ( val ) == signum ) return new biginteger ( add ( mag , math . abs ( val ) ) , signum ) ; int cmp = comparemagnitude ( val ) ; if ( cmp == _num ) return zero ; int [ ] resultmag = ( cmp > _num ? subtract ( mag , math . abs ( val ) ) : subtract ( math . abs ( val ) , mag ) ) ; resultmag = trustedstripleadingzeroints ( resultmag ) ; return new biginteger ( resultmag , cmp == signum ? _num : - _num ) ; }	package private methods used by bigdecimal code to add a biginteger with a long.
public boolean isprimitive ( type type ) throws exception { return isprimitive ( type . gettype ( ) ) ; }	this is used to determine whether the scanned type represents a primitive type.
protected jsonobject readinputstream ( inputstream is ) throws ioexception { string jsonstring = readstreamtostring ( is ) ; jsonobject jsonobject ; try { return new jsonobject ( jsonstring ) ; } catch ( jsonexception error ) { throw new ioexception ( error . tostring ( ) ) ; } }	helper method to read an http response .
public static double log2 ( double arg ) { return math . log ( arg ) / math . log ( _num ) ; }	returns the logarithm to base 2 .
private camelstreamer < integer , string > createcamelstreamer ( ignitedatastreamer < integer , string > datastreamer ) { camelstreamer < integer , string > streamer = new camelstreamer < > ( ) ; streamer . setignite ( grid ( ) ) ; streamer . setstreamer ( datastreamer ) ; streamer . setendpointuri ( _str + url ) ; datastreamer . allowoverwrite ( _bool ) ; datastreamer . autoflushfrequency ( _num ) ; return streamer ; }	creates a camel streamer .
public static properties readproperties ( class clazz ) { return readproperties ( clazz . getname ( ) ) ; }	read a file in the meta - inf / services location.
private void addcomponent ( jpanel panel , gridbaglayout gbl , component c , int x , int y , int width , int height , int fill , double weightx , double weighty , insets insets ) { gridbagconstraints gbc = new gridbagconstraints ( ) ; gbc . gridx = x ; gbc . gridy = y ; gbc . gridwidth = width ; gbc . gridheight = height ; gbc . fill = fill ; gbc . weightx = weightx ; gbc . weighty = weighty ; gbc . insets = insets ; gbl . setconstraints ( c , gbc ) ; panel . add ( c ) ; }	adds a component to this panel.
public void testsearch ( ) throws exception { stringwriter sw = new stringwriter ( ) ; printwriter pw = new printwriter ( sw , _bool ) ; dotestsearch ( random ( ) , pw , _bool ) ; pw . close ( ) ; sw . close ( ) ; string multifileoutput = sw . tostring ( ) ; sw = new stringwriter ( ) ; pw = new printwriter ( sw , _bool ) ; dotestsearch ( random ( ) , pw , _bool ) ; pw . close ( ) ; sw . close ( ) ; string singlefileoutput = sw . tostring ( ) ; assertequals ( multifileoutput , singlefileoutput ) ; }	this test performs a number of searches.
protected void updatehosttable ( ) { final servicescore [ ] servicescores = servicetableref . get ( ) ; final ihostscoringrule scoringrule = scoringruleref . get ( ) ; if ( servicescores == null || servicescores . length == _num || scoringrule == null ) { hosttableref . set ( null ) ; return ; } final map < string , ihostmetrics > hostmetricsmap = gethostreportforknownservices ( scoringrule , servicescores ) ; if ( hostmetricsmap == null || hostmetricsmap . isempty ( ) ) { hosttableref . set ( null ) ; return ; } if ( log . istraceenabled ( ) ) log . trace ( _str + hostmetricsmap ) ; final hosttable newhosttable = normalizehostscores ( scoringrule , hostmetricsmap ) ; if ( log . istraceenabled ( ) ) log . trace ( _str + newhosttable ) ; hosttableref . set ( newhosttable ) ; }	update the per - host scoring table.
private static boolean validatestring ( string string ) { return ! string . contains ( _str ) ; }	validate string - return false if contains newlines.
@ override protected void drawxlabels ( list < double > xlabels , double [ ] xtextlabellocations , canvas canvas , paint paint , int left , int top , int bottom , double xpixelsperunit , double minx , double maxx ) { int length = xlabels . size ( ) ; if ( length > _num ) { boolean showlabels = mrenderer . isshowlabels ( ) ; boolean showgridy = mrenderer . isshowgridy ( ) ; dateformat format = getdateformat ( xlabels . get ( _num ) , xlabels . get ( length - _num ) ) ; for ( int i = _num ; i < length ; i ++ ) { long label = math . round ( xlabels . get ( i ) ) ; float xlabel = ( float ) ( left + xpixelsperunit * ( label - minx ) ) ; if ( showlabels ) { paint . setcolor ( mrenderer . getxlabelscolor ( ) ) ; canvas . drawline ( xlabel , bottom , xlabel , bottom + mrenderer . getlabelstextsize ( ) / _num , paint ) ; drawtext ( canvas , format . format ( new date ( label ) ) , xlabel , bottom + mrenderer . getlabelstextsize ( ) * _num / _num + mrenderer . getxlabelspadding ( ) , paint , mrenderer . getxlabelsangle ( ) ) ; } if ( showgridy ) { paint . setcolor ( mrenderer . getgridcolor ( _num ) ) ; canvas . drawline ( xlabel , bottom , xlabel , top , paint ) ; } } } drawxtextlabels ( xtextlabellocations , canvas , paint , _bool , left , top , bottom , xpixelsperunit , minx , maxx ) ; }	the graphical representation of the labels on the x axis .
rsaprivatecrtkeyimpl ( byte [ ] encoded ) throws invalidkeyexception { decode ( encoded ) ; rsakeyfactory . checkrsaproviderkeylengths ( n . bitlength ( ) , e ) ; }	construct a key from its encoding.
public synchronized void clear ( ) { super . clear ( ) ; mvalue . clear ( ) ; initrange ( ) ; }	removes all the values from the series .
public void testcase23 ( ) { byte rbytes [ ] = { _num } ; biginteger anumber = biginteger . zero ; biginteger bnumber = biginteger . zero ; biginteger result = anumber . subtract ( bnumber ) ; byte resbytes [ ] = new byte [ rbytes . length ] ; resbytes = result . tobytearray ( ) ; for ( int i = _num ; i < resbytes . length ; i ++ ) { asserttrue ( resbytes [ i ] == rbytes [ i ] ) ; } assertequals ( _num , result . signum ( ) ) ; }	subtract zero from zero .
public void append ( int key , float value ) { if ( msize != _num && key <= mkeys [ msize - _num ] ) { put ( key , value ) ; return ; } int pos = msize ; if ( pos >= mkeys . length ) { int n = arrayutils . idealintarraysize ( pos + _num ) ; int [ ] nkeys = new int [ n ] ; float [ ] nvalues = new float [ n ] ; system . arraycopy ( mkeys , _num , nkeys , _num , mkeys . length ) ; system . arraycopy ( mvalues , _num , nvalues , _num , mvalues . length ) ; mkeys = nkeys ; mvalues = nvalues ; } mkeys [ pos ] = key ; mvalues [ pos ] = value ; msize = pos + _num ; }	puts a key / value pair into the array , optimizing for the case where the key is greater than all existing keys in the array .
public void write ( byte [ ] bytes , int start , int length ) throws ioexception { flushbits ( ) ; if ( bytes != null && length > _num ) { out . write ( bytes , start , length ) ; byteswritten += length ; } }	write the given bytes to the output stream.
public void executeaction ( final string jscode ) { actionsexecuted = _bool ; if ( disablejavascript ) { return ; } jsparser . executefunctions ( jscode , null ) ; }	called to execute various action commands such as page opened triggered by events not easily tracked with listeners.
private void writenonstuffed ( int b ) throws ioexception { out . write ( b ) ; }	writes non - stuffed byte to the underlying output stream.
private node logicalnextdomtextnode ( node n ) { node p = n . getnextsibling ( ) ; if ( p == null ) { for ( n = n . getparentnode ( ) ; n != null && entity_reference_node == n . getnodetype ( ) ; n = n . getparentnode ( ) ) { p = n . getnextsibling ( ) ; if ( p != null ) break ; } } n = p ; while ( n != null && entity_reference_node == n . getnodetype ( ) ) { if ( n . haschildnodes ( ) ) n = n . getfirstchild ( ) ; else n = n . getnextsibling ( ) ; } if ( n != null ) { int ntype = n . getnodetype ( ) ; if ( text_node != ntype && cdata_section_node != ntype ) n = null ; } return n ; }	utility function : given a dom text node , determine whether it is logically followed by another text or cdatasection node.
public final static int countnonzeropairs ( final long x ) { return long . bitcount ( ( x | x > > > _num ) & _num ) ; }	counts the number of nonzero pairs of bits in a long .
synchronized string segstring ( iterable < segmentcommitinfo > infos ) { final stringbuilder buffer = new stringbuilder ( ) ; for ( final segmentcommitinfo info : infos ) { if ( buffer . length ( ) > _num ) { buffer . append ( _str ) ; } buffer . append ( segstring ( info ) ) ; } return buffer . tostring ( ) ; }	returns a string description of the specified segments , for debugging .
@ override @ suppresswarnings ( _str ) public void applyshape ( region shape ) { if ( shapelog . isloggable ( platformlogger . level . finer ) ) { shapelog . finer ( _str + this + _str + target + _str + shape ) ; } if ( shape != null ) { setrectangularshape ( shape . getlox ( ) , shape . getloy ( ) , shape . gethix ( ) , shape . gethiy ( ) , ( shape . isrectangular ( ) ? null : shape ) ) ; } else { setrectangularshape ( _num , _num , _num , _num , null ) ; } }	applies the shape to the native component window .
@ override public void kill ( session session ) throws sqlexception , replicatorexception { if ( ! isprivileged ( ) ) { throw new replicatorexception ( _str ) ; } string sql = string . format ( _str , session . getidentifier ( ) ) ; execute ( sql ) ; }	issue a kill command to remove a particular session .
private int distance ( node v1 , node v2 ) { int g = _num ; node v = v1 ; while ( v . parent != null ) { g ++ ; v = v . parent ; } int h = ( int ) ( math . sqrt ( ( v1 . x - v2 . x ) * ( v1 . x - v2 . x ) + ( v1 . y - v2 . y ) * ( v1 . y - v2 . y ) ) / unit ) + _num ; return g + h ; }	computes the a * distance f ( x ) = g ( x ) + h ( x ).
public void put ( string key , file file , string contenttype , string customfilename ) throws filenotfoundexception { if ( file == null || ! file . exists ( ) ) { throw new filenotfoundexception ( ) ; } if ( key != null ) { fileparams . put ( key , new filewrapper ( file , contenttype , customfilename ) ) ; } }	adds a file to the request with both custom provided file content - type and file name.
public void test_dividebigdecimalroundingmodefloor ( ) { string a = _str ; string b = _str ; roundingmode rm = roundingmode . floor ; string c = _str ; bigdecimal anumber = new bigdecimal ( new biginteger ( a ) ) ; bigdecimal bnumber = new bigdecimal ( new biginteger ( b ) ) ; bigdecimal result = anumber . divide ( bnumber , rm ) ; assertequals ( _str , c , result . tostring ( ) ) ; }	java . math . bigdecimal # divide ( java . math . bigdecimal , java . math . roundingmode ) divide ( bigdecimal , roundingmode ).
private re concat ( re x , re y ) { if ( rec == recursion . right ) { return x . concat ( y ) ; } else { return y . concat ( x ) ; } }	given a pair of regular expressions , concatenate them in a manner consistent with this production ' s recursion form ( left - or right - recursive ) .
@ deprecated public boolean ishod ( final long assignid ) { final list < headofdepartments > hodlist = employeedepartmentrepository . getallhoddepartments ( assignid ) ; return ! hodlist . isempty ( ) ; }	refer the same api in assignment service.
private void updatepanelformaximization ( float percentage ) { float promovisibilitypercentage = isfullscreensizepanel ( ) ? _num - percentage : _num ; updatepromovisibility ( promovisibilitypercentage ) ; mbasepagey = getbasepagetargety ( ) ; float brightness = mathutils . interpolate ( base_page_brightness_state_expanded , base_page_brightness_state_maximized , percentage ) ; mbasepagebrightness = brightness ; float searchbarheight = math . round ( mathutils . interpolate ( getsearchbarheightexpanded ( ) , getsearchbarheightmaximized ( ) , percentage ) ) ; msearchbarheight = searchbarheight ; missearchbarbordervisible = _bool ; msearchbarbordery = searchbarheight - search_bar_border_height_dp + _num ; msea